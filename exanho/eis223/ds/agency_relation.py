#!/usr/bin/env python
# -*- coding: utf-8 -*-

#
# Generated Tue Dec  8 15:23:45 2020 by generateDS.py version 2.37.5.
# Python 3.8.2 (default, Apr 12 2020, 19:32:31)  [GCC 8.3.0]
#
# Command line options:
#   ('--use-getter-setter', 'none')
#   ('--enable-slots', '')
#   ('--member-specs', 'dict')
#   ('--export', '')
#   ('--silence', '')
#   ('-u', 'exanho/eis223/ds/gends_user_methods.py')
#   ('-o', 'exanho/eis223/ds/agency_relation.py')
#
# Command line arguments:
#   exanho/eis223/ds/xsd/10.2.310/agencyRelation.xsd
#
# Command line:
#   venv/bin/generateDS.py --use-getter-setter="none" --enable-slots --member-specs="dict" --export --silence -u "exanho/eis223/ds/gends_user_methods.py" -o "exanho/eis223/ds/agency_relation.py" exanho/eis223/ds/xsd/10.2.310/agencyRelation.xsd
#
# Current working directory (os.getcwd()):
#   exanho
#

import sys
try:
    ModulenotfoundExp_ = ModuleNotFoundError
except NameError:
    ModulenotfoundExp_ = ImportError
from itertools import islice
import os
import re as re_
import base64
import datetime as datetime_
import decimal as decimal_
try:
    from lxml import etree as etree_
except ModulenotfoundExp_ :
    from xml.etree import ElementTree as etree_


Validate_simpletypes_ = True
SaveElementTreeNode = True
if sys.version_info.major == 2:
    BaseStrType_ = basestring
else:
    BaseStrType_ = str


def parsexml_(infile, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        try:
            parser = etree_.ETCompatXMLParser()
        except AttributeError:
            # fallback to xml.etree
            parser = etree_.XMLParser()
    try:
        if isinstance(infile, os.PathLike):
            infile = os.path.join(infile)
    except AttributeError:
        pass
    doc = etree_.parse(infile, parser=parser, **kwargs)
    return doc

def parsexmlstring_(instring, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        try:
            parser = etree_.ETCompatXMLParser()
        except AttributeError:
            # fallback to xml.etree
            parser = etree_.XMLParser()
    element = etree_.fromstring(instring, parser=parser, **kwargs)
    return element

#
# Namespace prefix definition table (and other attributes, too)
#
# The module generatedsnamespaces, if it is importable, must contain
# a dictionary named GeneratedsNamespaceDefs.  This Python dictionary
# should map element type names (strings) to XML schema namespace prefix
# definitions.  The export method for any class for which there is
# a namespace prefix definition, will export that definition in the
# XML representation of that element.  See the export method of
# any generated element type class for an example of the use of this
# table.
# A sample table is:
#
#     # File: generatedsnamespaces.py
#
#     GenerateDSNamespaceDefs = {
#         "ElementtypeA": "http://www.xxx.com/namespaceA",
#         "ElementtypeB": "http://www.xxx.com/namespaceB",
#     }
#
# Additionally, the generatedsnamespaces module can contain a python
# dictionary named GenerateDSNamespaceTypePrefixes that associates element
# types with the namespace prefixes that are to be added to the
# "xsi:type" attribute value.  See the exportAttributes method of
# any generated element type and the generation of "xsi:type" for an
# example of the use of this table.
# An example table:
#
#     # File: generatedsnamespaces.py
#
#     GenerateDSNamespaceTypePrefixes = {
#         "ElementtypeC": "aaa:",
#         "ElementtypeD": "bbb:",
#     }
#

try:
    from generatedsnamespaces import GenerateDSNamespaceDefs as GenerateDSNamespaceDefs_
except ModulenotfoundExp_ :
    GenerateDSNamespaceDefs_ = {}
try:
    from generatedsnamespaces import GenerateDSNamespaceTypePrefixes as GenerateDSNamespaceTypePrefixes_
except ModulenotfoundExp_ :
    GenerateDSNamespaceTypePrefixes_ = {}

#
# You can replace the following class definition by defining an
# importable module named "generatedscollector" containing a class
# named "GdsCollector".  See the default class definition below for
# clues about the possible content of that class.
#
try:
    from generatedscollector import GdsCollector as GdsCollector_
except ModulenotfoundExp_ :

    class GdsCollector_(object):

        def __init__(self, messages=None):
            if messages is None:
                self.messages = []
            else:
                self.messages = messages

        def add_message(self, msg):
            self.messages.append(msg)

        def get_messages(self):
            return self.messages

        def clear_messages(self):
            self.messages = []

        def print_messages(self):
            for msg in self.messages:
                print("Warning: {}".format(msg))

        def write_messages(self, outstream):
            for msg in self.messages:
                outstream.write("Warning: {}\n".format(msg))


#
# The super-class for enum types
#

try:
    from enum import Enum
except ModulenotfoundExp_ :
    Enum = object

#
# The root super-class for element type classes
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ModulenotfoundExp_ as exp:
    
    class GeneratedsSuper(object):
        __slots__ = ['gds_collector_', 'gds_elementtree_node_', 'original_tagname_', 'parent_object_', 'ns_prefix_']
        __hash__ = object.__hash__
        tzoff_pattern = re_.compile(r'(\+|-)((0\d|1[0-3]):[0-5]\d|14:00)$')
        class _FixedOffsetTZ(datetime_.tzinfo):
            def __init__(self, offset, name):
                self.__offset = datetime_.timedelta(minutes=offset)
                self.__name = name
            def utcoffset(self, dt):
                return self.__offset
            def tzname(self, dt):
                return self.__name
            def dst(self, dt):
                return None
        @staticmethod
        def gds_subclass_slots(member_data_items):
            slots = []
            for member in member_data_items:
                slots.append(member)
                slots.append("%s_nsprefix_" % member)
            return slots
        def gds_format_string(self, input_data, input_name=''):
            return input_data
        def gds_parse_string(self, input_data, node=None, input_name=''):
            return input_data
        def gds_validate_string(self, input_data, node=None, input_name=''):
            if not input_data:
                return ''
            else:
                return input_data
        def gds_format_base64(self, input_data, input_name=''):
            return base64.b64encode(input_data)
        def gds_validate_base64(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer(self, input_data, input_name=''):
            return '%d' % input_data
        def gds_parse_integer(self, input_data, node=None, input_name=''):
            try:
                ival = int(input_data)
            except (TypeError, ValueError) as exp:
                raise_parse_error(node, 'Requires integer value: %s' % exp)
            return ival
        def gds_validate_integer(self, input_data, node=None, input_name=''):
            try:
                value = int(input_data)
            except (TypeError, ValueError):
                raise_parse_error(node, 'Requires integer value')
            return value
        def gds_format_integer_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_integer_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    int(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of integer valuess')
            return values
        def gds_format_float(self, input_data, input_name=''):
            return ('%.15f' % input_data).rstrip('0')
        def gds_parse_float(self, input_data, node=None, input_name=''):
            try:
                fval_ = float(input_data)
            except (TypeError, ValueError) as exp:
                raise_parse_error(node, 'Requires float or double value: %s' % exp)
            return fval_
        def gds_validate_float(self, input_data, node=None, input_name=''):
            try:
                value = float(input_data)
            except (TypeError, ValueError):
                raise_parse_error(node, 'Requires float value')
            return value
        def gds_format_float_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_float_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of float values')
            return values
        def gds_format_decimal(self, input_data, input_name=''):
            return_value = '%s' % input_data
            if '.' in return_value:
                return_value = return_value.rstrip('0')
                if return_value.endswith('.'):
                    return_value = return_value.rstrip('.')
            return return_value
        def gds_parse_decimal(self, input_data, node=None, input_name=''):
            try:
                decimal_value = decimal_.Decimal(input_data)
            except (TypeError, ValueError):
                raise_parse_error(node, 'Requires decimal value')
            return decimal_value
        def gds_validate_decimal(self, input_data, node=None, input_name=''):
            try:
                value = decimal_.Decimal(input_data)
            except (TypeError, ValueError):
                raise_parse_error(node, 'Requires decimal value')
            return value
        def gds_format_decimal_list(self, input_data, input_name=''):
            return ' '.join([self.gds_format_decimal(item) for item in input_data])
        def gds_validate_decimal_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    decimal_.Decimal(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of decimal values')
            return values
        def gds_format_double(self, input_data, input_name=''):
            return '%e' % input_data
        def gds_parse_double(self, input_data, node=None, input_name=''):
            try:
                fval_ = float(input_data)
            except (TypeError, ValueError) as exp:
                raise_parse_error(node, 'Requires double or float value: %s' % exp)
            return fval_
        def gds_validate_double(self, input_data, node=None, input_name=''):
            try:
                value = float(input_data)
            except (TypeError, ValueError):
                raise_parse_error(node, 'Requires double or float value')
            return value
        def gds_format_double_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_double_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(
                        node, 'Requires sequence of double or float values')
            return values
        def gds_format_boolean(self, input_data, input_name=''):
            return ('%s' % input_data).lower()
        def gds_parse_boolean(self, input_data, node=None, input_name=''):
            if input_data in ('true', '1'):
                bval = True
            elif input_data in ('false', '0'):
                bval = False
            else:
                raise_parse_error(node, 'Requires boolean value')
            return bval
        def gds_validate_boolean(self, input_data, node=None, input_name=''):
            if input_data not in (True, 1, False, 0, ):
                raise_parse_error(
                    node,
                    'Requires boolean value '
                    '(one of True, 1, False, 0)')
            return input_data
        def gds_format_boolean_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_boolean_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                if value not in (True, 1, False, 0, ):
                    raise_parse_error(
                        node,
                        'Requires sequence of boolean values '
                        '(one of True, 1, False, 0)')
            return values
        def gds_validate_datetime(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_datetime(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d.%s' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        @classmethod
        def gds_parse_datetime(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            time_parts = input_data.split('.')
            if len(time_parts) > 1:
                micro_seconds = int(float('0.' + time_parts[1]) * 1000000)
                input_data = '%s.%s' % (
                    time_parts[0], "{}".format(micro_seconds).rjust(6, "0"), )
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt
        def gds_validate_date(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_date(self, input_data, input_name=''):
            _svalue = '%04d-%02d-%02d' % (
                input_data.year,
                input_data.month,
                input_data.day,
            )
            try:
                if input_data.tzinfo is not None:
                    tzoff = input_data.tzinfo.utcoffset(input_data)
                    if tzoff is not None:
                        total_seconds = tzoff.seconds + (86400 * tzoff.days)
                        if total_seconds == 0:
                            _svalue += 'Z'
                        else:
                            if total_seconds < 0:
                                _svalue += '-'
                                total_seconds *= -1
                            else:
                                _svalue += '+'
                            hours = total_seconds // 3600
                            minutes = (total_seconds - (hours * 3600)) // 60
                            _svalue += '{0:02d}:{1:02d}'.format(
                                hours, minutes)
            except AttributeError:
                pass
            return _svalue
        @classmethod
        def gds_parse_date(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            dt = datetime_.datetime.strptime(input_data, '%Y-%m-%d')
            dt = dt.replace(tzinfo=tz)
            return dt.date()
        def gds_validate_time(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_time(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%02d:%02d:%02d' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%02d:%02d:%02d.%s' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        def gds_validate_simple_patterns(self, patterns, target):
            # pat is a list of lists of strings/patterns.
            # The target value must match at least one of the patterns
            # in order for the test to succeed.
            found1 = True
            for patterns1 in patterns:
                found2 = False
                for patterns2 in patterns1:
                    mo = re_.search(patterns2, target)
                    if mo is not None and len(mo.group(0)) == len(target):
                        found2 = True
                        break
                if not found2:
                    found1 = False
                    break
            return found1
        @classmethod
        def gds_parse_time(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            if len(input_data.split('.')) > 1:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt.time()
        def gds_check_cardinality_(
                self, value, input_name,
                min_occurs=0, max_occurs=1, required=None):
            if value is None:
                length = 0
            elif isinstance(value, list):
                length = len(value)
            else:
                length = 1
            if required is not None :
                if required and length < 1:
                    self.gds_collector_.add_message(
                        "Required value {}{} is missing".format(
                            input_name, self.gds_get_node_lineno_()))
            if length < min_occurs:
                self.gds_collector_.add_message(
                    "Number of values for {}{} is below "
                    "the minimum allowed, "
                    "expected at least {}, found {}".format(
                        input_name, self.gds_get_node_lineno_(),
                        min_occurs, length))
            elif length > max_occurs:
                self.gds_collector_.add_message(
                    "Number of values for {}{} is above "
                    "the maximum allowed, "
                    "expected at most {}, found {}".format(
                        input_name, self.gds_get_node_lineno_(),
                        max_occurs, length))
        def gds_validate_builtin_ST_(
                self, validator, value, input_name,
                min_occurs=None, max_occurs=None, required=None):
            if value is not None:
                try:
                    validator(value, input_name=input_name)
                except GDSParseError as parse_error:
                    self.gds_collector_.add_message(str(parse_error))
        def gds_validate_defined_ST_(
                self, validator, value, input_name,
                min_occurs=None, max_occurs=None, required=None):
            if value is not None:
                try:
                    validator(value)
                except GDSParseError as parse_error:
                    self.gds_collector_.add_message(str(parse_error))
        def gds_str_lower(self, instring):
            return instring.lower()
        def get_path_(self, node):
            path_list = []
            self.get_path_list_(node, path_list)
            path_list.reverse()
            path = '/'.join(path_list)
            return path
        Tag_strip_pattern_ = re_.compile(r'\{.*\}')
        def get_path_list_(self, node, path_list):
            if node is None:
                return
            tag = GeneratedsSuper.Tag_strip_pattern_.sub('', node.tag)
            if tag:
                path_list.append(tag)
            self.get_path_list_(node.getparent(), path_list)
        def get_class_obj_(self, node, default_class=None):
            class_obj1 = default_class
            if 'xsi' in node.nsmap:
                classname = node.get('{%s}type' % node.nsmap['xsi'])
                if classname is not None:
                    names = classname.split(':')
                    if len(names) == 2:
                        classname = names[1]
                    class_obj2 = globals().get(classname)
                    if class_obj2 is not None:
                        class_obj1 = class_obj2
            return class_obj1
        def gds_build_any(self, node, type_name=None):
            # provide default value in case option --disable-xml is used.
            content = ""
            content = etree_.tostring(node, encoding="unicode")
            return content
        @classmethod
        def gds_reverse_node_mapping(cls, mapping):
            return dict(((v, k) for k, v in mapping.items()))
        @staticmethod
        def gds_encode(instring):
            if sys.version_info.major == 2:
                if ExternalEncoding:
                    encoding = ExternalEncoding
                else:
                    encoding = 'utf-8'
                return instring.encode(encoding)
            else:
                return instring
        @staticmethod
        def convert_unicode(instring):
            if isinstance(instring, str):
                result = quote_xml(instring)
            elif sys.version_info.major == 2 and isinstance(instring, unicode):
                result = quote_xml(instring).encode('utf8')
            else:
                result = GeneratedsSuper.gds_encode(str(instring))
            return result
        def __eq__(self, other):
            if type(self) != type(other):
                return False
            mro = self.__class__.__mro__
            return all(
                getattr(self, attribute) == getattr(other, attribute)
                for cls in islice(mro, 0, len(mro) - 2)
                for attribute in cls.member_data_items_)
        def __ne__(self, other):
            return not self.__eq__(other)
        # Django ETL transform hooks.
        def gds_djo_etl_transform(self):
            pass
        def gds_djo_etl_transform_db_obj(self, dbobj):
            pass
        # SQLAlchemy ETL transform hooks.
        def gds_sqa_etl_transform(self):
            return 0, None
        def gds_sqa_etl_transform_db_obj(self, dbobj):
            pass
        def gds_get_node_lineno_(self):
            if (hasattr(self, "gds_elementtree_node_") and
                    self.gds_elementtree_node_ is not None):
                return ' near line {}'.format(
                    self.gds_elementtree_node_.sourceline)
            else:
                return ""
    
    
    def getSubclassFromModule_(module, class_):
        '''Get the subclass of a class from a specific module.'''
        name = class_.__name__ + 'Sub'
        if hasattr(module, name):
            return getattr(module, name)
        else:
            return None


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = ''
# Set this to false in order to deactivate during export, the use of
# name space prefixes captured from the input document.
UseCapturedNS_ = True
CapturedNsmap_ = {}
Tag_pattern_ = re_.compile(r'({.*})?(.*)')
String_cleanup_pat_ = re_.compile(r"[\n\r\s]+")
Namespace_extract_pat_ = re_.compile(r'{(.*)}(.*)')
CDATA_pattern_ = re_.compile(r"<!\[CDATA\[.*?\]\]>", re_.DOTALL)

# Change this to redirect the generated superclass module to use a
# specific subclass module.
CurrentSubclassModule_ = None

#
# Support/utility functions.
#


def showIndent(outfile, level, pretty_print=True):
    if pretty_print:
        for idx in range(level):
            outfile.write('    ')


def quote_xml(inStr):
    "Escape markup chars, but do not modify CDATA sections."
    if not inStr:
        return ''
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s2 = ''
    pos = 0
    matchobjects = CDATA_pattern_.finditer(s1)
    for mo in matchobjects:
        s3 = s1[pos:mo.start()]
        s2 += quote_xml_aux(s3)
        s2 += s1[mo.start():mo.end()]
        pos = mo.end()
    s3 = s1[pos:]
    s2 += quote_xml_aux(s3)
    return s2


def quote_xml_aux(inStr):
    s1 = inStr.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1


def quote_attrib(inStr):
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1


def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1


def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text


def find_attr_value_(attr_name, node):
    attrs = node.attrib
    attr_parts = attr_name.split(':')
    value = None
    if len(attr_parts) == 1:
        value = attrs.get(attr_name)
    elif len(attr_parts) == 2:
        prefix, name = attr_parts
        namespace = node.nsmap.get(prefix)
        if namespace is not None:
            value = attrs.get('{%s}%s' % (namespace, name, ))
    return value


def encode_str_2_3(instr):
    return instr


class GDSParseError(Exception):
    pass


def raise_parse_error(node, msg):
    if node is not None:
        msg = '%s (element %s/line %d)' % (msg, node.tag, node.sourceline, )
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    TypeBase64 = 8
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace,
               pretty_print=True):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(
                outfile, level, namespace, name_=name,
                pretty_print=pretty_print)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeBase64:
            outfile.write('<%s>%s</%s>' % (
                self.name,
                base64.b64encode(self.value),
                self.name))
    def to_etree(self, element, mapping_=None, nsmap_=None):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                if len(element) > 0:
                    if element[-1].tail is None:
                        element[-1].tail = self.value
                    else:
                        element[-1].tail += self.value
                else:
                    if element.text is None:
                        element.text = self.value
                    else:
                        element.text += self.value
        elif self.category == MixedContainer.CategorySimple:
            subelement = etree_.SubElement(
                element, '%s' % self.name)
            subelement.text = self.to_etree_simple()
        else:    # category == MixedContainer.CategoryComplex
            self.value.to_etree(element)
    def to_etree_simple(self, mapping_=None, nsmap_=None):
        if self.content_type == MixedContainer.TypeString:
            text = self.value
        elif (self.content_type == MixedContainer.TypeInteger or
                self.content_type == MixedContainer.TypeBoolean):
            text = '%d' % self.value
        elif (self.content_type == MixedContainer.TypeFloat or
                self.content_type == MixedContainer.TypeDecimal):
            text = '%f' % self.value
        elif self.content_type == MixedContainer.TypeDouble:
            text = '%g' % self.value
        elif self.content_type == MixedContainer.TypeBase64:
            text = '%s' % base64.b64encode(self.value)
        return text
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type,
                    self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type,
                    self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s",\n' % (
                    self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0,
            optional=0, child_attrs=None, choice=None):
        self.name = name
        self.data_type = data_type
        self.container = container
        self.child_attrs = child_attrs
        self.choice = choice
        self.optional = optional
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container
    def set_child_attrs(self, child_attrs): self.child_attrs = child_attrs
    def get_child_attrs(self): return self.child_attrs
    def set_choice(self, choice): self.choice = choice
    def get_choice(self): return self.choice
    def set_optional(self, optional): self.optional = optional
    def get_optional(self): return self.optional


def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)

#
# Data representation classes.
#


class acceptedType(str, Enum):
    """Признак допуска"""
    T='T' # Допущен
    F='F' # Не допущен


class acceptedType2(str, Enum):
    """Признак допуска"""
    T='T' # Допущен
    F='F' # Не допущен
    N='N' # Не указывается в данном протоколе


class agencyRelationStatus(str, Enum):
    """Статус связи"""
    APPROVAL_REQUESTED='APPROVAL_REQUESTED' # На подтверждении
    APPROVED='APPROVED' # Подтверждена
    BLOCKED='BLOCKED' # Заблокирована
    REVOKED='REVOKED' # Аннулирована
    REFUSED='REFUSED' # Отклонена


class agencyRelationType(str, Enum):
    """Тип связи"""
    R='R' # Организация, являющаяся представителем заказчика
    B='B' # Обособленное подразделение заказчика
    S='S' # Организация-правопреемник
    C='C' # Организация, согласующая закупки с уполномоченным органом


class agencyStatusType(str, Enum):
    """Статус организации в ППА
    BLOCKED("Заблокирована"),
    REGISTERED("Зарегистрирована"),
    REJECTED("Отказано в регистрации"),
    PENDING("На регистрации"),
    ON_HOLD("Приостановлено действие");"""
    BLOCKED='BLOCKED' # Заблокирована
    REGISTERED='REGISTERED' # Зарегистрирована
    REJECTED='REJECTED' # Отказано в регистрации
    PENDING='PENDING' # На регистрации
    ON_HOLD='ON_HOLD' # Приостановлено действие


class commissionIsFunctionalCharacteristicsRefineNeededType(str, Enum):
    """Принятое решение о необходимости уточнения функциональных
    характеристик"""
    NEEDED='NEEDED' # Требуется уточнение функциональных характеристик
    NOT_NEEDED='NOT_NEEDED' # Не требуется уточнение функциональных характеристик


class deliveryPlaceIndicationType(str, Enum):
    """Признак указания места поставки"""
    GL='GL' # Указывается общее для лота
    ELP='ELP' # Указывается для каждой позиции лота
    LC='LC' # Указывается в сведениях по участнику совместной закупки
    GA='GA' # Указывается общее для организации
    EP='EP' # Указывается для каждой позиции


class disagreementsProtocolStatus(str, Enum):
    """Статус протокола разногласий"""
    F='F' # Новый
    P='P' # Размещено
    I='I' # Отказано


class explanationRequestStatusType(str, Enum):
    """Статус запроса на разъяснение"""
    F='F' # Редактирование
    P='P' # Размещено


class explanationStatusType(str, Enum):
    """Статус разъяснения"""
    F='F' # Редактирование
    P='P' # Размещено


class extendFieldType(str, Enum):
    """Тип данных"""
    STRING='STRING' # Строка
    TEXT='TEXT' # Текст
    INTEGER='INTEGER' # Целое число
    NUMBER='NUMBER' # Число
    BOOLEAN='BOOLEAN' # Логический
    TIME='TIME' # Время
    DATETIME='DATETIME' # Дата / время
    DATE='DATE' # Дата
    LINK='LINK' # Гиперссылка
    FILE='FILE' # Файл
    REGEXP='REGEXP' # Значение по шаблону
    CURRENCY='CURRENCY' # Справочник «Валюта»
    UNITS='UNITS' # Справочник «Единицы измерения»
    OKDP='OKDP' # Справочник «ОКДП»
    OKPD_2='OKPD2' # Справочник «ОКПД2»
    OKVED='OKVED' # Справочник «ОКВЭД»
    OKVED_2='OKVED2' # Справочник «ОКВЭД2»
    TABLE='TABLE' # Табличное представление из справочника


class listGWSStatusType(str, Enum):
    """Статус перечня ТРУ"""
    F='F' # Редактирование
    P='P' # Размещено
    I='I' # Недействительно
    M='M' # Изменение


class listInnovStatusType(str, Enum):
    """Статус перечня ИПВП"""
    F='F' # Редактирование
    P='P' # Размещено
    I='I' # Недействительно
    M='M' # Изменение


class lotCancellationType(str, Enum):
    """Флаг места хранения информации об отмене лота:
    * COMMON - причина отмены записывается в саму сущность LotCancellation
    * VARIOUS - причина отмены записывается своя индивидуально в каждый
    отменяемый лот"""
    COMMON='COMMON' # Общая причина отмены всех лотов
    VARIOUS='VARIOUS' # Различные причины отмены лотов


class lotPlanPositionType(str, Enum):
    """Признак указания места поставки"""
    COMMODITY='COMMODITY' # Обычный план
    INNOVATION='INNOVATION' # Инновационный план


class noticeDeliveryPlaceIndicationType(str, Enum):
    """Признак указания места поставки для закупки"""
    SINGLE_PLACE='SINGLE_PLACE' # Единое место поставки лотов
    DIFFERENT_PLACE='DIFFERENT_PLACE' # Различные места поставки лотов


class noticeTemplateFieldLevelType(str, Enum):
    """Уровень размещения вкладки"""
    NOTICE='NOTICE' # Извещение
    LOT='LOT' # Лот
    LOT_CUSTOMER='LOT_CUSTOMER' # Сведения по заказчику


class orderClauseStatusType(str, Enum):
    """Статус положения о закупках"""
    F='F' # Проект
    P='P' # Размещено
    I='I' # Недействительно
    M='M' # Изменение


class planInformationType(str, Enum):
    """Тип сведений плана"""
    PLAN_PROJECT='PLAN_PROJECT' # Проект плана закупки
    PLAN_PROJECT_MODIFICATION='PLAN_PROJECT_MODIFICATION' # Проект изменений плана закупки
    PLAN='PLAN' # План закупки
    PLAN_MODIFICATION='PLAN_MODIFICATION' # Изменение плана закупки
    SMB='SMB' # Отчет МСП
    SMB_MODIFICATION='SMB_MODIFICATION' # Изменение отчета МСП
    HIGH_TECH='HIGH_TECH' # Отчет ИПВП
    HIGH_TECH_MODIFICATION='HIGH_TECH_MODIFICATION' # Изменение отчета ИПВП


class protocolTemplateFieldLevelType(str, Enum):
    """Уровень размещения вкладки"""
    PROTOCOL='PROTOCOL' # Протокол
    APPLICATION='APPLICATION' # Заявка поставщика


class purchaseContractAccountStatusType(str, Enum):
    """Статус отчетности о договорах"""
    F='F' # Редактирование
    P='P' # Размещено
    I='I' # Недействительно
    M='M' # Изменение


class purchaseContractStatusType(str, Enum):
    """Статус договора закупки"""
    F='F' # Редактирование
    P='P' # Размещено
    I='I' # Недействительно
    M='M' # Изменение


class purchaseContractTypeCodeType(str, Enum):
    """Тип отчетности о договорах"""
    _1='1' # Договора по результатам закупок
    _2='2' # Договора, заключенные заказчиком по результатам закупки у единственного поставщика (исполнителя, подрядчика)
    _3='3' # Договора, заключенные заказчиком по результатам закупки, сведения о которой составляют государственную тайну или в отношении которой приняты решения Правительства Российской Федерации
    _4='4' # Договоры, заключенные заказчиком по результатам закупки у субъектов малого и среднего предпринимательства
    _5='5' # Договоры, заключенные заказчиком с единственным поставщиком (исполнителем, подрядчиком) по результатам несостоявшейся конкурентной закупки


class purchaseContractTypeInfoType(str, Enum):
    """Тип сведений договора"""
    N='N' # Первоначальные сведения о договоре
    C='C' # Сведения об изменении в договоре


class purchaseMethodClassType(str, Enum):
    """Cпособ закупки"""
    OK='OK' # Открытый конкурс (до 01.07.18)
    OA='OA' # Открытый аукцион (до 01.07.18)
    AE='AE' # Открытый аукцион в электронной форме (до 01.07.18)
    AE_94='AE94' # Открытый аукцион в электронной форме (по 94ФЗ) (до 01.07.18)
    ZK='ZK' # Запрос котировок (до 01.07.18)
    EP='EP' # Закупка у единственного поставщика (исполнителя, подрядчика) (до 01.07.18)
    KESMBO='KESMBO' # Конкурс в электронной форме, участниками которого могут являться только субъекты малого и среднего предпринимательства
    AESMBO='AESMBO' # Аукцион в электронной форме, участниками которого могут являться только субъекты малого и среднего предпринимательства
    ZKESMBO='ZKESMBO' # Запрос котировок в электронной форме, участниками которого могут являться только субъекты малого и среднего предпринимательства
    ZPESMBO='ZPESMBO' # Запрос предложений в электронной форме, участниками которого могут являться только субъекты малого и среднего предпринимательства
    IS='IS' # Иной способ
    TSK='TSK' # Типовой способ с видом «Конкурс»
    TSA='TSA' # Типовой способ с видом «Аукцион»
    TSZK='TSZK' # Типовой способ с видом «Запрос котировок»
    TSZP='TSZP' # Типовой способ с видом «Запрос предложений»
    TSEP='TSEP' # Типовой способ с видом «Закупка у единственного поставщика (подрядчика, исполнителя)»


class purchaseNoticeStatusType(str, Enum):
    """Статус извещения"""
    F='F' # Редактирование
    P='P' # Размещено
    I='I' # Недействительно
    M='M' # Изменение


class purchasePlanItemStatusType(str, Enum):
    """Статус позиции плана закупок"""
    N='N' # Новая
    P='P' # Размещена
    C='C' # Изменена
    A='A' # Аннулирована


class purchasePlanStatusType(str, Enum):
    """Статус сведений плана закупок"""
    P='P' # Проект плана закупки
    M='M' # Проект изменений плана закупки
    A='A' # Утвержден


class purchaseProtocolStatusType(str, Enum):
    """Статус протокола закупки"""
    F='F' # Редактирование
    P='P' # Размещено
    I='I' # Недействительно
    M='M' # Изменение


class purchaseStageType(str, Enum):
    """Этап извещения о закупке"""
    NOTICE_FORMATION='NOTICE_FORMATION' # Формирование извещения
    APPLICATION_FILING='APPLICATION_FILING' # Подача заявок
    COMMISSION_ACTIVITIES='COMMISSION_ACTIVITIES' # Работа комиссии
    PLACEMENT_COMPLETE='PLACEMENT_COMPLETE' # Размещение завершено
    PLACEMENT_CANCELED='PLACEMENT_CANCELED' # Размещение отменено


class resultType(str, Enum):
    """Результат операции"""
    SUCCESS='success'
    FAILURE='failure'


class signatureType(str, Enum):
    """Тип электронной подписи"""
    C_AD_ESBES='CAdES-BES'
    C_AD_ESA='CAdES-A'


class statusType(str, Enum):
    """Статус обработки пакета"""
    SUCCESS='success'
    FAILURE='failure'
    QUEUED='queued'
    PROCESSING='processing'


class stopCommodityStatus(str, Enum):
    """Статус перечня ТРУ для приостановки"""
    N='N' # Новый
    P='P' # Размещено


class supplierType(str, Enum):
    """Тип организации поставщика"""
    L='L' # Юридическое лицо
    P='P' # Физическое лицо


class templateExtendPurchaseTypes(str, Enum):
    """Источник копирования полей
    OK(Открытый конкурс),
    OA(Открытый аукцион),
    OE(Открытый аукцион в электронной форме),
    ZK(Запрос котировок),
    ZE(Закупка у единственного поставщика),
    IS(Иной способ (состав данных согласно Федеральному закону 223-ФЗ)),
    ES(Иной способ в электронной форме (выбор ВСРЗ для проведения закупки));"""
    OK='OK' # Открытый конкурс
    OA='OA' # Открытый аукцион
    OE='OE' # Открытый аукцион в электронной форме
    ZK='ZK' # Запрос котировок
    ZE='ZE' # Закупка у единственного поставщика
    IS='IS' # Иной способ (состав данных согласно Федеральному закону 223-ФЗ)
    ES='ES' # Иной способ в электронной форме (выбор ВСРЗ для проведения закупки)


class templateStatusType(str, Enum):
    """Статус шаблона"""
    I='I' # Неактуальная версия
    P='P' # Актуальная версия


class violation_levelType(str, Enum):
    """Тип ошибки"""
    ERROR='error'
    WARNING='warning'


class volumePurchaseStatusType(str, Enum):
    """Статус годового отчета о закупки у МСП"""
    F='F' # Редактирование
    P='P' # Размещено
    I='I' # Недействительно
    M='M' # Изменение


class winnerIndication(str, Enum):
    """Результат"""
    F='F' # Победитель
    S='S' # Второе место
    T='T' # Третье место
    B='B' # Ниже третьего
    N='N' # Не указывается в данном протоколе


class winnerIndication3(str, Enum):
    """Результат"""
    W='W' # Победитель
    F='F' # Участник, предложивший цену победителя
    S='S' # Участник, предложивший цену, следующую после победителя


class agencyRelation(GeneratedsSuper):
    """Связь организации"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'customer': MemberSpec_('customer', 'customerInfo2Type', 0, 0, {'name': 'customer', 'type': 'customerInfo2Type'}, None),
        'comment': MemberSpec_('comment', ['commentType', 't:nonEmptyString'], 0, 1, {'minOccurs': '0', 'name': 'comment', 'type': 'xs:string'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, customer=None, comment=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.customer = customer
        self.customer_nsprefix_ = None
        self.comment = comment
        self.validate_commentType(self.comment)
        self.comment_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, agencyRelation)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if agencyRelation.subclass:
            return agencyRelation.subclass(*args_, **kwargs_)
        else:
            return agencyRelation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_commentType(self, value):
        result = True
        # Validate type commentType, a restriction on t:nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 2000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on commentType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on commentType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.customer is not None or
            self.comment is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'customer':
            obj_ = customerInfo2Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.customer = obj_
            obj_.original_tagname_ = 'customer'
        elif nodeName_ == 'comment':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'comment')
            value_ = self.gds_validate_string(value_, node, 'comment')
            self.comment = value_
            self.comment_nsprefix_ = child_.prefix
            # validate type commentType
            self.validate_commentType(self.comment)
# end class agencyRelation


class nsiAgencyRelationsDataType(GeneratedsSuper):
    """Связь между организациями"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'customer': MemberSpec_('customer', 'customerMainInfoType', 0, 0, {'name': 'customer', 'type': 'customerMainInfoType'}, None),
        'relations': MemberSpec_('relations', 'relationsType', 0, 0, {'name': 'relations', 'type': 'relationsType'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, customer=None, relations=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.customer = customer
        self.customer_nsprefix_ = None
        self.relations = relations
        self.relations_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, nsiAgencyRelationsDataType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if nsiAgencyRelationsDataType.subclass:
            return nsiAgencyRelationsDataType.subclass(*args_, **kwargs_)
        else:
            return nsiAgencyRelationsDataType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.customer is not None or
            self.relations is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'customer':
            obj_ = customerMainInfoType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.customer = obj_
            obj_.original_tagname_ = 'customer'
        elif nodeName_ == 'relations':
            obj_ = relationsType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.relations = obj_
            obj_.original_tagname_ = 'relations'
# end class nsiAgencyRelationsDataType


class documentUploadBaseData(GeneratedsSuper):
    """Базовый тип для загружаемого документа"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'guid': MemberSpec_('guid', ['guidType', 'xs:string'], 0, 0, {'name': 'guid', 'type': 'xs:string'}, None),
        'entityGuid': MemberSpec_('entityGuid', ['guidType', 'xs:string'], 0, 0, {'name': 'entityGuid', 'type': 'xs:string'}, None),
        'placer': MemberSpec_('placer', 'customerInfoType', 0, 0, {'name': 'placer', 'type': 'customerInfoType'}, None),
        'additionalDocumentsCount': MemberSpec_('additionalDocumentsCount', 'xs:positiveInteger', 0, 0, {'name': 'additionalDocumentsCount', 'type': 'xs:positiveInteger'}, None),
        'documentNumber': MemberSpec_('documentNumber', 'xs:positiveInteger', 0, 0, {'name': 'documentNumber', 'type': 'xs:positiveInteger'}, None),
        'document': MemberSpec_('document', 'documentType', 0, 0, {'name': 'document', 'type': 'documentType'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_) + ['extensiontype_']
    subclass = None
    superclass = None
    def __init__(self, guid=None, entityGuid=None, placer=None, additionalDocumentsCount=None, documentNumber=None, document=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.guid = guid
        self.validate_guidType(self.guid)
        self.guid_nsprefix_ = None
        self.entityGuid = entityGuid
        self.validate_guidType(self.entityGuid)
        self.entityGuid_nsprefix_ = None
        self.placer = placer
        self.placer_nsprefix_ = None
        self.additionalDocumentsCount = additionalDocumentsCount
        self.additionalDocumentsCount_nsprefix_ = None
        self.documentNumber = documentNumber
        self.documentNumber_nsprefix_ = None
        self.document = document
        self.document_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, documentUploadBaseData)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if documentUploadBaseData.subclass:
            return documentUploadBaseData.subclass(*args_, **kwargs_)
        else:
            return documentUploadBaseData(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_guidType(self, value):
        result = True
        # Validate type guidType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) != 36:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd length restriction on guidType' % {"value": encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_guidType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_guidType_patterns_, ))
                result = False
        return result
    validate_guidType_patterns_ = [['^([a-fA-F0-9]{8}\\-[a-fA-F0-9]{4}\\-[a-fA-F0-9]{4}\\-[a-fA-F0-9]{4}\\-[a-fA-F0-9]{12})$']]
    def hasContent_(self):
        if (
            self.guid is not None or
            self.entityGuid is not None or
            self.placer is not None or
            self.additionalDocumentsCount is not None or
            self.documentNumber is not None or
            self.document is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'guid':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'guid')
            value_ = self.gds_validate_string(value_, node, 'guid')
            self.guid = value_
            self.guid_nsprefix_ = child_.prefix
            # validate type guidType
            self.validate_guidType(self.guid)
        elif nodeName_ == 'entityGuid':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'entityGuid')
            value_ = self.gds_validate_string(value_, node, 'entityGuid')
            self.entityGuid = value_
            self.entityGuid_nsprefix_ = child_.prefix
            # validate type guidType
            self.validate_guidType(self.entityGuid)
        elif nodeName_ == 'placer':
            obj_ = customerInfoType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.placer = obj_
            obj_.original_tagname_ = 'placer'
        elif nodeName_ == 'additionalDocumentsCount' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'additionalDocumentsCount')
            if ival_ <= 0:
                raise_parse_error(child_, 'requires positiveInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'additionalDocumentsCount')
            self.additionalDocumentsCount = ival_
            self.additionalDocumentsCount_nsprefix_ = child_.prefix
        elif nodeName_ == 'documentNumber' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'documentNumber')
            if ival_ <= 0:
                raise_parse_error(child_, 'requires positiveInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'documentNumber')
            self.documentNumber = ival_
            self.documentNumber_nsprefix_ = child_.prefix
        elif nodeName_ == 'document':
            obj_ = documentType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.document = obj_
            obj_.original_tagname_ = 'document'
# end class documentUploadBaseData


class contactInfoType(GeneratedsSuper):
    """Информация о контактном лице"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'firstName': MemberSpec_('firstName', ['firstNameType', 'nonEmptyString', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'firstName', 'type': 'xs:string'}, None),
        'middleName': MemberSpec_('middleName', ['middleNameType', 'nonEmptyString', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'middleName', 'type': 'xs:string'}, None),
        'lastName': MemberSpec_('lastName', ['lastNameType', 'nonEmptyString', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'lastName', 'type': 'xs:string'}, None),
        'phone': MemberSpec_('phone', ['phoneType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'phone', 'type': 'xs:string'}, None),
        'fax': MemberSpec_('fax', ['phoneType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'fax', 'type': 'xs:string'}, None),
        'email': MemberSpec_('email', ['emailType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'email', 'type': 'xs:string'}, None),
        'additionalContactInfo': MemberSpec_('additionalContactInfo', ['additionalContactInfoType', 'nonEmptyString', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'additionalContactInfo', 'type': 'xs:string'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, firstName=None, middleName=None, lastName=None, phone=None, fax=None, email=None, additionalContactInfo=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.firstName = firstName
        self.validate_firstNameType(self.firstName)
        self.firstName_nsprefix_ = None
        self.middleName = middleName
        self.validate_middleNameType(self.middleName)
        self.middleName_nsprefix_ = None
        self.lastName = lastName
        self.validate_lastNameType(self.lastName)
        self.lastName_nsprefix_ = None
        self.phone = phone
        self.validate_phoneType(self.phone)
        self.phone_nsprefix_ = None
        self.fax = fax
        self.validate_phoneType(self.fax)
        self.fax_nsprefix_ = None
        self.email = email
        self.validate_emailType(self.email)
        self.email_nsprefix_ = None
        self.additionalContactInfo = additionalContactInfo
        self.validate_additionalContactInfoType(self.additionalContactInfo)
        self.additionalContactInfo_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, contactInfoType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if contactInfoType.subclass:
            return contactInfoType.subclass(*args_, **kwargs_)
        else:
            return contactInfoType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_firstNameType(self, value):
        result = True
        # Validate type firstNameType, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 300:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on firstNameType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on firstNameType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_middleNameType(self, value):
        result = True
        # Validate type middleNameType, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 300:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on middleNameType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on middleNameType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_lastNameType(self, value):
        result = True
        # Validate type lastNameType, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 300:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on lastNameType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on lastNameType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_phoneType(self, value):
        result = True
        # Validate type phoneType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 300:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on phoneType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on phoneType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_emailType(self, value):
        result = True
        # Validate type emailType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 300:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on emailType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on emailType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_emailType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_emailType_patterns_, ))
                result = False
        return result
    validate_emailType_patterns_ = [["^(([\\-a-zA-Zа-яА-Я0-9!#%&'\\*\\+/=\\?\\^_`\\{\\|\\}~]+(\\.[\\-a-zA-Zа-яА-Я0-9!#%&'\\*\\+/=\\?\\^_`\\{\\|\\}~]+)*@([a-zA-Zа-яА-Я0-9]([\\-_a-zA-Zа-яА-Я0-9]{0,61}[a-zA-Zа-яА-Я0-9])?\\.)*[\\-a-zA-Zа-яА-Я0-9]+(\\.[\\-a-zA-Zа-яА-Я0-9]+)*)+(,\\s?[\\-a-zA-Zа-яА-Я0-9!#%&'\\*\\+/=\\?\\^_`\\{\\|\\}~]+(\\.[\\-a-zA-Zа-яА-Я0-9!#%&'\\*\\+/=\\?\\^_`\\{\\|\\}~]+)*@([a-zA-Zа-яА-Я0-9]([\\-_a-zA-Zа-яА-Я0-9]{0,61}[a-zA-Zа-яА-Я0-9])?\\.)*[\\-a-zA-Zа-яА-Я0-9]+(\\.[\\-a-zA-Zа-яА-Я0-9]+)*)*)$"]]
    def validate_additionalContactInfoType(self, value):
        result = True
        # Validate type additionalContactInfoType, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 2000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on additionalContactInfoType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on additionalContactInfoType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.firstName is not None or
            self.middleName is not None or
            self.lastName is not None or
            self.phone is not None or
            self.fax is not None or
            self.email is not None or
            self.additionalContactInfo is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'firstName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'firstName')
            value_ = self.gds_validate_string(value_, node, 'firstName')
            self.firstName = value_
            self.firstName_nsprefix_ = child_.prefix
            # validate type firstNameType
            self.validate_firstNameType(self.firstName)
        elif nodeName_ == 'middleName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'middleName')
            value_ = self.gds_validate_string(value_, node, 'middleName')
            self.middleName = value_
            self.middleName_nsprefix_ = child_.prefix
            # validate type middleNameType
            self.validate_middleNameType(self.middleName)
        elif nodeName_ == 'lastName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'lastName')
            value_ = self.gds_validate_string(value_, node, 'lastName')
            self.lastName = value_
            self.lastName_nsprefix_ = child_.prefix
            # validate type lastNameType
            self.validate_lastNameType(self.lastName)
        elif nodeName_ == 'phone':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'phone')
            value_ = self.gds_validate_string(value_, node, 'phone')
            self.phone = value_
            self.phone_nsprefix_ = child_.prefix
            # validate type phoneType
            self.validate_phoneType(self.phone)
        elif nodeName_ == 'fax':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'fax')
            value_ = self.gds_validate_string(value_, node, 'fax')
            self.fax = value_
            self.fax_nsprefix_ = child_.prefix
            # validate type phoneType
            self.validate_phoneType(self.fax)
        elif nodeName_ == 'email':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'email')
            value_ = self.gds_validate_string(value_, node, 'email')
            self.email = value_
            self.email_nsprefix_ = child_.prefix
            # validate type emailType
            self.validate_emailType(self.email)
        elif nodeName_ == 'additionalContactInfo':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'additionalContactInfo')
            value_ = self.gds_validate_string(value_, node, 'additionalContactInfo')
            self.additionalContactInfo = value_
            self.additionalContactInfo_nsprefix_ = child_.prefix
            # validate type additionalContactInfoType
            self.validate_additionalContactInfoType(self.additionalContactInfo)
# end class contactInfoType


class cryptoSignsType(GeneratedsSuper):
    """ЭЦП документа"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'signature': MemberSpec_('signature', 'signatureType6', 1, 0, {'maxOccurs': 'unbounded', 'name': 'signature', 'type': 'signatureType6'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, signature=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if signature is None:
            self.signature = []
        else:
            self.signature = signature
        self.signature_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, cryptoSignsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if cryptoSignsType.subclass:
            return cryptoSignsType.subclass(*args_, **kwargs_)
        else:
            return cryptoSignsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.signature
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'signature':
            obj_ = signatureType6.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.signature.append(obj_)
            obj_.original_tagname_ = 'signature'
# end class cryptoSignsType


class currencyType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'letterCode': MemberSpec_('letterCode', ['letterCodeType', 'nonEmptyString', 'xs:string'], 0, 0, {'name': 'letterCode', 'type': 'xs:string'}, 1),
        'code': MemberSpec_('code', ['codeType', 'nonEmptyString', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'code', 'type': 'xs:string'}, 1),
        'digitalCode': MemberSpec_('digitalCode', ['digitalCodeType', 'nonEmptyString', 'xs:string'], 0, 0, {'name': 'digitalCode', 'type': 'xs:string'}, 1),
        'name': MemberSpec_('name', ['nameType', 'nonEmptyString', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'name', 'type': 'xs:string'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, letterCode=None, code=None, digitalCode=None, name=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.letterCode = letterCode
        self.validate_letterCodeType(self.letterCode)
        self.letterCode_nsprefix_ = None
        self.code = code
        self.validate_codeType(self.code)
        self.code_nsprefix_ = None
        self.digitalCode = digitalCode
        self.validate_digitalCodeType(self.digitalCode)
        self.digitalCode_nsprefix_ = None
        self.name = name
        self.validate_nameType(self.name)
        self.name_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, currencyType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if currencyType.subclass:
            return currencyType.subclass(*args_, **kwargs_)
        else:
            return currencyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_letterCodeType(self, value):
        result = True
        # Validate type letterCodeType, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 3:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on letterCodeType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on letterCodeType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_codeType(self, value):
        result = True
        # Validate type codeType, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 3:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on codeType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on codeType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_digitalCodeType(self, value):
        result = True
        # Validate type digitalCodeType, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 3:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on digitalCodeType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on digitalCodeType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_nameType(self, value):
        result = True
        # Validate type nameType, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 50:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on nameType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on nameType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.letterCode is not None or
            self.code is not None or
            self.digitalCode is not None or
            self.name is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'letterCode':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'letterCode')
            value_ = self.gds_validate_string(value_, node, 'letterCode')
            self.letterCode = value_
            self.letterCode_nsprefix_ = child_.prefix
            # validate type letterCodeType
            self.validate_letterCodeType(self.letterCode)
        elif nodeName_ == 'code':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'code')
            value_ = self.gds_validate_string(value_, node, 'code')
            self.code = value_
            self.code_nsprefix_ = child_.prefix
            # validate type codeType
            self.validate_codeType(self.code)
        elif nodeName_ == 'digitalCode':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'digitalCode')
            value_ = self.gds_validate_string(value_, node, 'digitalCode')
            self.digitalCode = value_
            self.digitalCode_nsprefix_ = child_.prefix
            # validate type digitalCodeType
            self.validate_digitalCodeType(self.digitalCode)
        elif nodeName_ == 'name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'name')
            value_ = self.gds_validate_string(value_, node, 'name')
            self.name = value_
            self.name_nsprefix_ = child_.prefix
            # validate type nameType
            self.validate_nameType(self.name)
# end class currencyType


class customerInfoType(GeneratedsSuper):
    """Данные заказчика"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'mainInfo': MemberSpec_('mainInfo', 'customerMainInfoType', 0, 0, {'name': 'mainInfo', 'type': 'customerMainInfoType'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, mainInfo=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.mainInfo = mainInfo
        self.mainInfo_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, customerInfoType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if customerInfoType.subclass:
            return customerInfoType.subclass(*args_, **kwargs_)
        else:
            return customerInfoType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.mainInfo is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'mainInfo':
            obj_ = customerMainInfoType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.mainInfo = obj_
            obj_.original_tagname_ = 'mainInfo'
# end class customerInfoType


class supplierInfoType(GeneratedsSuper):
    """Данные поставщика"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'mainInfo': MemberSpec_('mainInfo', 'supplierMainInfoType', 0, 0, {'name': 'mainInfo', 'type': 'supplierMainInfoType'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, mainInfo=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.mainInfo = mainInfo
        self.mainInfo_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, supplierInfoType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if supplierInfoType.subclass:
            return supplierInfoType.subclass(*args_, **kwargs_)
        else:
            return supplierInfoType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.mainInfo is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'mainInfo':
            obj_ = supplierMainInfoType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.mainInfo = obj_
            obj_.original_tagname_ = 'mainInfo'
# end class supplierInfoType


class supplierMainInfoType(GeneratedsSuper):
    """Основная информация об организации поставщика"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'name': MemberSpec_('name', ['nameType7', 'nonEmptyString', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'name', 'type': 'xs:string'}, None),
        'inn': MemberSpec_('inn', ['innType', 'nonEmptyString', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'inn', 'type': 'xs:string'}, None),
        'kpp': MemberSpec_('kpp', ['kppType', 'nonEmptyString', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'kpp', 'type': 'xs:string'}, None),
        'ogrn': MemberSpec_('ogrn', ['ogrnType', 'nonEmptyString', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'ogrn', 'type': 'xs:string'}, None),
        'type_': MemberSpec_('type_', ['supplierType', 'xs:string'], 0, 0, {'name': 'type', 'type': 'xs:string'}, None),
        'address': MemberSpec_('address', ['addressType', 'nonEmptyString', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'address', 'type': 'xs:string'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, name=None, inn=None, kpp=None, ogrn=None, type_=None, address=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.name = name
        self.validate_nameType7(self.name)
        self.name_nsprefix_ = None
        self.inn = inn
        self.validate_innType(self.inn)
        self.inn_nsprefix_ = None
        self.kpp = kpp
        self.validate_kppType(self.kpp)
        self.kpp_nsprefix_ = None
        self.ogrn = ogrn
        self.validate_ogrnType(self.ogrn)
        self.ogrn_nsprefix_ = None
        self.type_ = type_
        self.validate_supplierType(self.type_)
        self.type__nsprefix_ = None
        self.address = address
        self.validate_addressType(self.address)
        self.address_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, supplierMainInfoType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if supplierMainInfoType.subclass:
            return supplierMainInfoType.subclass(*args_, **kwargs_)
        else:
            return supplierMainInfoType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_nameType7(self, value):
        result = True
        # Validate type nameType7, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on nameType7' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on nameType7' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_innType(self, value):
        result = True
        # Validate type innType, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on innType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_innType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_innType_patterns_, ))
                result = False
        return result
    validate_innType_patterns_ = [['^(\\d{10}|\\d{12})$']]
    def validate_kppType(self, value):
        result = True
        # Validate type kppType, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on kppType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_kppType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_kppType_patterns_, ))
                result = False
        return result
    validate_kppType_patterns_ = [['^(\\d{9})$']]
    def validate_ogrnType(self, value):
        result = True
        # Validate type ogrnType, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ogrnType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_ogrnType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_ogrnType_patterns_, ))
                result = False
        return result
    validate_ogrnType_patterns_ = [['^(\\d{13})$']]
    def validate_supplierType(self, value):
        result = True
        # Validate type supplierType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['L', 'P']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on supplierType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_addressType(self, value):
        result = True
        # Validate type addressType, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on addressType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on addressType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.name is not None or
            self.inn is not None or
            self.kpp is not None or
            self.ogrn is not None or
            self.type_ is not None or
            self.address is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'name')
            value_ = self.gds_validate_string(value_, node, 'name')
            self.name = value_
            self.name_nsprefix_ = child_.prefix
            # validate type nameType7
            self.validate_nameType7(self.name)
        elif nodeName_ == 'inn':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'inn')
            value_ = self.gds_validate_string(value_, node, 'inn')
            self.inn = value_
            self.inn_nsprefix_ = child_.prefix
            # validate type innType
            self.validate_innType(self.inn)
        elif nodeName_ == 'kpp':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'kpp')
            value_ = self.gds_validate_string(value_, node, 'kpp')
            self.kpp = value_
            self.kpp_nsprefix_ = child_.prefix
            # validate type kppType
            self.validate_kppType(self.kpp)
        elif nodeName_ == 'ogrn':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'ogrn')
            value_ = self.gds_validate_string(value_, node, 'ogrn')
            self.ogrn = value_
            self.ogrn_nsprefix_ = child_.prefix
            # validate type ogrnType
            self.validate_ogrnType(self.ogrn)
        elif nodeName_ == 'type':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'type')
            value_ = self.gds_validate_string(value_, node, 'type')
            self.type_ = value_
            self.type_nsprefix_ = child_.prefix
            # validate type supplierType
            self.validate_supplierType(self.type_)
        elif nodeName_ == 'address':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'address')
            value_ = self.gds_validate_string(value_, node, 'address')
            self.address = value_
            self.address_nsprefix_ = child_.prefix
            # validate type addressType
            self.validate_addressType(self.address)
# end class supplierMainInfoType


class nonResidentInfoType(GeneratedsSuper):
    """Сведения о нерезиденте РФ"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'info': MemberSpec_('info', ['infoType8', 'nonEmptyString', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'info', 'type': 'xs:string'}, None),
        'type_': MemberSpec_('type_', ['supplierType', 'xs:string'], 0, 0, {'name': 'type', 'type': 'xs:string'}, None),
        'name': MemberSpec_('name', ['nameType9', 'nonEmptyString', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'name', 'type': 'xs:string'}, None),
        'code': MemberSpec_('code', ['codeType10', 'nonEmptyString', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'code', 'type': 'xs:string'}, None),
        'additionalCode': MemberSpec_('additionalCode', ['additionalCodeType', 'nonEmptyString', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'additionalCode', 'type': 'xs:string'}, None),
        'country': MemberSpec_('country', 'countryType', 0, 1, {'minOccurs': '0', 'name': 'country', 'type': 'countryType'}, None),
        'address': MemberSpec_('address', ['addressType11', 'nonEmptyString', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'address', 'type': 'xs:string'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, info=None, type_=None, name=None, code=None, additionalCode=None, country=None, address=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.info = info
        self.validate_infoType8(self.info)
        self.info_nsprefix_ = None
        self.type_ = type_
        self.validate_supplierType(self.type_)
        self.type__nsprefix_ = None
        self.name = name
        self.validate_nameType9(self.name)
        self.name_nsprefix_ = None
        self.code = code
        self.validate_codeType10(self.code)
        self.code_nsprefix_ = None
        self.additionalCode = additionalCode
        self.validate_additionalCodeType(self.additionalCode)
        self.additionalCode_nsprefix_ = None
        self.country = country
        self.country_nsprefix_ = None
        self.address = address
        self.validate_addressType11(self.address)
        self.address_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, nonResidentInfoType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if nonResidentInfoType.subclass:
            return nonResidentInfoType.subclass(*args_, **kwargs_)
        else:
            return nonResidentInfoType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_infoType8(self, value):
        result = True
        # Validate type infoType8, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 2000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on infoType8' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on infoType8' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_supplierType(self, value):
        result = True
        # Validate type supplierType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['L', 'P']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on supplierType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_nameType9(self, value):
        result = True
        # Validate type nameType9, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on nameType9' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on nameType9' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_codeType10(self, value):
        result = True
        # Validate type codeType10, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 200:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on codeType10' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on codeType10' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_additionalCodeType(self, value):
        result = True
        # Validate type additionalCodeType, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 200:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on additionalCodeType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on additionalCodeType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_addressType11(self, value):
        result = True
        # Validate type addressType11, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on addressType11' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on addressType11' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.info is not None or
            self.type_ is not None or
            self.name is not None or
            self.code is not None or
            self.additionalCode is not None or
            self.country is not None or
            self.address is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'info':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'info')
            value_ = self.gds_validate_string(value_, node, 'info')
            self.info = value_
            self.info_nsprefix_ = child_.prefix
            # validate type infoType8
            self.validate_infoType8(self.info)
        elif nodeName_ == 'type':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'type')
            value_ = self.gds_validate_string(value_, node, 'type')
            self.type_ = value_
            self.type_nsprefix_ = child_.prefix
            # validate type supplierType
            self.validate_supplierType(self.type_)
        elif nodeName_ == 'name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'name')
            value_ = self.gds_validate_string(value_, node, 'name')
            self.name = value_
            self.name_nsprefix_ = child_.prefix
            # validate type nameType9
            self.validate_nameType9(self.name)
        elif nodeName_ == 'code':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'code')
            value_ = self.gds_validate_string(value_, node, 'code')
            self.code = value_
            self.code_nsprefix_ = child_.prefix
            # validate type codeType10
            self.validate_codeType10(self.code)
        elif nodeName_ == 'additionalCode':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'additionalCode')
            value_ = self.gds_validate_string(value_, node, 'additionalCode')
            self.additionalCode = value_
            self.additionalCode_nsprefix_ = child_.prefix
            # validate type additionalCodeType
            self.validate_additionalCodeType(self.additionalCode)
        elif nodeName_ == 'country':
            obj_ = countryType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.country = obj_
            obj_.original_tagname_ = 'country'
        elif nodeName_ == 'address':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'address')
            value_ = self.gds_validate_string(value_, node, 'address')
            self.address = value_
            self.address_nsprefix_ = child_.prefix
            # validate type addressType11
            self.validate_addressType11(self.address)
# end class nonResidentInfoType


class nonResidentLotCustomerInfoType(GeneratedsSuper):
    """Сведения о нерезиденте РФ"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'name': MemberSpec_('name', ['nameType12', 'nonEmptyString', 'xs:string'], 0, 0, {'name': 'name', 'type': 'xs:string'}, None),
        'code': MemberSpec_('code', ['codeType13', 'nonEmptyString', 'xs:string'], 0, 0, {'name': 'code', 'type': 'xs:string'}, None),
        'country': MemberSpec_('country', 'countryType', 0, 0, {'name': 'country', 'type': 'countryType'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, name=None, code=None, country=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.name = name
        self.validate_nameType12(self.name)
        self.name_nsprefix_ = None
        self.code = code
        self.validate_codeType13(self.code)
        self.code_nsprefix_ = None
        self.country = country
        self.country_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, nonResidentLotCustomerInfoType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if nonResidentLotCustomerInfoType.subclass:
            return nonResidentLotCustomerInfoType.subclass(*args_, **kwargs_)
        else:
            return nonResidentLotCustomerInfoType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_nameType12(self, value):
        result = True
        # Validate type nameType12, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on nameType12' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on nameType12' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_codeType13(self, value):
        result = True
        # Validate type codeType13, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 200:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on codeType13' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on codeType13' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.name is not None or
            self.code is not None or
            self.country is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'name')
            value_ = self.gds_validate_string(value_, node, 'name')
            self.name = value_
            self.name_nsprefix_ = child_.prefix
            # validate type nameType12
            self.validate_nameType12(self.name)
        elif nodeName_ == 'code':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'code')
            value_ = self.gds_validate_string(value_, node, 'code')
            self.code = value_
            self.code_nsprefix_ = child_.prefix
            # validate type codeType13
            self.validate_codeType13(self.code)
        elif nodeName_ == 'country':
            obj_ = countryType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.country = obj_
            obj_.original_tagname_ = 'country'
# end class nonResidentLotCustomerInfoType


class contractItemType(GeneratedsSuper):
    """Информация о товаре, работе, услуге"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'okdp': MemberSpec_('okdp', 'okdpProductType', 0, 0, {'name': 'okdp', 'type': 'okdpProductType'}, 2),
        'okpd2': MemberSpec_('okpd2', 'okpd2ProductType', 0, 0, {'name': 'okpd2', 'type': 'okpd2ProductType'}, 2),
        'okved': MemberSpec_('okved', 'okvedProductType', 0, 0, {'name': 'okved', 'type': 'okvedProductType'}, 3),
        'okved2': MemberSpec_('okved2', 'okved2ProductType', 0, 0, {'name': 'okved2', 'type': 'okved2ProductType'}, 3),
        'okei': MemberSpec_('okei', 'okeiProductType', 0, 1, {'minOccurs': '0', 'name': 'okei', 'type': 'okeiProductType'}, None),
        'qty': MemberSpec_('qty', ['lotItemQtyType', 'xs:decimal'], 0, 1, {'minOccurs': '0', 'name': 'qty', 'type': 'xs:decimal'}, None),
        'deliveryPlace': MemberSpec_('deliveryPlace', 'deliveryPlaceType', 0, 1, {'minOccurs': '0', 'name': 'deliveryPlace', 'type': 'deliveryPlaceType'}, None),
        'additionalInfo': MemberSpec_('additionalInfo', ['additionalInfoType', 'nonEmptyString', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'additionalInfo', 'type': 'xs:string'}, None),
        'ordinalNumber': MemberSpec_('ordinalNumber', 'xs:int', 0, 0, {'name': 'ordinalNumber', 'type': 'xs:int'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, okdp=None, okpd2=None, okved=None, okved2=None, okei=None, qty=None, deliveryPlace=None, additionalInfo=None, ordinalNumber=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.okdp = okdp
        self.okdp_nsprefix_ = None
        self.okpd2 = okpd2
        self.okpd2_nsprefix_ = None
        self.okved = okved
        self.okved_nsprefix_ = None
        self.okved2 = okved2
        self.okved2_nsprefix_ = None
        self.okei = okei
        self.okei_nsprefix_ = None
        self.qty = qty
        self.validate_lotItemQtyType(self.qty)
        self.qty_nsprefix_ = None
        self.deliveryPlace = deliveryPlace
        self.deliveryPlace_nsprefix_ = None
        self.additionalInfo = additionalInfo
        self.validate_additionalInfoType(self.additionalInfo)
        self.additionalInfo_nsprefix_ = None
        self.ordinalNumber = ordinalNumber
        self.ordinalNumber_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, contractItemType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if contractItemType.subclass:
            return contractItemType.subclass(*args_, **kwargs_)
        else:
            return contractItemType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_lotItemQtyType(self, value):
        result = True
        # Validate type lotItemQtyType, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, decimal_.Decimal):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (decimal_.Decimal)' % {"value": value, "lineno": lineno, })
                return False
            if len(str(value)) >= 25:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd totalDigits restriction on lotItemQtyType' % {"value": value, "lineno": lineno} )
                result = False
        return result
    def validate_additionalInfoType(self, value):
        result = True
        # Validate type additionalInfoType, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on additionalInfoType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on additionalInfoType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.okdp is not None or
            self.okpd2 is not None or
            self.okved is not None or
            self.okved2 is not None or
            self.okei is not None or
            self.qty is not None or
            self.deliveryPlace is not None or
            self.additionalInfo is not None or
            self.ordinalNumber is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'okdp':
            obj_ = okdpProductType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.okdp = obj_
            obj_.original_tagname_ = 'okdp'
        elif nodeName_ == 'okpd2':
            obj_ = okpd2ProductType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.okpd2 = obj_
            obj_.original_tagname_ = 'okpd2'
        elif nodeName_ == 'okved':
            obj_ = okvedProductType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.okved = obj_
            obj_.original_tagname_ = 'okved'
        elif nodeName_ == 'okved2':
            obj_ = okved2ProductType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.okved2 = obj_
            obj_.original_tagname_ = 'okved2'
        elif nodeName_ == 'okei':
            obj_ = okeiProductType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.okei = obj_
            obj_.original_tagname_ = 'okei'
        elif nodeName_ == 'qty' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'qty')
            fval_ = self.gds_validate_decimal(fval_, node, 'qty')
            self.qty = fval_
            self.qty_nsprefix_ = child_.prefix
            # validate type lotItemQtyType
            self.validate_lotItemQtyType(self.qty)
        elif nodeName_ == 'deliveryPlace':
            obj_ = deliveryPlaceType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.deliveryPlace = obj_
            obj_.original_tagname_ = 'deliveryPlace'
        elif nodeName_ == 'additionalInfo':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'additionalInfo')
            value_ = self.gds_validate_string(value_, node, 'additionalInfo')
            self.additionalInfo = value_
            self.additionalInfo_nsprefix_ = child_.prefix
            # validate type additionalInfoType
            self.validate_additionalInfoType(self.additionalInfo)
        elif nodeName_ == 'ordinalNumber' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'ordinalNumber')
            ival_ = self.gds_validate_integer(ival_, node, 'ordinalNumber')
            self.ordinalNumber = ival_
            self.ordinalNumber_nsprefix_ = child_.prefix
# end class contractItemType


class customerInfo2Type(GeneratedsSuper):
    """Данные заказчика"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'mainInfo': MemberSpec_('mainInfo', 'customerMainInfo2Type', 0, 0, {'name': 'mainInfo', 'type': 'customerMainInfo2Type'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, mainInfo=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.mainInfo = mainInfo
        self.mainInfo_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, customerInfo2Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if customerInfo2Type.subclass:
            return customerInfo2Type.subclass(*args_, **kwargs_)
        else:
            return customerInfo2Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.mainInfo is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'mainInfo':
            obj_ = customerMainInfo2Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.mainInfo = obj_
            obj_.original_tagname_ = 'mainInfo'
# end class customerInfo2Type


class customerInfo3Type(GeneratedsSuper):
    """Данные заказчика"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'mainInfo': MemberSpec_('mainInfo', 'customerMainInfo3Type', 0, 0, {'name': 'mainInfo', 'type': 'customerMainInfo3Type'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, mainInfo=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.mainInfo = mainInfo
        self.mainInfo_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, customerInfo3Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if customerInfo3Type.subclass:
            return customerInfo3Type.subclass(*args_, **kwargs_)
        else:
            return customerInfo3Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.mainInfo is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'mainInfo':
            obj_ = customerMainInfo3Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.mainInfo = obj_
            obj_.original_tagname_ = 'mainInfo'
# end class customerInfo3Type


class customerMainInfoType(GeneratedsSuper):
    """Основная информация об организации"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'fullName': MemberSpec_('fullName', ['fullNameType', 'nonEmptyString', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'fullName', 'type': 'xs:string'}, None),
        'shortName': MemberSpec_('shortName', ['shortNameType', 'nonEmptyString', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'shortName', 'type': 'xs:string'}, None),
        'iko': MemberSpec_('iko', ['ikoType', 'nonEmptyString', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'iko', 'type': 'xs:string'}, None),
        'inn': MemberSpec_('inn', ['innType', 'nonEmptyString', 'xs:string'], 0, 0, {'name': 'inn', 'type': 'xs:string'}, None),
        'kpp': MemberSpec_('kpp', ['kppType', 'nonEmptyString', 'xs:string'], 0, 0, {'name': 'kpp', 'type': 'xs:string'}, None),
        'ogrn': MemberSpec_('ogrn', ['ogrnType', 'nonEmptyString', 'xs:string'], 0, 0, {'name': 'ogrn', 'type': 'xs:string'}, None),
        'legalAddress': MemberSpec_('legalAddress', ['legalAddressType', 'nonEmptyString', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'legalAddress', 'type': 'xs:string'}, None),
        'postalAddress': MemberSpec_('postalAddress', ['postalAddressType', 'nonEmptyString', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'postalAddress', 'type': 'xs:string'}, None),
        'phone': MemberSpec_('phone', ['phoneType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'phone', 'type': 'xs:string'}, None),
        'fax': MemberSpec_('fax', ['phoneType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'fax', 'type': 'xs:string'}, None),
        'email': MemberSpec_('email', ['emailType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'email', 'type': 'xs:string'}, None),
        'okato': MemberSpec_('okato', ['codeOkatoType', 'nonEmptyString', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'okato', 'type': 'xs:string'}, None),
        'okopf': MemberSpec_('okopf', ['codeOkopfType', 'nonEmptyString', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'okopf', 'type': 'xs:string'}, None),
        'okopfName': MemberSpec_('okopfName', ['okopfNameType', 'nonEmptyString', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'okopfName', 'type': 'xs:string'}, None),
        'okpo': MemberSpec_('okpo', ['customerCodeOkpoType', 'nonEmptyString', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'okpo', 'type': 'xs:string'}, None),
        'customerRegistrationDate': MemberSpec_('customerRegistrationDate', 'xs:dateTime', 0, 1, {'minOccurs': '0', 'name': 'customerRegistrationDate', 'type': 'xs:dateTime'}, None),
        'timeZone': MemberSpec_('timeZone', 'timeZoneType', 0, 1, {'minOccurs': '0', 'name': 'timeZone', 'type': 'timeZoneType'}, None),
        'region': MemberSpec_('region', ['regionType', 'nonEmptyString', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'region', 'type': 'xs:string'}, None),
        'customerAssessedCompliance': MemberSpec_('customerAssessedCompliance', 'xs:boolean', 0, 1, {'minOccurs': '0', 'name': 'customerAssessedCompliance', 'type': 'xs:boolean'}, None),
        'customerMonitoredCompliance': MemberSpec_('customerMonitoredCompliance', 'xs:boolean', 0, 1, {'minOccurs': '0', 'name': 'customerMonitoredCompliance', 'type': 'xs:boolean'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, fullName=None, shortName=None, iko=None, inn=None, kpp=None, ogrn=None, legalAddress=None, postalAddress=None, phone=None, fax=None, email=None, okato=None, okopf=None, okopfName=None, okpo=None, customerRegistrationDate=None, timeZone=None, region=None, customerAssessedCompliance=None, customerMonitoredCompliance=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.fullName = fullName
        self.validate_fullNameType(self.fullName)
        self.fullName_nsprefix_ = None
        self.shortName = shortName
        self.validate_shortNameType(self.shortName)
        self.shortName_nsprefix_ = None
        self.iko = iko
        self.validate_ikoType(self.iko)
        self.iko_nsprefix_ = None
        self.inn = inn
        self.validate_innType(self.inn)
        self.inn_nsprefix_ = None
        self.kpp = kpp
        self.validate_kppType(self.kpp)
        self.kpp_nsprefix_ = None
        self.ogrn = ogrn
        self.validate_ogrnType(self.ogrn)
        self.ogrn_nsprefix_ = None
        self.legalAddress = legalAddress
        self.validate_legalAddressType(self.legalAddress)
        self.legalAddress_nsprefix_ = None
        self.postalAddress = postalAddress
        self.validate_postalAddressType(self.postalAddress)
        self.postalAddress_nsprefix_ = None
        self.phone = phone
        self.validate_phoneType(self.phone)
        self.phone_nsprefix_ = None
        self.fax = fax
        self.validate_phoneType(self.fax)
        self.fax_nsprefix_ = None
        self.email = email
        self.validate_emailType(self.email)
        self.email_nsprefix_ = None
        self.okato = okato
        self.validate_codeOkatoType(self.okato)
        self.okato_nsprefix_ = None
        self.okopf = okopf
        self.validate_codeOkopfType(self.okopf)
        self.okopf_nsprefix_ = None
        self.okopfName = okopfName
        self.validate_okopfNameType(self.okopfName)
        self.okopfName_nsprefix_ = None
        self.okpo = okpo
        self.validate_customerCodeOkpoType(self.okpo)
        self.okpo_nsprefix_ = None
        if isinstance(customerRegistrationDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(customerRegistrationDate, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = customerRegistrationDate
        self.customerRegistrationDate = initvalue_
        self.customerRegistrationDate_nsprefix_ = None
        self.timeZone = timeZone
        self.timeZone_nsprefix_ = None
        self.region = region
        self.validate_regionType(self.region)
        self.region_nsprefix_ = None
        self.customerAssessedCompliance = customerAssessedCompliance
        self.customerAssessedCompliance_nsprefix_ = None
        self.customerMonitoredCompliance = customerMonitoredCompliance
        self.customerMonitoredCompliance_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, customerMainInfoType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if customerMainInfoType.subclass:
            return customerMainInfoType.subclass(*args_, **kwargs_)
        else:
            return customerMainInfoType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_fullNameType(self, value):
        result = True
        # Validate type fullNameType, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on fullNameType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on fullNameType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_shortNameType(self, value):
        result = True
        # Validate type shortNameType, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 500:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on shortNameType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on shortNameType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_ikoType(self, value):
        result = True
        # Validate type ikoType, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ikoType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_ikoType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_ikoType_patterns_, ))
                result = False
        return result
    validate_ikoType_patterns_ = [['^(\\d{20}|\\d{22})$']]
    def validate_innType(self, value):
        result = True
        # Validate type innType, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on innType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_innType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_innType_patterns_, ))
                result = False
        return result
    validate_innType_patterns_ = [['^(\\d{10}|\\d{12})$']]
    def validate_kppType(self, value):
        result = True
        # Validate type kppType, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on kppType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_kppType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_kppType_patterns_, ))
                result = False
        return result
    validate_kppType_patterns_ = [['^(\\d{9})$']]
    def validate_ogrnType(self, value):
        result = True
        # Validate type ogrnType, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ogrnType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_ogrnType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_ogrnType_patterns_, ))
                result = False
        return result
    validate_ogrnType_patterns_ = [['^(\\d{13})$']]
    def validate_legalAddressType(self, value):
        result = True
        # Validate type legalAddressType, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 2000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on legalAddressType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on legalAddressType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_postalAddressType(self, value):
        result = True
        # Validate type postalAddressType, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 2000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on postalAddressType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on postalAddressType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_phoneType(self, value):
        result = True
        # Validate type phoneType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 300:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on phoneType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on phoneType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_emailType(self, value):
        result = True
        # Validate type emailType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 300:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on emailType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on emailType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_emailType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_emailType_patterns_, ))
                result = False
        return result
    validate_emailType_patterns_ = [["^(([\\-a-zA-Zа-яА-Я0-9!#%&'\\*\\+/=\\?\\^_`\\{\\|\\}~]+(\\.[\\-a-zA-Zа-яА-Я0-9!#%&'\\*\\+/=\\?\\^_`\\{\\|\\}~]+)*@([a-zA-Zа-яА-Я0-9]([\\-_a-zA-Zа-яА-Я0-9]{0,61}[a-zA-Zа-яА-Я0-9])?\\.)*[\\-a-zA-Zа-яА-Я0-9]+(\\.[\\-a-zA-Zа-яА-Я0-9]+)*)+(,\\s?[\\-a-zA-Zа-яА-Я0-9!#%&'\\*\\+/=\\?\\^_`\\{\\|\\}~]+(\\.[\\-a-zA-Zа-яА-Я0-9!#%&'\\*\\+/=\\?\\^_`\\{\\|\\}~]+)*@([a-zA-Zа-яА-Я0-9]([\\-_a-zA-Zа-яА-Я0-9]{0,61}[a-zA-Zа-яА-Я0-9])?\\.)*[\\-a-zA-Zа-яА-Я0-9]+(\\.[\\-a-zA-Zа-яА-Я0-9]+)*)*)$"]]
    def validate_codeOkatoType(self, value):
        result = True
        # Validate type codeOkatoType, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on codeOkatoType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_codeOkatoType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_codeOkatoType_patterns_, ))
                result = False
        return result
    validate_codeOkatoType_patterns_ = [['^(\\d{11})$']]
    def validate_codeOkopfType(self, value):
        result = True
        # Validate type codeOkopfType, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on codeOkopfType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_codeOkopfType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_codeOkopfType_patterns_, ))
                result = False
        return result
    validate_codeOkopfType_patterns_ = [['^(\\d{2}|\\d{5})$']]
    def validate_okopfNameType(self, value):
        result = True
        # Validate type okopfNameType, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 200:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on okopfNameType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on okopfNameType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_customerCodeOkpoType(self, value):
        result = True
        # Validate type customerCodeOkpoType, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on customerCodeOkpoType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_customerCodeOkpoType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_customerCodeOkpoType_patterns_, ))
                result = False
        return result
    validate_customerCodeOkpoType_patterns_ = [['^(\\d{8})$']]
    def validate_regionType(self, value):
        result = True
        # Validate type regionType, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 200:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on regionType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on regionType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.fullName is not None or
            self.shortName is not None or
            self.iko is not None or
            self.inn is not None or
            self.kpp is not None or
            self.ogrn is not None or
            self.legalAddress is not None or
            self.postalAddress is not None or
            self.phone is not None or
            self.fax is not None or
            self.email is not None or
            self.okato is not None or
            self.okopf is not None or
            self.okopfName is not None or
            self.okpo is not None or
            self.customerRegistrationDate is not None or
            self.timeZone is not None or
            self.region is not None or
            self.customerAssessedCompliance is not None or
            self.customerMonitoredCompliance is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'fullName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'fullName')
            value_ = self.gds_validate_string(value_, node, 'fullName')
            self.fullName = value_
            self.fullName_nsprefix_ = child_.prefix
            # validate type fullNameType
            self.validate_fullNameType(self.fullName)
        elif nodeName_ == 'shortName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'shortName')
            value_ = self.gds_validate_string(value_, node, 'shortName')
            self.shortName = value_
            self.shortName_nsprefix_ = child_.prefix
            # validate type shortNameType
            self.validate_shortNameType(self.shortName)
        elif nodeName_ == 'iko':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'iko')
            value_ = self.gds_validate_string(value_, node, 'iko')
            self.iko = value_
            self.iko_nsprefix_ = child_.prefix
            # validate type ikoType
            self.validate_ikoType(self.iko)
        elif nodeName_ == 'inn':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'inn')
            value_ = self.gds_validate_string(value_, node, 'inn')
            self.inn = value_
            self.inn_nsprefix_ = child_.prefix
            # validate type innType
            self.validate_innType(self.inn)
        elif nodeName_ == 'kpp':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'kpp')
            value_ = self.gds_validate_string(value_, node, 'kpp')
            self.kpp = value_
            self.kpp_nsprefix_ = child_.prefix
            # validate type kppType
            self.validate_kppType(self.kpp)
        elif nodeName_ == 'ogrn':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'ogrn')
            value_ = self.gds_validate_string(value_, node, 'ogrn')
            self.ogrn = value_
            self.ogrn_nsprefix_ = child_.prefix
            # validate type ogrnType
            self.validate_ogrnType(self.ogrn)
        elif nodeName_ == 'legalAddress':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'legalAddress')
            value_ = self.gds_validate_string(value_, node, 'legalAddress')
            self.legalAddress = value_
            self.legalAddress_nsprefix_ = child_.prefix
            # validate type legalAddressType
            self.validate_legalAddressType(self.legalAddress)
        elif nodeName_ == 'postalAddress':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'postalAddress')
            value_ = self.gds_validate_string(value_, node, 'postalAddress')
            self.postalAddress = value_
            self.postalAddress_nsprefix_ = child_.prefix
            # validate type postalAddressType
            self.validate_postalAddressType(self.postalAddress)
        elif nodeName_ == 'phone':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'phone')
            value_ = self.gds_validate_string(value_, node, 'phone')
            self.phone = value_
            self.phone_nsprefix_ = child_.prefix
            # validate type phoneType
            self.validate_phoneType(self.phone)
        elif nodeName_ == 'fax':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'fax')
            value_ = self.gds_validate_string(value_, node, 'fax')
            self.fax = value_
            self.fax_nsprefix_ = child_.prefix
            # validate type phoneType
            self.validate_phoneType(self.fax)
        elif nodeName_ == 'email':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'email')
            value_ = self.gds_validate_string(value_, node, 'email')
            self.email = value_
            self.email_nsprefix_ = child_.prefix
            # validate type emailType
            self.validate_emailType(self.email)
        elif nodeName_ == 'okato':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'okato')
            value_ = self.gds_validate_string(value_, node, 'okato')
            self.okato = value_
            self.okato_nsprefix_ = child_.prefix
            # validate type codeOkatoType
            self.validate_codeOkatoType(self.okato)
        elif nodeName_ == 'okopf':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'okopf')
            value_ = self.gds_validate_string(value_, node, 'okopf')
            self.okopf = value_
            self.okopf_nsprefix_ = child_.prefix
            # validate type codeOkopfType
            self.validate_codeOkopfType(self.okopf)
        elif nodeName_ == 'okopfName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'okopfName')
            value_ = self.gds_validate_string(value_, node, 'okopfName')
            self.okopfName = value_
            self.okopfName_nsprefix_ = child_.prefix
            # validate type okopfNameType
            self.validate_okopfNameType(self.okopfName)
        elif nodeName_ == 'okpo':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'okpo')
            value_ = self.gds_validate_string(value_, node, 'okpo')
            self.okpo = value_
            self.okpo_nsprefix_ = child_.prefix
            # validate type customerCodeOkpoType
            self.validate_customerCodeOkpoType(self.okpo)
        elif nodeName_ == 'customerRegistrationDate':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.customerRegistrationDate = dval_
            self.customerRegistrationDate_nsprefix_ = child_.prefix
        elif nodeName_ == 'timeZone':
            obj_ = timeZoneType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.timeZone = obj_
            obj_.original_tagname_ = 'timeZone'
        elif nodeName_ == 'region':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'region')
            value_ = self.gds_validate_string(value_, node, 'region')
            self.region = value_
            self.region_nsprefix_ = child_.prefix
            # validate type regionType
            self.validate_regionType(self.region)
        elif nodeName_ == 'customerAssessedCompliance':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'customerAssessedCompliance')
            ival_ = self.gds_validate_boolean(ival_, node, 'customerAssessedCompliance')
            self.customerAssessedCompliance = ival_
            self.customerAssessedCompliance_nsprefix_ = child_.prefix
        elif nodeName_ == 'customerMonitoredCompliance':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'customerMonitoredCompliance')
            ival_ = self.gds_validate_boolean(ival_, node, 'customerMonitoredCompliance')
            self.customerMonitoredCompliance = ival_
            self.customerMonitoredCompliance_nsprefix_ = child_.prefix
# end class customerMainInfoType


class customerRegistryInfoType(GeneratedsSuper):
    """Регистрационные данные юридического лица"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'fullName': MemberSpec_('fullName', ['fullNameType14', 'nonEmptyString', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'fullName', 'type': 'xs:string'}, None),
        'ogrn': MemberSpec_('ogrn', ['ogrnType', 'nonEmptyString', 'xs:string'], 0, 0, {'name': 'ogrn', 'type': 'xs:string'}, None),
        'inn': MemberSpec_('inn', ['innType', 'nonEmptyString', 'xs:string'], 0, 0, {'name': 'inn', 'type': 'xs:string'}, None),
        'kpp': MemberSpec_('kpp', ['kppType', 'nonEmptyString', 'xs:string'], 0, 0, {'name': 'kpp', 'type': 'xs:string'}, None),
        'customerRegistrationDate': MemberSpec_('customerRegistrationDate', 'xs:dateTime', 0, 1, {'minOccurs': '0', 'name': 'customerRegistrationDate', 'type': 'xs:dateTime'}, None),
        'legalAddress': MemberSpec_('legalAddress', ['legalAddressType15', 'nonEmptyString', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'legalAddress', 'type': 'xs:string'}, None),
        'website': MemberSpec_('website', ['websiteType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'website', 'type': 'xs:string'}, None),
        'iko': MemberSpec_('iko', ['ikoType', 'nonEmptyString', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'iko', 'type': 'xs:string'}, None),
        'createIkoDate': MemberSpec_('createIkoDate', 'xs:dateTime', 0, 1, {'minOccurs': '0', 'name': 'createIkoDate', 'type': 'xs:dateTime'}, None),
        'timeZone': MemberSpec_('timeZone', 'timeZoneType', 0, 1, {'minOccurs': '0', 'name': 'timeZone', 'type': 'timeZoneType'}, None),
        'postalAddress': MemberSpec_('postalAddress', ['postalAddressType16', 'nonEmptyString', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'postalAddress', 'type': 'xs:string'}, None),
        'emailSystem': MemberSpec_('emailSystem', ['emailType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'emailSystem', 'type': 'xs:string'}, None),
        'email': MemberSpec_('email', ['emailType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'email', 'type': 'xs:string'}, None),
        'phone': MemberSpec_('phone', ['phoneType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'phone', 'type': 'xs:string'}, None),
        'fax': MemberSpec_('fax', ['phoneType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'fax', 'type': 'xs:string'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, fullName=None, ogrn=None, inn=None, kpp=None, customerRegistrationDate=None, legalAddress=None, website=None, iko=None, createIkoDate=None, timeZone=None, postalAddress=None, emailSystem=None, email=None, phone=None, fax=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.fullName = fullName
        self.validate_fullNameType14(self.fullName)
        self.fullName_nsprefix_ = None
        self.ogrn = ogrn
        self.validate_ogrnType(self.ogrn)
        self.ogrn_nsprefix_ = None
        self.inn = inn
        self.validate_innType(self.inn)
        self.inn_nsprefix_ = None
        self.kpp = kpp
        self.validate_kppType(self.kpp)
        self.kpp_nsprefix_ = None
        if isinstance(customerRegistrationDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(customerRegistrationDate, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = customerRegistrationDate
        self.customerRegistrationDate = initvalue_
        self.customerRegistrationDate_nsprefix_ = None
        self.legalAddress = legalAddress
        self.validate_legalAddressType15(self.legalAddress)
        self.legalAddress_nsprefix_ = None
        self.website = website
        self.validate_websiteType(self.website)
        self.website_nsprefix_ = None
        self.iko = iko
        self.validate_ikoType(self.iko)
        self.iko_nsprefix_ = None
        if isinstance(createIkoDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(createIkoDate, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = createIkoDate
        self.createIkoDate = initvalue_
        self.createIkoDate_nsprefix_ = None
        self.timeZone = timeZone
        self.timeZone_nsprefix_ = None
        self.postalAddress = postalAddress
        self.validate_postalAddressType16(self.postalAddress)
        self.postalAddress_nsprefix_ = None
        self.emailSystem = emailSystem
        self.validate_emailType(self.emailSystem)
        self.emailSystem_nsprefix_ = None
        self.email = email
        self.validate_emailType(self.email)
        self.email_nsprefix_ = None
        self.phone = phone
        self.validate_phoneType(self.phone)
        self.phone_nsprefix_ = None
        self.fax = fax
        self.validate_phoneType(self.fax)
        self.fax_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, customerRegistryInfoType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if customerRegistryInfoType.subclass:
            return customerRegistryInfoType.subclass(*args_, **kwargs_)
        else:
            return customerRegistryInfoType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_fullNameType14(self, value):
        result = True
        # Validate type fullNameType14, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on fullNameType14' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on fullNameType14' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_ogrnType(self, value):
        result = True
        # Validate type ogrnType, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ogrnType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_ogrnType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_ogrnType_patterns_, ))
                result = False
        return result
    validate_ogrnType_patterns_ = [['^(\\d{13})$']]
    def validate_innType(self, value):
        result = True
        # Validate type innType, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on innType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_innType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_innType_patterns_, ))
                result = False
        return result
    validate_innType_patterns_ = [['^(\\d{10}|\\d{12})$']]
    def validate_kppType(self, value):
        result = True
        # Validate type kppType, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on kppType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_kppType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_kppType_patterns_, ))
                result = False
        return result
    validate_kppType_patterns_ = [['^(\\d{9})$']]
    def validate_legalAddressType15(self, value):
        result = True
        # Validate type legalAddressType15, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 2000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on legalAddressType15' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on legalAddressType15' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_websiteType(self, value):
        result = True
        # Validate type websiteType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 300:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on websiteType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_ikoType(self, value):
        result = True
        # Validate type ikoType, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ikoType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_ikoType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_ikoType_patterns_, ))
                result = False
        return result
    validate_ikoType_patterns_ = [['^(\\d{20}|\\d{22})$']]
    def validate_postalAddressType16(self, value):
        result = True
        # Validate type postalAddressType16, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 2000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on postalAddressType16' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on postalAddressType16' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_emailType(self, value):
        result = True
        # Validate type emailType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 300:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on emailType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on emailType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_emailType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_emailType_patterns_, ))
                result = False
        return result
    validate_emailType_patterns_ = [["^(([\\-a-zA-Zа-яА-Я0-9!#%&'\\*\\+/=\\?\\^_`\\{\\|\\}~]+(\\.[\\-a-zA-Zа-яА-Я0-9!#%&'\\*\\+/=\\?\\^_`\\{\\|\\}~]+)*@([a-zA-Zа-яА-Я0-9]([\\-_a-zA-Zа-яА-Я0-9]{0,61}[a-zA-Zа-яА-Я0-9])?\\.)*[\\-a-zA-Zа-яА-Я0-9]+(\\.[\\-a-zA-Zа-яА-Я0-9]+)*)+(,\\s?[\\-a-zA-Zа-яА-Я0-9!#%&'\\*\\+/=\\?\\^_`\\{\\|\\}~]+(\\.[\\-a-zA-Zа-яА-Я0-9!#%&'\\*\\+/=\\?\\^_`\\{\\|\\}~]+)*@([a-zA-Zа-яА-Я0-9]([\\-_a-zA-Zа-яА-Я0-9]{0,61}[a-zA-Zа-яА-Я0-9])?\\.)*[\\-a-zA-Zа-яА-Я0-9]+(\\.[\\-a-zA-Zа-яА-Я0-9]+)*)*)$"]]
    def validate_phoneType(self, value):
        result = True
        # Validate type phoneType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 300:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on phoneType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on phoneType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.fullName is not None or
            self.ogrn is not None or
            self.inn is not None or
            self.kpp is not None or
            self.customerRegistrationDate is not None or
            self.legalAddress is not None or
            self.website is not None or
            self.iko is not None or
            self.createIkoDate is not None or
            self.timeZone is not None or
            self.postalAddress is not None or
            self.emailSystem is not None or
            self.email is not None or
            self.phone is not None or
            self.fax is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'fullName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'fullName')
            value_ = self.gds_validate_string(value_, node, 'fullName')
            self.fullName = value_
            self.fullName_nsprefix_ = child_.prefix
            # validate type fullNameType14
            self.validate_fullNameType14(self.fullName)
        elif nodeName_ == 'ogrn':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'ogrn')
            value_ = self.gds_validate_string(value_, node, 'ogrn')
            self.ogrn = value_
            self.ogrn_nsprefix_ = child_.prefix
            # validate type ogrnType
            self.validate_ogrnType(self.ogrn)
        elif nodeName_ == 'inn':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'inn')
            value_ = self.gds_validate_string(value_, node, 'inn')
            self.inn = value_
            self.inn_nsprefix_ = child_.prefix
            # validate type innType
            self.validate_innType(self.inn)
        elif nodeName_ == 'kpp':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'kpp')
            value_ = self.gds_validate_string(value_, node, 'kpp')
            self.kpp = value_
            self.kpp_nsprefix_ = child_.prefix
            # validate type kppType
            self.validate_kppType(self.kpp)
        elif nodeName_ == 'customerRegistrationDate':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.customerRegistrationDate = dval_
            self.customerRegistrationDate_nsprefix_ = child_.prefix
        elif nodeName_ == 'legalAddress':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'legalAddress')
            value_ = self.gds_validate_string(value_, node, 'legalAddress')
            self.legalAddress = value_
            self.legalAddress_nsprefix_ = child_.prefix
            # validate type legalAddressType15
            self.validate_legalAddressType15(self.legalAddress)
        elif nodeName_ == 'website':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'website')
            value_ = self.gds_validate_string(value_, node, 'website')
            self.website = value_
            self.website_nsprefix_ = child_.prefix
            # validate type websiteType
            self.validate_websiteType(self.website)
        elif nodeName_ == 'iko':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'iko')
            value_ = self.gds_validate_string(value_, node, 'iko')
            self.iko = value_
            self.iko_nsprefix_ = child_.prefix
            # validate type ikoType
            self.validate_ikoType(self.iko)
        elif nodeName_ == 'createIkoDate':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.createIkoDate = dval_
            self.createIkoDate_nsprefix_ = child_.prefix
        elif nodeName_ == 'timeZone':
            obj_ = timeZoneType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.timeZone = obj_
            obj_.original_tagname_ = 'timeZone'
        elif nodeName_ == 'postalAddress':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'postalAddress')
            value_ = self.gds_validate_string(value_, node, 'postalAddress')
            self.postalAddress = value_
            self.postalAddress_nsprefix_ = child_.prefix
            # validate type postalAddressType16
            self.validate_postalAddressType16(self.postalAddress)
        elif nodeName_ == 'emailSystem':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'emailSystem')
            value_ = self.gds_validate_string(value_, node, 'emailSystem')
            self.emailSystem = value_
            self.emailSystem_nsprefix_ = child_.prefix
            # validate type emailType
            self.validate_emailType(self.emailSystem)
        elif nodeName_ == 'email':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'email')
            value_ = self.gds_validate_string(value_, node, 'email')
            self.email = value_
            self.email_nsprefix_ = child_.prefix
            # validate type emailType
            self.validate_emailType(self.email)
        elif nodeName_ == 'phone':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'phone')
            value_ = self.gds_validate_string(value_, node, 'phone')
            self.phone = value_
            self.phone_nsprefix_ = child_.prefix
            # validate type phoneType
            self.validate_phoneType(self.phone)
        elif nodeName_ == 'fax':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'fax')
            value_ = self.gds_validate_string(value_, node, 'fax')
            self.fax = value_
            self.fax_nsprefix_ = child_.prefix
            # validate type phoneType
            self.validate_phoneType(self.fax)
# end class customerRegistryInfoType


class ikulType(GeneratedsSuper):
    """Идентификационные коды юридического лица (ИКЮЛ)"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'ikulCode': MemberSpec_('ikulCode', ['ikulCodeType', 'nonEmptyString', 'xs:string'], 0, 0, {'name': 'ikulCode', 'type': 'xs:string'}, None),
        'ikulName': MemberSpec_('ikulName', ['ikulNameType', 'nonEmptyString', 'xs:string'], 0, 0, {'name': 'ikulName', 'type': 'xs:string'}, None),
        'assignmentDate': MemberSpec_('assignmentDate', 'xs:dateTime', 0, 1, {'minOccurs': '0', 'name': 'assignmentDate', 'type': 'xs:dateTime'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, ikulCode=None, ikulName=None, assignmentDate=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.ikulCode = ikulCode
        self.validate_ikulCodeType(self.ikulCode)
        self.ikulCode_nsprefix_ = None
        self.ikulName = ikulName
        self.validate_ikulNameType(self.ikulName)
        self.ikulName_nsprefix_ = None
        if isinstance(assignmentDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(assignmentDate, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = assignmentDate
        self.assignmentDate = initvalue_
        self.assignmentDate_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ikulType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ikulType.subclass:
            return ikulType.subclass(*args_, **kwargs_)
        else:
            return ikulType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_ikulCodeType(self, value):
        result = True
        # Validate type ikulCodeType, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 100:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ikulCodeType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ikulCodeType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_ikulNameType(self, value):
        result = True
        # Validate type ikulNameType, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 255:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ikulNameType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ikulNameType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.ikulCode is not None or
            self.ikulName is not None or
            self.assignmentDate is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ikulCode':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'ikulCode')
            value_ = self.gds_validate_string(value_, node, 'ikulCode')
            self.ikulCode = value_
            self.ikulCode_nsprefix_ = child_.prefix
            # validate type ikulCodeType
            self.validate_ikulCodeType(self.ikulCode)
        elif nodeName_ == 'ikulName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'ikulName')
            value_ = self.gds_validate_string(value_, node, 'ikulName')
            self.ikulName = value_
            self.ikulName_nsprefix_ = child_.prefix
            # validate type ikulNameType
            self.validate_ikulNameType(self.ikulName)
        elif nodeName_ == 'assignmentDate':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.assignmentDate = dval_
            self.assignmentDate_nsprefix_ = child_.prefix
# end class ikulType


class grantedUserWoAttorneyType(GeneratedsSuper):
    """Информация о лице, имеющем право действовать без доверенности"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'lastName': MemberSpec_('lastName', ['lastNameType17', 'nonEmptyString', 'xs:string'], 0, 0, {'name': 'lastName', 'type': 'xs:string'}, None),
        'firstName': MemberSpec_('firstName', ['firstNameType18', 'nonEmptyString', 'xs:string'], 0, 0, {'name': 'firstName', 'type': 'xs:string'}, None),
        'middleName': MemberSpec_('middleName', ['middleNameType19', 'nonEmptyString', 'xs:string'], 0, 0, {'name': 'middleName', 'type': 'xs:string'}, None),
        'inn': MemberSpec_('inn', ['innType', 'nonEmptyString', 'xs:string'], 0, 0, {'name': 'inn', 'type': 'xs:string'}, None),
        'position': MemberSpec_('position', ['positionType', 'nonEmptyString', 'xs:string'], 0, 0, {'name': 'position', 'type': 'xs:string'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, lastName=None, firstName=None, middleName=None, inn=None, position=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.lastName = lastName
        self.validate_lastNameType17(self.lastName)
        self.lastName_nsprefix_ = None
        self.firstName = firstName
        self.validate_firstNameType18(self.firstName)
        self.firstName_nsprefix_ = None
        self.middleName = middleName
        self.validate_middleNameType19(self.middleName)
        self.middleName_nsprefix_ = None
        self.inn = inn
        self.validate_innType(self.inn)
        self.inn_nsprefix_ = None
        self.position = position
        self.validate_positionType(self.position)
        self.position_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, grantedUserWoAttorneyType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if grantedUserWoAttorneyType.subclass:
            return grantedUserWoAttorneyType.subclass(*args_, **kwargs_)
        else:
            return grantedUserWoAttorneyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_lastNameType17(self, value):
        result = True
        # Validate type lastNameType17, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 100:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on lastNameType17' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on lastNameType17' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_firstNameType18(self, value):
        result = True
        # Validate type firstNameType18, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 100:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on firstNameType18' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on firstNameType18' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_middleNameType19(self, value):
        result = True
        # Validate type middleNameType19, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 100:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on middleNameType19' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on middleNameType19' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_innType(self, value):
        result = True
        # Validate type innType, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on innType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_innType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_innType_patterns_, ))
                result = False
        return result
    validate_innType_patterns_ = [['^(\\d{10}|\\d{12})$']]
    def validate_positionType(self, value):
        result = True
        # Validate type positionType, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 200:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on positionType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on positionType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.lastName is not None or
            self.firstName is not None or
            self.middleName is not None or
            self.inn is not None or
            self.position is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'lastName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'lastName')
            value_ = self.gds_validate_string(value_, node, 'lastName')
            self.lastName = value_
            self.lastName_nsprefix_ = child_.prefix
            # validate type lastNameType17
            self.validate_lastNameType17(self.lastName)
        elif nodeName_ == 'firstName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'firstName')
            value_ = self.gds_validate_string(value_, node, 'firstName')
            self.firstName = value_
            self.firstName_nsprefix_ = child_.prefix
            # validate type firstNameType18
            self.validate_firstNameType18(self.firstName)
        elif nodeName_ == 'middleName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'middleName')
            value_ = self.gds_validate_string(value_, node, 'middleName')
            self.middleName = value_
            self.middleName_nsprefix_ = child_.prefix
            # validate type middleNameType19
            self.validate_middleNameType19(self.middleName)
        elif nodeName_ == 'inn':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'inn')
            value_ = self.gds_validate_string(value_, node, 'inn')
            self.inn = value_
            self.inn_nsprefix_ = child_.prefix
            # validate type innType
            self.validate_innType(self.inn)
        elif nodeName_ == 'position':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'position')
            value_ = self.gds_validate_string(value_, node, 'position')
            self.position = value_
            self.position_nsprefix_ = child_.prefix
            # validate type positionType
            self.validate_positionType(self.position)
# end class grantedUserWoAttorneyType


class capitalStockAgencyType(GeneratedsSuper):
    """Информация о юридических лицах, перечисленных в пунктах 1, 2 части 2
    статьи 1 Федерального закона № 223-ФЗ"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'fullName': MemberSpec_('fullName', ['fullNameType20', 'nonEmptyString', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'fullName', 'type': 'xs:string'}, None),
        'ogrn': MemberSpec_('ogrn', ['ogrnType', 'nonEmptyString', 'xs:string'], 0, 0, {'name': 'ogrn', 'type': 'xs:string'}, None),
        'inn': MemberSpec_('inn', ['innType', 'nonEmptyString', 'xs:string'], 0, 0, {'name': 'inn', 'type': 'xs:string'}, None),
        'kpp': MemberSpec_('kpp', ['kppType', 'nonEmptyString', 'xs:string'], 0, 0, {'name': 'kpp', 'type': 'xs:string'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, fullName=None, ogrn=None, inn=None, kpp=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.fullName = fullName
        self.validate_fullNameType20(self.fullName)
        self.fullName_nsprefix_ = None
        self.ogrn = ogrn
        self.validate_ogrnType(self.ogrn)
        self.ogrn_nsprefix_ = None
        self.inn = inn
        self.validate_innType(self.inn)
        self.inn_nsprefix_ = None
        self.kpp = kpp
        self.validate_kppType(self.kpp)
        self.kpp_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, capitalStockAgencyType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if capitalStockAgencyType.subclass:
            return capitalStockAgencyType.subclass(*args_, **kwargs_)
        else:
            return capitalStockAgencyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_fullNameType20(self, value):
        result = True
        # Validate type fullNameType20, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on fullNameType20' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on fullNameType20' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_ogrnType(self, value):
        result = True
        # Validate type ogrnType, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ogrnType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_ogrnType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_ogrnType_patterns_, ))
                result = False
        return result
    validate_ogrnType_patterns_ = [['^(\\d{13})$']]
    def validate_innType(self, value):
        result = True
        # Validate type innType, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on innType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_innType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_innType_patterns_, ))
                result = False
        return result
    validate_innType_patterns_ = [['^(\\d{10}|\\d{12})$']]
    def validate_kppType(self, value):
        result = True
        # Validate type kppType, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on kppType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_kppType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_kppType_patterns_, ))
                result = False
        return result
    validate_kppType_patterns_ = [['^(\\d{9})$']]
    def hasContent_(self):
        if (
            self.fullName is not None or
            self.ogrn is not None or
            self.inn is not None or
            self.kpp is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'fullName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'fullName')
            value_ = self.gds_validate_string(value_, node, 'fullName')
            self.fullName = value_
            self.fullName_nsprefix_ = child_.prefix
            # validate type fullNameType20
            self.validate_fullNameType20(self.fullName)
        elif nodeName_ == 'ogrn':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'ogrn')
            value_ = self.gds_validate_string(value_, node, 'ogrn')
            self.ogrn = value_
            self.ogrn_nsprefix_ = child_.prefix
            # validate type ogrnType
            self.validate_ogrnType(self.ogrn)
        elif nodeName_ == 'inn':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'inn')
            value_ = self.gds_validate_string(value_, node, 'inn')
            self.inn = value_
            self.inn_nsprefix_ = child_.prefix
            # validate type innType
            self.validate_innType(self.inn)
        elif nodeName_ == 'kpp':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'kpp')
            value_ = self.gds_validate_string(value_, node, 'kpp')
            self.kpp = value_
            self.kpp_nsprefix_ = child_.prefix
            # validate type kppType
            self.validate_kppType(self.kpp)
# end class capitalStockAgencyType


class fz223type(GeneratedsSuper):
    """Тип организации"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'code': MemberSpec_('code', ['nonEmptyString', 'xs:string'], 0, 0, {'name': 'code', 'type': 'xs:string'}, None),
        'name': MemberSpec_('name', ['nonEmptyString', 'xs:string'], 0, 0, {'name': 'name', 'type': 'xs:string'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, code=None, name=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.code = code
        self.validate_nonEmptyString(self.code)
        self.code_nsprefix_ = None
        self.name = name
        self.validate_nonEmptyString(self.name)
        self.name_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, fz223type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if fz223type.subclass:
            return fz223type.subclass(*args_, **kwargs_)
        else:
            return fz223type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_nonEmptyString(self, value):
        result = True
        # Validate type nonEmptyString, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on nonEmptyString' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.code is not None or
            self.name is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'code':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'code')
            value_ = self.gds_validate_string(value_, node, 'code')
            self.code = value_
            self.code_nsprefix_ = child_.prefix
            # validate type nonEmptyString
            self.validate_nonEmptyString(self.code)
        elif nodeName_ == 'name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'name')
            value_ = self.gds_validate_string(value_, node, 'name')
            self.name = value_
            self.name_nsprefix_ = child_.prefix
            # validate type nonEmptyString
            self.validate_nonEmptyString(self.name)
# end class fz223type


class timeZoneType(GeneratedsSuper):
    """Временная зона"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'offset': MemberSpec_('offset', 'xs:int', 0, 0, {'name': 'offset', 'type': 'xs:int'}, None),
        'name': MemberSpec_('name', ['nameType21', 'nonEmptyString', 'xs:string'], 0, 0, {'name': 'name', 'type': 'xs:string'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, offset=None, name=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.offset = offset
        self.offset_nsprefix_ = None
        self.name = name
        self.validate_nameType21(self.name)
        self.name_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, timeZoneType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if timeZoneType.subclass:
            return timeZoneType.subclass(*args_, **kwargs_)
        else:
            return timeZoneType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_nameType21(self, value):
        result = True
        # Validate type nameType21, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 100:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on nameType21' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on nameType21' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.offset is not None or
            self.name is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'offset' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'offset')
            ival_ = self.gds_validate_integer(ival_, node, 'offset')
            self.offset = ival_
            self.offset_nsprefix_ = child_.prefix
        elif nodeName_ == 'name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'name')
            value_ = self.gds_validate_string(value_, node, 'name')
            self.name = value_
            self.name_nsprefix_ = child_.prefix
            # validate type nameType21
            self.validate_nameType21(self.name)
# end class timeZoneType


class customerMainInfo2Type(GeneratedsSuper):
    """Основная информация об организации - обособленном подразделении"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'fullName': MemberSpec_('fullName', ['fullNameType22', 'nonEmptyString', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'fullName', 'type': 'xs:string'}, None),
        'shortName': MemberSpec_('shortName', ['shortNameType23', 'nonEmptyString', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'shortName', 'type': 'xs:string'}, None),
        'detachedFullName': MemberSpec_('detachedFullName', ['detachedFullNameType', 'nonEmptyString', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'detachedFullName', 'type': 'xs:string'}, None),
        'detachedShortName': MemberSpec_('detachedShortName', ['detachedShortNameType', 'nonEmptyString', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'detachedShortName', 'type': 'xs:string'}, None),
        'inn': MemberSpec_('inn', ['innType', 'nonEmptyString', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'inn', 'type': 'xs:string'}, None),
        'kpp': MemberSpec_('kpp', ['kppType', 'nonEmptyString', 'xs:string'], 0, 0, {'name': 'kpp', 'type': 'xs:string'}, None),
        'ogrn': MemberSpec_('ogrn', ['ogrnType', 'nonEmptyString', 'xs:string'], 0, 0, {'name': 'ogrn', 'type': 'xs:string'}, None),
        'legalAddress': MemberSpec_('legalAddress', ['legalAddressType24', 'nonEmptyString', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'legalAddress', 'type': 'xs:string'}, None),
        'postalAddress': MemberSpec_('postalAddress', ['postalAddressType25', 'nonEmptyString', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'postalAddress', 'type': 'xs:string'}, None),
        'innovVolumeChecked': MemberSpec_('innovVolumeChecked', ['innovVolumeChecked', 'xs:boolean'], 0, 1, {'minOccurs': '0', 'name': 'innovVolumeChecked', 'type': 'xs:boolean'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, fullName=None, shortName=None, detachedFullName=None, detachedShortName=None, inn=None, kpp=None, ogrn=None, legalAddress=None, postalAddress=None, innovVolumeChecked=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.fullName = fullName
        self.validate_fullNameType22(self.fullName)
        self.fullName_nsprefix_ = None
        self.shortName = shortName
        self.validate_shortNameType23(self.shortName)
        self.shortName_nsprefix_ = None
        self.detachedFullName = detachedFullName
        self.validate_detachedFullNameType(self.detachedFullName)
        self.detachedFullName_nsprefix_ = None
        self.detachedShortName = detachedShortName
        self.validate_detachedShortNameType(self.detachedShortName)
        self.detachedShortName_nsprefix_ = None
        self.inn = inn
        self.validate_innType(self.inn)
        self.inn_nsprefix_ = None
        self.kpp = kpp
        self.validate_kppType(self.kpp)
        self.kpp_nsprefix_ = None
        self.ogrn = ogrn
        self.validate_ogrnType(self.ogrn)
        self.ogrn_nsprefix_ = None
        self.legalAddress = legalAddress
        self.validate_legalAddressType24(self.legalAddress)
        self.legalAddress_nsprefix_ = None
        self.postalAddress = postalAddress
        self.validate_postalAddressType25(self.postalAddress)
        self.postalAddress_nsprefix_ = None
        self.innovVolumeChecked = innovVolumeChecked
        self.validate_innovVolumeChecked(self.innovVolumeChecked)
        self.innovVolumeChecked_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, customerMainInfo2Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if customerMainInfo2Type.subclass:
            return customerMainInfo2Type.subclass(*args_, **kwargs_)
        else:
            return customerMainInfo2Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_fullNameType22(self, value):
        result = True
        # Validate type fullNameType22, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on fullNameType22' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on fullNameType22' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_shortNameType23(self, value):
        result = True
        # Validate type shortNameType23, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 500:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on shortNameType23' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on shortNameType23' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_detachedFullNameType(self, value):
        result = True
        # Validate type detachedFullNameType, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on detachedFullNameType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on detachedFullNameType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_detachedShortNameType(self, value):
        result = True
        # Validate type detachedShortNameType, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 500:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on detachedShortNameType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on detachedShortNameType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_innType(self, value):
        result = True
        # Validate type innType, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on innType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_innType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_innType_patterns_, ))
                result = False
        return result
    validate_innType_patterns_ = [['^(\\d{10}|\\d{12})$']]
    def validate_kppType(self, value):
        result = True
        # Validate type kppType, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on kppType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_kppType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_kppType_patterns_, ))
                result = False
        return result
    validate_kppType_patterns_ = [['^(\\d{9})$']]
    def validate_ogrnType(self, value):
        result = True
        # Validate type ogrnType, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ogrnType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_ogrnType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_ogrnType_patterns_, ))
                result = False
        return result
    validate_ogrnType_patterns_ = [['^(\\d{13})$']]
    def validate_legalAddressType24(self, value):
        result = True
        # Validate type legalAddressType24, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 2000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on legalAddressType24' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on legalAddressType24' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_postalAddressType25(self, value):
        result = True
        # Validate type postalAddressType25, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 2000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on postalAddressType25' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on postalAddressType25' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_innovVolumeChecked(self, value):
        result = True
        # Validate type innovVolumeChecked, a restriction on xs:boolean.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            pass
        return result
    def hasContent_(self):
        if (
            self.fullName is not None or
            self.shortName is not None or
            self.detachedFullName is not None or
            self.detachedShortName is not None or
            self.inn is not None or
            self.kpp is not None or
            self.ogrn is not None or
            self.legalAddress is not None or
            self.postalAddress is not None or
            self.innovVolumeChecked is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'fullName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'fullName')
            value_ = self.gds_validate_string(value_, node, 'fullName')
            self.fullName = value_
            self.fullName_nsprefix_ = child_.prefix
            # validate type fullNameType22
            self.validate_fullNameType22(self.fullName)
        elif nodeName_ == 'shortName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'shortName')
            value_ = self.gds_validate_string(value_, node, 'shortName')
            self.shortName = value_
            self.shortName_nsprefix_ = child_.prefix
            # validate type shortNameType23
            self.validate_shortNameType23(self.shortName)
        elif nodeName_ == 'detachedFullName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'detachedFullName')
            value_ = self.gds_validate_string(value_, node, 'detachedFullName')
            self.detachedFullName = value_
            self.detachedFullName_nsprefix_ = child_.prefix
            # validate type detachedFullNameType
            self.validate_detachedFullNameType(self.detachedFullName)
        elif nodeName_ == 'detachedShortName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'detachedShortName')
            value_ = self.gds_validate_string(value_, node, 'detachedShortName')
            self.detachedShortName = value_
            self.detachedShortName_nsprefix_ = child_.prefix
            # validate type detachedShortNameType
            self.validate_detachedShortNameType(self.detachedShortName)
        elif nodeName_ == 'inn':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'inn')
            value_ = self.gds_validate_string(value_, node, 'inn')
            self.inn = value_
            self.inn_nsprefix_ = child_.prefix
            # validate type innType
            self.validate_innType(self.inn)
        elif nodeName_ == 'kpp':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'kpp')
            value_ = self.gds_validate_string(value_, node, 'kpp')
            self.kpp = value_
            self.kpp_nsprefix_ = child_.prefix
            # validate type kppType
            self.validate_kppType(self.kpp)
        elif nodeName_ == 'ogrn':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'ogrn')
            value_ = self.gds_validate_string(value_, node, 'ogrn')
            self.ogrn = value_
            self.ogrn_nsprefix_ = child_.prefix
            # validate type ogrnType
            self.validate_ogrnType(self.ogrn)
        elif nodeName_ == 'legalAddress':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'legalAddress')
            value_ = self.gds_validate_string(value_, node, 'legalAddress')
            self.legalAddress = value_
            self.legalAddress_nsprefix_ = child_.prefix
            # validate type legalAddressType24
            self.validate_legalAddressType24(self.legalAddress)
        elif nodeName_ == 'postalAddress':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'postalAddress')
            value_ = self.gds_validate_string(value_, node, 'postalAddress')
            self.postalAddress = value_
            self.postalAddress_nsprefix_ = child_.prefix
            # validate type postalAddressType25
            self.validate_postalAddressType25(self.postalAddress)
        elif nodeName_ == 'innovVolumeChecked':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'innovVolumeChecked')
            ival_ = self.gds_validate_boolean(ival_, node, 'innovVolumeChecked')
            self.innovVolumeChecked = ival_
            self.innovVolumeChecked_nsprefix_ = child_.prefix
            # validate type innovVolumeChecked
            self.validate_innovVolumeChecked(self.innovVolumeChecked)
# end class customerMainInfo2Type


class customerMainInfo3Type(GeneratedsSuper):
    """Основная информация об организации - обособленном подразделении"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'fullName': MemberSpec_('fullName', ['fullNameType26', 'nonEmptyString', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'fullName', 'type': 'xs:string'}, None),
        'shortName': MemberSpec_('shortName', ['shortNameType27', 'nonEmptyString', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'shortName', 'type': 'xs:string'}, None),
        'detachedFullName': MemberSpec_('detachedFullName', ['detachedFullNameType28', 'nonEmptyString', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'detachedFullName', 'type': 'xs:string'}, None),
        'detachedShortName': MemberSpec_('detachedShortName', ['detachedShortNameType29', 'nonEmptyString', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'detachedShortName', 'type': 'xs:string'}, None),
        'inn': MemberSpec_('inn', ['innType', 'nonEmptyString', 'xs:string'], 0, 0, {'name': 'inn', 'type': 'xs:string'}, None),
        'kpp': MemberSpec_('kpp', ['kppType', 'nonEmptyString', 'xs:string'], 0, 0, {'name': 'kpp', 'type': 'xs:string'}, None),
        'ogrn': MemberSpec_('ogrn', ['ogrnType', 'nonEmptyString', 'xs:string'], 0, 0, {'name': 'ogrn', 'type': 'xs:string'}, None),
        'legalAddress': MemberSpec_('legalAddress', ['legalAddressType30', 'nonEmptyString', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'legalAddress', 'type': 'xs:string'}, None),
        'postalAddress': MemberSpec_('postalAddress', ['postalAddressType31', 'nonEmptyString', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'postalAddress', 'type': 'xs:string'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, fullName=None, shortName=None, detachedFullName=None, detachedShortName=None, inn=None, kpp=None, ogrn=None, legalAddress=None, postalAddress=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.fullName = fullName
        self.validate_fullNameType26(self.fullName)
        self.fullName_nsprefix_ = None
        self.shortName = shortName
        self.validate_shortNameType27(self.shortName)
        self.shortName_nsprefix_ = None
        self.detachedFullName = detachedFullName
        self.validate_detachedFullNameType28(self.detachedFullName)
        self.detachedFullName_nsprefix_ = None
        self.detachedShortName = detachedShortName
        self.validate_detachedShortNameType29(self.detachedShortName)
        self.detachedShortName_nsprefix_ = None
        self.inn = inn
        self.validate_innType(self.inn)
        self.inn_nsprefix_ = None
        self.kpp = kpp
        self.validate_kppType(self.kpp)
        self.kpp_nsprefix_ = None
        self.ogrn = ogrn
        self.validate_ogrnType(self.ogrn)
        self.ogrn_nsprefix_ = None
        self.legalAddress = legalAddress
        self.validate_legalAddressType30(self.legalAddress)
        self.legalAddress_nsprefix_ = None
        self.postalAddress = postalAddress
        self.validate_postalAddressType31(self.postalAddress)
        self.postalAddress_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, customerMainInfo3Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if customerMainInfo3Type.subclass:
            return customerMainInfo3Type.subclass(*args_, **kwargs_)
        else:
            return customerMainInfo3Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_fullNameType26(self, value):
        result = True
        # Validate type fullNameType26, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on fullNameType26' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on fullNameType26' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_shortNameType27(self, value):
        result = True
        # Validate type shortNameType27, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 500:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on shortNameType27' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on shortNameType27' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_detachedFullNameType28(self, value):
        result = True
        # Validate type detachedFullNameType28, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on detachedFullNameType28' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on detachedFullNameType28' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_detachedShortNameType29(self, value):
        result = True
        # Validate type detachedShortNameType29, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 500:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on detachedShortNameType29' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on detachedShortNameType29' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_innType(self, value):
        result = True
        # Validate type innType, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on innType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_innType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_innType_patterns_, ))
                result = False
        return result
    validate_innType_patterns_ = [['^(\\d{10}|\\d{12})$']]
    def validate_kppType(self, value):
        result = True
        # Validate type kppType, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on kppType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_kppType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_kppType_patterns_, ))
                result = False
        return result
    validate_kppType_patterns_ = [['^(\\d{9})$']]
    def validate_ogrnType(self, value):
        result = True
        # Validate type ogrnType, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ogrnType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_ogrnType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_ogrnType_patterns_, ))
                result = False
        return result
    validate_ogrnType_patterns_ = [['^(\\d{13})$']]
    def validate_legalAddressType30(self, value):
        result = True
        # Validate type legalAddressType30, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 2000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on legalAddressType30' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on legalAddressType30' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_postalAddressType31(self, value):
        result = True
        # Validate type postalAddressType31, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 2000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on postalAddressType31' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on postalAddressType31' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.fullName is not None or
            self.shortName is not None or
            self.detachedFullName is not None or
            self.detachedShortName is not None or
            self.inn is not None or
            self.kpp is not None or
            self.ogrn is not None or
            self.legalAddress is not None or
            self.postalAddress is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'fullName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'fullName')
            value_ = self.gds_validate_string(value_, node, 'fullName')
            self.fullName = value_
            self.fullName_nsprefix_ = child_.prefix
            # validate type fullNameType26
            self.validate_fullNameType26(self.fullName)
        elif nodeName_ == 'shortName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'shortName')
            value_ = self.gds_validate_string(value_, node, 'shortName')
            self.shortName = value_
            self.shortName_nsprefix_ = child_.prefix
            # validate type shortNameType27
            self.validate_shortNameType27(self.shortName)
        elif nodeName_ == 'detachedFullName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'detachedFullName')
            value_ = self.gds_validate_string(value_, node, 'detachedFullName')
            self.detachedFullName = value_
            self.detachedFullName_nsprefix_ = child_.prefix
            # validate type detachedFullNameType28
            self.validate_detachedFullNameType28(self.detachedFullName)
        elif nodeName_ == 'detachedShortName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'detachedShortName')
            value_ = self.gds_validate_string(value_, node, 'detachedShortName')
            self.detachedShortName = value_
            self.detachedShortName_nsprefix_ = child_.prefix
            # validate type detachedShortNameType29
            self.validate_detachedShortNameType29(self.detachedShortName)
        elif nodeName_ == 'inn':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'inn')
            value_ = self.gds_validate_string(value_, node, 'inn')
            self.inn = value_
            self.inn_nsprefix_ = child_.prefix
            # validate type innType
            self.validate_innType(self.inn)
        elif nodeName_ == 'kpp':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'kpp')
            value_ = self.gds_validate_string(value_, node, 'kpp')
            self.kpp = value_
            self.kpp_nsprefix_ = child_.prefix
            # validate type kppType
            self.validate_kppType(self.kpp)
        elif nodeName_ == 'ogrn':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'ogrn')
            value_ = self.gds_validate_string(value_, node, 'ogrn')
            self.ogrn = value_
            self.ogrn_nsprefix_ = child_.prefix
            # validate type ogrnType
            self.validate_ogrnType(self.ogrn)
        elif nodeName_ == 'legalAddress':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'legalAddress')
            value_ = self.gds_validate_string(value_, node, 'legalAddress')
            self.legalAddress = value_
            self.legalAddress_nsprefix_ = child_.prefix
            # validate type legalAddressType30
            self.validate_legalAddressType30(self.legalAddress)
        elif nodeName_ == 'postalAddress':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'postalAddress')
            value_ = self.gds_validate_string(value_, node, 'postalAddress')
            self.postalAddress = value_
            self.postalAddress_nsprefix_ = child_.prefix
            # validate type postalAddressType31
            self.validate_postalAddressType31(self.postalAddress)
# end class customerMainInfo3Type


class docDeliveryInfoType(GeneratedsSuper):
    """Информация о предоставлении документации"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'deliveryStartDateTime': MemberSpec_('deliveryStartDateTime', 'xs:date', 0, 0, {'name': 'deliveryStartDateTime', 'type': 'xs:date'}, None),
        'deliveryEndDateTime': MemberSpec_('deliveryEndDateTime', 'xs:date', 0, 0, {'name': 'deliveryEndDateTime', 'type': 'xs:date'}, None),
        'place': MemberSpec_('place', ['placeType', 'nonEmptyString', 'xs:string'], 0, 0, {'name': 'place', 'type': 'xs:string'}, None),
        'procedure': MemberSpec_('procedure', ['procedureType', 'nonEmptyString', 'xs:string'], 0, 0, {'name': 'procedure', 'type': 'xs:string'}, None),
        'payment': MemberSpec_('payment', 'docDeliveryPaymentType', 0, 1, {'minOccurs': '0', 'name': 'payment', 'type': 'docDeliveryPaymentType'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, deliveryStartDateTime=None, deliveryEndDateTime=None, place=None, procedure=None, payment=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if isinstance(deliveryStartDateTime, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(deliveryStartDateTime, '%Y-%m-%d').date()
        else:
            initvalue_ = deliveryStartDateTime
        self.deliveryStartDateTime = initvalue_
        self.deliveryStartDateTime_nsprefix_ = None
        if isinstance(deliveryEndDateTime, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(deliveryEndDateTime, '%Y-%m-%d').date()
        else:
            initvalue_ = deliveryEndDateTime
        self.deliveryEndDateTime = initvalue_
        self.deliveryEndDateTime_nsprefix_ = None
        self.place = place
        self.validate_placeType(self.place)
        self.place_nsprefix_ = None
        self.procedure = procedure
        self.validate_procedureType(self.procedure)
        self.procedure_nsprefix_ = None
        self.payment = payment
        self.payment_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, docDeliveryInfoType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if docDeliveryInfoType.subclass:
            return docDeliveryInfoType.subclass(*args_, **kwargs_)
        else:
            return docDeliveryInfoType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_placeType(self, value):
        result = True
        # Validate type placeType, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 2000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on placeType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on placeType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_procedureType(self, value):
        result = True
        # Validate type procedureType, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 2000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on procedureType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on procedureType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.deliveryStartDateTime is not None or
            self.deliveryEndDateTime is not None or
            self.place is not None or
            self.procedure is not None or
            self.payment is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'deliveryStartDateTime':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.deliveryStartDateTime = dval_
            self.deliveryStartDateTime_nsprefix_ = child_.prefix
        elif nodeName_ == 'deliveryEndDateTime':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.deliveryEndDateTime = dval_
            self.deliveryEndDateTime_nsprefix_ = child_.prefix
        elif nodeName_ == 'place':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'place')
            value_ = self.gds_validate_string(value_, node, 'place')
            self.place = value_
            self.place_nsprefix_ = child_.prefix
            # validate type placeType
            self.validate_placeType(self.place)
        elif nodeName_ == 'procedure':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'procedure')
            value_ = self.gds_validate_string(value_, node, 'procedure')
            self.procedure = value_
            self.procedure_nsprefix_ = child_.prefix
            # validate type procedureType
            self.validate_procedureType(self.procedure)
        elif nodeName_ == 'payment':
            obj_ = docDeliveryPaymentType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.payment = obj_
            obj_.original_tagname_ = 'payment'
# end class docDeliveryInfoType


class docDeliveryPaymentType(GeneratedsSuper):
    """Информация об оплате за предоставление информации"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'currency': MemberSpec_('currency', 'currencyType', 0, 0, {'name': 'currency', 'type': 'currencyType'}, None),
        'sum': MemberSpec_('sum', ['money2', 'xs:decimal'], 0, 0, {'name': 'sum', 'type': 'xs:decimal'}, None),
        'procedure': MemberSpec_('procedure', ['procedureType32', 'nonEmptyString', 'xs:string'], 0, 0, {'name': 'procedure', 'type': 'xs:string'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, currency=None, sum=None, procedure=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.currency = currency
        self.currency_nsprefix_ = None
        self.sum = sum
        self.validate_money2(self.sum)
        self.sum_nsprefix_ = None
        self.procedure = procedure
        self.validate_procedureType32(self.procedure)
        self.procedure_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, docDeliveryPaymentType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if docDeliveryPaymentType.subclass:
            return docDeliveryPaymentType.subclass(*args_, **kwargs_)
        else:
            return docDeliveryPaymentType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_money2(self, value):
        result = True
        # Validate type money2, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, decimal_.Decimal):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (decimal_.Decimal)' % {"value": value, "lineno": lineno, })
                return False
            if len(str(value)) >= 20:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd totalDigits restriction on money2' % {"value": value, "lineno": lineno} )
                result = False
        return result
    def validate_procedureType32(self, value):
        result = True
        # Validate type procedureType32, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 2000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on procedureType32' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on procedureType32' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.currency is not None or
            self.sum is not None or
            self.procedure is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'currency':
            obj_ = currencyType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.currency = obj_
            obj_.original_tagname_ = 'currency'
        elif nodeName_ == 'sum' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'sum')
            fval_ = self.gds_validate_decimal(fval_, node, 'sum')
            self.sum = fval_
            self.sum_nsprefix_ = child_.prefix
            # validate type money2
            self.validate_money2(self.sum)
        elif nodeName_ == 'procedure':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'procedure')
            value_ = self.gds_validate_string(value_, node, 'procedure')
            self.procedure = value_
            self.procedure_nsprefix_ = child_.prefix
            # validate type procedureType32
            self.validate_procedureType32(self.procedure)
# end class docDeliveryPaymentType


class documentListType(GeneratedsSuper):
    """Прикрепленные документы"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'totalDocumentsCount': MemberSpec_('totalDocumentsCount', 'xs:positiveInteger', 0, 1, {'minOccurs': '0', 'name': 'totalDocumentsCount', 'type': 'xs:positiveInteger'}, None),
        'additionalDocumentsCount': MemberSpec_('additionalDocumentsCount', 'xs:nonNegativeInteger', 0, 1, {'minOccurs': '0', 'name': 'additionalDocumentsCount', 'type': 'xs:nonNegativeInteger'}, None),
        'prevDocument': MemberSpec_('prevDocument', 'prevDocumentType', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'prevDocument', 'type': 'prevDocumentType'}, None),
        'document': MemberSpec_('document', 'documentType', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'document', 'type': 'documentType'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, totalDocumentsCount=None, additionalDocumentsCount=None, prevDocument=None, document=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.totalDocumentsCount = totalDocumentsCount
        self.totalDocumentsCount_nsprefix_ = None
        self.additionalDocumentsCount = additionalDocumentsCount
        self.additionalDocumentsCount_nsprefix_ = None
        if prevDocument is None:
            self.prevDocument = []
        else:
            self.prevDocument = prevDocument
        self.prevDocument_nsprefix_ = None
        if document is None:
            self.document = []
        else:
            self.document = document
        self.document_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, documentListType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if documentListType.subclass:
            return documentListType.subclass(*args_, **kwargs_)
        else:
            return documentListType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.totalDocumentsCount is not None or
            self.additionalDocumentsCount is not None or
            self.prevDocument or
            self.document
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'totalDocumentsCount' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'totalDocumentsCount')
            if ival_ <= 0:
                raise_parse_error(child_, 'requires positiveInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'totalDocumentsCount')
            self.totalDocumentsCount = ival_
            self.totalDocumentsCount_nsprefix_ = child_.prefix
        elif nodeName_ == 'additionalDocumentsCount' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'additionalDocumentsCount')
            if ival_ < 0:
                raise_parse_error(child_, 'requires nonNegativeInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'additionalDocumentsCount')
            self.additionalDocumentsCount = ival_
            self.additionalDocumentsCount_nsprefix_ = child_.prefix
        elif nodeName_ == 'prevDocument':
            obj_ = prevDocumentType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.prevDocument.append(obj_)
            obj_.original_tagname_ = 'prevDocument'
        elif nodeName_ == 'document':
            obj_ = documentType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.document.append(obj_)
            obj_.original_tagname_ = 'document'
# end class documentListType


class documentType(GeneratedsSuper):
    """Прикрепленный к сведениям документ"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'guid': MemberSpec_('guid', ['guidType', 'xs:string'], 0, 0, {'name': 'guid', 'type': 'xs:string'}, None),
        'createDateTime': MemberSpec_('createDateTime', 'xs:dateTime', 0, 1, {'minOccurs': '0', 'name': 'createDateTime', 'type': 'xs:dateTime'}, None),
        'fileName': MemberSpec_('fileName', ['fileNameType', 'nonEmptyString', 'xs:string'], 0, 0, {'name': 'fileName', 'type': 'xs:string'}, None),
        'description': MemberSpec_('description', ['descriptionType', 'nonEmptyString', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'description', 'type': 'xs:string'}, None),
        'content': MemberSpec_('content', 'xs:base64Binary', 0, 0, {'name': 'content', 'type': 'xs:base64Binary'}, 4),
        'url': MemberSpec_('url', ['nonEmptyString', 'xs:string'], 0, 0, {'name': 'url', 'type': 'xs:string'}, 4),
        'registrationNumber': MemberSpec_('registrationNumber', ['registrationNumber23Type', 'nonEmptyString', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'registrationNumber', 'type': 'xs:string'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, guid=None, createDateTime=None, fileName=None, description=None, content=None, url=None, registrationNumber=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.guid = guid
        self.validate_guidType(self.guid)
        self.guid_nsprefix_ = None
        if isinstance(createDateTime, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(createDateTime, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = createDateTime
        self.createDateTime = initvalue_
        self.createDateTime_nsprefix_ = None
        self.fileName = fileName
        self.validate_fileNameType(self.fileName)
        self.fileName_nsprefix_ = None
        self.description = description
        self.validate_descriptionType(self.description)
        self.description_nsprefix_ = None
        self.content = content
        self.content_nsprefix_ = None
        self.url = url
        self.validate_nonEmptyString(self.url)
        self.url_nsprefix_ = None
        self.registrationNumber = registrationNumber
        self.validate_registrationNumber23Type(self.registrationNumber)
        self.registrationNumber_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, documentType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if documentType.subclass:
            return documentType.subclass(*args_, **kwargs_)
        else:
            return documentType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_guidType(self, value):
        result = True
        # Validate type guidType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) != 36:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd length restriction on guidType' % {"value": encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_guidType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_guidType_patterns_, ))
                result = False
        return result
    validate_guidType_patterns_ = [['^([a-fA-F0-9]{8}\\-[a-fA-F0-9]{4}\\-[a-fA-F0-9]{4}\\-[a-fA-F0-9]{4}\\-[a-fA-F0-9]{12})$']]
    def validate_fileNameType(self, value):
        result = True
        # Validate type fileNameType, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 255:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on fileNameType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on fileNameType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_descriptionType(self, value):
        result = True
        # Validate type descriptionType, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 2000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on descriptionType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on descriptionType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_nonEmptyString(self, value):
        result = True
        # Validate type nonEmptyString, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on nonEmptyString' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_registrationNumber23Type(self, value):
        result = True
        # Validate type registrationNumber23Type, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on registrationNumber23Type' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_registrationNumber23Type_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_registrationNumber23Type_patterns_, ))
                result = False
        return result
    validate_registrationNumber23Type_patterns_ = [['^(\\d{23})$']]
    def hasContent_(self):
        if (
            self.guid is not None or
            self.createDateTime is not None or
            self.fileName is not None or
            self.description is not None or
            self.content is not None or
            self.url is not None or
            self.registrationNumber is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'guid':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'guid')
            value_ = self.gds_validate_string(value_, node, 'guid')
            self.guid = value_
            self.guid_nsprefix_ = child_.prefix
            # validate type guidType
            self.validate_guidType(self.guid)
        elif nodeName_ == 'createDateTime':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.createDateTime = dval_
            self.createDateTime_nsprefix_ = child_.prefix
        elif nodeName_ == 'fileName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'fileName')
            value_ = self.gds_validate_string(value_, node, 'fileName')
            self.fileName = value_
            self.fileName_nsprefix_ = child_.prefix
            # validate type fileNameType
            self.validate_fileNameType(self.fileName)
        elif nodeName_ == 'description':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'description')
            value_ = self.gds_validate_string(value_, node, 'description')
            self.description = value_
            self.description_nsprefix_ = child_.prefix
            # validate type descriptionType
            self.validate_descriptionType(self.description)
        elif nodeName_ == 'content':
            sval_ = child_.text
            if sval_ is not None:
                try:
                    bval_ = base64.b64decode(sval_)
                except (TypeError, ValueError) as exp:
                    raise_parse_error(child_, 'requires base64 encoded string: %s' % exp)
                bval_ = self.gds_validate_base64(bval_, node, 'content')
            else:
                bval_ = None
            self.content = bval_
            self.content_nsprefix_ = child_.prefix
        elif nodeName_ == 'url':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'url')
            value_ = self.gds_validate_string(value_, node, 'url')
            self.url = value_
            self.url_nsprefix_ = child_.prefix
            # validate type nonEmptyString
            self.validate_nonEmptyString(self.url)
        elif nodeName_ == 'registrationNumber':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'registrationNumber')
            value_ = self.gds_validate_string(value_, node, 'registrationNumber')
            self.registrationNumber = value_
            self.registrationNumber_nsprefix_ = child_.prefix
            # validate type registrationNumber23Type
            self.validate_registrationNumber23Type(self.registrationNumber)
# end class documentType


class electronicPlaceInfoType(GeneratedsSuper):
    """Информация о ЭТП"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'name': MemberSpec_('name', ['nameType33', 'nonEmptyString', 'xs:string'], 0, 0, {'name': 'name', 'type': 'xs:string'}, None),
        'url': MemberSpec_('url', ['urlType', 'nonEmptyString', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'url', 'type': 'xs:string'}, None),
        'electronicPlaceId': MemberSpec_('electronicPlaceId', 'xs:long', 0, 0, {'name': 'electronicPlaceId', 'type': 'xs:long'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, name=None, url=None, electronicPlaceId=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.name = name
        self.validate_nameType33(self.name)
        self.name_nsprefix_ = None
        self.url = url
        self.validate_urlType(self.url)
        self.url_nsprefix_ = None
        self.electronicPlaceId = electronicPlaceId
        self.electronicPlaceId_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, electronicPlaceInfoType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if electronicPlaceInfoType.subclass:
            return electronicPlaceInfoType.subclass(*args_, **kwargs_)
        else:
            return electronicPlaceInfoType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_nameType33(self, value):
        result = True
        # Validate type nameType33, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on nameType33' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on nameType33' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_urlType(self, value):
        result = True
        # Validate type urlType, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on urlType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on urlType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.name is not None or
            self.url is not None or
            self.electronicPlaceId is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'name')
            value_ = self.gds_validate_string(value_, node, 'name')
            self.name = value_
            self.name_nsprefix_ = child_.prefix
            # validate type nameType33
            self.validate_nameType33(self.name)
        elif nodeName_ == 'url':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'url')
            value_ = self.gds_validate_string(value_, node, 'url')
            self.url = value_
            self.url_nsprefix_ = child_.prefix
            # validate type urlType
            self.validate_urlType(self.url)
        elif nodeName_ == 'electronicPlaceId' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'electronicPlaceId')
            ival_ = self.gds_validate_integer(ival_, node, 'electronicPlaceId')
            self.electronicPlaceId = ival_
            self.electronicPlaceId_nsprefix_ = child_.prefix
# end class electronicPlaceInfoType


class headerType(GeneratedsSuper):
    """Заголовок информационного пакета"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'guid': MemberSpec_('guid', ['guidType', 'xs:string'], 0, 0, {'name': 'guid', 'type': 'xs:string'}, None),
        'createDateTime': MemberSpec_('createDateTime', 'xs:dateTime', 0, 0, {'name': 'createDateTime', 'type': 'xs:dateTime'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, guid=None, createDateTime=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.guid = guid
        self.validate_guidType(self.guid)
        self.guid_nsprefix_ = None
        if isinstance(createDateTime, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(createDateTime, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = createDateTime
        self.createDateTime = initvalue_
        self.createDateTime_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, headerType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if headerType.subclass:
            return headerType.subclass(*args_, **kwargs_)
        else:
            return headerType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_guidType(self, value):
        result = True
        # Validate type guidType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) != 36:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd length restriction on guidType' % {"value": encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_guidType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_guidType_patterns_, ))
                result = False
        return result
    validate_guidType_patterns_ = [['^([a-fA-F0-9]{8}\\-[a-fA-F0-9]{4}\\-[a-fA-F0-9]{4}\\-[a-fA-F0-9]{4}\\-[a-fA-F0-9]{12})$']]
    def hasContent_(self):
        if (
            self.guid is not None or
            self.createDateTime is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'guid':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'guid')
            value_ = self.gds_validate_string(value_, node, 'guid')
            self.guid = value_
            self.guid_nsprefix_ = child_.prefix
            # validate type guidType
            self.validate_guidType(self.guid)
        elif nodeName_ == 'createDateTime':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.createDateTime = dval_
            self.createDateTime_nsprefix_ = child_.prefix
# end class headerType


class itemResultListType(GeneratedsSuper):
    """Результат обработки позиции"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'itemResult': MemberSpec_('itemResult', 'itemResultType', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'itemResult', 'type': 'itemResultType'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, itemResult=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if itemResult is None:
            self.itemResult = []
        else:
            self.itemResult = itemResult
        self.itemResult_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, itemResultListType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if itemResultListType.subclass:
            return itemResultListType.subclass(*args_, **kwargs_)
        else:
            return itemResultListType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.itemResult
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'itemResult':
            obj_ = itemResultType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.itemResult.append(obj_)
            obj_.original_tagname_ = 'itemResult'
# end class itemResultListType


class itemResultType(GeneratedsSuper):
    """Результат обработки позиции"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'refguid': MemberSpec_('refguid', ['guidType', 'xs:string'], 0, 0, {'name': 'refguid', 'type': 'xs:string'}, None),
        'entityGuid': MemberSpec_('entityGuid', ['guidType', 'xs:string'], 0, 0, {'name': 'entityGuid', 'type': 'xs:string'}, None),
        'result': MemberSpec_('result', ['resultType', 'xs:string'], 0, 0, {'name': 'result', 'type': 'xs:string'}, None),
        'violations': MemberSpec_('violations', 'violationListType', 0, 1, {'minOccurs': '0', 'name': 'violations', 'type': 'violationListType'}, None),
        'url': MemberSpec_('url', ['nonEmptyString', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'url', 'type': 'xs:string'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, refguid=None, entityGuid=None, result=None, violations=None, url=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.refguid = refguid
        self.validate_guidType(self.refguid)
        self.refguid_nsprefix_ = None
        self.entityGuid = entityGuid
        self.validate_guidType(self.entityGuid)
        self.entityGuid_nsprefix_ = None
        self.result = result
        self.validate_resultType(self.result)
        self.result_nsprefix_ = None
        self.violations = violations
        self.violations_nsprefix_ = None
        self.url = url
        self.validate_nonEmptyString(self.url)
        self.url_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, itemResultType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if itemResultType.subclass:
            return itemResultType.subclass(*args_, **kwargs_)
        else:
            return itemResultType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_guidType(self, value):
        result = True
        # Validate type guidType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) != 36:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd length restriction on guidType' % {"value": encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_guidType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_guidType_patterns_, ))
                result = False
        return result
    validate_guidType_patterns_ = [['^([a-fA-F0-9]{8}\\-[a-fA-F0-9]{4}\\-[a-fA-F0-9]{4}\\-[a-fA-F0-9]{4}\\-[a-fA-F0-9]{12})$']]
    def validate_resultType(self, value):
        result = True
        # Validate type resultType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['success', 'failure']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on resultType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_nonEmptyString(self, value):
        result = True
        # Validate type nonEmptyString, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on nonEmptyString' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.refguid is not None or
            self.entityGuid is not None or
            self.result is not None or
            self.violations is not None or
            self.url is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'refguid':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'refguid')
            value_ = self.gds_validate_string(value_, node, 'refguid')
            self.refguid = value_
            self.refguid_nsprefix_ = child_.prefix
            # validate type guidType
            self.validate_guidType(self.refguid)
        elif nodeName_ == 'entityGuid':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'entityGuid')
            value_ = self.gds_validate_string(value_, node, 'entityGuid')
            self.entityGuid = value_
            self.entityGuid_nsprefix_ = child_.prefix
            # validate type guidType
            self.validate_guidType(self.entityGuid)
        elif nodeName_ == 'result':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'result')
            value_ = self.gds_validate_string(value_, node, 'result')
            self.result = value_
            self.result_nsprefix_ = child_.prefix
            # validate type resultType
            self.validate_resultType(self.result)
        elif nodeName_ == 'violations':
            obj_ = violationListType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.violations = obj_
            obj_.original_tagname_ = 'violations'
        elif nodeName_ == 'url':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'url')
            value_ = self.gds_validate_string(value_, node, 'url')
            self.url = value_
            self.url_nsprefix_ = child_.prefix
            # validate type nonEmptyString
            self.validate_nonEmptyString(self.url)
# end class itemResultType


class itemType(GeneratedsSuper):
    """Данные позиции в пакете"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'guid': MemberSpec_('guid', ['guidType', 'xs:string'], 0, 0, {'name': 'guid', 'type': 'xs:string'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_) + ['extensiontype_']
    subclass = None
    superclass = None
    def __init__(self, guid=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.guid = guid
        self.validate_guidType(self.guid)
        self.guid_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, itemType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if itemType.subclass:
            return itemType.subclass(*args_, **kwargs_)
        else:
            return itemType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_guidType(self, value):
        result = True
        # Validate type guidType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) != 36:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd length restriction on guidType' % {"value": encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_guidType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_guidType_patterns_, ))
                result = False
        return result
    validate_guidType_patterns_ = [['^([a-fA-F0-9]{8}\\-[a-fA-F0-9]{4}\\-[a-fA-F0-9]{4}\\-[a-fA-F0-9]{4}\\-[a-fA-F0-9]{12})$']]
    def hasContent_(self):
        if (
            self.guid is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'guid':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'guid')
            value_ = self.gds_validate_string(value_, node, 'guid')
            self.guid = value_
            self.guid_nsprefix_ = child_.prefix
            # validate type guidType
            self.validate_guidType(self.guid)
# end class itemType


class lotItemListType(GeneratedsSuper):
    """Позиции лота"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'newCodes': MemberSpec_('newCodes', 'xs:boolean', 0, 1, {'minOccurs': '0', 'name': 'newCodes', 'type': 'xs:boolean'}, None),
        'lotItem': MemberSpec_('lotItem', 'lotItemType', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'lotItem', 'type': 'lotItemType'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, newCodes=None, lotItem=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.newCodes = newCodes
        self.newCodes_nsprefix_ = None
        if lotItem is None:
            self.lotItem = []
        else:
            self.lotItem = lotItem
        self.lotItem_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, lotItemListType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if lotItemListType.subclass:
            return lotItemListType.subclass(*args_, **kwargs_)
        else:
            return lotItemListType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.newCodes is not None or
            self.lotItem
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'newCodes':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'newCodes')
            ival_ = self.gds_validate_boolean(ival_, node, 'newCodes')
            self.newCodes = ival_
            self.newCodes_nsprefix_ = child_.prefix
        elif nodeName_ == 'lotItem':
            obj_ = lotItemType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.lotItem.append(obj_)
            obj_.original_tagname_ = 'lotItem'
# end class lotItemListType


class lotItemType(GeneratedsSuper):
    """Позиция лота"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'guid': MemberSpec_('guid', ['guidType', 'xs:string'], 0, 0, {'name': 'guid', 'type': 'xs:string'}, None),
        'ordinalNumber': MemberSpec_('ordinalNumber', 'xs:int', 0, 0, {'name': 'ordinalNumber', 'type': 'xs:int'}, None),
        'okdp': MemberSpec_('okdp', 'okdpProductType', 0, 1, {'minOccurs': '0', 'name': 'okdp', 'type': 'okdpProductType'}, 5),
        'okpd2': MemberSpec_('okpd2', 'okpd2ProductType', 0, 1, {'minOccurs': '0', 'name': 'okpd2', 'type': 'okpd2ProductType'}, 5),
        'okved': MemberSpec_('okved', 'okvedProductType', 0, 1, {'minOccurs': '0', 'name': 'okved', 'type': 'okvedProductType'}, 6),
        'okved2': MemberSpec_('okved2', 'okved2ProductType', 0, 1, {'minOccurs': '0', 'name': 'okved2', 'type': 'okved2ProductType'}, 6),
        'okei': MemberSpec_('okei', 'okeiProductType', 0, 1, {'minOccurs': '0', 'name': 'okei', 'type': 'okeiProductType'}, None),
        'qty': MemberSpec_('qty', ['lotItemQtyType', 'xs:decimal'], 0, 1, {'minOccurs': '0', 'name': 'qty', 'type': 'xs:decimal'}, None),
        'additionalInfo': MemberSpec_('additionalInfo', ['additionalInfoType34', 'nonEmptyString', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'additionalInfo', 'type': 'xs:string'}, None),
        'deliveryPlace': MemberSpec_('deliveryPlace', 'deliveryPlaceType', 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'deliveryPlace', 'type': 'deliveryPlaceType'}, None),
        'commodityItemPrice': MemberSpec_('commodityItemPrice', ['money2', 'xs:decimal'], 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'commodityItemPrice', 'type': 'xs:decimal'}, None),
        'commodityItemPriceRub': MemberSpec_('commodityItemPriceRub', ['money2', 'xs:decimal'], 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'commodityItemPriceRub', 'type': 'xs:decimal'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, guid=None, ordinalNumber=None, okdp=None, okpd2=None, okved=None, okved2=None, okei=None, qty=None, additionalInfo=None, deliveryPlace=None, commodityItemPrice=None, commodityItemPriceRub=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.guid = guid
        self.validate_guidType(self.guid)
        self.guid_nsprefix_ = None
        self.ordinalNumber = ordinalNumber
        self.ordinalNumber_nsprefix_ = None
        self.okdp = okdp
        self.okdp_nsprefix_ = None
        self.okpd2 = okpd2
        self.okpd2_nsprefix_ = None
        self.okved = okved
        self.okved_nsprefix_ = None
        self.okved2 = okved2
        self.okved2_nsprefix_ = None
        self.okei = okei
        self.okei_nsprefix_ = None
        self.qty = qty
        self.validate_lotItemQtyType(self.qty)
        self.qty_nsprefix_ = None
        self.additionalInfo = additionalInfo
        self.validate_additionalInfoType34(self.additionalInfo)
        self.additionalInfo_nsprefix_ = None
        self.deliveryPlace = deliveryPlace
        self.deliveryPlace_nsprefix_ = None
        self.commodityItemPrice = commodityItemPrice
        self.validate_money2(self.commodityItemPrice)
        self.commodityItemPrice_nsprefix_ = None
        self.commodityItemPriceRub = commodityItemPriceRub
        self.validate_money2(self.commodityItemPriceRub)
        self.commodityItemPriceRub_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, lotItemType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if lotItemType.subclass:
            return lotItemType.subclass(*args_, **kwargs_)
        else:
            return lotItemType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_guidType(self, value):
        result = True
        # Validate type guidType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) != 36:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd length restriction on guidType' % {"value": encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_guidType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_guidType_patterns_, ))
                result = False
        return result
    validate_guidType_patterns_ = [['^([a-fA-F0-9]{8}\\-[a-fA-F0-9]{4}\\-[a-fA-F0-9]{4}\\-[a-fA-F0-9]{4}\\-[a-fA-F0-9]{12})$']]
    def validate_lotItemQtyType(self, value):
        result = True
        # Validate type lotItemQtyType, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, decimal_.Decimal):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (decimal_.Decimal)' % {"value": value, "lineno": lineno, })
                return False
            if len(str(value)) >= 25:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd totalDigits restriction on lotItemQtyType' % {"value": value, "lineno": lineno} )
                result = False
        return result
    def validate_additionalInfoType34(self, value):
        result = True
        # Validate type additionalInfoType34, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on additionalInfoType34' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on additionalInfoType34' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_money2(self, value):
        result = True
        # Validate type money2, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, decimal_.Decimal):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (decimal_.Decimal)' % {"value": value, "lineno": lineno, })
                return False
            if len(str(value)) >= 20:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd totalDigits restriction on money2' % {"value": value, "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.guid is not None or
            self.ordinalNumber is not None or
            self.okdp is not None or
            self.okpd2 is not None or
            self.okved is not None or
            self.okved2 is not None or
            self.okei is not None or
            self.qty is not None or
            self.additionalInfo is not None or
            self.deliveryPlace is not None or
            self.commodityItemPrice is not None or
            self.commodityItemPriceRub is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'guid':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'guid')
            value_ = self.gds_validate_string(value_, node, 'guid')
            self.guid = value_
            self.guid_nsprefix_ = child_.prefix
            # validate type guidType
            self.validate_guidType(self.guid)
        elif nodeName_ == 'ordinalNumber' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'ordinalNumber')
            ival_ = self.gds_validate_integer(ival_, node, 'ordinalNumber')
            self.ordinalNumber = ival_
            self.ordinalNumber_nsprefix_ = child_.prefix
        elif nodeName_ == 'okdp':
            obj_ = okdpProductType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.okdp = obj_
            obj_.original_tagname_ = 'okdp'
        elif nodeName_ == 'okpd2':
            obj_ = okpd2ProductType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.okpd2 = obj_
            obj_.original_tagname_ = 'okpd2'
        elif nodeName_ == 'okved':
            obj_ = okvedProductType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.okved = obj_
            obj_.original_tagname_ = 'okved'
        elif nodeName_ == 'okved2':
            obj_ = okved2ProductType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.okved2 = obj_
            obj_.original_tagname_ = 'okved2'
        elif nodeName_ == 'okei':
            obj_ = okeiProductType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.okei = obj_
            obj_.original_tagname_ = 'okei'
        elif nodeName_ == 'qty' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'qty')
            fval_ = self.gds_validate_decimal(fval_, node, 'qty')
            self.qty = fval_
            self.qty_nsprefix_ = child_.prefix
            # validate type lotItemQtyType
            self.validate_lotItemQtyType(self.qty)
        elif nodeName_ == 'additionalInfo':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'additionalInfo')
            value_ = self.gds_validate_string(value_, node, 'additionalInfo')
            self.additionalInfo = value_
            self.additionalInfo_nsprefix_ = child_.prefix
            # validate type additionalInfoType34
            self.validate_additionalInfoType34(self.additionalInfo)
        elif nodeName_ == 'deliveryPlace':
            obj_ = deliveryPlaceType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.deliveryPlace = obj_
            obj_.original_tagname_ = 'deliveryPlace'
        elif nodeName_ == 'commodityItemPrice' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'commodityItemPrice')
            fval_ = self.gds_validate_decimal(fval_, node, 'commodityItemPrice')
            self.commodityItemPrice = fval_
            self.commodityItemPrice_nsprefix_ = child_.prefix
            # validate type money2
            self.validate_money2(self.commodityItemPrice)
        elif nodeName_ == 'commodityItemPriceRub' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'commodityItemPriceRub')
            fval_ = self.gds_validate_decimal(fval_, node, 'commodityItemPriceRub')
            self.commodityItemPriceRub = fval_
            self.commodityItemPriceRub_nsprefix_ = child_.prefix
            # validate type money2
            self.validate_money2(self.commodityItemPriceRub)
# end class lotItemType


class lotListType(GeneratedsSuper):
    """Лоты"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'lot': MemberSpec_('lot', 'lotType', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'lot', 'type': 'lotType'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, lot=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if lot is None:
            self.lot = []
        else:
            self.lot = lot
        self.lot_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, lotListType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if lotListType.subclass:
            return lotListType.subclass(*args_, **kwargs_)
        else:
            return lotListType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.lot
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'lot':
            class_obj_ = self.get_class_obj_(child_, lotType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.lot.append(obj_)
            obj_.original_tagname_ = 'lot'
# end class lotListType


class lotISListType(GeneratedsSuper):
    """Лоты ИС"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'lot': MemberSpec_('lot', 'lotTypeIS', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'lot', 'type': 'lotTypeIS'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, lot=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if lot is None:
            self.lot = []
        else:
            self.lot = lot
        self.lot_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, lotISListType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if lotISListType.subclass:
            return lotISListType.subclass(*args_, **kwargs_)
        else:
            return lotISListType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.lot
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'lot':
            obj_ = lotTypeIS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.lot.append(obj_)
            obj_.original_tagname_ = 'lot'
# end class lotISListType


class lotType(GeneratedsSuper):
    """Лот"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'guid': MemberSpec_('guid', ['guidType', 'xs:string'], 0, 0, {'name': 'guid', 'type': 'xs:string'}, None),
        'ordinalNumber': MemberSpec_('ordinalNumber', 'xs:int', 0, 0, {'name': 'ordinalNumber', 'type': 'xs:int'}, None),
        'lotEditEnabled': MemberSpec_('lotEditEnabled', 'xs:boolean', 0, 0, {'name': 'lotEditEnabled', 'type': 'xs:boolean'}, None),
        'lotData': MemberSpec_('lotData', 'lotDataType', 0, 1, {'minOccurs': '0', 'name': 'lotData', 'type': 'lotDataType'}, None),
        'deliveryPlaceIndication': MemberSpec_('deliveryPlaceIndication', ['deliveryPlaceIndicationType', 'xs:string'], 0, 0, {'name': 'deliveryPlaceIndication', 'type': 'xs:string'}, None),
        'jointLotData': MemberSpec_('jointLotData', 'jointLotDataType', 0, 1, {'minOccurs': '0', 'name': 'jointLotData', 'type': 'jointLotDataType'}, None),
        'lotPlanInfo': MemberSpec_('lotPlanInfo', 'planInfoType', 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'lotPlanInfo', 'type': 'planInfoType'}, None),
        'cancelled': MemberSpec_('cancelled', 'xs:boolean', 0, 0, {'name': 'cancelled', 'type': 'xs:boolean'}, None),
        'cancellation': MemberSpec_('cancellation', 'lotCancellationInfoType', 0, 1, {'minOccurs': '0', 'name': 'cancellation', 'type': 'lotCancellationInfoType'}, None),
        'criteria': MemberSpec_('criteria', 'lotCriteriaListType', 0, 1, {'minOccurs': '0', 'name': 'criteria', 'type': 'lotCriteriaListType'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_) + ['extensiontype_']
    subclass = None
    superclass = None
    def __init__(self, guid=None, ordinalNumber=None, lotEditEnabled=None, lotData=None, deliveryPlaceIndication=None, jointLotData=None, lotPlanInfo=None, cancelled=None, cancellation=None, criteria=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.guid = guid
        self.validate_guidType(self.guid)
        self.guid_nsprefix_ = None
        self.ordinalNumber = ordinalNumber
        self.ordinalNumber_nsprefix_ = None
        self.lotEditEnabled = lotEditEnabled
        self.lotEditEnabled_nsprefix_ = None
        self.lotData = lotData
        self.lotData_nsprefix_ = None
        self.deliveryPlaceIndication = deliveryPlaceIndication
        self.validate_deliveryPlaceIndicationType(self.deliveryPlaceIndication)
        self.deliveryPlaceIndication_nsprefix_ = None
        self.jointLotData = jointLotData
        self.jointLotData_nsprefix_ = None
        self.lotPlanInfo = lotPlanInfo
        self.lotPlanInfo_nsprefix_ = None
        self.cancelled = cancelled
        self.cancelled_nsprefix_ = None
        self.cancellation = cancellation
        self.cancellation_nsprefix_ = None
        self.criteria = criteria
        self.criteria_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, lotType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if lotType.subclass:
            return lotType.subclass(*args_, **kwargs_)
        else:
            return lotType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_guidType(self, value):
        result = True
        # Validate type guidType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) != 36:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd length restriction on guidType' % {"value": encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_guidType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_guidType_patterns_, ))
                result = False
        return result
    validate_guidType_patterns_ = [['^([a-fA-F0-9]{8}\\-[a-fA-F0-9]{4}\\-[a-fA-F0-9]{4}\\-[a-fA-F0-9]{4}\\-[a-fA-F0-9]{12})$']]
    def validate_deliveryPlaceIndicationType(self, value):
        result = True
        # Validate type deliveryPlaceIndicationType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['GL', 'ELP', 'LC', 'GA', 'EP']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on deliveryPlaceIndicationType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.guid is not None or
            self.ordinalNumber is not None or
            self.lotEditEnabled is not None or
            self.lotData is not None or
            self.deliveryPlaceIndication is not None or
            self.jointLotData is not None or
            self.lotPlanInfo is not None or
            self.cancelled is not None or
            self.cancellation is not None or
            self.criteria is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'guid':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'guid')
            value_ = self.gds_validate_string(value_, node, 'guid')
            self.guid = value_
            self.guid_nsprefix_ = child_.prefix
            # validate type guidType
            self.validate_guidType(self.guid)
        elif nodeName_ == 'ordinalNumber' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'ordinalNumber')
            ival_ = self.gds_validate_integer(ival_, node, 'ordinalNumber')
            self.ordinalNumber = ival_
            self.ordinalNumber_nsprefix_ = child_.prefix
        elif nodeName_ == 'lotEditEnabled':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'lotEditEnabled')
            ival_ = self.gds_validate_boolean(ival_, node, 'lotEditEnabled')
            self.lotEditEnabled = ival_
            self.lotEditEnabled_nsprefix_ = child_.prefix
        elif nodeName_ == 'lotData':
            obj_ = lotDataType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.lotData = obj_
            obj_.original_tagname_ = 'lotData'
        elif nodeName_ == 'deliveryPlaceIndication':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'deliveryPlaceIndication')
            value_ = self.gds_validate_string(value_, node, 'deliveryPlaceIndication')
            self.deliveryPlaceIndication = value_
            self.deliveryPlaceIndication_nsprefix_ = child_.prefix
            # validate type deliveryPlaceIndicationType
            self.validate_deliveryPlaceIndicationType(self.deliveryPlaceIndication)
        elif nodeName_ == 'jointLotData':
            obj_ = jointLotDataType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.jointLotData = obj_
            obj_.original_tagname_ = 'jointLotData'
        elif nodeName_ == 'lotPlanInfo':
            obj_ = planInfoType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.lotPlanInfo = obj_
            obj_.original_tagname_ = 'lotPlanInfo'
        elif nodeName_ == 'cancelled':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'cancelled')
            ival_ = self.gds_validate_boolean(ival_, node, 'cancelled')
            self.cancelled = ival_
            self.cancelled_nsprefix_ = child_.prefix
        elif nodeName_ == 'cancellation':
            obj_ = lotCancellationInfoType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.cancellation = obj_
            obj_.original_tagname_ = 'cancellation'
        elif nodeName_ == 'criteria':
            obj_ = lotCriteriaListType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.criteria = obj_
            obj_.original_tagname_ = 'criteria'
# end class lotType


class lotCriteriaListType(GeneratedsSuper):
    """Список критериев по лоту"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'lotCriteria': MemberSpec_('lotCriteria', 'lotCriteriaType', 1, 0, {'maxOccurs': 'unbounded', 'name': 'lotCriteria', 'type': 'lotCriteriaType'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, lotCriteria=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if lotCriteria is None:
            self.lotCriteria = []
        else:
            self.lotCriteria = lotCriteria
        self.lotCriteria_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, lotCriteriaListType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if lotCriteriaListType.subclass:
            return lotCriteriaListType.subclass(*args_, **kwargs_)
        else:
            return lotCriteriaListType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.lotCriteria
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'lotCriteria':
            obj_ = lotCriteriaType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.lotCriteria.append(obj_)
            obj_.original_tagname_ = 'lotCriteria'
# end class lotCriteriaListType


class lotApplicationsCriteriaListType(GeneratedsSuper):
    """Список критериев по лоту протокола"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'lotApplicationsCriteria': MemberSpec_('lotApplicationsCriteria', 'lotApplicationsCriteriaType', 1, 0, {'maxOccurs': 'unbounded', 'name': 'lotApplicationsCriteria', 'type': 'lotApplicationsCriteriaType'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, lotApplicationsCriteria=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if lotApplicationsCriteria is None:
            self.lotApplicationsCriteria = []
        else:
            self.lotApplicationsCriteria = lotApplicationsCriteria
        self.lotApplicationsCriteria_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, lotApplicationsCriteriaListType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if lotApplicationsCriteriaListType.subclass:
            return lotApplicationsCriteriaListType.subclass(*args_, **kwargs_)
        else:
            return lotApplicationsCriteriaListType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.lotApplicationsCriteria
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'lotApplicationsCriteria':
            obj_ = lotApplicationsCriteriaType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.lotApplicationsCriteria.append(obj_)
            obj_.original_tagname_ = 'lotApplicationsCriteria'
# end class lotApplicationsCriteriaListType


class baseCriteriaType(GeneratedsSuper):
    """Базовый критерий по лоту"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'guid': MemberSpec_('guid', ['guidType', 'xs:string'], 0, 0, {'name': 'guid', 'type': 'xs:string'}, None),
        'name': MemberSpec_('name', ['nameType35', 'nonEmptyString', 'xs:string'], 0, 0, {'name': 'name', 'type': 'xs:string'}, None),
        'description': MemberSpec_('description', ['descriptionType36', 'nonEmptyString', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'description', 'type': 'xs:string'}, None),
        'maxValue': MemberSpec_('maxValue', ['decimal20_2', 'xs:decimal'], 0, 0, {'name': 'maxValue', 'type': 'xs:decimal'}, None),
        'weight': MemberSpec_('weight', ['decimal20_2', 'xs:decimal'], 0, 0, {'name': 'weight', 'type': 'xs:decimal'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_) + ['extensiontype_']
    subclass = None
    superclass = None
    def __init__(self, guid=None, name=None, description=None, maxValue=None, weight=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.guid = guid
        self.validate_guidType(self.guid)
        self.guid_nsprefix_ = None
        self.name = name
        self.validate_nameType35(self.name)
        self.name_nsprefix_ = None
        self.description = description
        self.validate_descriptionType36(self.description)
        self.description_nsprefix_ = None
        self.maxValue = maxValue
        self.validate_decimal20_2(self.maxValue)
        self.maxValue_nsprefix_ = None
        self.weight = weight
        self.validate_decimal20_2(self.weight)
        self.weight_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, baseCriteriaType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if baseCriteriaType.subclass:
            return baseCriteriaType.subclass(*args_, **kwargs_)
        else:
            return baseCriteriaType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_guidType(self, value):
        result = True
        # Validate type guidType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) != 36:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd length restriction on guidType' % {"value": encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_guidType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_guidType_patterns_, ))
                result = False
        return result
    validate_guidType_patterns_ = [['^([a-fA-F0-9]{8}\\-[a-fA-F0-9]{4}\\-[a-fA-F0-9]{4}\\-[a-fA-F0-9]{4}\\-[a-fA-F0-9]{12})$']]
    def validate_nameType35(self, value):
        result = True
        # Validate type nameType35, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 500:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on nameType35' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on nameType35' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_descriptionType36(self, value):
        result = True
        # Validate type descriptionType36, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on descriptionType36' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on descriptionType36' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_decimal20_2(self, value):
        result = True
        # Validate type decimal20_2, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, decimal_.Decimal):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (decimal_.Decimal)' % {"value": value, "lineno": lineno, })
                return False
            if len(str(value)) >= 20:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd totalDigits restriction on decimal20_2' % {"value": value, "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.guid is not None or
            self.name is not None or
            self.description is not None or
            self.maxValue is not None or
            self.weight is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'guid':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'guid')
            value_ = self.gds_validate_string(value_, node, 'guid')
            self.guid = value_
            self.guid_nsprefix_ = child_.prefix
            # validate type guidType
            self.validate_guidType(self.guid)
        elif nodeName_ == 'name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'name')
            value_ = self.gds_validate_string(value_, node, 'name')
            self.name = value_
            self.name_nsprefix_ = child_.prefix
            # validate type nameType35
            self.validate_nameType35(self.name)
        elif nodeName_ == 'description':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'description')
            value_ = self.gds_validate_string(value_, node, 'description')
            self.description = value_
            self.description_nsprefix_ = child_.prefix
            # validate type descriptionType36
            self.validate_descriptionType36(self.description)
        elif nodeName_ == 'maxValue' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'maxValue')
            fval_ = self.gds_validate_decimal(fval_, node, 'maxValue')
            self.maxValue = fval_
            self.maxValue_nsprefix_ = child_.prefix
            # validate type decimal20_2
            self.validate_decimal20_2(self.maxValue)
        elif nodeName_ == 'weight' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'weight')
            fval_ = self.gds_validate_decimal(fval_, node, 'weight')
            self.weight = fval_
            self.weight_nsprefix_ = child_.prefix
            # validate type decimal20_2
            self.validate_decimal20_2(self.weight)
# end class baseCriteriaType


class applicationLotCriteriaListType(GeneratedsSuper):
    """Список значений критериев заявок"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'applicationLotCriteria': MemberSpec_('applicationLotCriteria', 'applicationLotCriteriaType', 1, 0, {'maxOccurs': 'unbounded', 'name': 'applicationLotCriteria', 'type': 'applicationLotCriteriaType'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, applicationLotCriteria=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if applicationLotCriteria is None:
            self.applicationLotCriteria = []
        else:
            self.applicationLotCriteria = applicationLotCriteria
        self.applicationLotCriteria_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, applicationLotCriteriaListType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if applicationLotCriteriaListType.subclass:
            return applicationLotCriteriaListType.subclass(*args_, **kwargs_)
        else:
            return applicationLotCriteriaListType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.applicationLotCriteria
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'applicationLotCriteria':
            obj_ = applicationLotCriteriaType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.applicationLotCriteria.append(obj_)
            obj_.original_tagname_ = 'applicationLotCriteria'
# end class applicationLotCriteriaListType


class applicationLotCriteriaType(GeneratedsSuper):
    """Значения критериев заявок"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'lotApplcationsCriteria': MemberSpec_('lotApplcationsCriteria', 'lotApplcationsCriteriaType', 0, 0, {'name': 'lotApplcationsCriteria', 'type': 'lotApplcationsCriteriaType'}, None),
        'value': MemberSpec_('value', ['decimal20_2', 'xs:decimal'], 0, 0, {'name': 'value', 'type': 'xs:decimal'}, None),
        'description': MemberSpec_('description', ['descriptionType38', 'nonEmptyString', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'description', 'type': 'xs:string'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, lotApplcationsCriteria=None, value=None, description=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.lotApplcationsCriteria = lotApplcationsCriteria
        self.lotApplcationsCriteria_nsprefix_ = None
        self.value = value
        self.validate_decimal20_2(self.value)
        self.value_nsprefix_ = None
        self.description = description
        self.validate_descriptionType38(self.description)
        self.description_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, applicationLotCriteriaType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if applicationLotCriteriaType.subclass:
            return applicationLotCriteriaType.subclass(*args_, **kwargs_)
        else:
            return applicationLotCriteriaType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_decimal20_2(self, value):
        result = True
        # Validate type decimal20_2, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, decimal_.Decimal):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (decimal_.Decimal)' % {"value": value, "lineno": lineno, })
                return False
            if len(str(value)) >= 20:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd totalDigits restriction on decimal20_2' % {"value": value, "lineno": lineno} )
                result = False
        return result
    def validate_descriptionType38(self, value):
        result = True
        # Validate type descriptionType38, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on descriptionType38' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on descriptionType38' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.lotApplcationsCriteria is not None or
            self.value is not None or
            self.description is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'lotApplcationsCriteria':
            obj_ = lotApplcationsCriteriaType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.lotApplcationsCriteria = obj_
            obj_.original_tagname_ = 'lotApplcationsCriteria'
        elif nodeName_ == 'value' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'value')
            fval_ = self.gds_validate_decimal(fval_, node, 'value')
            self.value = fval_
            self.value_nsprefix_ = child_.prefix
            # validate type decimal20_2
            self.validate_decimal20_2(self.value)
        elif nodeName_ == 'description':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'description')
            value_ = self.gds_validate_string(value_, node, 'description')
            self.description = value_
            self.description_nsprefix_ = child_.prefix
            # validate type descriptionType38
            self.validate_descriptionType38(self.description)
# end class applicationLotCriteriaType


class lotCancellationInfoType(GeneratedsSuper):
    """Данные об отмене лота"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'cancelDate': MemberSpec_('cancelDate', 'xs:date', 0, 0, {'name': 'cancelDate', 'type': 'xs:date'}, None),
        'cancelInfo': MemberSpec_('cancelInfo', ['cancelInfoType', 'nonEmptyString', 'xs:string'], 0, 0, {'name': 'cancelInfo', 'type': 'xs:string'}, None),
        'emergency': MemberSpec_('emergency', 'xs:boolean', 0, 1, {'minOccurs': '0', 'name': 'emergency', 'type': 'xs:boolean'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, cancelDate=None, cancelInfo=None, emergency=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if isinstance(cancelDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(cancelDate, '%Y-%m-%d').date()
        else:
            initvalue_ = cancelDate
        self.cancelDate = initvalue_
        self.cancelDate_nsprefix_ = None
        self.cancelInfo = cancelInfo
        self.validate_cancelInfoType(self.cancelInfo)
        self.cancelInfo_nsprefix_ = None
        self.emergency = emergency
        self.emergency_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, lotCancellationInfoType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if lotCancellationInfoType.subclass:
            return lotCancellationInfoType.subclass(*args_, **kwargs_)
        else:
            return lotCancellationInfoType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_cancelInfoType(self, value):
        result = True
        # Validate type cancelInfoType, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 2000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on cancelInfoType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on cancelInfoType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.cancelDate is not None or
            self.cancelInfo is not None or
            self.emergency is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'cancelDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.cancelDate = dval_
            self.cancelDate_nsprefix_ = child_.prefix
        elif nodeName_ == 'cancelInfo':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'cancelInfo')
            value_ = self.gds_validate_string(value_, node, 'cancelInfo')
            self.cancelInfo = value_
            self.cancelInfo_nsprefix_ = child_.prefix
            # validate type cancelInfoType
            self.validate_cancelInfoType(self.cancelInfo)
        elif nodeName_ == 'emergency':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'emergency')
            ival_ = self.gds_validate_boolean(ival_, node, 'emergency')
            self.emergency = ival_
            self.emergency_nsprefix_ = child_.prefix
# end class lotCancellationInfoType


class lotAllocationReferenceType(GeneratedsSuper):
    """Сведения о формировании протокола в результате выделения лотов"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'protocolRequisites': MemberSpec_('protocolRequisites', 'protocolRequisitesType', 0, 0, {'name': 'protocolRequisites', 'type': 'protocolRequisitesType'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, protocolRequisites=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.protocolRequisites = protocolRequisites
        self.protocolRequisites_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, lotAllocationReferenceType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if lotAllocationReferenceType.subclass:
            return lotAllocationReferenceType.subclass(*args_, **kwargs_)
        else:
            return lotAllocationReferenceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.protocolRequisites is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'protocolRequisites':
            class_obj_ = self.get_class_obj_(child_, protocolRequisitesType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.protocolRequisites = obj_
            obj_.original_tagname_ = 'protocolRequisites'
# end class lotAllocationReferenceType


class lotAllocationInfoType(GeneratedsSuper):
    """Данные о выделении лота в отдельный протокол"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'allocationDate': MemberSpec_('allocationDate', 'xs:date', 0, 0, {'name': 'allocationDate', 'type': 'xs:date'}, None),
        'allocationInfo': MemberSpec_('allocationInfo', ['allocationInfoType', 'nonEmptyString', 'xs:string'], 0, 0, {'name': 'allocationInfo', 'type': 'xs:string'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, allocationDate=None, allocationInfo=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if isinstance(allocationDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(allocationDate, '%Y-%m-%d').date()
        else:
            initvalue_ = allocationDate
        self.allocationDate = initvalue_
        self.allocationDate_nsprefix_ = None
        self.allocationInfo = allocationInfo
        self.validate_allocationInfoType(self.allocationInfo)
        self.allocationInfo_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, lotAllocationInfoType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if lotAllocationInfoType.subclass:
            return lotAllocationInfoType.subclass(*args_, **kwargs_)
        else:
            return lotAllocationInfoType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_allocationInfoType(self, value):
        result = True
        # Validate type allocationInfoType, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 2000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on allocationInfoType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on allocationInfoType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.allocationDate is not None or
            self.allocationInfo is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'allocationDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.allocationDate = dval_
            self.allocationDate_nsprefix_ = child_.prefix
        elif nodeName_ == 'allocationInfo':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'allocationInfo')
            value_ = self.gds_validate_string(value_, node, 'allocationInfo')
            self.allocationInfo = value_
            self.allocationInfo_nsprefix_ = child_.prefix
            # validate type allocationInfoType
            self.validate_allocationInfoType(self.allocationInfo)
# end class lotAllocationInfoType


class deliveryPlaceType(GeneratedsSuper):
    """Место поставки"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'state': MemberSpec_('state', ['stateType', 'nonEmptyString', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'state', 'type': 'xs:string'}, None),
        'region': MemberSpec_('region', ['regionType39', 'nonEmptyString', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'region', 'type': 'xs:string'}, None),
        'regionOkato': MemberSpec_('regionOkato', ['codeOkatoType', 'nonEmptyString', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'regionOkato', 'type': 'xs:string'}, None),
        'address': MemberSpec_('address', ['addressType40', 'nonEmptyString', 'xs:string'], 0, 0, {'name': 'address', 'type': 'xs:string'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, state=None, region=None, regionOkato=None, address=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.state = state
        self.validate_stateType(self.state)
        self.state_nsprefix_ = None
        self.region = region
        self.validate_regionType39(self.region)
        self.region_nsprefix_ = None
        self.regionOkato = regionOkato
        self.validate_codeOkatoType(self.regionOkato)
        self.regionOkato_nsprefix_ = None
        self.address = address
        self.validate_addressType40(self.address)
        self.address_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, deliveryPlaceType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if deliveryPlaceType.subclass:
            return deliveryPlaceType.subclass(*args_, **kwargs_)
        else:
            return deliveryPlaceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_stateType(self, value):
        result = True
        # Validate type stateType, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 2000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on stateType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on stateType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_regionType39(self, value):
        result = True
        # Validate type regionType39, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 2000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on regionType39' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on regionType39' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_codeOkatoType(self, value):
        result = True
        # Validate type codeOkatoType, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on codeOkatoType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_codeOkatoType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_codeOkatoType_patterns_, ))
                result = False
        return result
    validate_codeOkatoType_patterns_ = [['^(\\d{11})$']]
    def validate_addressType40(self, value):
        result = True
        # Validate type addressType40, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 2000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on addressType40' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on addressType40' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.state is not None or
            self.region is not None or
            self.regionOkato is not None or
            self.address is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'state':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'state')
            value_ = self.gds_validate_string(value_, node, 'state')
            self.state = value_
            self.state_nsprefix_ = child_.prefix
            # validate type stateType
            self.validate_stateType(self.state)
        elif nodeName_ == 'region':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'region')
            value_ = self.gds_validate_string(value_, node, 'region')
            self.region = value_
            self.region_nsprefix_ = child_.prefix
            # validate type regionType39
            self.validate_regionType39(self.region)
        elif nodeName_ == 'regionOkato':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'regionOkato')
            value_ = self.gds_validate_string(value_, node, 'regionOkato')
            self.regionOkato = value_
            self.regionOkato_nsprefix_ = child_.prefix
            # validate type codeOkatoType
            self.validate_codeOkatoType(self.regionOkato)
        elif nodeName_ == 'address':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'address')
            value_ = self.gds_validate_string(value_, node, 'address')
            self.address = value_
            self.address_nsprefix_ = child_.prefix
            # validate type addressType40
            self.validate_addressType40(self.address)
# end class deliveryPlaceType


class planInfoType(GeneratedsSuper):
    """Информация о плане и позиции"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'planRegistrationNumber': MemberSpec_('planRegistrationNumber', ['registrationNumberType', 'nonEmptyString', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'planRegistrationNumber', 'type': 'xs:string'}, None),
        'planGuid': MemberSpec_('planGuid', ['guidType', 'xs:string'], 0, 0, {'name': 'planGuid', 'type': 'xs:string'}, None),
        'positionNumber': MemberSpec_('positionNumber', 'xs:long', 0, 0, {'name': 'positionNumber', 'type': 'xs:long'}, None),
        'lotPlanPosition': MemberSpec_('lotPlanPosition', ['lotPlanPositionType', 'xs:string'], 0, 0, {'name': 'lotPlanPosition', 'type': 'xs:string'}, None),
        'positionGuid': MemberSpec_('positionGuid', ['guidType', 'xs:string'], 0, 0, {'name': 'positionGuid', 'type': 'xs:string'}, None),
        'contractSubject': MemberSpec_('contractSubject', ['contractSubjectType', 'nonEmptyString', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'contractSubject', 'type': 'xs:string'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, planRegistrationNumber=None, planGuid=None, positionNumber=None, lotPlanPosition=None, positionGuid=None, contractSubject=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.planRegistrationNumber = planRegistrationNumber
        self.validate_registrationNumberType(self.planRegistrationNumber)
        self.planRegistrationNumber_nsprefix_ = None
        self.planGuid = planGuid
        self.validate_guidType(self.planGuid)
        self.planGuid_nsprefix_ = None
        self.positionNumber = positionNumber
        self.positionNumber_nsprefix_ = None
        self.lotPlanPosition = lotPlanPosition
        self.validate_lotPlanPositionType(self.lotPlanPosition)
        self.lotPlanPosition_nsprefix_ = None
        self.positionGuid = positionGuid
        self.validate_guidType(self.positionGuid)
        self.positionGuid_nsprefix_ = None
        self.contractSubject = contractSubject
        self.validate_contractSubjectType(self.contractSubject)
        self.contractSubject_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, planInfoType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if planInfoType.subclass:
            return planInfoType.subclass(*args_, **kwargs_)
        else:
            return planInfoType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_registrationNumberType(self, value):
        result = True
        # Validate type registrationNumberType, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on registrationNumberType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_registrationNumberType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_registrationNumberType_patterns_, ))
                result = False
        return result
    validate_registrationNumberType_patterns_ = [['^(\\d{10})$']]
    def validate_guidType(self, value):
        result = True
        # Validate type guidType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) != 36:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd length restriction on guidType' % {"value": encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_guidType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_guidType_patterns_, ))
                result = False
        return result
    validate_guidType_patterns_ = [['^([a-fA-F0-9]{8}\\-[a-fA-F0-9]{4}\\-[a-fA-F0-9]{4}\\-[a-fA-F0-9]{4}\\-[a-fA-F0-9]{12})$']]
    def validate_lotPlanPositionType(self, value):
        result = True
        # Validate type lotPlanPositionType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['COMMODITY', 'INNOVATION']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on lotPlanPositionType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_contractSubjectType(self, value):
        result = True
        # Validate type contractSubjectType, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 4000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on contractSubjectType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on contractSubjectType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.planRegistrationNumber is not None or
            self.planGuid is not None or
            self.positionNumber is not None or
            self.lotPlanPosition is not None or
            self.positionGuid is not None or
            self.contractSubject is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'planRegistrationNumber':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'planRegistrationNumber')
            value_ = self.gds_validate_string(value_, node, 'planRegistrationNumber')
            self.planRegistrationNumber = value_
            self.planRegistrationNumber_nsprefix_ = child_.prefix
            # validate type registrationNumberType
            self.validate_registrationNumberType(self.planRegistrationNumber)
        elif nodeName_ == 'planGuid':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'planGuid')
            value_ = self.gds_validate_string(value_, node, 'planGuid')
            self.planGuid = value_
            self.planGuid_nsprefix_ = child_.prefix
            # validate type guidType
            self.validate_guidType(self.planGuid)
        elif nodeName_ == 'positionNumber' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'positionNumber')
            ival_ = self.gds_validate_integer(ival_, node, 'positionNumber')
            self.positionNumber = ival_
            self.positionNumber_nsprefix_ = child_.prefix
        elif nodeName_ == 'lotPlanPosition':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'lotPlanPosition')
            value_ = self.gds_validate_string(value_, node, 'lotPlanPosition')
            self.lotPlanPosition = value_
            self.lotPlanPosition_nsprefix_ = child_.prefix
            # validate type lotPlanPositionType
            self.validate_lotPlanPositionType(self.lotPlanPosition)
        elif nodeName_ == 'positionGuid':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'positionGuid')
            value_ = self.gds_validate_string(value_, node, 'positionGuid')
            self.positionGuid = value_
            self.positionGuid_nsprefix_ = child_.prefix
            # validate type guidType
            self.validate_guidType(self.positionGuid)
        elif nodeName_ == 'contractSubject':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'contractSubject')
            value_ = self.gds_validate_string(value_, node, 'contractSubject')
            self.contractSubject = value_
            self.contractSubject_nsprefix_ = child_.prefix
            # validate type contractSubjectType
            self.validate_contractSubjectType(self.contractSubject)
# end class planInfoType


class lotCustomerListType(GeneratedsSuper):
    """Участники совместной закупки"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'lotCustomer': MemberSpec_('lotCustomer', 'lotCustomerType', 1, 0, {'maxOccurs': 'unbounded', 'minOccurs': '1', 'name': 'lotCustomer', 'type': 'lotCustomerType'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, lotCustomer=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if lotCustomer is None:
            self.lotCustomer = []
        else:
            self.lotCustomer = lotCustomer
        self.lotCustomer_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, lotCustomerListType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if lotCustomerListType.subclass:
            return lotCustomerListType.subclass(*args_, **kwargs_)
        else:
            return lotCustomerListType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.lotCustomer
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'lotCustomer':
            obj_ = lotCustomerType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.lotCustomer.append(obj_)
            obj_.original_tagname_ = 'lotCustomer'
# end class lotCustomerListType


class lotCustomerListShortType(GeneratedsSuper):
    """Участники совместной закупки"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'lotCustomer': MemberSpec_('lotCustomer', 'lotCustomerShortType', 1, 0, {'maxOccurs': 'unbounded', 'minOccurs': '1', 'name': 'lotCustomer', 'type': 'lotCustomerShortType'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, lotCustomer=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if lotCustomer is None:
            self.lotCustomer = []
        else:
            self.lotCustomer = lotCustomer
        self.lotCustomer_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, lotCustomerListShortType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if lotCustomerListShortType.subclass:
            return lotCustomerListShortType.subclass(*args_, **kwargs_)
        else:
            return lotCustomerListShortType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.lotCustomer
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'lotCustomer':
            obj_ = lotCustomerShortType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.lotCustomer.append(obj_)
            obj_.original_tagname_ = 'lotCustomer'
# end class lotCustomerListShortType


class lotCustomerBaseType(GeneratedsSuper):
    """Участник совместной закупки"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'additionalInfo': MemberSpec_('additionalInfo', ['additionalInfoType41', 'nonEmptyString', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'additionalInfo', 'type': 'xs:string'}, None),
        'deliveryPlaceIndication': MemberSpec_('deliveryPlaceIndication', ['deliveryPlaceIndicationType', 'xs:string'], 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'deliveryPlaceIndication', 'type': 'xs:string'}, None),
        'lotCustomerEditEnabled': MemberSpec_('lotCustomerEditEnabled', 'xs:boolean', 0, 0, {'name': 'lotCustomerEditEnabled', 'type': 'xs:boolean'}, None),
        'lotCustomerData': MemberSpec_('lotCustomerData', 'lotCustomerDataType', 0, 0, {'name': 'lotCustomerData', 'type': 'lotCustomerDataType'}, None),
        'lotPlanInfo': MemberSpec_('lotPlanInfo', 'planInfoType', 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'lotPlanInfo', 'type': 'planInfoType'}, None),
        'extendFields': MemberSpec_('extendFields', 'noticeExtendFieldValueListType', 0, 1, {'minOccurs': '0', 'name': 'extendFields', 'type': 'noticeExtendFieldValueListType'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_) + ['extensiontype_']
    subclass = None
    superclass = None
    def __init__(self, additionalInfo=None, deliveryPlaceIndication=None, lotCustomerEditEnabled=None, lotCustomerData=None, lotPlanInfo=None, extendFields=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.additionalInfo = additionalInfo
        self.validate_additionalInfoType41(self.additionalInfo)
        self.additionalInfo_nsprefix_ = None
        self.deliveryPlaceIndication = deliveryPlaceIndication
        self.validate_deliveryPlaceIndicationType(self.deliveryPlaceIndication)
        self.deliveryPlaceIndication_nsprefix_ = None
        self.lotCustomerEditEnabled = lotCustomerEditEnabled
        self.lotCustomerEditEnabled_nsprefix_ = None
        self.lotCustomerData = lotCustomerData
        self.lotCustomerData_nsprefix_ = None
        self.lotPlanInfo = lotPlanInfo
        self.lotPlanInfo_nsprefix_ = None
        self.extendFields = extendFields
        self.extendFields_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, lotCustomerBaseType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if lotCustomerBaseType.subclass:
            return lotCustomerBaseType.subclass(*args_, **kwargs_)
        else:
            return lotCustomerBaseType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_additionalInfoType41(self, value):
        result = True
        # Validate type additionalInfoType41, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 2000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on additionalInfoType41' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on additionalInfoType41' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_deliveryPlaceIndicationType(self, value):
        result = True
        # Validate type deliveryPlaceIndicationType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['GL', 'ELP', 'LC', 'GA', 'EP']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on deliveryPlaceIndicationType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.additionalInfo is not None or
            self.deliveryPlaceIndication is not None or
            self.lotCustomerEditEnabled is not None or
            self.lotCustomerData is not None or
            self.lotPlanInfo is not None or
            self.extendFields is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'additionalInfo':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'additionalInfo')
            value_ = self.gds_validate_string(value_, node, 'additionalInfo')
            self.additionalInfo = value_
            self.additionalInfo_nsprefix_ = child_.prefix
            # validate type additionalInfoType41
            self.validate_additionalInfoType41(self.additionalInfo)
        elif nodeName_ == 'deliveryPlaceIndication':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'deliveryPlaceIndication')
            value_ = self.gds_validate_string(value_, node, 'deliveryPlaceIndication')
            self.deliveryPlaceIndication = value_
            self.deliveryPlaceIndication_nsprefix_ = child_.prefix
            # validate type deliveryPlaceIndicationType
            self.validate_deliveryPlaceIndicationType(self.deliveryPlaceIndication)
        elif nodeName_ == 'lotCustomerEditEnabled':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'lotCustomerEditEnabled')
            ival_ = self.gds_validate_boolean(ival_, node, 'lotCustomerEditEnabled')
            self.lotCustomerEditEnabled = ival_
            self.lotCustomerEditEnabled_nsprefix_ = child_.prefix
        elif nodeName_ == 'lotCustomerData':
            obj_ = lotCustomerDataType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.lotCustomerData = obj_
            obj_.original_tagname_ = 'lotCustomerData'
        elif nodeName_ == 'lotPlanInfo':
            obj_ = planInfoType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.lotPlanInfo = obj_
            obj_.original_tagname_ = 'lotPlanInfo'
        elif nodeName_ == 'extendFields':
            obj_ = noticeExtendFieldValueListType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.extendFields = obj_
            obj_.original_tagname_ = 'extendFields'
# end class lotCustomerBaseType


class lotCustomerType(lotCustomerBaseType):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'nonResident': MemberSpec_('nonResident', 'xs:boolean', 0, 1, {'minOccurs': '0', 'name': 'nonResident', 'type': 'xs:boolean'}, None),
        'tax': MemberSpec_('tax', 'xs:boolean', 0, 1, {'minOccurs': '0', 'name': 'tax', 'type': 'xs:boolean'}, None),
        'customerInfo': MemberSpec_('customerInfo', 'customerMainInfoType', 0, 1, {'minOccurs': '0', 'name': 'customerInfo', 'type': 'customerMainInfoType'}, None),
        'nonResidentInfo': MemberSpec_('nonResidentInfo', 'nonResidentLotCustomerInfoType', 0, 1, {'minOccurs': '0', 'name': 'nonResidentInfo', 'type': 'nonResidentLotCustomerInfoType'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = lotCustomerBaseType
    def __init__(self, additionalInfo=None, deliveryPlaceIndication=None, lotCustomerEditEnabled=None, lotCustomerData=None, lotPlanInfo=None, extendFields=None, nonResident=None, tax=None, customerInfo=None, nonResidentInfo=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(lotCustomerType, self).__init__(additionalInfo, deliveryPlaceIndication, lotCustomerEditEnabled, lotCustomerData, lotPlanInfo, extendFields,  **kwargs_)
        self.nonResident = nonResident
        self.nonResident_nsprefix_ = None
        self.tax = tax
        self.tax_nsprefix_ = None
        self.customerInfo = customerInfo
        self.customerInfo_nsprefix_ = None
        self.nonResidentInfo = nonResidentInfo
        self.nonResidentInfo_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, lotCustomerType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if lotCustomerType.subclass:
            return lotCustomerType.subclass(*args_, **kwargs_)
        else:
            return lotCustomerType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.nonResident is not None or
            self.tax is not None or
            self.customerInfo is not None or
            self.nonResidentInfo is not None or
            super(lotCustomerType, self).hasContent_()
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(lotCustomerType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'nonResident':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'nonResident')
            ival_ = self.gds_validate_boolean(ival_, node, 'nonResident')
            self.nonResident = ival_
            self.nonResident_nsprefix_ = child_.prefix
        elif nodeName_ == 'tax':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'tax')
            ival_ = self.gds_validate_boolean(ival_, node, 'tax')
            self.tax = ival_
            self.tax_nsprefix_ = child_.prefix
        elif nodeName_ == 'customerInfo':
            obj_ = customerMainInfoType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.customerInfo = obj_
            obj_.original_tagname_ = 'customerInfo'
        elif nodeName_ == 'nonResidentInfo':
            obj_ = nonResidentLotCustomerInfoType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.nonResidentInfo = obj_
            obj_.original_tagname_ = 'nonResidentInfo'
        super(lotCustomerType, self).buildChildren(child_, node, nodeName_, True)
# end class lotCustomerType


class lotCustomerShortType(lotCustomerBaseType):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'customerInfo': MemberSpec_('customerInfo', 'customerMainInfo2Type', 0, 0, {'name': 'customerInfo', 'type': 'customerMainInfo2Type'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = lotCustomerBaseType
    def __init__(self, additionalInfo=None, deliveryPlaceIndication=None, lotCustomerEditEnabled=None, lotCustomerData=None, lotPlanInfo=None, extendFields=None, customerInfo=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(lotCustomerShortType, self).__init__(additionalInfo, deliveryPlaceIndication, lotCustomerEditEnabled, lotCustomerData, lotPlanInfo, extendFields,  **kwargs_)
        self.customerInfo = customerInfo
        self.customerInfo_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, lotCustomerShortType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if lotCustomerShortType.subclass:
            return lotCustomerShortType.subclass(*args_, **kwargs_)
        else:
            return lotCustomerShortType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.customerInfo is not None or
            super(lotCustomerShortType, self).hasContent_()
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(lotCustomerShortType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'customerInfo':
            obj_ = customerMainInfo2Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.customerInfo = obj_
            obj_.original_tagname_ = 'customerInfo'
        super(lotCustomerShortType, self).buildChildren(child_, node, nodeName_, True)
# end class lotCustomerShortType


class lotTypeIS(lotType):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'extendFields': MemberSpec_('extendFields', 'noticeExtendFieldValueListType', 0, 1, {'minOccurs': '0', 'name': 'extendFields', 'type': 'noticeExtendFieldValueListType'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = lotType
    def __init__(self, guid=None, ordinalNumber=None, lotEditEnabled=None, lotData=None, deliveryPlaceIndication=None, jointLotData=None, lotPlanInfo=None, cancelled=None, cancellation=None, criteria=None, extendFields=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(lotTypeIS, self).__init__(guid, ordinalNumber, lotEditEnabled, lotData, deliveryPlaceIndication, jointLotData, lotPlanInfo, cancelled, cancellation, criteria,  **kwargs_)
        self.extendFields = extendFields
        self.extendFields_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, lotTypeIS)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if lotTypeIS.subclass:
            return lotTypeIS.subclass(*args_, **kwargs_)
        else:
            return lotTypeIS(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.extendFields is not None or
            super(lotTypeIS, self).hasContent_()
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(lotTypeIS, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'extendFields':
            obj_ = noticeExtendFieldValueListType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.extendFields = obj_
            obj_.original_tagname_ = 'extendFields'
        super(lotTypeIS, self).buildChildren(child_, node, nodeName_, True)
# end class lotTypeIS


class lotLinkType(GeneratedsSuper):
    """Ccылка на лот"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'guid': MemberSpec_('guid', ['guidType', 'xs:string'], 0, 0, {'name': 'guid', 'type': 'xs:string'}, None),
        'subject': MemberSpec_('subject', ['subjectType45', 'nonEmptyString', 'xs:string'], 0, 0, {'name': 'subject', 'type': 'xs:string'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, guid=None, subject=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.guid = guid
        self.validate_guidType(self.guid)
        self.guid_nsprefix_ = None
        self.subject = subject
        self.validate_subjectType45(self.subject)
        self.subject_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, lotLinkType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if lotLinkType.subclass:
            return lotLinkType.subclass(*args_, **kwargs_)
        else:
            return lotLinkType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_guidType(self, value):
        result = True
        # Validate type guidType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) != 36:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd length restriction on guidType' % {"value": encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_guidType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_guidType_patterns_, ))
                result = False
        return result
    validate_guidType_patterns_ = [['^([a-fA-F0-9]{8}\\-[a-fA-F0-9]{4}\\-[a-fA-F0-9]{4}\\-[a-fA-F0-9]{4}\\-[a-fA-F0-9]{12})$']]
    def validate_subjectType45(self, value):
        result = True
        # Validate type subjectType45, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 2000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on subjectType45' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on subjectType45' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.guid is not None or
            self.subject is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'guid':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'guid')
            value_ = self.gds_validate_string(value_, node, 'guid')
            self.guid = value_
            self.guid_nsprefix_ = child_.prefix
            # validate type guidType
            self.validate_guidType(self.guid)
        elif nodeName_ == 'subject':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'subject')
            value_ = self.gds_validate_string(value_, node, 'subject')
            self.subject = value_
            self.subject_nsprefix_ = child_.prefix
            # validate type subjectType45
            self.validate_subjectType45(self.subject)
# end class lotLinkType


class okeiProductType(GeneratedsSuper):
    """Код единицы измерения по ОКЕИ"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'code': MemberSpec_('code', ['codeType46', 'nonEmptyString', 'xs:string'], 0, 0, {'name': 'code', 'type': 'xs:string'}, None),
        'name': MemberSpec_('name', ['nameType47', 'nonEmptyString', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'name', 'type': 'xs:string'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, code=None, name=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.code = code
        self.validate_codeType46(self.code)
        self.code_nsprefix_ = None
        self.name = name
        self.validate_nameType47(self.name)
        self.name_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, okeiProductType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if okeiProductType.subclass:
            return okeiProductType.subclass(*args_, **kwargs_)
        else:
            return okeiProductType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_codeType46(self, value):
        result = True
        # Validate type codeType46, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 20:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on codeType46' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on codeType46' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_nameType47(self, value):
        result = True
        # Validate type nameType47, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 2000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on nameType47' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on nameType47' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.code is not None or
            self.name is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'code':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'code')
            value_ = self.gds_validate_string(value_, node, 'code')
            self.code = value_
            self.code_nsprefix_ = child_.prefix
            # validate type codeType46
            self.validate_codeType46(self.code)
        elif nodeName_ == 'name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'name')
            value_ = self.gds_validate_string(value_, node, 'name')
            self.name = value_
            self.name_nsprefix_ = child_.prefix
            # validate type nameType47
            self.validate_nameType47(self.name)
# end class okeiProductType


class okvedProductType(GeneratedsSuper):
    """Код товара, работы или услуги по ОКВЭД"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'code': MemberSpec_('code', ['codeOkvedType', 'nonEmptyString', 'xs:string'], 0, 0, {'name': 'code', 'type': 'xs:string'}, None),
        'name': MemberSpec_('name', ['nameType48', 'nonEmptyString', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'name', 'type': 'xs:string'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, code=None, name=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.code = code
        self.validate_codeOkvedType(self.code)
        self.code_nsprefix_ = None
        self.name = name
        self.validate_nameType48(self.name)
        self.name_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, okvedProductType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if okvedProductType.subclass:
            return okvedProductType.subclass(*args_, **kwargs_)
        else:
            return okvedProductType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_codeOkvedType(self, value):
        result = True
        # Validate type codeOkvedType, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on codeOkvedType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_codeOkvedType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_codeOkvedType_patterns_, ))
                result = False
        return result
    validate_codeOkvedType_patterns_ = [['^([A-Q]{1,2}|(\\d{2}((\\.\\d{1,2})|(\\.\\d{2}\\.\\d{1,2}))?))$']]
    def validate_nameType48(self, value):
        result = True
        # Validate type nameType48, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 500:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on nameType48' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on nameType48' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.code is not None or
            self.name is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'code':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'code')
            value_ = self.gds_validate_string(value_, node, 'code')
            self.code = value_
            self.code_nsprefix_ = child_.prefix
            # validate type codeOkvedType
            self.validate_codeOkvedType(self.code)
        elif nodeName_ == 'name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'name')
            value_ = self.gds_validate_string(value_, node, 'name')
            self.name = value_
            self.name_nsprefix_ = child_.prefix
            # validate type nameType48
            self.validate_nameType48(self.name)
# end class okvedProductType


class okved2ProductType(GeneratedsSuper):
    """Код товара, работы или услуги по ОКВЭД2"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'code': MemberSpec_('code', ['codeOkvedType', 'nonEmptyString', 'xs:string'], 0, 0, {'name': 'code', 'type': 'xs:string'}, None),
        'name': MemberSpec_('name', ['nameType49', 'nonEmptyString', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'name', 'type': 'xs:string'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, code=None, name=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.code = code
        self.validate_codeOkvedType(self.code)
        self.code_nsprefix_ = None
        self.name = name
        self.validate_nameType49(self.name)
        self.name_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, okved2ProductType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if okved2ProductType.subclass:
            return okved2ProductType.subclass(*args_, **kwargs_)
        else:
            return okved2ProductType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_codeOkvedType(self, value):
        result = True
        # Validate type codeOkvedType, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on codeOkvedType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_codeOkvedType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_codeOkvedType_patterns_, ))
                result = False
        return result
    validate_codeOkvedType_patterns_ = [['^([A-Q]{1,2}|(\\d{2}((\\.\\d{1,2})|(\\.\\d{2}\\.\\d{1,2}))?))$']]
    def validate_nameType49(self, value):
        result = True
        # Validate type nameType49, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 500:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on nameType49' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on nameType49' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.code is not None or
            self.name is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'code':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'code')
            value_ = self.gds_validate_string(value_, node, 'code')
            self.code = value_
            self.code_nsprefix_ = child_.prefix
            # validate type codeOkvedType
            self.validate_codeOkvedType(self.code)
        elif nodeName_ == 'name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'name')
            value_ = self.gds_validate_string(value_, node, 'name')
            self.name = value_
            self.name_nsprefix_ = child_.prefix
            # validate type nameType49
            self.validate_nameType49(self.name)
# end class okved2ProductType


class okpdProductType(GeneratedsSuper):
    """Код товара, работы или услуги по ОКПД"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'code': MemberSpec_('code', ['codeType50', 'nonEmptyString', 'xs:string'], 0, 0, {'name': 'code', 'type': 'xs:string'}, None),
        'name': MemberSpec_('name', ['nameType51', 'nonEmptyString', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'name', 'type': 'xs:string'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, code=None, name=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.code = code
        self.validate_codeType50(self.code)
        self.code_nsprefix_ = None
        self.name = name
        self.validate_nameType51(self.name)
        self.name_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, okpdProductType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if okpdProductType.subclass:
            return okpdProductType.subclass(*args_, **kwargs_)
        else:
            return okpdProductType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_codeType50(self, value):
        result = True
        # Validate type codeType50, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 20:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on codeType50' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on codeType50' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_nameType51(self, value):
        result = True
        # Validate type nameType51, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 500:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on nameType51' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on nameType51' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.code is not None or
            self.name is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'code':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'code')
            value_ = self.gds_validate_string(value_, node, 'code')
            self.code = value_
            self.code_nsprefix_ = child_.prefix
            # validate type codeType50
            self.validate_codeType50(self.code)
        elif nodeName_ == 'name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'name')
            value_ = self.gds_validate_string(value_, node, 'name')
            self.name = value_
            self.name_nsprefix_ = child_.prefix
            # validate type nameType51
            self.validate_nameType51(self.name)
# end class okpdProductType


class okpd2ProductType(GeneratedsSuper):
    """Код товара, работы или услуги по ОКПД2"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'code': MemberSpec_('code', ['codeType52', 'nonEmptyString', 'xs:string'], 0, 0, {'name': 'code', 'type': 'xs:string'}, None),
        'name': MemberSpec_('name', ['nameType53', 'nonEmptyString', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'name', 'type': 'xs:string'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, code=None, name=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.code = code
        self.validate_codeType52(self.code)
        self.code_nsprefix_ = None
        self.name = name
        self.validate_nameType53(self.name)
        self.name_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, okpd2ProductType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if okpd2ProductType.subclass:
            return okpd2ProductType.subclass(*args_, **kwargs_)
        else:
            return okpd2ProductType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_codeType52(self, value):
        result = True
        # Validate type codeType52, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 20:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on codeType52' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on codeType52' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_nameType53(self, value):
        result = True
        # Validate type nameType53, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 500:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on nameType53' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on nameType53' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.code is not None or
            self.name is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'code':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'code')
            value_ = self.gds_validate_string(value_, node, 'code')
            self.code = value_
            self.code_nsprefix_ = child_.prefix
            # validate type codeType52
            self.validate_codeType52(self.code)
        elif nodeName_ == 'name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'name')
            value_ = self.gds_validate_string(value_, node, 'name')
            self.name = value_
            self.name_nsprefix_ = child_.prefix
            # validate type nameType53
            self.validate_nameType53(self.name)
# end class okpd2ProductType


class okdpProductType(GeneratedsSuper):
    """Код товара, работы или услуги по ОКДП"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'code': MemberSpec_('code', ['codeType54', 'nonEmptyString', 'xs:string'], 0, 0, {'name': 'code', 'type': 'xs:string'}, None),
        'name': MemberSpec_('name', ['nameType55', 'nonEmptyString', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'name', 'type': 'xs:string'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, code=None, name=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.code = code
        self.validate_codeType54(self.code)
        self.code_nsprefix_ = None
        self.name = name
        self.validate_nameType55(self.name)
        self.name_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, okdpProductType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if okdpProductType.subclass:
            return okdpProductType.subclass(*args_, **kwargs_)
        else:
            return okdpProductType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_codeType54(self, value):
        result = True
        # Validate type codeType54, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 20:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on codeType54' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on codeType54' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_nameType55(self, value):
        result = True
        # Validate type nameType55, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 500:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on nameType55' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on nameType55' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.code is not None or
            self.name is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'code':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'code')
            value_ = self.gds_validate_string(value_, node, 'code')
            self.code = value_
            self.code_nsprefix_ = child_.prefix
            # validate type codeType54
            self.validate_codeType54(self.code)
        elif nodeName_ == 'name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'name')
            value_ = self.gds_validate_string(value_, node, 'name')
            self.name = value_
            self.name_nsprefix_ = child_.prefix
            # validate type nameType55
            self.validate_nameType55(self.name)
# end class okdpProductType


class eisXmlDoc(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_) + ['extensiontype_']
    subclass = None
    superclass = None
    def __init__(self, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, eisXmlDoc)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if eisXmlDoc.subclass:
            return eisXmlDoc.subclass(*args_, **kwargs_)
        else:
            return eisXmlDoc(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class eisXmlDoc


class packetType(eisXmlDoc):
    """Пакет данных"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'header': MemberSpec_('header', 'headerType', 0, 0, {'name': 'header', 'type': 'headerType'}, None),
        'signature': MemberSpec_('signature', 'xs:base64Binary', 0, 1, {'minOccurs': '0', 'name': 'signature', 'type': 'xs:base64Binary'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_) + ['extensiontype_']
    subclass = None
    superclass = eisXmlDoc
    def __init__(self, header=None, signature=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(packetType, self).__init__(extensiontype_,  **kwargs_)
        self.header = header
        self.header_nsprefix_ = None
        self.signature = signature
        self.signature_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, packetType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if packetType.subclass:
            return packetType.subclass(*args_, **kwargs_)
        else:
            return packetType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.header is not None or
            self.signature is not None or
            super(packetType, self).hasContent_()
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(packetType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'header':
            obj_ = headerType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.header = obj_
            obj_.original_tagname_ = 'header'
        elif nodeName_ == 'signature':
            sval_ = child_.text
            if sval_ is not None:
                try:
                    bval_ = base64.b64decode(sval_)
                except (TypeError, ValueError) as exp:
                    raise_parse_error(child_, 'requires base64 encoded string: %s' % exp)
                bval_ = self.gds_validate_base64(bval_, node, 'signature')
            else:
                bval_ = None
            self.signature = bval_
            self.signature_nsprefix_ = child_.prefix
        super(packetType, self).buildChildren(child_, node, nodeName_, True)
    def get_xml_tag(self):
        return self.gds_elementtree_node_.tag
# end class packetType


class purchaseInfoType(GeneratedsSuper):
    """Информация о закупке"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'guid': MemberSpec_('guid', ['guidType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'guid', 'type': 'xs:string'}, None),
        'purchaseNoticeNumber': MemberSpec_('purchaseNoticeNumber', ['registrationNumber11Type', 'nonEmptyString', 'xs:string'], 0, 0, {'name': 'purchaseNoticeNumber', 'type': 'xs:string'}, None),
        'publicationDateTime': MemberSpec_('publicationDateTime', 'xs:dateTime', 0, 1, {'minOccurs': '0', 'name': 'publicationDateTime', 'type': 'xs:dateTime'}, None),
        'name': MemberSpec_('name', ['nameType56', 'nonEmptyString', 'xs:string'], 0, 0, {'name': 'name', 'type': 'xs:string'}, None),
        'purchaseMethod': MemberSpec_('purchaseMethod', ['purchaseMethodClassType', 'xs:string'], 0, 0, {'name': 'purchaseMethod', 'type': 'xs:string'}, 7),
        'purchaseMethodCode': MemberSpec_('purchaseMethodCode', 'xs:long', 0, 1, {'minOccurs': '0', 'name': 'purchaseMethodCode', 'type': 'xs:long'}, 7),
        'purchaseCodeName': MemberSpec_('purchaseCodeName', ['purchaseCodeNameType', 'nonEmptyString', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'purchaseCodeName', 'type': 'xs:string'}, 7),
        'emergency': MemberSpec_('emergency', 'xs:boolean', 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'emergency', 'type': 'xs:boolean'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_) + ['extensiontype_']
    subclass = None
    superclass = None
    def __init__(self, guid=None, purchaseNoticeNumber=None, publicationDateTime=None, name=None, purchaseMethod=None, purchaseMethodCode=None, purchaseCodeName=None, emergency=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.guid = guid
        self.validate_guidType(self.guid)
        self.guid_nsprefix_ = None
        self.purchaseNoticeNumber = purchaseNoticeNumber
        self.validate_registrationNumber11Type(self.purchaseNoticeNumber)
        self.purchaseNoticeNumber_nsprefix_ = None
        if isinstance(publicationDateTime, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(publicationDateTime, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = publicationDateTime
        self.publicationDateTime = initvalue_
        self.publicationDateTime_nsprefix_ = None
        self.name = name
        self.validate_nameType56(self.name)
        self.name_nsprefix_ = None
        self.purchaseMethod = purchaseMethod
        self.validate_purchaseMethodClassType(self.purchaseMethod)
        self.purchaseMethod_nsprefix_ = None
        self.purchaseMethodCode = purchaseMethodCode
        self.purchaseMethodCode_nsprefix_ = None
        self.purchaseCodeName = purchaseCodeName
        self.validate_purchaseCodeNameType(self.purchaseCodeName)
        self.purchaseCodeName_nsprefix_ = None
        self.emergency = emergency
        self.emergency_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, purchaseInfoType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if purchaseInfoType.subclass:
            return purchaseInfoType.subclass(*args_, **kwargs_)
        else:
            return purchaseInfoType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_guidType(self, value):
        result = True
        # Validate type guidType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) != 36:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd length restriction on guidType' % {"value": encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_guidType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_guidType_patterns_, ))
                result = False
        return result
    validate_guidType_patterns_ = [['^([a-fA-F0-9]{8}\\-[a-fA-F0-9]{4}\\-[a-fA-F0-9]{4}\\-[a-fA-F0-9]{4}\\-[a-fA-F0-9]{12})$']]
    def validate_registrationNumber11Type(self, value):
        result = True
        # Validate type registrationNumber11Type, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on registrationNumber11Type' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_registrationNumber11Type_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_registrationNumber11Type_patterns_, ))
                result = False
        return result
    validate_registrationNumber11Type_patterns_ = [['^(\\d{11})$']]
    def validate_nameType56(self, value):
        result = True
        # Validate type nameType56, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 2000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on nameType56' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on nameType56' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_purchaseMethodClassType(self, value):
        result = True
        # Validate type purchaseMethodClassType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['OK', 'OA', 'AE', 'AE94', 'ZK', 'EP', 'KESMBO', 'AESMBO', 'ZKESMBO', 'ZPESMBO', 'IS', 'TSK', 'TSA', 'TSZK', 'TSZP', 'TSEP']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on purchaseMethodClassType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_purchaseCodeNameType(self, value):
        result = True
        # Validate type purchaseCodeNameType, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 2000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on purchaseCodeNameType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on purchaseCodeNameType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.guid is not None or
            self.purchaseNoticeNumber is not None or
            self.publicationDateTime is not None or
            self.name is not None or
            self.purchaseMethod is not None or
            self.purchaseMethodCode is not None or
            self.purchaseCodeName is not None or
            self.emergency is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'guid':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'guid')
            value_ = self.gds_validate_string(value_, node, 'guid')
            self.guid = value_
            self.guid_nsprefix_ = child_.prefix
            # validate type guidType
            self.validate_guidType(self.guid)
        elif nodeName_ == 'purchaseNoticeNumber':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'purchaseNoticeNumber')
            value_ = self.gds_validate_string(value_, node, 'purchaseNoticeNumber')
            self.purchaseNoticeNumber = value_
            self.purchaseNoticeNumber_nsprefix_ = child_.prefix
            # validate type registrationNumber11Type
            self.validate_registrationNumber11Type(self.purchaseNoticeNumber)
        elif nodeName_ == 'publicationDateTime':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.publicationDateTime = dval_
            self.publicationDateTime_nsprefix_ = child_.prefix
        elif nodeName_ == 'name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'name')
            value_ = self.gds_validate_string(value_, node, 'name')
            self.name = value_
            self.name_nsprefix_ = child_.prefix
            # validate type nameType56
            self.validate_nameType56(self.name)
        elif nodeName_ == 'purchaseMethod':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'purchaseMethod')
            value_ = self.gds_validate_string(value_, node, 'purchaseMethod')
            self.purchaseMethod = value_
            self.purchaseMethod_nsprefix_ = child_.prefix
            # validate type purchaseMethodClassType
            self.validate_purchaseMethodClassType(self.purchaseMethod)
        elif nodeName_ == 'purchaseMethodCode' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'purchaseMethodCode')
            ival_ = self.gds_validate_integer(ival_, node, 'purchaseMethodCode')
            self.purchaseMethodCode = ival_
            self.purchaseMethodCode_nsprefix_ = child_.prefix
        elif nodeName_ == 'purchaseCodeName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'purchaseCodeName')
            value_ = self.gds_validate_string(value_, node, 'purchaseCodeName')
            self.purchaseCodeName = value_
            self.purchaseCodeName_nsprefix_ = child_.prefix
            # validate type purchaseCodeNameType
            self.validate_purchaseCodeNameType(self.purchaseCodeName)
        elif nodeName_ == 'emergency':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'emergency')
            ival_ = self.gds_validate_boolean(ival_, node, 'emergency')
            self.emergency = ival_
            self.emergency_nsprefix_ = child_.prefix
# end class purchaseInfoType


class contractInfoType(GeneratedsSuper):
    """Информация о договоре"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'contractNumber': MemberSpec_('contractNumber', ['registrationNumber11-2Type', 'nonEmptyString', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'contractNumber', 'type': 'xs:string'}, None),
        'contractDate': MemberSpec_('contractDate', 'xs:date', 0, 0, {'name': 'contractDate', 'type': 'xs:date'}, None),
        'name': MemberSpec_('name', ['nameType57', 'nonEmptyString', 'xs:string'], 0, 0, {'name': 'name', 'type': 'xs:string'}, None),
        'currency': MemberSpec_('currency', 'currencyType', 0, 0, {'name': 'currency', 'type': 'currencyType'}, 8),
        'sum': MemberSpec_('sum', ['money2', 'xs:decimal'], 0, 0, {'name': 'sum', 'type': 'xs:decimal'}, 8),
        'sumInfo': MemberSpec_('sumInfo', ['sumInfoType', 'nonEmptyString', 'xs:string'], 0, 0, {'name': 'sumInfo', 'type': 'xs:string'}, 8),
        'fulfillmentDate': MemberSpec_('fulfillmentDate', ['fulfillmentDateType', 'nonEmptyString', 'xs:string'], 0, 0, {'name': 'fulfillmentDate', 'type': 'xs:string'}, None),
        'cancellationReason': MemberSpec_('cancellationReason', ['cancellationReasonType', 'nonEmptyString', 'xs:string'], 0, 0, {'name': 'cancellationReason', 'type': 'xs:string'}, None),
        'cancellationJudgmentDate': MemberSpec_('cancellationJudgmentDate', 'xs:date', 0, 1, {'minOccurs': '0', 'name': 'cancellationJudgmentDate', 'type': 'xs:date'}, None),
        'cancellationDate': MemberSpec_('cancellationDate', 'xs:date', 0, 1, {'minOccurs': '0', 'name': 'cancellationDate', 'type': 'xs:date'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, contractNumber=None, contractDate=None, name=None, currency=None, sum=None, sumInfo=None, fulfillmentDate=None, cancellationReason=None, cancellationJudgmentDate=None, cancellationDate=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.contractNumber = contractNumber
        self.validate_registrationNumber11_2Type(self.contractNumber)
        self.contractNumber_nsprefix_ = None
        if isinstance(contractDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(contractDate, '%Y-%m-%d').date()
        else:
            initvalue_ = contractDate
        self.contractDate = initvalue_
        self.contractDate_nsprefix_ = None
        self.name = name
        self.validate_nameType57(self.name)
        self.name_nsprefix_ = None
        self.currency = currency
        self.currency_nsprefix_ = None
        self.sum = sum
        self.validate_money2(self.sum)
        self.sum_nsprefix_ = None
        self.sumInfo = sumInfo
        self.validate_sumInfoType(self.sumInfo)
        self.sumInfo_nsprefix_ = None
        self.fulfillmentDate = fulfillmentDate
        self.validate_fulfillmentDateType(self.fulfillmentDate)
        self.fulfillmentDate_nsprefix_ = None
        self.cancellationReason = cancellationReason
        self.validate_cancellationReasonType(self.cancellationReason)
        self.cancellationReason_nsprefix_ = None
        if isinstance(cancellationJudgmentDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(cancellationJudgmentDate, '%Y-%m-%d').date()
        else:
            initvalue_ = cancellationJudgmentDate
        self.cancellationJudgmentDate = initvalue_
        self.cancellationJudgmentDate_nsprefix_ = None
        if isinstance(cancellationDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(cancellationDate, '%Y-%m-%d').date()
        else:
            initvalue_ = cancellationDate
        self.cancellationDate = initvalue_
        self.cancellationDate_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, contractInfoType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if contractInfoType.subclass:
            return contractInfoType.subclass(*args_, **kwargs_)
        else:
            return contractInfoType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_registrationNumber11_2Type(self, value):
        result = True
        # Validate type registrationNumber11-2Type, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on registrationNumber11-2Type' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_registrationNumber11_2Type_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_registrationNumber11_2Type_patterns_, ))
                result = False
        return result
    validate_registrationNumber11_2Type_patterns_ = [['^(\\d{11}-\\d{2})$']]
    def validate_nameType57(self, value):
        result = True
        # Validate type nameType57, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 2000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on nameType57' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on nameType57' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_money2(self, value):
        result = True
        # Validate type money2, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, decimal_.Decimal):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (decimal_.Decimal)' % {"value": value, "lineno": lineno, })
                return False
            if len(str(value)) >= 20:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd totalDigits restriction on money2' % {"value": value, "lineno": lineno} )
                result = False
        return result
    def validate_sumInfoType(self, value):
        result = True
        # Validate type sumInfoType, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 2000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on sumInfoType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on sumInfoType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_fulfillmentDateType(self, value):
        result = True
        # Validate type fulfillmentDateType, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 2000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on fulfillmentDateType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on fulfillmentDateType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_cancellationReasonType(self, value):
        result = True
        # Validate type cancellationReasonType, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 2000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on cancellationReasonType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on cancellationReasonType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.contractNumber is not None or
            self.contractDate is not None or
            self.name is not None or
            self.currency is not None or
            self.sum is not None or
            self.sumInfo is not None or
            self.fulfillmentDate is not None or
            self.cancellationReason is not None or
            self.cancellationJudgmentDate is not None or
            self.cancellationDate is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'contractNumber':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'contractNumber')
            value_ = self.gds_validate_string(value_, node, 'contractNumber')
            self.contractNumber = value_
            self.contractNumber_nsprefix_ = child_.prefix
            # validate type registrationNumber11-2Type
            self.validate_registrationNumber11_2Type(self.contractNumber)
        elif nodeName_ == 'contractDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.contractDate = dval_
            self.contractDate_nsprefix_ = child_.prefix
        elif nodeName_ == 'name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'name')
            value_ = self.gds_validate_string(value_, node, 'name')
            self.name = value_
            self.name_nsprefix_ = child_.prefix
            # validate type nameType57
            self.validate_nameType57(self.name)
        elif nodeName_ == 'currency':
            obj_ = currencyType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.currency = obj_
            obj_.original_tagname_ = 'currency'
        elif nodeName_ == 'sum' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'sum')
            fval_ = self.gds_validate_decimal(fval_, node, 'sum')
            self.sum = fval_
            self.sum_nsprefix_ = child_.prefix
            # validate type money2
            self.validate_money2(self.sum)
        elif nodeName_ == 'sumInfo':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'sumInfo')
            value_ = self.gds_validate_string(value_, node, 'sumInfo')
            self.sumInfo = value_
            self.sumInfo_nsprefix_ = child_.prefix
            # validate type sumInfoType
            self.validate_sumInfoType(self.sumInfo)
        elif nodeName_ == 'fulfillmentDate':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'fulfillmentDate')
            value_ = self.gds_validate_string(value_, node, 'fulfillmentDate')
            self.fulfillmentDate = value_
            self.fulfillmentDate_nsprefix_ = child_.prefix
            # validate type fulfillmentDateType
            self.validate_fulfillmentDateType(self.fulfillmentDate)
        elif nodeName_ == 'cancellationReason':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'cancellationReason')
            value_ = self.gds_validate_string(value_, node, 'cancellationReason')
            self.cancellationReason = value_
            self.cancellationReason_nsprefix_ = child_.prefix
            # validate type cancellationReasonType
            self.validate_cancellationReasonType(self.cancellationReason)
        elif nodeName_ == 'cancellationJudgmentDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.cancellationJudgmentDate = dval_
            self.cancellationJudgmentDate_nsprefix_ = child_.prefix
        elif nodeName_ == 'cancellationDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.cancellationDate = dval_
            self.cancellationDate_nsprefix_ = child_.prefix
# end class contractInfoType


class purchaseInfo2Type(purchaseInfoType):
    """Информация о закупке и лоте"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'lotData': MemberSpec_('lotData', 'lotDataType58', 0, 1, {'minOccurs': '0', 'name': 'lotData', 'type': 'lotDataType58'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = purchaseInfoType
    def __init__(self, guid=None, purchaseNoticeNumber=None, publicationDateTime=None, name=None, purchaseMethod=None, purchaseMethodCode=None, purchaseCodeName=None, emergency=None, lotData=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(purchaseInfo2Type, self).__init__(guid, purchaseNoticeNumber, publicationDateTime, name, purchaseMethod, purchaseMethodCode, purchaseCodeName, emergency,  **kwargs_)
        self.lotData = lotData
        self.lotData_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, purchaseInfo2Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if purchaseInfo2Type.subclass:
            return purchaseInfo2Type.subclass(*args_, **kwargs_)
        else:
            return purchaseInfo2Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.lotData is not None or
            super(purchaseInfo2Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(purchaseInfo2Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'lotData':
            obj_ = lotDataType58.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.lotData = obj_
            obj_.original_tagname_ = 'lotData'
        super(purchaseInfo2Type, self).buildChildren(child_, node, nodeName_, True)
# end class purchaseInfo2Type


class violationListType(GeneratedsSuper):
    """Выявленные в процессе обработки нарушения и ошибки"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'violation': MemberSpec_('violation', 'violationType', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'violation', 'type': 'violationType'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, violation=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if violation is None:
            self.violation = []
        else:
            self.violation = violation
        self.violation_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, violationListType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if violationListType.subclass:
            return violationListType.subclass(*args_, **kwargs_)
        else:
            return violationListType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.violation
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'violation':
            obj_ = violationType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.violation.append(obj_)
            obj_.original_tagname_ = 'violation'
# end class violationListType


class violationType(GeneratedsSuper):
    """Выявленные в процессе обработки нарушения и ошибки"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'code': MemberSpec_('code', 'xs:string', 0, 0, {'name': 'code', 'type': 'xs:string'}, None),
        'level': MemberSpec_('level', ['violation.levelType', 'xs:string'], 0, 0, {'name': 'level', 'type': 'xs:string'}, None),
        'name': MemberSpec_('name', 'xs:string', 0, 0, {'name': 'name', 'type': 'xs:string'}, None),
        'description': MemberSpec_('description', 'xs:string', 0, 1, {'minOccurs': '0', 'name': 'description', 'type': 'xs:string'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, code=None, level=None, name=None, description=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.code = code
        self.code_nsprefix_ = None
        self.level = level
        self.validate_violation_levelType(self.level)
        self.level_nsprefix_ = None
        self.name = name
        self.name_nsprefix_ = None
        self.description = description
        self.description_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, violationType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if violationType.subclass:
            return violationType.subclass(*args_, **kwargs_)
        else:
            return violationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_violation_levelType(self, value):
        result = True
        # Validate type violation.levelType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['error', 'warning']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on violation.levelType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.code is not None or
            self.level is not None or
            self.name is not None or
            self.description is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'code':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'code')
            value_ = self.gds_validate_string(value_, node, 'code')
            self.code = value_
            self.code_nsprefix_ = child_.prefix
        elif nodeName_ == 'level':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'level')
            value_ = self.gds_validate_string(value_, node, 'level')
            self.level = value_
            self.level_nsprefix_ = child_.prefix
            # validate type violation.levelType
            self.validate_violation_levelType(self.level)
        elif nodeName_ == 'name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'name')
            value_ = self.gds_validate_string(value_, node, 'name')
            self.name = value_
            self.name_nsprefix_ = child_.prefix
        elif nodeName_ == 'description':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'description')
            value_ = self.gds_validate_string(value_, node, 'description')
            self.description = value_
            self.description_nsprefix_ = child_.prefix
# end class violationType


class userType(GeneratedsSuper):
    """Информация о пользователе"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'snils': MemberSpec_('snils', ['snilsType', 'nonEmptyString', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'snils', 'type': 'xs:string'}, None),
        'login': MemberSpec_('login', ['loginType', 'nonEmptyString', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'login', 'type': 'xs:string'}, None),
        'firstName': MemberSpec_('firstName', ['firstNameType59', 'nonEmptyString', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'firstName', 'type': 'xs:string'}, None),
        'middleName': MemberSpec_('middleName', ['middleNameType60', 'nonEmptyString', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'middleName', 'type': 'xs:string'}, None),
        'lastName': MemberSpec_('lastName', ['lastNameType61', 'nonEmptyString', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'lastName', 'type': 'xs:string'}, None),
        'phone': MemberSpec_('phone', ['phoneType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'phone', 'type': 'xs:string'}, None),
        'email': MemberSpec_('email', ['emailType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'email', 'type': 'xs:string'}, None),
        'organization': MemberSpec_('organization', 'customerInfoType', 0, 1, {'minOccurs': '0', 'name': 'organization', 'type': 'customerInfoType'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, snils=None, login=None, firstName=None, middleName=None, lastName=None, phone=None, email=None, organization=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.snils = snils
        self.validate_snilsType(self.snils)
        self.snils_nsprefix_ = None
        self.login = login
        self.validate_loginType(self.login)
        self.login_nsprefix_ = None
        self.firstName = firstName
        self.validate_firstNameType59(self.firstName)
        self.firstName_nsprefix_ = None
        self.middleName = middleName
        self.validate_middleNameType60(self.middleName)
        self.middleName_nsprefix_ = None
        self.lastName = lastName
        self.validate_lastNameType61(self.lastName)
        self.lastName_nsprefix_ = None
        self.phone = phone
        self.validate_phoneType(self.phone)
        self.phone_nsprefix_ = None
        self.email = email
        self.validate_emailType(self.email)
        self.email_nsprefix_ = None
        self.organization = organization
        self.organization_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, userType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if userType.subclass:
            return userType.subclass(*args_, **kwargs_)
        else:
            return userType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_snilsType(self, value):
        result = True
        # Validate type snilsType, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 11:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on snilsType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on snilsType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_loginType(self, value):
        result = True
        # Validate type loginType, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 255:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on loginType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on loginType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_firstNameType59(self, value):
        result = True
        # Validate type firstNameType59, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 255:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on firstNameType59' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on firstNameType59' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_middleNameType60(self, value):
        result = True
        # Validate type middleNameType60, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 255:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on middleNameType60' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on middleNameType60' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_lastNameType61(self, value):
        result = True
        # Validate type lastNameType61, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 255:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on lastNameType61' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on lastNameType61' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_phoneType(self, value):
        result = True
        # Validate type phoneType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 300:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on phoneType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on phoneType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_emailType(self, value):
        result = True
        # Validate type emailType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 300:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on emailType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on emailType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_emailType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_emailType_patterns_, ))
                result = False
        return result
    validate_emailType_patterns_ = [["^(([\\-a-zA-Zа-яА-Я0-9!#%&'\\*\\+/=\\?\\^_`\\{\\|\\}~]+(\\.[\\-a-zA-Zа-яА-Я0-9!#%&'\\*\\+/=\\?\\^_`\\{\\|\\}~]+)*@([a-zA-Zа-яА-Я0-9]([\\-_a-zA-Zа-яА-Я0-9]{0,61}[a-zA-Zа-яА-Я0-9])?\\.)*[\\-a-zA-Zа-яА-Я0-9]+(\\.[\\-a-zA-Zа-яА-Я0-9]+)*)+(,\\s?[\\-a-zA-Zа-яА-Я0-9!#%&'\\*\\+/=\\?\\^_`\\{\\|\\}~]+(\\.[\\-a-zA-Zа-яА-Я0-9!#%&'\\*\\+/=\\?\\^_`\\{\\|\\}~]+)*@([a-zA-Zа-яА-Я0-9]([\\-_a-zA-Zа-яА-Я0-9]{0,61}[a-zA-Zа-яА-Я0-9])?\\.)*[\\-a-zA-Zа-яА-Я0-9]+(\\.[\\-a-zA-Zа-яА-Я0-9]+)*)*)$"]]
    def hasContent_(self):
        if (
            self.snils is not None or
            self.login is not None or
            self.firstName is not None or
            self.middleName is not None or
            self.lastName is not None or
            self.phone is not None or
            self.email is not None or
            self.organization is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'snils':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'snils')
            value_ = self.gds_validate_string(value_, node, 'snils')
            self.snils = value_
            self.snils_nsprefix_ = child_.prefix
            # validate type snilsType
            self.validate_snilsType(self.snils)
        elif nodeName_ == 'login':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'login')
            value_ = self.gds_validate_string(value_, node, 'login')
            self.login = value_
            self.login_nsprefix_ = child_.prefix
            # validate type loginType
            self.validate_loginType(self.login)
        elif nodeName_ == 'firstName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'firstName')
            value_ = self.gds_validate_string(value_, node, 'firstName')
            self.firstName = value_
            self.firstName_nsprefix_ = child_.prefix
            # validate type firstNameType59
            self.validate_firstNameType59(self.firstName)
        elif nodeName_ == 'middleName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'middleName')
            value_ = self.gds_validate_string(value_, node, 'middleName')
            self.middleName = value_
            self.middleName_nsprefix_ = child_.prefix
            # validate type middleNameType60
            self.validate_middleNameType60(self.middleName)
        elif nodeName_ == 'lastName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'lastName')
            value_ = self.gds_validate_string(value_, node, 'lastName')
            self.lastName = value_
            self.lastName_nsprefix_ = child_.prefix
            # validate type lastNameType61
            self.validate_lastNameType61(self.lastName)
        elif nodeName_ == 'phone':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'phone')
            value_ = self.gds_validate_string(value_, node, 'phone')
            self.phone = value_
            self.phone_nsprefix_ = child_.prefix
            # validate type phoneType
            self.validate_phoneType(self.phone)
        elif nodeName_ == 'email':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'email')
            value_ = self.gds_validate_string(value_, node, 'email')
            self.email = value_
            self.email_nsprefix_ = child_.prefix
            # validate type emailType
            self.validate_emailType(self.email)
        elif nodeName_ == 'organization':
            obj_ = customerInfoType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.organization = obj_
            obj_.original_tagname_ = 'organization'
# end class userType


class countryType(GeneratedsSuper):
    """Страна"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'name': MemberSpec_('name', ['nameType62', 'nonEmptyString', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'name', 'type': 'xs:string'}, None),
        'digitalCode': MemberSpec_('digitalCode', ['digitalCodeType63', 'nonEmptyString', 'xs:string'], 0, 0, {'name': 'digitalCode', 'type': 'xs:string'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, name=None, digitalCode=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.name = name
        self.validate_nameType62(self.name)
        self.name_nsprefix_ = None
        self.digitalCode = digitalCode
        self.validate_digitalCodeType63(self.digitalCode)
        self.digitalCode_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, countryType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if countryType.subclass:
            return countryType.subclass(*args_, **kwargs_)
        else:
            return countryType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_nameType62(self, value):
        result = True
        # Validate type nameType62, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 500:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on nameType62' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on nameType62' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_digitalCodeType63(self, value):
        result = True
        # Validate type digitalCodeType63, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on digitalCodeType63' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_digitalCodeType63_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_digitalCodeType63_patterns_, ))
                result = False
        return result
    validate_digitalCodeType63_patterns_ = [['^(\\d{3})$']]
    def hasContent_(self):
        if (
            self.name is not None or
            self.digitalCode is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'name')
            value_ = self.gds_validate_string(value_, node, 'name')
            self.name = value_
            self.name_nsprefix_ = child_.prefix
            # validate type nameType62
            self.validate_nameType62(self.name)
        elif nodeName_ == 'digitalCode':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'digitalCode')
            value_ = self.gds_validate_string(value_, node, 'digitalCode')
            self.digitalCode = value_
            self.digitalCode_nsprefix_ = child_.prefix
            # validate type digitalCodeType63
            self.validate_digitalCodeType63(self.digitalCode)
# end class countryType


class baseTemplateType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'id': MemberSpec_('id', 'xs:long', 0, 0, {'name': 'id', 'type': 'xs:long'}, None),
        'parent': MemberSpec_('parent', 'xs:long', 0, 0, {'name': 'parent', 'type': 'xs:long'}, None),
        'status': MemberSpec_('status', ['templateStatusType', 'xs:string'], 0, 0, {'name': 'status', 'type': 'xs:string'}, None),
        'version': MemberSpec_('version', ['templateVersionType', 'xs:long'], 0, 0, {'name': 'version', 'type': 'xs:long'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_) + ['extensiontype_']
    subclass = None
    superclass = None
    def __init__(self, id=None, parent=None, status=None, version=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.id = id
        self.id_nsprefix_ = None
        self.parent = parent
        self.parent_nsprefix_ = None
        self.status = status
        self.validate_templateStatusType(self.status)
        self.status_nsprefix_ = None
        self.version = version
        self.validate_templateVersionType(self.version)
        self.version_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, baseTemplateType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if baseTemplateType.subclass:
            return baseTemplateType.subclass(*args_, **kwargs_)
        else:
            return baseTemplateType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_templateStatusType(self, value):
        result = True
        # Validate type templateStatusType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['I', 'P']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on templateStatusType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_templateVersionType(self, value):
        result = True
        # Validate type templateVersionType, a restriction on xs:long.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            if value < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on templateVersionType' % {"value": value, "lineno": lineno} )
                result = False
            if len(str(value)) >= 5:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd totalDigits restriction on templateVersionType' % {"value": value, "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.id is not None or
            self.parent is not None or
            self.status is not None or
            self.version is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'id' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'id')
            ival_ = self.gds_validate_integer(ival_, node, 'id')
            self.id = ival_
            self.id_nsprefix_ = child_.prefix
        elif nodeName_ == 'parent' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'parent')
            ival_ = self.gds_validate_integer(ival_, node, 'parent')
            self.parent = ival_
            self.parent_nsprefix_ = child_.prefix
        elif nodeName_ == 'status':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'status')
            value_ = self.gds_validate_string(value_, node, 'status')
            self.status = value_
            self.status_nsprefix_ = child_.prefix
            # validate type templateStatusType
            self.validate_templateStatusType(self.status)
        elif nodeName_ == 'version' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'version')
            ival_ = self.gds_validate_integer(ival_, node, 'version')
            self.version = ival_
            self.version_nsprefix_ = child_.prefix
            # validate type templateVersionType
            self.validate_templateVersionType(self.version)
# end class baseTemplateType


class protocolTemplateHideBlocks(GeneratedsSuper):
    """Скрываемые группы полей протокола"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'hideCommDecision': MemberSpec_('hideCommDecision', 'xs:boolean', 0, 0, {'name': 'hideCommDecision', 'type': 'xs:boolean'}, None),
        'hideCommDecisionAccess': MemberSpec_('hideCommDecisionAccess', 'xs:boolean', 0, 0, {'name': 'hideCommDecisionAccess', 'type': 'xs:boolean'}, None),
        'hideCommDecisionResult': MemberSpec_('hideCommDecisionResult', 'xs:boolean', 0, 0, {'name': 'hideCommDecisionResult', 'type': 'xs:boolean'}, None),
        'hideProcedure': MemberSpec_('hideProcedure', 'xs:boolean', 0, 0, {'name': 'hideProcedure', 'type': 'xs:boolean'}, None),
        'hideCancellation': MemberSpec_('hideCancellation', 'xs:boolean', 0, 0, {'name': 'hideCancellation', 'type': 'xs:boolean'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, hideCommDecision=None, hideCommDecisionAccess=None, hideCommDecisionResult=None, hideProcedure=None, hideCancellation=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.hideCommDecision = hideCommDecision
        self.hideCommDecision_nsprefix_ = None
        self.hideCommDecisionAccess = hideCommDecisionAccess
        self.hideCommDecisionAccess_nsprefix_ = None
        self.hideCommDecisionResult = hideCommDecisionResult
        self.hideCommDecisionResult_nsprefix_ = None
        self.hideProcedure = hideProcedure
        self.hideProcedure_nsprefix_ = None
        self.hideCancellation = hideCancellation
        self.hideCancellation_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, protocolTemplateHideBlocks)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if protocolTemplateHideBlocks.subclass:
            return protocolTemplateHideBlocks.subclass(*args_, **kwargs_)
        else:
            return protocolTemplateHideBlocks(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.hideCommDecision is not None or
            self.hideCommDecisionAccess is not None or
            self.hideCommDecisionResult is not None or
            self.hideProcedure is not None or
            self.hideCancellation is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'hideCommDecision':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'hideCommDecision')
            ival_ = self.gds_validate_boolean(ival_, node, 'hideCommDecision')
            self.hideCommDecision = ival_
            self.hideCommDecision_nsprefix_ = child_.prefix
        elif nodeName_ == 'hideCommDecisionAccess':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'hideCommDecisionAccess')
            ival_ = self.gds_validate_boolean(ival_, node, 'hideCommDecisionAccess')
            self.hideCommDecisionAccess = ival_
            self.hideCommDecisionAccess_nsprefix_ = child_.prefix
        elif nodeName_ == 'hideCommDecisionResult':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'hideCommDecisionResult')
            ival_ = self.gds_validate_boolean(ival_, node, 'hideCommDecisionResult')
            self.hideCommDecisionResult = ival_
            self.hideCommDecisionResult_nsprefix_ = child_.prefix
        elif nodeName_ == 'hideProcedure':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'hideProcedure')
            ival_ = self.gds_validate_boolean(ival_, node, 'hideProcedure')
            self.hideProcedure = ival_
            self.hideProcedure_nsprefix_ = child_.prefix
        elif nodeName_ == 'hideCancellation':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'hideCancellation')
            ival_ = self.gds_validate_boolean(ival_, node, 'hideCancellation')
            self.hideCancellation = ival_
            self.hideCancellation_nsprefix_ = child_.prefix
# end class protocolTemplateHideBlocks


class protocolTemplateType(baseTemplateType):
    """Шаблон протокола"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'blocks': MemberSpec_('blocks', 'protocolTemplateHideBlocks', 0, 1, {'minOccurs': '0', 'name': 'blocks', 'type': 'protocolTemplateHideBlocks'}, None),
        'fields': MemberSpec_('fields', 'protocolTemplateFieldList', 0, 1, {'minOccurs': '0', 'name': 'fields', 'type': 'protocolTemplateFieldList'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = baseTemplateType
    def __init__(self, id=None, parent=None, status=None, version=None, blocks=None, fields=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(protocolTemplateType, self).__init__(id, parent, status, version,  **kwargs_)
        self.blocks = blocks
        self.blocks_nsprefix_ = None
        self.fields = fields
        self.fields_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, protocolTemplateType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if protocolTemplateType.subclass:
            return protocolTemplateType.subclass(*args_, **kwargs_)
        else:
            return protocolTemplateType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.blocks is not None or
            self.fields is not None or
            super(protocolTemplateType, self).hasContent_()
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(protocolTemplateType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'blocks':
            obj_ = protocolTemplateHideBlocks.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.blocks = obj_
            obj_.original_tagname_ = 'blocks'
        elif nodeName_ == 'fields':
            obj_ = protocolTemplateFieldList.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.fields = obj_
            obj_.original_tagname_ = 'fields'
        super(protocolTemplateType, self).buildChildren(child_, node, nodeName_, True)
# end class protocolTemplateType


class orderClauseTemplateType(baseTemplateType):
    """Шаблон положения о закупках"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'fields': MemberSpec_('fields', 'orderClauseTemplateFieldList', 0, 1, {'minOccurs': '0', 'name': 'fields', 'type': 'orderClauseTemplateFieldList'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = baseTemplateType
    def __init__(self, id=None, parent=None, status=None, version=None, fields=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(orderClauseTemplateType, self).__init__(id, parent, status, version,  **kwargs_)
        self.fields = fields
        self.fields_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, orderClauseTemplateType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if orderClauseTemplateType.subclass:
            return orderClauseTemplateType.subclass(*args_, **kwargs_)
        else:
            return orderClauseTemplateType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.fields is not None or
            super(orderClauseTemplateType, self).hasContent_()
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(orderClauseTemplateType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'fields':
            obj_ = orderClauseTemplateFieldList.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.fields = obj_
            obj_.original_tagname_ = 'fields'
        super(orderClauseTemplateType, self).buildChildren(child_, node, nodeName_, True)
# end class orderClauseTemplateType


class noticeTemplateType(baseTemplateType):
    """Шаблон извещения"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'copyOfType': MemberSpec_('copyOfType', ['templateExtendPurchaseTypes', 'xs:string'], 0, 0, {'name': 'copyOfType', 'type': 'xs:string'}, None),
        'hiddenFields': MemberSpec_('hiddenFields', ['hiddenFieldsType', 'nonEmptyString', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'hiddenFields', 'type': 'xs:string'}, None),
        'fields': MemberSpec_('fields', 'noticeTemplateFieldList', 0, 1, {'minOccurs': '0', 'name': 'fields', 'type': 'noticeTemplateFieldList'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = baseTemplateType
    def __init__(self, id=None, parent=None, status=None, version=None, copyOfType=None, hiddenFields=None, fields=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(noticeTemplateType, self).__init__(id, parent, status, version,  **kwargs_)
        self.copyOfType = copyOfType
        self.validate_templateExtendPurchaseTypes(self.copyOfType)
        self.copyOfType_nsprefix_ = None
        self.hiddenFields = hiddenFields
        self.validate_hiddenFieldsType(self.hiddenFields)
        self.hiddenFields_nsprefix_ = None
        self.fields = fields
        self.fields_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, noticeTemplateType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if noticeTemplateType.subclass:
            return noticeTemplateType.subclass(*args_, **kwargs_)
        else:
            return noticeTemplateType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_templateExtendPurchaseTypes(self, value):
        result = True
        # Validate type templateExtendPurchaseTypes, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['OK', 'OA', 'OE', 'ZK', 'ZE', 'IS', 'ES']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on templateExtendPurchaseTypes' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_hiddenFieldsType(self, value):
        result = True
        # Validate type hiddenFieldsType, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 20:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on hiddenFieldsType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on hiddenFieldsType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.copyOfType is not None or
            self.hiddenFields is not None or
            self.fields is not None or
            super(noticeTemplateType, self).hasContent_()
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(noticeTemplateType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'copyOfType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'copyOfType')
            value_ = self.gds_validate_string(value_, node, 'copyOfType')
            self.copyOfType = value_
            self.copyOfType_nsprefix_ = child_.prefix
            # validate type templateExtendPurchaseTypes
            self.validate_templateExtendPurchaseTypes(self.copyOfType)
        elif nodeName_ == 'hiddenFields':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'hiddenFields')
            value_ = self.gds_validate_string(value_, node, 'hiddenFields')
            self.hiddenFields = value_
            self.hiddenFields_nsprefix_ = child_.prefix
            # validate type hiddenFieldsType
            self.validate_hiddenFieldsType(self.hiddenFields)
        elif nodeName_ == 'fields':
            obj_ = noticeTemplateFieldList.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.fields = obj_
            obj_.original_tagname_ = 'fields'
        super(noticeTemplateType, self).buildChildren(child_, node, nodeName_, True)
# end class noticeTemplateType


class templateTableType(GeneratedsSuper):
    """Табличное представление данных"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'id': MemberSpec_('id', 'xs:long', 0, 0, {'name': 'id', 'type': 'xs:long'}, None),
        'name': MemberSpec_('name', ['nameType64', 'nonEmptyString', 'xs:string'], 0, 0, {'name': 'name', 'type': 'xs:string'}, None),
        'fixedColumnsData': MemberSpec_('fixedColumnsData', 'fixedColumnsDataType', 0, 1, {'minOccurs': '0', 'name': 'fixedColumnsData', 'type': 'fixedColumnsDataType'}, None),
        'columns': MemberSpec_('columns', 'columnsType', 0, 1, {'minOccurs': '0', 'name': 'columns', 'type': 'columnsType'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, id=None, name=None, fixedColumnsData=None, columns=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.id = id
        self.id_nsprefix_ = None
        self.name = name
        self.validate_nameType64(self.name)
        self.name_nsprefix_ = None
        self.fixedColumnsData = fixedColumnsData
        self.fixedColumnsData_nsprefix_ = None
        self.columns = columns
        self.columns_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, templateTableType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if templateTableType.subclass:
            return templateTableType.subclass(*args_, **kwargs_)
        else:
            return templateTableType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_nameType64(self, value):
        result = True
        # Validate type nameType64, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 100:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on nameType64' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on nameType64' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.id is not None or
            self.name is not None or
            self.fixedColumnsData is not None or
            self.columns is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'id' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'id')
            ival_ = self.gds_validate_integer(ival_, node, 'id')
            self.id = ival_
            self.id_nsprefix_ = child_.prefix
        elif nodeName_ == 'name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'name')
            value_ = self.gds_validate_string(value_, node, 'name')
            self.name = value_
            self.name_nsprefix_ = child_.prefix
            # validate type nameType64
            self.validate_nameType64(self.name)
        elif nodeName_ == 'fixedColumnsData':
            obj_ = fixedColumnsDataType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.fixedColumnsData = obj_
            obj_.original_tagname_ = 'fixedColumnsData'
        elif nodeName_ == 'columns':
            obj_ = columnsType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.columns = obj_
            obj_.original_tagname_ = 'columns'
# end class templateTableType


class templateTableColumnType(GeneratedsSuper):
    """Колонка табличного представления данных"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'colIndex': MemberSpec_('colIndex', ['colIndexType', 'xs:int'], 0, 0, {'name': 'colIndex', 'type': 'xs:int'}, None),
        'colName': MemberSpec_('colName', ['colNameType', 'nonEmptyString', 'xs:string'], 0, 0, {'name': 'colName', 'type': 'xs:string'}, None),
        'colType': MemberSpec_('colType', ['extendFieldType', 'xs:string'], 0, 0, {'name': 'colType', 'type': 'xs:string'}, None),
        'colLength': MemberSpec_('colLength', ['colLengthType', 'xs:decimal'], 0, 1, {'minOccurs': '0', 'name': 'colLength', 'type': 'xs:decimal'}, None),
        'colMandatory': MemberSpec_('colMandatory', 'xs:boolean', 0, 0, {'name': 'colMandatory', 'type': 'xs:boolean'}, None),
        'integrCode': MemberSpec_('integrCode', ['integrCodeType', 'xs:string'], 0, 0, {'name': 'integrCode', 'type': 'xs:string'}, None),
        'typeInfo': MemberSpec_('typeInfo', ['typeInfoType', 'nonEmptyString', 'xs:string'], 0, 0, {'name': 'typeInfo', 'type': 'xs:string'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, colIndex=None, colName=None, colType=None, colLength=None, colMandatory=None, integrCode=None, typeInfo=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.colIndex = colIndex
        self.validate_colIndexType(self.colIndex)
        self.colIndex_nsprefix_ = None
        self.colName = colName
        self.validate_colNameType(self.colName)
        self.colName_nsprefix_ = None
        self.colType = colType
        self.validate_extendFieldType(self.colType)
        self.colType_nsprefix_ = None
        self.colLength = colLength
        self.validate_colLengthType(self.colLength)
        self.colLength_nsprefix_ = None
        self.colMandatory = colMandatory
        self.colMandatory_nsprefix_ = None
        self.integrCode = integrCode
        self.validate_integrCodeType(self.integrCode)
        self.integrCode_nsprefix_ = None
        self.typeInfo = typeInfo
        self.validate_typeInfoType(self.typeInfo)
        self.typeInfo_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, templateTableColumnType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if templateTableColumnType.subclass:
            return templateTableColumnType.subclass(*args_, **kwargs_)
        else:
            return templateTableColumnType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_colIndexType(self, value):
        result = True
        # Validate type colIndexType, a restriction on xs:int.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            if value < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on colIndexType' % {"value": value, "lineno": lineno} )
                result = False
            if value > 10:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxInclusive restriction on colIndexType' % {"value": value, "lineno": lineno} )
                result = False
        return result
    def validate_colNameType(self, value):
        result = True
        # Validate type colNameType, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 40:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on colNameType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on colNameType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_extendFieldType(self, value):
        result = True
        # Validate type extendFieldType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['STRING', 'TEXT', 'INTEGER', 'NUMBER', 'BOOLEAN', 'TIME', 'DATETIME', 'DATE', 'LINK', 'FILE', 'REGEXP', 'CURRENCY', 'UNITS', 'OKDP', 'OKPD2', 'OKVED', 'OKVED2', 'TABLE']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on extendFieldType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_colLengthType(self, value):
        result = True
        # Validate type colLengthType, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, decimal_.Decimal):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (decimal_.Decimal)' % {"value": value, "lineno": lineno, })
                return False
            if len(str(value)) >= 20:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd totalDigits restriction on colLengthType' % {"value": value, "lineno": lineno} )
                result = False
        return result
    def validate_integrCodeType(self, value):
        result = True
        # Validate type integrCodeType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 50:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on integrCodeType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on integrCodeType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_integrCodeType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_integrCodeType_patterns_, ))
                result = False
        return result
    validate_integrCodeType_patterns_ = [['^([_a-zA-Z]+)$']]
    def validate_typeInfoType(self, value):
        result = True
        # Validate type typeInfoType, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 400:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on typeInfoType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on typeInfoType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.colIndex is not None or
            self.colName is not None or
            self.colType is not None or
            self.colLength is not None or
            self.colMandatory is not None or
            self.integrCode is not None or
            self.typeInfo is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'colIndex' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'colIndex')
            ival_ = self.gds_validate_integer(ival_, node, 'colIndex')
            self.colIndex = ival_
            self.colIndex_nsprefix_ = child_.prefix
            # validate type colIndexType
            self.validate_colIndexType(self.colIndex)
        elif nodeName_ == 'colName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'colName')
            value_ = self.gds_validate_string(value_, node, 'colName')
            self.colName = value_
            self.colName_nsprefix_ = child_.prefix
            # validate type colNameType
            self.validate_colNameType(self.colName)
        elif nodeName_ == 'colType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'colType')
            value_ = self.gds_validate_string(value_, node, 'colType')
            self.colType = value_
            self.colType_nsprefix_ = child_.prefix
            # validate type extendFieldType
            self.validate_extendFieldType(self.colType)
        elif nodeName_ == 'colLength' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'colLength')
            fval_ = self.gds_validate_decimal(fval_, node, 'colLength')
            self.colLength = fval_
            self.colLength_nsprefix_ = child_.prefix
            # validate type colLengthType
            self.validate_colLengthType(self.colLength)
        elif nodeName_ == 'colMandatory':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'colMandatory')
            ival_ = self.gds_validate_boolean(ival_, node, 'colMandatory')
            self.colMandatory = ival_
            self.colMandatory_nsprefix_ = child_.prefix
        elif nodeName_ == 'integrCode':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'integrCode')
            value_ = self.gds_validate_string(value_, node, 'integrCode')
            self.integrCode = value_
            self.integrCode_nsprefix_ = child_.prefix
            # validate type integrCodeType
            self.validate_integrCodeType(self.integrCode)
        elif nodeName_ == 'typeInfo':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'typeInfo')
            value_ = self.gds_validate_string(value_, node, 'typeInfo')
            self.typeInfo = value_
            self.typeInfo_nsprefix_ = child_.prefix
            # validate type typeInfoType
            self.validate_typeInfoType(self.typeInfo)
# end class templateTableColumnType


class baseTemplateFieldType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'id': MemberSpec_('id', 'xs:long', 0, 0, {'name': 'id', 'type': 'xs:long'}, None),
        'name': MemberSpec_('name', ['nameType65', 'nonEmptyString', 'xs:string'], 0, 0, {'name': 'name', 'type': 'xs:string'}, None),
        'type_': MemberSpec_('type_', ['extendFieldType', 'xs:string'], 0, 0, {'name': 'type', 'type': 'xs:string'}, None),
        'length': MemberSpec_('length', ['lengthType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'length', 'type': 'xs:string'}, None),
        'mandatory': MemberSpec_('mandatory', 'xs:boolean', 0, 0, {'name': 'mandatory', 'type': 'xs:boolean'}, None),
        'position': MemberSpec_('position', 'templateFieldPositionType', 0, 0, {'name': 'position', 'type': 'templateFieldPositionType'}, None),
        'typeInfo': MemberSpec_('typeInfo', ['typeInfoType66', 'nonEmptyString', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'typeInfo', 'type': 'xs:string'}, None),
        'integrCode': MemberSpec_('integrCode', ['integrCodeType', 'xs:string'], 0, 0, {'name': 'integrCode', 'type': 'xs:string'}, None),
        'indexNumber': MemberSpec_('indexNumber', ['indexNumberType', 'xs:int'], 0, 0, {'name': 'indexNumber', 'type': 'xs:int'}, None),
        'code': MemberSpec_('code', ['codeType67', 'nonEmptyString', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'code', 'type': 'xs:string'}, None),
        'tableType': MemberSpec_('tableType', 'tableType', 0, 1, {'minOccurs': '0', 'name': 'tableType', 'type': 'templateTableType'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_) + ['extensiontype_']
    subclass = None
    superclass = None
    def __init__(self, id=None, name=None, type_=None, length=None, mandatory=None, position=None, typeInfo=None, integrCode=None, indexNumber=None, code=None, tableType=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.id = id
        self.id_nsprefix_ = None
        self.name = name
        self.validate_nameType65(self.name)
        self.name_nsprefix_ = None
        self.type_ = type_
        self.validate_extendFieldType(self.type_)
        self.type__nsprefix_ = None
        self.length = length
        self.validate_lengthType(self.length)
        self.length_nsprefix_ = None
        self.mandatory = mandatory
        self.mandatory_nsprefix_ = None
        self.position = position
        self.position_nsprefix_ = None
        self.typeInfo = typeInfo
        self.validate_typeInfoType66(self.typeInfo)
        self.typeInfo_nsprefix_ = None
        self.integrCode = integrCode
        self.validate_integrCodeType(self.integrCode)
        self.integrCode_nsprefix_ = None
        self.indexNumber = indexNumber
        self.validate_indexNumberType(self.indexNumber)
        self.indexNumber_nsprefix_ = None
        self.code = code
        self.validate_codeType67(self.code)
        self.code_nsprefix_ = None
        self.tableType = tableType
        self.tableType_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, baseTemplateFieldType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if baseTemplateFieldType.subclass:
            return baseTemplateFieldType.subclass(*args_, **kwargs_)
        else:
            return baseTemplateFieldType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_nameType65(self, value):
        result = True
        # Validate type nameType65, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 100:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on nameType65' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on nameType65' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_extendFieldType(self, value):
        result = True
        # Validate type extendFieldType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['STRING', 'TEXT', 'INTEGER', 'NUMBER', 'BOOLEAN', 'TIME', 'DATETIME', 'DATE', 'LINK', 'FILE', 'REGEXP', 'CURRENCY', 'UNITS', 'OKDP', 'OKPD2', 'OKVED', 'OKVED2', 'TABLE']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on extendFieldType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_lengthType(self, value):
        result = True
        # Validate type lengthType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 21:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on lengthType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on lengthType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_lengthType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_lengthType_patterns_, ))
                result = False
        return result
    validate_lengthType_patterns_ = [['^(\\d{1,14}[\\.,]{0,1}\\d{0,6})$']]
    def validate_typeInfoType66(self, value):
        result = True
        # Validate type typeInfoType66, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 100:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on typeInfoType66' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on typeInfoType66' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_integrCodeType(self, value):
        result = True
        # Validate type integrCodeType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 50:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on integrCodeType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on integrCodeType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_integrCodeType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_integrCodeType_patterns_, ))
                result = False
        return result
    validate_integrCodeType_patterns_ = [['^([_a-zA-Z]+)$']]
    def validate_indexNumberType(self, value):
        result = True
        # Validate type indexNumberType, a restriction on xs:int.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            if value < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on indexNumberType' % {"value": value, "lineno": lineno} )
                result = False
            if len(str(value)) >= 3:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd totalDigits restriction on indexNumberType' % {"value": value, "lineno": lineno} )
                result = False
        return result
    def validate_codeType67(self, value):
        result = True
        # Validate type codeType67, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 30:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on codeType67' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on codeType67' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.id is not None or
            self.name is not None or
            self.type_ is not None or
            self.length is not None or
            self.mandatory is not None or
            self.position is not None or
            self.typeInfo is not None or
            self.integrCode is not None or
            self.indexNumber is not None or
            self.code is not None or
            self.tableType is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'id' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'id')
            ival_ = self.gds_validate_integer(ival_, node, 'id')
            self.id = ival_
            self.id_nsprefix_ = child_.prefix
        elif nodeName_ == 'name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'name')
            value_ = self.gds_validate_string(value_, node, 'name')
            self.name = value_
            self.name_nsprefix_ = child_.prefix
            # validate type nameType65
            self.validate_nameType65(self.name)
        elif nodeName_ == 'type':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'type')
            value_ = self.gds_validate_string(value_, node, 'type')
            self.type_ = value_
            self.type_nsprefix_ = child_.prefix
            # validate type extendFieldType
            self.validate_extendFieldType(self.type_)
        elif nodeName_ == 'length':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'length')
            value_ = self.gds_validate_string(value_, node, 'length')
            self.length = value_
            self.length_nsprefix_ = child_.prefix
            # validate type lengthType
            self.validate_lengthType(self.length)
        elif nodeName_ == 'mandatory':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'mandatory')
            ival_ = self.gds_validate_boolean(ival_, node, 'mandatory')
            self.mandatory = ival_
            self.mandatory_nsprefix_ = child_.prefix
        elif nodeName_ == 'position':
            obj_ = templateFieldPositionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.position = obj_
            obj_.original_tagname_ = 'position'
        elif nodeName_ == 'typeInfo':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'typeInfo')
            value_ = self.gds_validate_string(value_, node, 'typeInfo')
            self.typeInfo = value_
            self.typeInfo_nsprefix_ = child_.prefix
            # validate type typeInfoType66
            self.validate_typeInfoType66(self.typeInfo)
        elif nodeName_ == 'integrCode':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'integrCode')
            value_ = self.gds_validate_string(value_, node, 'integrCode')
            self.integrCode = value_
            self.integrCode_nsprefix_ = child_.prefix
            # validate type integrCodeType
            self.validate_integrCodeType(self.integrCode)
        elif nodeName_ == 'indexNumber' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'indexNumber')
            ival_ = self.gds_validate_integer(ival_, node, 'indexNumber')
            self.indexNumber = ival_
            self.indexNumber_nsprefix_ = child_.prefix
            # validate type indexNumberType
            self.validate_indexNumberType(self.indexNumber)
        elif nodeName_ == 'code':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'code')
            value_ = self.gds_validate_string(value_, node, 'code')
            self.code = value_
            self.code_nsprefix_ = child_.prefix
            # validate type codeType67
            self.validate_codeType67(self.code)
        elif nodeName_ == 'tableType':
            obj_ = templateTableType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.tableType = obj_
            obj_.original_tagname_ = 'tableType'
# end class baseTemplateFieldType


class templateFieldPositionType(GeneratedsSuper):
    """Расположение поля"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'tabOrdinal': MemberSpec_('tabOrdinal', 'xs:long', 0, 0, {'name': 'tabOrdinal', 'type': 'xs:long'}, None),
        'tabName': MemberSpec_('tabName', ['tabNameType', 'nonEmptyString', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'tabName', 'type': 'xs:string'}, None),
        'sectionOrdinal': MemberSpec_('sectionOrdinal', 'xs:long', 0, 0, {'name': 'sectionOrdinal', 'type': 'xs:long'}, None),
        'sectionName': MemberSpec_('sectionName', ['sectionNameType', 'nonEmptyString', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'sectionName', 'type': 'xs:string'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, tabOrdinal=None, tabName=None, sectionOrdinal=None, sectionName=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.tabOrdinal = tabOrdinal
        self.tabOrdinal_nsprefix_ = None
        self.tabName = tabName
        self.validate_tabNameType(self.tabName)
        self.tabName_nsprefix_ = None
        self.sectionOrdinal = sectionOrdinal
        self.sectionOrdinal_nsprefix_ = None
        self.sectionName = sectionName
        self.validate_sectionNameType(self.sectionName)
        self.sectionName_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, templateFieldPositionType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if templateFieldPositionType.subclass:
            return templateFieldPositionType.subclass(*args_, **kwargs_)
        else:
            return templateFieldPositionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_tabNameType(self, value):
        result = True
        # Validate type tabNameType, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 130:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on tabNameType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on tabNameType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_sectionNameType(self, value):
        result = True
        # Validate type sectionNameType, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 130:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on sectionNameType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on sectionNameType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.tabOrdinal is not None or
            self.tabName is not None or
            self.sectionOrdinal is not None or
            self.sectionName is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'tabOrdinal' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'tabOrdinal')
            ival_ = self.gds_validate_integer(ival_, node, 'tabOrdinal')
            self.tabOrdinal = ival_
            self.tabOrdinal_nsprefix_ = child_.prefix
        elif nodeName_ == 'tabName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'tabName')
            value_ = self.gds_validate_string(value_, node, 'tabName')
            self.tabName = value_
            self.tabName_nsprefix_ = child_.prefix
            # validate type tabNameType
            self.validate_tabNameType(self.tabName)
        elif nodeName_ == 'sectionOrdinal' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'sectionOrdinal')
            ival_ = self.gds_validate_integer(ival_, node, 'sectionOrdinal')
            self.sectionOrdinal = ival_
            self.sectionOrdinal_nsprefix_ = child_.prefix
        elif nodeName_ == 'sectionName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'sectionName')
            value_ = self.gds_validate_string(value_, node, 'sectionName')
            self.sectionName = value_
            self.sectionName_nsprefix_ = child_.prefix
            # validate type sectionNameType
            self.validate_sectionNameType(self.sectionName)
# end class templateFieldPositionType


class orderClauseTemplateFieldType(baseTemplateFieldType):
    """Поле шаблона положения о закупках"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = baseTemplateFieldType
    def __init__(self, id=None, name=None, type_=None, length=None, mandatory=None, position=None, typeInfo=None, integrCode=None, indexNumber=None, code=None, tableType=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(orderClauseTemplateFieldType, self).__init__(id, name, type_, length, mandatory, position, typeInfo, integrCode, indexNumber, code, tableType,  **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, orderClauseTemplateFieldType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if orderClauseTemplateFieldType.subclass:
            return orderClauseTemplateFieldType.subclass(*args_, **kwargs_)
        else:
            return orderClauseTemplateFieldType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(orderClauseTemplateFieldType, self).hasContent_()
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(orderClauseTemplateFieldType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(orderClauseTemplateFieldType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class orderClauseTemplateFieldType


class noticeTemplateFieldType(baseTemplateFieldType):
    """Поле шаблона извещения"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'tabLevel': MemberSpec_('tabLevel', ['noticeTemplateFieldLevelType', 'xs:string'], 0, 0, {'name': 'tabLevel', 'type': 'xs:string'}, None),
        'isBaseField': MemberSpec_('isBaseField', 'xs:boolean', 0, 0, {'name': 'isBaseField', 'type': 'xs:boolean'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = baseTemplateFieldType
    def __init__(self, id=None, name=None, type_=None, length=None, mandatory=None, position=None, typeInfo=None, integrCode=None, indexNumber=None, code=None, tableType=None, tabLevel=None, isBaseField=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(noticeTemplateFieldType, self).__init__(id, name, type_, length, mandatory, position, typeInfo, integrCode, indexNumber, code, tableType,  **kwargs_)
        self.tabLevel = tabLevel
        self.validate_noticeTemplateFieldLevelType(self.tabLevel)
        self.tabLevel_nsprefix_ = None
        self.isBaseField = isBaseField
        self.isBaseField_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, noticeTemplateFieldType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if noticeTemplateFieldType.subclass:
            return noticeTemplateFieldType.subclass(*args_, **kwargs_)
        else:
            return noticeTemplateFieldType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_noticeTemplateFieldLevelType(self, value):
        result = True
        # Validate type noticeTemplateFieldLevelType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['NOTICE', 'LOT', 'LOT_CUSTOMER']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on noticeTemplateFieldLevelType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.tabLevel is not None or
            self.isBaseField is not None or
            super(noticeTemplateFieldType, self).hasContent_()
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(noticeTemplateFieldType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'tabLevel':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'tabLevel')
            value_ = self.gds_validate_string(value_, node, 'tabLevel')
            self.tabLevel = value_
            self.tabLevel_nsprefix_ = child_.prefix
            # validate type noticeTemplateFieldLevelType
            self.validate_noticeTemplateFieldLevelType(self.tabLevel)
        elif nodeName_ == 'isBaseField':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'isBaseField')
            ival_ = self.gds_validate_boolean(ival_, node, 'isBaseField')
            self.isBaseField = ival_
            self.isBaseField_nsprefix_ = child_.prefix
        super(noticeTemplateFieldType, self).buildChildren(child_, node, nodeName_, True)
# end class noticeTemplateFieldType


class protocolTemplateFieldType(baseTemplateFieldType):
    """Поле шаблона протокола"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'tabLevel': MemberSpec_('tabLevel', ['protocolTemplateFieldLevelType', 'xs:string'], 0, 0, {'name': 'tabLevel', 'type': 'xs:string'}, None),
        'isBaseField': MemberSpec_('isBaseField', 'xs:boolean', 0, 0, {'name': 'isBaseField', 'type': 'xs:boolean'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = baseTemplateFieldType
    def __init__(self, id=None, name=None, type_=None, length=None, mandatory=None, position=None, typeInfo=None, integrCode=None, indexNumber=None, code=None, tableType=None, tabLevel=None, isBaseField=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(protocolTemplateFieldType, self).__init__(id, name, type_, length, mandatory, position, typeInfo, integrCode, indexNumber, code, tableType,  **kwargs_)
        self.tabLevel = tabLevel
        self.validate_protocolTemplateFieldLevelType(self.tabLevel)
        self.tabLevel_nsprefix_ = None
        self.isBaseField = isBaseField
        self.isBaseField_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, protocolTemplateFieldType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if protocolTemplateFieldType.subclass:
            return protocolTemplateFieldType.subclass(*args_, **kwargs_)
        else:
            return protocolTemplateFieldType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_protocolTemplateFieldLevelType(self, value):
        result = True
        # Validate type protocolTemplateFieldLevelType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['PROTOCOL', 'APPLICATION']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on protocolTemplateFieldLevelType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.tabLevel is not None or
            self.isBaseField is not None or
            super(protocolTemplateFieldType, self).hasContent_()
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(protocolTemplateFieldType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'tabLevel':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'tabLevel')
            value_ = self.gds_validate_string(value_, node, 'tabLevel')
            self.tabLevel = value_
            self.tabLevel_nsprefix_ = child_.prefix
            # validate type protocolTemplateFieldLevelType
            self.validate_protocolTemplateFieldLevelType(self.tabLevel)
        elif nodeName_ == 'isBaseField':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'isBaseField')
            ival_ = self.gds_validate_boolean(ival_, node, 'isBaseField')
            self.isBaseField = ival_
            self.isBaseField_nsprefix_ = child_.prefix
        super(protocolTemplateFieldType, self).buildChildren(child_, node, nodeName_, True)
# end class protocolTemplateFieldType


class orderClauseTemplateFieldList(GeneratedsSuper):
    """Поля шаблона положения о закупках"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'field': MemberSpec_('field', 'orderClauseTemplateFieldType', 1, 0, {'maxOccurs': 'unbounded', 'minOccurs': '1', 'name': 'field', 'type': 'orderClauseTemplateFieldType'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, field=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if field is None:
            self.field = []
        else:
            self.field = field
        self.field_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, orderClauseTemplateFieldList)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if orderClauseTemplateFieldList.subclass:
            return orderClauseTemplateFieldList.subclass(*args_, **kwargs_)
        else:
            return orderClauseTemplateFieldList(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.field
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'field':
            obj_ = orderClauseTemplateFieldType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.field.append(obj_)
            obj_.original_tagname_ = 'field'
# end class orderClauseTemplateFieldList


class noticeTemplateFieldList(GeneratedsSuper):
    """Поля шаблона извещения"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'field': MemberSpec_('field', 'noticeTemplateFieldType', 1, 0, {'maxOccurs': 'unbounded', 'minOccurs': '1', 'name': 'field', 'type': 'noticeTemplateFieldType'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, field=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if field is None:
            self.field = []
        else:
            self.field = field
        self.field_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, noticeTemplateFieldList)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if noticeTemplateFieldList.subclass:
            return noticeTemplateFieldList.subclass(*args_, **kwargs_)
        else:
            return noticeTemplateFieldList(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.field
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'field':
            obj_ = noticeTemplateFieldType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.field.append(obj_)
            obj_.original_tagname_ = 'field'
# end class noticeTemplateFieldList


class protocolTemplateFieldList(GeneratedsSuper):
    """Поля шаблона протокола"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'field': MemberSpec_('field', 'protocolTemplateFieldType', 1, 0, {'maxOccurs': 'unbounded', 'minOccurs': '1', 'name': 'field', 'type': 'protocolTemplateFieldType'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, field=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if field is None:
            self.field = []
        else:
            self.field = field
        self.field_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, protocolTemplateFieldList)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if protocolTemplateFieldList.subclass:
            return protocolTemplateFieldList.subclass(*args_, **kwargs_)
        else:
            return protocolTemplateFieldList(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.field
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'field':
            obj_ = protocolTemplateFieldType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.field.append(obj_)
            obj_.original_tagname_ = 'field'
# end class protocolTemplateFieldList


class noticeExtendFieldValueListType(GeneratedsSuper):
    """Значения дополнительных полей шаблона извещения"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'noticeExtendField': MemberSpec_('noticeExtendField', 'noticeExtendBlockFieldType', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'noticeExtendField', 'type': 'noticeExtendBlockFieldType'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, noticeExtendField=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if noticeExtendField is None:
            self.noticeExtendField = []
        else:
            self.noticeExtendField = noticeExtendField
        self.noticeExtendField_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, noticeExtendFieldValueListType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if noticeExtendFieldValueListType.subclass:
            return noticeExtendFieldValueListType.subclass(*args_, **kwargs_)
        else:
            return noticeExtendFieldValueListType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.noticeExtendField
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'noticeExtendField':
            obj_ = noticeExtendBlockFieldType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.noticeExtendField.append(obj_)
            obj_.original_tagname_ = 'noticeExtendField'
# end class noticeExtendFieldValueListType


class protocolExtendFieldValueListType(GeneratedsSuper):
    """Значения дополнительных полей шаблона протокола"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'protocolExtendField': MemberSpec_('protocolExtendField', 'protocolExtendBlockFieldType', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'protocolExtendField', 'type': 'protocolExtendBlockFieldType'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, protocolExtendField=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if protocolExtendField is None:
            self.protocolExtendField = []
        else:
            self.protocolExtendField = protocolExtendField
        self.protocolExtendField_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, protocolExtendFieldValueListType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if protocolExtendFieldValueListType.subclass:
            return protocolExtendFieldValueListType.subclass(*args_, **kwargs_)
        else:
            return protocolExtendFieldValueListType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.protocolExtendField
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'protocolExtendField':
            obj_ = protocolExtendBlockFieldType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.protocolExtendField.append(obj_)
            obj_.original_tagname_ = 'protocolExtendField'
# end class protocolExtendFieldValueListType


class orderClauseExtendFieldValueListType(GeneratedsSuper):
    """Значения дополнительных полей положения о закупках"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'orderClauseExtendField': MemberSpec_('orderClauseExtendField', 'orderClauseExtendBlockFieldType', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'orderClauseExtendField', 'type': 'orderClauseExtendBlockFieldType'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, orderClauseExtendField=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if orderClauseExtendField is None:
            self.orderClauseExtendField = []
        else:
            self.orderClauseExtendField = orderClauseExtendField
        self.orderClauseExtendField_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, orderClauseExtendFieldValueListType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if orderClauseExtendFieldValueListType.subclass:
            return orderClauseExtendFieldValueListType.subclass(*args_, **kwargs_)
        else:
            return orderClauseExtendFieldValueListType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.orderClauseExtendField
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'orderClauseExtendField':
            obj_ = orderClauseExtendBlockFieldType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.orderClauseExtendField.append(obj_)
            obj_.original_tagname_ = 'orderClauseExtendField'
# end class orderClauseExtendFieldValueListType


class baseExtendFieldType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'integrCode': MemberSpec_('integrCode', ['integrCodeType', 'xs:string'], 0, 0, {'name': 'integrCode', 'type': 'xs:string'}, None),
        'description': MemberSpec_('description', ['descriptionType68', 'nonEmptyString', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'description', 'type': 'xs:string'}, None),
        'type_': MemberSpec_('type_', ['extendFieldType', 'xs:string'], 0, 0, {'name': 'type', 'type': 'xs:string'}, None),
        'value': MemberSpec_('value', 'fieldValueType', 0, 0, {'name': 'value', 'type': 'fieldValueType'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, integrCode=None, description=None, type_=None, value=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.integrCode = integrCode
        self.validate_integrCodeType(self.integrCode)
        self.integrCode_nsprefix_ = None
        self.description = description
        self.validate_descriptionType68(self.description)
        self.description_nsprefix_ = None
        self.type_ = type_
        self.validate_extendFieldType(self.type_)
        self.type__nsprefix_ = None
        self.value = value
        self.value_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, baseExtendFieldType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if baseExtendFieldType.subclass:
            return baseExtendFieldType.subclass(*args_, **kwargs_)
        else:
            return baseExtendFieldType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_integrCodeType(self, value):
        result = True
        # Validate type integrCodeType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 50:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on integrCodeType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on integrCodeType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_integrCodeType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_integrCodeType_patterns_, ))
                result = False
        return result
    validate_integrCodeType_patterns_ = [['^([_a-zA-Z]+)$']]
    def validate_descriptionType68(self, value):
        result = True
        # Validate type descriptionType68, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 200:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on descriptionType68' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on descriptionType68' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_extendFieldType(self, value):
        result = True
        # Validate type extendFieldType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['STRING', 'TEXT', 'INTEGER', 'NUMBER', 'BOOLEAN', 'TIME', 'DATETIME', 'DATE', 'LINK', 'FILE', 'REGEXP', 'CURRENCY', 'UNITS', 'OKDP', 'OKPD2', 'OKVED', 'OKVED2', 'TABLE']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on extendFieldType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.integrCode is not None or
            self.description is not None or
            self.type_ is not None or
            self.value is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'integrCode':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'integrCode')
            value_ = self.gds_validate_string(value_, node, 'integrCode')
            self.integrCode = value_
            self.integrCode_nsprefix_ = child_.prefix
            # validate type integrCodeType
            self.validate_integrCodeType(self.integrCode)
        elif nodeName_ == 'description':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'description')
            value_ = self.gds_validate_string(value_, node, 'description')
            self.description = value_
            self.description_nsprefix_ = child_.prefix
            # validate type descriptionType68
            self.validate_descriptionType68(self.description)
        elif nodeName_ == 'type':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'type')
            value_ = self.gds_validate_string(value_, node, 'type')
            self.type_ = value_
            self.type_nsprefix_ = child_.prefix
            # validate type extendFieldType
            self.validate_extendFieldType(self.type_)
        elif nodeName_ == 'value':
            obj_ = fieldValueType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.value = obj_
            obj_.original_tagname_ = 'value'
# end class baseExtendFieldType


class baseExtendBlockFieldType(GeneratedsSuper):
    """Значения дополнительных полей извещения/протокола"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'extendField': MemberSpec_('extendField', 'baseExtendFieldType', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'extendField', 'type': 'baseExtendFieldType'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_) + ['extensiontype_']
    subclass = None
    superclass = None
    def __init__(self, extendField=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if extendField is None:
            self.extendField = []
        else:
            self.extendField = extendField
        self.extendField_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, baseExtendBlockFieldType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if baseExtendBlockFieldType.subclass:
            return baseExtendBlockFieldType.subclass(*args_, **kwargs_)
        else:
            return baseExtendBlockFieldType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.extendField
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'extendField':
            obj_ = baseExtendFieldType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.extendField.append(obj_)
            obj_.original_tagname_ = 'extendField'
# end class baseExtendBlockFieldType


class noticeExtendBlockFieldType(baseExtendBlockFieldType):
    """Дополнительные поля шаблона извещения"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'position': MemberSpec_('position', 'templateFieldPositionType', 0, 0, {'name': 'position', 'type': 'templateFieldPositionType'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = baseExtendBlockFieldType
    def __init__(self, extendField=None, position=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(noticeExtendBlockFieldType, self).__init__(extendField,  **kwargs_)
        self.position = position
        self.position_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, noticeExtendBlockFieldType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if noticeExtendBlockFieldType.subclass:
            return noticeExtendBlockFieldType.subclass(*args_, **kwargs_)
        else:
            return noticeExtendBlockFieldType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.position is not None or
            super(noticeExtendBlockFieldType, self).hasContent_()
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(noticeExtendBlockFieldType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'position':
            obj_ = templateFieldPositionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.position = obj_
            obj_.original_tagname_ = 'position'
        super(noticeExtendBlockFieldType, self).buildChildren(child_, node, nodeName_, True)
# end class noticeExtendBlockFieldType


class protocolExtendBlockFieldType(baseExtendBlockFieldType):
    """Дополнительные поля шаблона протокола"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'position': MemberSpec_('position', 'templateFieldPositionType', 0, 0, {'name': 'position', 'type': 'templateFieldPositionType'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = baseExtendBlockFieldType
    def __init__(self, extendField=None, position=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(protocolExtendBlockFieldType, self).__init__(extendField,  **kwargs_)
        self.position = position
        self.position_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, protocolExtendBlockFieldType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if protocolExtendBlockFieldType.subclass:
            return protocolExtendBlockFieldType.subclass(*args_, **kwargs_)
        else:
            return protocolExtendBlockFieldType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.position is not None or
            super(protocolExtendBlockFieldType, self).hasContent_()
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(protocolExtendBlockFieldType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'position':
            obj_ = templateFieldPositionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.position = obj_
            obj_.original_tagname_ = 'position'
        super(protocolExtendBlockFieldType, self).buildChildren(child_, node, nodeName_, True)
# end class protocolExtendBlockFieldType


class orderClauseExtendBlockFieldType(baseExtendBlockFieldType):
    """Дополнительные поля шаблона положения о закупках"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'position': MemberSpec_('position', 'templateFieldPositionType', 0, 0, {'name': 'position', 'type': 'templateFieldPositionType'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = baseExtendBlockFieldType
    def __init__(self, extendField=None, position=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(orderClauseExtendBlockFieldType, self).__init__(extendField,  **kwargs_)
        self.position = position
        self.position_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, orderClauseExtendBlockFieldType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if orderClauseExtendBlockFieldType.subclass:
            return orderClauseExtendBlockFieldType.subclass(*args_, **kwargs_)
        else:
            return orderClauseExtendBlockFieldType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.position is not None or
            super(orderClauseExtendBlockFieldType, self).hasContent_()
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(orderClauseExtendBlockFieldType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'position':
            obj_ = templateFieldPositionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.position = obj_
            obj_.original_tagname_ = 'position'
        super(orderClauseExtendBlockFieldType, self).buildChildren(child_, node, nodeName_, True)
# end class orderClauseExtendBlockFieldType


class fieldValueType(GeneratedsSuper):
    """Значение поля данных"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'string': MemberSpec_('string', ['stringType', 'nonEmptyString', 'xs:string'], 0, 0, {'name': 'string', 'type': 'xs:string'}, 9),
        'text': MemberSpec_('text', ['textType', 'nonEmptyString', 'xs:string'], 0, 0, {'name': 'text', 'type': 'xs:string'}, 9),
        'integer': MemberSpec_('integer', 'xs:int', 0, 0, {'name': 'integer', 'type': 'xs:int'}, 9),
        'number': MemberSpec_('number', 'xs:decimal', 0, 0, {'name': 'number', 'type': 'xs:decimal'}, 9),
        'boolean': MemberSpec_('boolean', 'xs:boolean', 0, 0, {'name': 'boolean', 'type': 'xs:boolean'}, 9),
        'time': MemberSpec_('time', 'xs:time', 0, 0, {'name': 'time', 'type': 'xs:time'}, 9),
        'dateTime': MemberSpec_('dateTime', 'xs:dateTime', 0, 0, {'name': 'dateTime', 'type': 'xs:dateTime'}, 9),
        'date': MemberSpec_('date', 'xs:date', 0, 0, {'name': 'date', 'type': 'xs:date'}, 9),
        'url': MemberSpec_('url', ['urlType69', 'nonEmptyString', 'xs:string'], 0, 0, {'name': 'url', 'type': 'xs:string'}, 9),
        'attachments': MemberSpec_('attachments', 'documentListType', 0, 0, {'name': 'attachments', 'type': 'documentListType'}, 9),
        'nsi': MemberSpec_('nsi', 'nsiType', 0, 0, {'name': 'nsi', 'type': 'nsiType'}, 9),
        'table': MemberSpec_('table', 'tableType', 0, 0, {'name': 'table', 'type': 'tableType'}, 9),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, string=None, text=None, integer=None, number=None, boolean=None, time=None, dateTime=None, date=None, url=None, attachments=None, nsi=None, table=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.string = string
        self.validate_stringType(self.string)
        self.string_nsprefix_ = None
        self.text = text
        self.validate_textType(self.text)
        self.text_nsprefix_ = None
        self.integer = integer
        self.integer_nsprefix_ = None
        self.number = number
        self.number_nsprefix_ = None
        self.boolean = boolean
        self.boolean_nsprefix_ = None
        if isinstance(time, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(time, '%H:%M:%S').time()
        else:
            initvalue_ = time
        self.time = initvalue_
        self.time_nsprefix_ = None
        if isinstance(dateTime, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(dateTime, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = dateTime
        self.dateTime = initvalue_
        self.dateTime_nsprefix_ = None
        if isinstance(date, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(date, '%Y-%m-%d').date()
        else:
            initvalue_ = date
        self.date = initvalue_
        self.date_nsprefix_ = None
        self.url = url
        self.validate_urlType69(self.url)
        self.url_nsprefix_ = None
        self.attachments = attachments
        self.attachments_nsprefix_ = None
        self.nsi = nsi
        self.nsi_nsprefix_ = None
        self.table = table
        self.table_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, fieldValueType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if fieldValueType.subclass:
            return fieldValueType.subclass(*args_, **kwargs_)
        else:
            return fieldValueType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_stringType(self, value):
        result = True
        # Validate type stringType, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on stringType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on stringType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_textType(self, value):
        result = True
        # Validate type textType, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 2000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on textType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on textType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_urlType69(self, value):
        result = True
        # Validate type urlType69, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on urlType69' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on urlType69' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.string is not None or
            self.text is not None or
            self.integer is not None or
            self.number is not None or
            self.boolean is not None or
            self.time is not None or
            self.dateTime is not None or
            self.date is not None or
            self.url is not None or
            self.attachments is not None or
            self.nsi is not None or
            self.table is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'string':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'string')
            value_ = self.gds_validate_string(value_, node, 'string')
            self.string = value_
            self.string_nsprefix_ = child_.prefix
            # validate type stringType
            self.validate_stringType(self.string)
        elif nodeName_ == 'text':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'text')
            value_ = self.gds_validate_string(value_, node, 'text')
            self.text = value_
            self.text_nsprefix_ = child_.prefix
            # validate type textType
            self.validate_textType(self.text)
        elif nodeName_ == 'integer' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'integer')
            ival_ = self.gds_validate_integer(ival_, node, 'integer')
            self.integer = ival_
            self.integer_nsprefix_ = child_.prefix
        elif nodeName_ == 'number' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'number')
            fval_ = self.gds_validate_decimal(fval_, node, 'number')
            self.number = fval_
            self.number_nsprefix_ = child_.prefix
        elif nodeName_ == 'boolean':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'boolean')
            self.boolean = ival_
            self.boolean_nsprefix_ = child_.prefix
        elif nodeName_ == 'time':
            sval_ = child_.text
            dval_ = self.gds_parse_time(sval_)
            self.time = dval_
            self.time_nsprefix_ = child_.prefix
        elif nodeName_ == 'dateTime':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.dateTime = dval_
            self.dateTime_nsprefix_ = child_.prefix
        elif nodeName_ == 'date':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.date = dval_
            self.date_nsprefix_ = child_.prefix
        elif nodeName_ == 'url':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'url')
            value_ = self.gds_validate_string(value_, node, 'url')
            self.url = value_
            self.url_nsprefix_ = child_.prefix
            # validate type urlType69
            self.validate_urlType69(self.url)
        elif nodeName_ == 'attachments':
            obj_ = documentListType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.attachments = obj_
            obj_.original_tagname_ = 'attachments'
        elif nodeName_ == 'nsi':
            obj_ = nsiType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.nsi = obj_
            obj_.original_tagname_ = 'nsi'
        elif nodeName_ == 'table':
            obj_ = tableType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.table = obj_
            obj_.original_tagname_ = 'table'
# end class fieldValueType


class extendTableRowType(GeneratedsSuper):
    """Строка табличного представления"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'column': MemberSpec_('column', 'extendTableColumnType', 1, 0, {'maxOccurs': '10', 'minOccurs': '1', 'name': 'column', 'type': 'extendTableColumnType'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, column=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if column is None:
            self.column = []
        else:
            self.column = column
        self.column_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, extendTableRowType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if extendTableRowType.subclass:
            return extendTableRowType.subclass(*args_, **kwargs_)
        else:
            return extendTableRowType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.column
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'column':
            obj_ = extendTableColumnType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.column.append(obj_)
            obj_.original_tagname_ = 'column'
# end class extendTableRowType


class extendTableColumnType(GeneratedsSuper):
    """Столбец табличного представления"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'colIndex': MemberSpec_('colIndex', ['colIndexType70', 'xs:int'], 0, 0, {'name': 'colIndex', 'type': 'xs:int'}, None),
        'colType': MemberSpec_('colType', ['extendFieldType', 'xs:string'], 0, 0, {'name': 'colType', 'type': 'xs:string'}, None),
        'integrCode': MemberSpec_('integrCode', ['integrCodeType', 'xs:string'], 0, 0, {'name': 'integrCode', 'type': 'xs:string'}, None),
        'value': MemberSpec_('value', 'tableColumnValueType', 0, 0, {'name': 'value', 'type': 'tableColumnValueType'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, colIndex=None, colType=None, integrCode=None, value=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.colIndex = colIndex
        self.validate_colIndexType70(self.colIndex)
        self.colIndex_nsprefix_ = None
        self.colType = colType
        self.validate_extendFieldType(self.colType)
        self.colType_nsprefix_ = None
        self.integrCode = integrCode
        self.validate_integrCodeType(self.integrCode)
        self.integrCode_nsprefix_ = None
        self.value = value
        self.value_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, extendTableColumnType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if extendTableColumnType.subclass:
            return extendTableColumnType.subclass(*args_, **kwargs_)
        else:
            return extendTableColumnType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_colIndexType70(self, value):
        result = True
        # Validate type colIndexType70, a restriction on xs:int.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            if value < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on colIndexType70' % {"value": value, "lineno": lineno} )
                result = False
            if value > 10:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxInclusive restriction on colIndexType70' % {"value": value, "lineno": lineno} )
                result = False
        return result
    def validate_extendFieldType(self, value):
        result = True
        # Validate type extendFieldType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['STRING', 'TEXT', 'INTEGER', 'NUMBER', 'BOOLEAN', 'TIME', 'DATETIME', 'DATE', 'LINK', 'FILE', 'REGEXP', 'CURRENCY', 'UNITS', 'OKDP', 'OKPD2', 'OKVED', 'OKVED2', 'TABLE']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on extendFieldType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_integrCodeType(self, value):
        result = True
        # Validate type integrCodeType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 50:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on integrCodeType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on integrCodeType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_integrCodeType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_integrCodeType_patterns_, ))
                result = False
        return result
    validate_integrCodeType_patterns_ = [['^([_a-zA-Z]+)$']]
    def hasContent_(self):
        if (
            self.colIndex is not None or
            self.colType is not None or
            self.integrCode is not None or
            self.value is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'colIndex' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'colIndex')
            ival_ = self.gds_validate_integer(ival_, node, 'colIndex')
            self.colIndex = ival_
            self.colIndex_nsprefix_ = child_.prefix
            # validate type colIndexType70
            self.validate_colIndexType70(self.colIndex)
        elif nodeName_ == 'colType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'colType')
            value_ = self.gds_validate_string(value_, node, 'colType')
            self.colType = value_
            self.colType_nsprefix_ = child_.prefix
            # validate type extendFieldType
            self.validate_extendFieldType(self.colType)
        elif nodeName_ == 'integrCode':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'integrCode')
            value_ = self.gds_validate_string(value_, node, 'integrCode')
            self.integrCode = value_
            self.integrCode_nsprefix_ = child_.prefix
            # validate type integrCodeType
            self.validate_integrCodeType(self.integrCode)
        elif nodeName_ == 'value':
            obj_ = tableColumnValueType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.value = obj_
            obj_.original_tagname_ = 'value'
# end class extendTableColumnType


class tableColumnValueType(GeneratedsSuper):
    """Значение поля данных"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'string': MemberSpec_('string', ['stringType71', 'nonEmptyString', 'xs:string'], 0, 0, {'name': 'string', 'type': 'xs:string'}, 10),
        'text': MemberSpec_('text', ['textType72', 'nonEmptyString', 'xs:string'], 0, 0, {'name': 'text', 'type': 'xs:string'}, 10),
        'integer': MemberSpec_('integer', 'xs:int', 0, 0, {'name': 'integer', 'type': 'xs:int'}, 10),
        'number': MemberSpec_('number', 'xs:decimal', 0, 0, {'name': 'number', 'type': 'xs:decimal'}, 10),
        'boolean': MemberSpec_('boolean', 'xs:boolean', 0, 0, {'name': 'boolean', 'type': 'xs:boolean'}, 10),
        'time': MemberSpec_('time', 'xs:time', 0, 0, {'name': 'time', 'type': 'xs:time'}, 10),
        'dateTime': MemberSpec_('dateTime', 'xs:dateTime', 0, 0, {'name': 'dateTime', 'type': 'xs:dateTime'}, 10),
        'date': MemberSpec_('date', 'xs:date', 0, 0, {'name': 'date', 'type': 'xs:date'}, 10),
        'url': MemberSpec_('url', ['urlType73', 'nonEmptyString', 'xs:string'], 0, 0, {'name': 'url', 'type': 'xs:string'}, 10),
        'attachments': MemberSpec_('attachments', 'documentListType', 0, 0, {'name': 'attachments', 'type': 'documentListType'}, 10),
        'nsi': MemberSpec_('nsi', 'nsiType74', 0, 0, {'name': 'nsi', 'type': 'nsiType74'}, 10),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, string=None, text=None, integer=None, number=None, boolean=None, time=None, dateTime=None, date=None, url=None, attachments=None, nsi=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.string = string
        self.validate_stringType71(self.string)
        self.string_nsprefix_ = None
        self.text = text
        self.validate_textType72(self.text)
        self.text_nsprefix_ = None
        self.integer = integer
        self.integer_nsprefix_ = None
        self.number = number
        self.number_nsprefix_ = None
        self.boolean = boolean
        self.boolean_nsprefix_ = None
        if isinstance(time, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(time, '%H:%M:%S').time()
        else:
            initvalue_ = time
        self.time = initvalue_
        self.time_nsprefix_ = None
        if isinstance(dateTime, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(dateTime, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = dateTime
        self.dateTime = initvalue_
        self.dateTime_nsprefix_ = None
        if isinstance(date, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(date, '%Y-%m-%d').date()
        else:
            initvalue_ = date
        self.date = initvalue_
        self.date_nsprefix_ = None
        self.url = url
        self.validate_urlType73(self.url)
        self.url_nsprefix_ = None
        self.attachments = attachments
        self.attachments_nsprefix_ = None
        self.nsi = nsi
        self.nsi_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tableColumnValueType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tableColumnValueType.subclass:
            return tableColumnValueType.subclass(*args_, **kwargs_)
        else:
            return tableColumnValueType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_stringType71(self, value):
        result = True
        # Validate type stringType71, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on stringType71' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on stringType71' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_textType72(self, value):
        result = True
        # Validate type textType72, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 2000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on textType72' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on textType72' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_urlType73(self, value):
        result = True
        # Validate type urlType73, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on urlType73' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on urlType73' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.string is not None or
            self.text is not None or
            self.integer is not None or
            self.number is not None or
            self.boolean is not None or
            self.time is not None or
            self.dateTime is not None or
            self.date is not None or
            self.url is not None or
            self.attachments is not None or
            self.nsi is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'string':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'string')
            value_ = self.gds_validate_string(value_, node, 'string')
            self.string = value_
            self.string_nsprefix_ = child_.prefix
            # validate type stringType71
            self.validate_stringType71(self.string)
        elif nodeName_ == 'text':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'text')
            value_ = self.gds_validate_string(value_, node, 'text')
            self.text = value_
            self.text_nsprefix_ = child_.prefix
            # validate type textType72
            self.validate_textType72(self.text)
        elif nodeName_ == 'integer' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'integer')
            ival_ = self.gds_validate_integer(ival_, node, 'integer')
            self.integer = ival_
            self.integer_nsprefix_ = child_.prefix
        elif nodeName_ == 'number' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'number')
            fval_ = self.gds_validate_decimal(fval_, node, 'number')
            self.number = fval_
            self.number_nsprefix_ = child_.prefix
        elif nodeName_ == 'boolean':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'boolean')
            self.boolean = ival_
            self.boolean_nsprefix_ = child_.prefix
        elif nodeName_ == 'time':
            sval_ = child_.text
            dval_ = self.gds_parse_time(sval_)
            self.time = dval_
            self.time_nsprefix_ = child_.prefix
        elif nodeName_ == 'dateTime':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.dateTime = dval_
            self.dateTime_nsprefix_ = child_.prefix
        elif nodeName_ == 'date':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.date = dval_
            self.date_nsprefix_ = child_.prefix
        elif nodeName_ == 'url':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'url')
            value_ = self.gds_validate_string(value_, node, 'url')
            self.url = value_
            self.url_nsprefix_ = child_.prefix
            # validate type urlType73
            self.validate_urlType73(self.url)
        elif nodeName_ == 'attachments':
            obj_ = documentListType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.attachments = obj_
            obj_.original_tagname_ = 'attachments'
        elif nodeName_ == 'nsi':
            obj_ = nsiType74.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.nsi = obj_
            obj_.original_tagname_ = 'nsi'
# end class tableColumnValueType


class protocolRequisitesType(GeneratedsSuper):
    """Реквизиты протокола"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'guid': MemberSpec_('guid', ['guidType', 'xs:string'], 0, 0, {'name': 'guid', 'type': 'xs:string'}, None),
        'registrationNumber': MemberSpec_('registrationNumber', ['registrationNumber11-2Type', 'nonEmptyString', 'xs:string'], 0, 0, {'name': 'registrationNumber', 'type': 'xs:string'}, None),
        'version': MemberSpec_('version', ['versionType', 'xs:long'], 0, 0, {'name': 'version', 'type': 'xs:long'}, None),
        'publicationDateTime': MemberSpec_('publicationDateTime', 'xs:dateTime', 0, 1, {'minOccurs': '0', 'name': 'publicationDateTime', 'type': 'xs:dateTime'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_) + ['extensiontype_']
    subclass = None
    superclass = None
    def __init__(self, guid=None, registrationNumber=None, version=None, publicationDateTime=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.guid = guid
        self.validate_guidType(self.guid)
        self.guid_nsprefix_ = None
        self.registrationNumber = registrationNumber
        self.validate_registrationNumber11_2Type(self.registrationNumber)
        self.registrationNumber_nsprefix_ = None
        self.version = version
        self.validate_versionType(self.version)
        self.version_nsprefix_ = None
        if isinstance(publicationDateTime, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(publicationDateTime, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = publicationDateTime
        self.publicationDateTime = initvalue_
        self.publicationDateTime_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, protocolRequisitesType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if protocolRequisitesType.subclass:
            return protocolRequisitesType.subclass(*args_, **kwargs_)
        else:
            return protocolRequisitesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_guidType(self, value):
        result = True
        # Validate type guidType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) != 36:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd length restriction on guidType' % {"value": encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_guidType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_guidType_patterns_, ))
                result = False
        return result
    validate_guidType_patterns_ = [['^([a-fA-F0-9]{8}\\-[a-fA-F0-9]{4}\\-[a-fA-F0-9]{4}\\-[a-fA-F0-9]{4}\\-[a-fA-F0-9]{12})$']]
    def validate_registrationNumber11_2Type(self, value):
        result = True
        # Validate type registrationNumber11-2Type, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on registrationNumber11-2Type' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_registrationNumber11_2Type_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_registrationNumber11_2Type_patterns_, ))
                result = False
        return result
    validate_registrationNumber11_2Type_patterns_ = [['^(\\d{11}-\\d{2})$']]
    def validate_versionType(self, value):
        result = True
        # Validate type versionType, a restriction on xs:long.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            if value < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on versionType' % {"value": value, "lineno": lineno} )
                result = False
            if len(str(value)) >= 9:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd totalDigits restriction on versionType' % {"value": value, "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.guid is not None or
            self.registrationNumber is not None or
            self.version is not None or
            self.publicationDateTime is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'guid':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'guid')
            value_ = self.gds_validate_string(value_, node, 'guid')
            self.guid = value_
            self.guid_nsprefix_ = child_.prefix
            # validate type guidType
            self.validate_guidType(self.guid)
        elif nodeName_ == 'registrationNumber':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'registrationNumber')
            value_ = self.gds_validate_string(value_, node, 'registrationNumber')
            self.registrationNumber = value_
            self.registrationNumber_nsprefix_ = child_.prefix
            # validate type registrationNumber11-2Type
            self.validate_registrationNumber11_2Type(self.registrationNumber)
        elif nodeName_ == 'version' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'version')
            ival_ = self.gds_validate_integer(ival_, node, 'version')
            self.version = ival_
            self.version_nsprefix_ = child_.prefix
            # validate type versionType
            self.validate_versionType(self.version)
        elif nodeName_ == 'publicationDateTime':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.publicationDateTime = dval_
            self.publicationDateTime_nsprefix_ = child_.prefix
# end class protocolRequisitesType


class protocolRequisitesType2(protocolRequisitesType):
    """Реквизиты протокола"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'typeName': MemberSpec_('typeName', ['typeNameType', 'nonEmptyString', 'xs:string'], 0, 0, {'name': 'typeName', 'type': 'xs:string'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = protocolRequisitesType
    def __init__(self, guid=None, registrationNumber=None, version=None, publicationDateTime=None, typeName=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(protocolRequisitesType2, self).__init__(guid, registrationNumber, version, publicationDateTime,  **kwargs_)
        self.typeName = typeName
        self.validate_typeNameType(self.typeName)
        self.typeName_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, protocolRequisitesType2)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if protocolRequisitesType2.subclass:
            return protocolRequisitesType2.subclass(*args_, **kwargs_)
        else:
            return protocolRequisitesType2(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_typeNameType(self, value):
        result = True
        # Validate type typeNameType, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 2000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on typeNameType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on typeNameType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.typeName is not None or
            super(protocolRequisitesType2, self).hasContent_()
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(protocolRequisitesType2, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'typeName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'typeName')
            value_ = self.gds_validate_string(value_, node, 'typeName')
            self.typeName = value_
            self.typeName_nsprefix_ = child_.prefix
            # validate type typeNameType
            self.validate_typeNameType(self.typeName)
        super(protocolRequisitesType2, self).buildChildren(child_, node, nodeName_, True)
# end class protocolRequisitesType2


class extendedAddressType(GeneratedsSuper):
    """Полный адрес организации"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'country': MemberSpec_('country', 'countryType', 0, 1, {'minOccurs': '0', 'name': 'country', 'type': 'countryType'}, None),
        'area': MemberSpec_('area', ['areaType', 'nonEmptyString', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'area', 'type': 'xs:string'}, None),
        'corpus': MemberSpec_('corpus', ['corpusType', 'nonEmptyString', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'corpus', 'type': 'xs:string'}, None),
        'house': MemberSpec_('house', ['houseType', 'nonEmptyString', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'house', 'type': 'xs:string'}, None),
        'zip': MemberSpec_('zip', ['zipType', 'nonEmptyString', 'xs:string'], 0, 0, {'name': 'zip', 'type': 'xs:string'}, None),
        'region': MemberSpec_('region', ['regionType75', 'nonEmptyString', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'region', 'type': 'xs:string'}, None),
        'structure': MemberSpec_('structure', ['structureType', 'nonEmptyString', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'structure', 'type': 'xs:string'}, None),
        'city': MemberSpec_('city', ['cityType', 'nonEmptyString', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'city', 'type': 'xs:string'}, None),
        'settlement': MemberSpec_('settlement', ['settlementType', 'nonEmptyString', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'settlement', 'type': 'xs:string'}, None),
        'street': MemberSpec_('street', ['streetType', 'nonEmptyString', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'street', 'type': 'xs:string'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, country=None, area=None, corpus=None, house=None, zip=None, region=None, structure=None, city=None, settlement=None, street=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.country = country
        self.country_nsprefix_ = None
        self.area = area
        self.validate_areaType(self.area)
        self.area_nsprefix_ = None
        self.corpus = corpus
        self.validate_corpusType(self.corpus)
        self.corpus_nsprefix_ = None
        self.house = house
        self.validate_houseType(self.house)
        self.house_nsprefix_ = None
        self.zip = zip
        self.validate_zipType(self.zip)
        self.zip_nsprefix_ = None
        self.region = region
        self.validate_regionType75(self.region)
        self.region_nsprefix_ = None
        self.structure = structure
        self.validate_structureType(self.structure)
        self.structure_nsprefix_ = None
        self.city = city
        self.validate_cityType(self.city)
        self.city_nsprefix_ = None
        self.settlement = settlement
        self.validate_settlementType(self.settlement)
        self.settlement_nsprefix_ = None
        self.street = street
        self.validate_streetType(self.street)
        self.street_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, extendedAddressType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if extendedAddressType.subclass:
            return extendedAddressType.subclass(*args_, **kwargs_)
        else:
            return extendedAddressType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_areaType(self, value):
        result = True
        # Validate type areaType, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 2000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on areaType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on areaType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_corpusType(self, value):
        result = True
        # Validate type corpusType, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 20:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on corpusType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on corpusType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_houseType(self, value):
        result = True
        # Validate type houseType, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 20:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on houseType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on houseType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_zipType(self, value):
        result = True
        # Validate type zipType, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on zipType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_zipType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_zipType_patterns_, ))
                result = False
        return result
    validate_zipType_patterns_ = [['^(\\d{6})$']]
    def validate_regionType75(self, value):
        result = True
        # Validate type regionType75, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 2000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on regionType75' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on regionType75' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_structureType(self, value):
        result = True
        # Validate type structureType, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 20:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on structureType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on structureType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_cityType(self, value):
        result = True
        # Validate type cityType, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 2000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on cityType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on cityType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_settlementType(self, value):
        result = True
        # Validate type settlementType, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 2000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on settlementType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on settlementType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_streetType(self, value):
        result = True
        # Validate type streetType, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 2000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on streetType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on streetType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.country is not None or
            self.area is not None or
            self.corpus is not None or
            self.house is not None or
            self.zip is not None or
            self.region is not None or
            self.structure is not None or
            self.city is not None or
            self.settlement is not None or
            self.street is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'country':
            obj_ = countryType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.country = obj_
            obj_.original_tagname_ = 'country'
        elif nodeName_ == 'area':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'area')
            value_ = self.gds_validate_string(value_, node, 'area')
            self.area = value_
            self.area_nsprefix_ = child_.prefix
            # validate type areaType
            self.validate_areaType(self.area)
        elif nodeName_ == 'corpus':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'corpus')
            value_ = self.gds_validate_string(value_, node, 'corpus')
            self.corpus = value_
            self.corpus_nsprefix_ = child_.prefix
            # validate type corpusType
            self.validate_corpusType(self.corpus)
        elif nodeName_ == 'house':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'house')
            value_ = self.gds_validate_string(value_, node, 'house')
            self.house = value_
            self.house_nsprefix_ = child_.prefix
            # validate type houseType
            self.validate_houseType(self.house)
        elif nodeName_ == 'zip':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'zip')
            value_ = self.gds_validate_string(value_, node, 'zip')
            self.zip = value_
            self.zip_nsprefix_ = child_.prefix
            # validate type zipType
            self.validate_zipType(self.zip)
        elif nodeName_ == 'region':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'region')
            value_ = self.gds_validate_string(value_, node, 'region')
            self.region = value_
            self.region_nsprefix_ = child_.prefix
            # validate type regionType75
            self.validate_regionType75(self.region)
        elif nodeName_ == 'structure':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'structure')
            value_ = self.gds_validate_string(value_, node, 'structure')
            self.structure = value_
            self.structure_nsprefix_ = child_.prefix
            # validate type structureType
            self.validate_structureType(self.structure)
        elif nodeName_ == 'city':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'city')
            value_ = self.gds_validate_string(value_, node, 'city')
            self.city = value_
            self.city_nsprefix_ = child_.prefix
            # validate type cityType
            self.validate_cityType(self.city)
        elif nodeName_ == 'settlement':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'settlement')
            value_ = self.gds_validate_string(value_, node, 'settlement')
            self.settlement = value_
            self.settlement_nsprefix_ = child_.prefix
            # validate type settlementType
            self.validate_settlementType(self.settlement)
        elif nodeName_ == 'street':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'street')
            value_ = self.gds_validate_string(value_, node, 'street')
            self.street = value_
            self.street_nsprefix_ = child_.prefix
            # validate type streetType
            self.validate_streetType(self.street)
# end class extendedAddressType


class templateStructureTabType(GeneratedsSuper):
    """Описание вкладки шаблона"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'tabOrdinal': MemberSpec_('tabOrdinal', 'xs:long', 0, 0, {'name': 'tabOrdinal', 'type': 'xs:long'}, None),
        'tabName': MemberSpec_('tabName', ['tabNameType76', 'nonEmptyString', 'xs:string'], 0, 0, {'name': 'tabName', 'type': 'xs:string'}, None),
        'fixedName': MemberSpec_('fixedName', ['fixedNameType', 'nonEmptyString', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'fixedName', 'type': 'xs:string'}, None),
        'section': MemberSpec_('section', 'sectionType', 1, 0, {'maxOccurs': 'unbounded', 'minOccurs': '1', 'name': 'section', 'type': 'sectionType'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, tabOrdinal=None, tabName=None, fixedName=None, section=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.tabOrdinal = tabOrdinal
        self.tabOrdinal_nsprefix_ = None
        self.tabName = tabName
        self.validate_tabNameType76(self.tabName)
        self.tabName_nsprefix_ = None
        self.fixedName = fixedName
        self.validate_fixedNameType(self.fixedName)
        self.fixedName_nsprefix_ = None
        if section is None:
            self.section = []
        else:
            self.section = section
        self.section_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, templateStructureTabType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if templateStructureTabType.subclass:
            return templateStructureTabType.subclass(*args_, **kwargs_)
        else:
            return templateStructureTabType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_tabNameType76(self, value):
        result = True
        # Validate type tabNameType76, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 130:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on tabNameType76' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on tabNameType76' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_fixedNameType(self, value):
        result = True
        # Validate type fixedNameType, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 130:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on fixedNameType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on fixedNameType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.tabOrdinal is not None or
            self.tabName is not None or
            self.fixedName is not None or
            self.section
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'tabOrdinal' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'tabOrdinal')
            ival_ = self.gds_validate_integer(ival_, node, 'tabOrdinal')
            self.tabOrdinal = ival_
            self.tabOrdinal_nsprefix_ = child_.prefix
        elif nodeName_ == 'tabName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'tabName')
            value_ = self.gds_validate_string(value_, node, 'tabName')
            self.tabName = value_
            self.tabName_nsprefix_ = child_.prefix
            # validate type tabNameType76
            self.validate_tabNameType76(self.tabName)
        elif nodeName_ == 'fixedName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'fixedName')
            value_ = self.gds_validate_string(value_, node, 'fixedName')
            self.fixedName = value_
            self.fixedName_nsprefix_ = child_.prefix
            # validate type fixedNameType
            self.validate_fixedNameType(self.fixedName)
        elif nodeName_ == 'section':
            obj_ = sectionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.section.append(obj_)
            obj_.original_tagname_ = 'section'
# end class templateStructureTabType


class purchaseCategory(GeneratedsSuper):
    """Категория закупки"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'code': MemberSpec_('code', 'xs:long', 0, 0, {'maxOccurs': '1', 'minOccurs': '1', 'name': 'code', 'type': 'xs:long'}, None),
        'name': MemberSpec_('name', 'xs:string', 0, 0, {'maxOccurs': '1', 'minOccurs': '1', 'name': 'name', 'type': 'xs:string'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, code=None, name=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.code = code
        self.code_nsprefix_ = None
        self.name = name
        self.name_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, purchaseCategory)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if purchaseCategory.subclass:
            return purchaseCategory.subclass(*args_, **kwargs_)
        else:
            return purchaseCategory(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.code is not None or
            self.name is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'code' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'code')
            ival_ = self.gds_validate_integer(ival_, node, 'code')
            self.code = ival_
            self.code_nsprefix_ = child_.prefix
        elif nodeName_ == 'name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'name')
            value_ = self.gds_validate_string(value_, node, 'name')
            self.name = value_
            self.name_nsprefix_ = child_.prefix
# end class purchaseCategory


class hiddenFzFields(GeneratedsSuper):
    """Скрытые поля 223 ФЗ"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'code': MemberSpec_('code', 'xs:string', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'code', 'type': 'xs:string'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, code=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if code is None:
            self.code = []
        else:
            self.code = code
        self.code_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, hiddenFzFields)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if hiddenFzFields.subclass:
            return hiddenFzFields.subclass(*args_, **kwargs_)
        else:
            return hiddenFzFields(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.code
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'code':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'code')
            value_ = self.gds_validate_string(value_, node, 'code')
            self.code.append(value_)
            self.code_nsprefix_ = child_.prefix
# end class hiddenFzFields


class bodyType(GeneratedsSuper):
    """Данные информационного пакета"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'item': MemberSpec_('item', 'nsiAgencyRelationsItemType', 1, 0, {'maxOccurs': 'unbounded', 'name': 'item', 'type': 'nsiAgencyRelationsItemType'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, item=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if item is None:
            self.item = []
        else:
            self.item = item
        self.item_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, bodyType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if bodyType.subclass:
            return bodyType.subclass(*args_, **kwargs_)
        else:
            return bodyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.item
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'item':
            obj_ = nsiAgencyRelationsItemType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.item.append(obj_)
            obj_.original_tagname_ = 'item'
# end class bodyType


class relationsType(GeneratedsSuper):
    """Список связей с организацией"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'relation': MemberSpec_('relation', 'relationType', 1, 0, {'maxOccurs': 'unbounded', 'name': 'relation', 'type': 'relationType'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, relation=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if relation is None:
            self.relation = []
        else:
            self.relation = relation
        self.relation_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, relationsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if relationsType.subclass:
            return relationsType.subclass(*args_, **kwargs_)
        else:
            return relationsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.relation
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'relation':
            obj_ = relationType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.relation.append(obj_)
            obj_.original_tagname_ = 'relation'
# end class relationsType


class relationType(GeneratedsSuper):
    """Связь с организацией"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'agency': MemberSpec_('agency', 'customerMainInfoType', 0, 0, {'name': 'agency', 'type': 'customerMainInfoType'}, None),
        'relationType': MemberSpec_('relationType', ['agencyRelationType', 'xs:string'], 0, 0, {'name': 'relationType', 'type': 'xs:string'}, None),
        'status': MemberSpec_('status', ['agencyRelationStatus', 'xs:string'], 0, 0, {'name': 'status', 'type': 'xs:string'}, None),
        'createDateTime': MemberSpec_('createDateTime', 'xs:dateTime', 0, 0, {'name': 'createDateTime', 'type': 'xs:dateTime'}, None),
        'updateDateTime': MemberSpec_('updateDateTime', 'xs:dateTime', 0, 0, {'name': 'updateDateTime', 'type': 'xs:dateTime'}, None),
        'comment': MemberSpec_('comment', ['commentType1', 't:nonEmptyString'], 0, 1, {'minOccurs': '0', 'name': 'comment', 'type': 'xs:string'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, agency=None, relationType_member=None, status=None, createDateTime=None, updateDateTime=None, comment=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.agency = agency
        self.agency_nsprefix_ = None
        self.relationType = relationType_member
        self.validate_agencyRelationType(self.relationType)
        self.relationType_nsprefix_ = None
        self.status = status
        self.validate_agencyRelationStatus(self.status)
        self.status_nsprefix_ = None
        if isinstance(createDateTime, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(createDateTime, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = createDateTime
        self.createDateTime = initvalue_
        self.createDateTime_nsprefix_ = None
        if isinstance(updateDateTime, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(updateDateTime, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = updateDateTime
        self.updateDateTime = initvalue_
        self.updateDateTime_nsprefix_ = None
        self.comment = comment
        self.validate_commentType1(self.comment)
        self.comment_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, relationType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if relationType.subclass:
            return relationType.subclass(*args_, **kwargs_)
        else:
            return relationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_agencyRelationType(self, value):
        result = True
        # Validate type agencyRelationType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['R', 'B', 'S', 'C']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on agencyRelationType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_agencyRelationStatus(self, value):
        result = True
        # Validate type agencyRelationStatus, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['APPROVAL_REQUESTED', 'APPROVED', 'BLOCKED', 'REVOKED', 'REFUSED']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on agencyRelationStatus' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_commentType1(self, value):
        result = True
        # Validate type commentType1, a restriction on t:nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 2000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on commentType1' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on commentType1' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.agency is not None or
            self.relationType is not None or
            self.status is not None or
            self.createDateTime is not None or
            self.updateDateTime is not None or
            self.comment is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'agency':
            obj_ = customerMainInfoType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.agency = obj_
            obj_.original_tagname_ = 'agency'
        elif nodeName_ == 'relationType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'relationType')
            value_ = self.gds_validate_string(value_, node, 'relationType')
            self.relationType = value_
            self.relationType_nsprefix_ = child_.prefix
            # validate type agencyRelationType
            self.validate_agencyRelationType(self.relationType)
        elif nodeName_ == 'status':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'status')
            value_ = self.gds_validate_string(value_, node, 'status')
            self.status = value_
            self.status_nsprefix_ = child_.prefix
            # validate type agencyRelationStatus
            self.validate_agencyRelationStatus(self.status)
        elif nodeName_ == 'createDateTime':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.createDateTime = dval_
            self.createDateTime_nsprefix_ = child_.prefix
        elif nodeName_ == 'updateDateTime':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.updateDateTime = dval_
            self.updateDateTime_nsprefix_ = child_.prefix
        elif nodeName_ == 'comment':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'comment')
            value_ = self.gds_validate_string(value_, node, 'comment')
            self.comment = value_
            self.comment_nsprefix_ = child_.prefix
            # validate type commentType1
            self.validate_commentType1(self.comment)
# end class relationType


class bodyType2(GeneratedsSuper):
    """Данные информационного пакета"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'orderClauseDocumentUpload': MemberSpec_('orderClauseDocumentUpload', 'orderClauseDocumentUploadType', 0, 0, {'name': 'orderClauseDocumentUpload', 'type': 'orderClauseDocumentUploadType'}, 11),
        'noticeDocumentUpload': MemberSpec_('noticeDocumentUpload', 'noticeDocumentUploadType', 0, 0, {'name': 'noticeDocumentUpload', 'type': 'noticeDocumentUploadType'}, 11),
        'protocolDocumentUpload': MemberSpec_('protocolDocumentUpload', 'protocolDocumentUploadType', 0, 0, {'name': 'protocolDocumentUpload', 'type': 'protocolDocumentUploadType'}, 11),
        'purchaseContractDocumentUpload': MemberSpec_('purchaseContractDocumentUpload', 'purchaseContractDocumentUploadType', 0, 0, {'name': 'purchaseContractDocumentUpload', 'type': 'purchaseContractDocumentUploadType'}, 11),
        'purchasePlanDocumentUpload': MemberSpec_('purchasePlanDocumentUpload', 'purchasePlanDocumentUploadType', 0, 0, {'name': 'purchasePlanDocumentUpload', 'type': 'purchasePlanDocumentUploadType'}, 11),
        'purchasePlanProjectDocumentUpload': MemberSpec_('purchasePlanProjectDocumentUpload', 'purchasePlanProjectDocumentUploadType', 0, 0, {'name': 'purchasePlanProjectDocumentUpload', 'type': 'purchasePlanProjectDocumentUploadType'}, 11),
        'purchaseContractAccountDocumentUpload': MemberSpec_('purchaseContractAccountDocumentUpload', 'purchaseContractAccountDocumentUploadType', 0, 0, {'name': 'purchaseContractAccountDocumentUpload', 'type': 'purchaseContractAccountDocumentUploadType'}, 11),
        'purchaseRejectionDocumentUpload': MemberSpec_('purchaseRejectionDocumentUpload', 'purchaseRejectionDocumentUploadType', 0, 0, {'name': 'purchaseRejectionDocumentUpload', 'type': 'purchaseRejectionDocumentUploadType'}, 11),
        'explanationDocumentUpload': MemberSpec_('explanationDocumentUpload', 'explanationDocumentUploadType', 0, 0, {'name': 'explanationDocumentUpload', 'type': 'explanationDocumentUploadType'}, 11),
        'explanationRequestDocumentUpload': MemberSpec_('explanationRequestDocumentUpload', 'explanationRequestDocumentUploadType', 0, 0, {'name': 'explanationRequestDocumentUpload', 'type': 'explanationRequestDocumentUploadType'}, 11),
        'changeRequirementsDocumentUpload': MemberSpec_('changeRequirementsDocumentUpload', 'changeRequirementsDocumentUploadType', 0, 0, {'name': 'changeRequirementsDocumentUpload', 'type': 'changeRequirementsDocumentUploadType'}, 11),
        'contractDocumentUpload': MemberSpec_('contractDocumentUpload', 'contractDocumentUploadType', 0, 0, {'name': 'contractDocumentUpload', 'type': 'contractDocumentUploadType'}, 11),
        'contractCompletionDocumentUpload': MemberSpec_('contractCompletionDocumentUpload', 'contractCompletionDocumentUploadType', 0, 0, {'name': 'contractCompletionDocumentUpload', 'type': 'contractCompletionDocumentUploadType'}, 11),
        'contractCancellationDocumentUpload': MemberSpec_('contractCancellationDocumentUpload', 'contractCancellationDocumentUploadType', 0, 0, {'name': 'contractCancellationDocumentUpload', 'type': 'contractCancellationDocumentUploadType'}, 11),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, orderClauseDocumentUpload=None, noticeDocumentUpload=None, protocolDocumentUpload=None, purchaseContractDocumentUpload=None, purchasePlanDocumentUpload=None, purchasePlanProjectDocumentUpload=None, purchaseContractAccountDocumentUpload=None, purchaseRejectionDocumentUpload=None, explanationDocumentUpload=None, explanationRequestDocumentUpload=None, changeRequirementsDocumentUpload=None, contractDocumentUpload=None, contractCompletionDocumentUpload=None, contractCancellationDocumentUpload=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.orderClauseDocumentUpload = orderClauseDocumentUpload
        self.orderClauseDocumentUpload_nsprefix_ = None
        self.noticeDocumentUpload = noticeDocumentUpload
        self.noticeDocumentUpload_nsprefix_ = None
        self.protocolDocumentUpload = protocolDocumentUpload
        self.protocolDocumentUpload_nsprefix_ = None
        self.purchaseContractDocumentUpload = purchaseContractDocumentUpload
        self.purchaseContractDocumentUpload_nsprefix_ = None
        self.purchasePlanDocumentUpload = purchasePlanDocumentUpload
        self.purchasePlanDocumentUpload_nsprefix_ = None
        self.purchasePlanProjectDocumentUpload = purchasePlanProjectDocumentUpload
        self.purchasePlanProjectDocumentUpload_nsprefix_ = None
        self.purchaseContractAccountDocumentUpload = purchaseContractAccountDocumentUpload
        self.purchaseContractAccountDocumentUpload_nsprefix_ = None
        self.purchaseRejectionDocumentUpload = purchaseRejectionDocumentUpload
        self.purchaseRejectionDocumentUpload_nsprefix_ = None
        self.explanationDocumentUpload = explanationDocumentUpload
        self.explanationDocumentUpload_nsprefix_ = None
        self.explanationRequestDocumentUpload = explanationRequestDocumentUpload
        self.explanationRequestDocumentUpload_nsprefix_ = None
        self.changeRequirementsDocumentUpload = changeRequirementsDocumentUpload
        self.changeRequirementsDocumentUpload_nsprefix_ = None
        self.contractDocumentUpload = contractDocumentUpload
        self.contractDocumentUpload_nsprefix_ = None
        self.contractCompletionDocumentUpload = contractCompletionDocumentUpload
        self.contractCompletionDocumentUpload_nsprefix_ = None
        self.contractCancellationDocumentUpload = contractCancellationDocumentUpload
        self.contractCancellationDocumentUpload_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, bodyType2)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if bodyType2.subclass:
            return bodyType2.subclass(*args_, **kwargs_)
        else:
            return bodyType2(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.orderClauseDocumentUpload is not None or
            self.noticeDocumentUpload is not None or
            self.protocolDocumentUpload is not None or
            self.purchaseContractDocumentUpload is not None or
            self.purchasePlanDocumentUpload is not None or
            self.purchasePlanProjectDocumentUpload is not None or
            self.purchaseContractAccountDocumentUpload is not None or
            self.purchaseRejectionDocumentUpload is not None or
            self.explanationDocumentUpload is not None or
            self.explanationRequestDocumentUpload is not None or
            self.changeRequirementsDocumentUpload is not None or
            self.contractDocumentUpload is not None or
            self.contractCompletionDocumentUpload is not None or
            self.contractCancellationDocumentUpload is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'orderClauseDocumentUpload':
            obj_ = orderClauseDocumentUploadType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.orderClauseDocumentUpload = obj_
            obj_.original_tagname_ = 'orderClauseDocumentUpload'
        elif nodeName_ == 'noticeDocumentUpload':
            obj_ = noticeDocumentUploadType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.noticeDocumentUpload = obj_
            obj_.original_tagname_ = 'noticeDocumentUpload'
        elif nodeName_ == 'protocolDocumentUpload':
            obj_ = protocolDocumentUploadType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.protocolDocumentUpload = obj_
            obj_.original_tagname_ = 'protocolDocumentUpload'
        elif nodeName_ == 'purchaseContractDocumentUpload':
            obj_ = purchaseContractDocumentUploadType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.purchaseContractDocumentUpload = obj_
            obj_.original_tagname_ = 'purchaseContractDocumentUpload'
        elif nodeName_ == 'purchasePlanDocumentUpload':
            obj_ = purchasePlanDocumentUploadType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.purchasePlanDocumentUpload = obj_
            obj_.original_tagname_ = 'purchasePlanDocumentUpload'
        elif nodeName_ == 'purchasePlanProjectDocumentUpload':
            obj_ = purchasePlanProjectDocumentUploadType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.purchasePlanProjectDocumentUpload = obj_
            obj_.original_tagname_ = 'purchasePlanProjectDocumentUpload'
        elif nodeName_ == 'purchaseContractAccountDocumentUpload':
            obj_ = purchaseContractAccountDocumentUploadType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.purchaseContractAccountDocumentUpload = obj_
            obj_.original_tagname_ = 'purchaseContractAccountDocumentUpload'
        elif nodeName_ == 'purchaseRejectionDocumentUpload':
            obj_ = purchaseRejectionDocumentUploadType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.purchaseRejectionDocumentUpload = obj_
            obj_.original_tagname_ = 'purchaseRejectionDocumentUpload'
        elif nodeName_ == 'explanationDocumentUpload':
            obj_ = explanationDocumentUploadType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.explanationDocumentUpload = obj_
            obj_.original_tagname_ = 'explanationDocumentUpload'
        elif nodeName_ == 'explanationRequestDocumentUpload':
            obj_ = explanationRequestDocumentUploadType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.explanationRequestDocumentUpload = obj_
            obj_.original_tagname_ = 'explanationRequestDocumentUpload'
        elif nodeName_ == 'changeRequirementsDocumentUpload':
            obj_ = changeRequirementsDocumentUploadType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.changeRequirementsDocumentUpload = obj_
            obj_.original_tagname_ = 'changeRequirementsDocumentUpload'
        elif nodeName_ == 'contractDocumentUpload':
            obj_ = contractDocumentUploadType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.contractDocumentUpload = obj_
            obj_.original_tagname_ = 'contractDocumentUpload'
        elif nodeName_ == 'contractCompletionDocumentUpload':
            obj_ = contractCompletionDocumentUploadType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.contractCompletionDocumentUpload = obj_
            obj_.original_tagname_ = 'contractCompletionDocumentUpload'
        elif nodeName_ == 'contractCancellationDocumentUpload':
            obj_ = contractCancellationDocumentUploadType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.contractCancellationDocumentUpload = obj_
            obj_.original_tagname_ = 'contractCancellationDocumentUpload'
# end class bodyType2


class orderClauseDocumentUploadType(documentUploadBaseData):
    """Документы положения о закупке"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = documentUploadBaseData
    def __init__(self, guid=None, entityGuid=None, placer=None, additionalDocumentsCount=None, documentNumber=None, document=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(orderClauseDocumentUploadType, self).__init__(guid, entityGuid, placer, additionalDocumentsCount, documentNumber, document,  **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, orderClauseDocumentUploadType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if orderClauseDocumentUploadType.subclass:
            return orderClauseDocumentUploadType.subclass(*args_, **kwargs_)
        else:
            return orderClauseDocumentUploadType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(orderClauseDocumentUploadType, self).hasContent_()
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(orderClauseDocumentUploadType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(orderClauseDocumentUploadType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class orderClauseDocumentUploadType


class noticeDocumentUploadType(documentUploadBaseData):
    """Документы извещения о закупке"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'isUploadComplete': MemberSpec_('isUploadComplete', 'xs:boolean', 0, 1, {'default': 'false', 'minOccurs': '0', 'name': 'isUploadComplete', 'type': 'xs:boolean'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = documentUploadBaseData
    def __init__(self, guid=None, entityGuid=None, placer=None, additionalDocumentsCount=None, documentNumber=None, document=None, isUploadComplete=False, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(noticeDocumentUploadType, self).__init__(guid, entityGuid, placer, additionalDocumentsCount, documentNumber, document,  **kwargs_)
        self.isUploadComplete = isUploadComplete
        self.isUploadComplete_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, noticeDocumentUploadType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if noticeDocumentUploadType.subclass:
            return noticeDocumentUploadType.subclass(*args_, **kwargs_)
        else:
            return noticeDocumentUploadType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.isUploadComplete or
            super(noticeDocumentUploadType, self).hasContent_()
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(noticeDocumentUploadType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'isUploadComplete':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'isUploadComplete')
            ival_ = self.gds_validate_boolean(ival_, node, 'isUploadComplete')
            self.isUploadComplete = ival_
            self.isUploadComplete_nsprefix_ = child_.prefix
        super(noticeDocumentUploadType, self).buildChildren(child_, node, nodeName_, True)
# end class noticeDocumentUploadType


class protocolDocumentUploadType(documentUploadBaseData):
    """Документы протокола"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = documentUploadBaseData
    def __init__(self, guid=None, entityGuid=None, placer=None, additionalDocumentsCount=None, documentNumber=None, document=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(protocolDocumentUploadType, self).__init__(guid, entityGuid, placer, additionalDocumentsCount, documentNumber, document,  **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, protocolDocumentUploadType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if protocolDocumentUploadType.subclass:
            return protocolDocumentUploadType.subclass(*args_, **kwargs_)
        else:
            return protocolDocumentUploadType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(protocolDocumentUploadType, self).hasContent_()
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(protocolDocumentUploadType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(protocolDocumentUploadType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class protocolDocumentUploadType


class purchaseContractDocumentUploadType(documentUploadBaseData):
    """Документы договора закупки"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = documentUploadBaseData
    def __init__(self, guid=None, entityGuid=None, placer=None, additionalDocumentsCount=None, documentNumber=None, document=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(purchaseContractDocumentUploadType, self).__init__(guid, entityGuid, placer, additionalDocumentsCount, documentNumber, document,  **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, purchaseContractDocumentUploadType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if purchaseContractDocumentUploadType.subclass:
            return purchaseContractDocumentUploadType.subclass(*args_, **kwargs_)
        else:
            return purchaseContractDocumentUploadType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(purchaseContractDocumentUploadType, self).hasContent_()
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(purchaseContractDocumentUploadType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(purchaseContractDocumentUploadType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class purchaseContractDocumentUploadType


class purchasePlanDocumentUploadType(documentUploadBaseData):
    """Документы плана закупок"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = documentUploadBaseData
    def __init__(self, guid=None, entityGuid=None, placer=None, additionalDocumentsCount=None, documentNumber=None, document=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(purchasePlanDocumentUploadType, self).__init__(guid, entityGuid, placer, additionalDocumentsCount, documentNumber, document,  **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, purchasePlanDocumentUploadType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if purchasePlanDocumentUploadType.subclass:
            return purchasePlanDocumentUploadType.subclass(*args_, **kwargs_)
        else:
            return purchasePlanDocumentUploadType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(purchasePlanDocumentUploadType, self).hasContent_()
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(purchasePlanDocumentUploadType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(purchasePlanDocumentUploadType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class purchasePlanDocumentUploadType


class purchasePlanProjectDocumentUploadType(documentUploadBaseData):
    """Документы проекта плана закупок"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = documentUploadBaseData
    def __init__(self, guid=None, entityGuid=None, placer=None, additionalDocumentsCount=None, documentNumber=None, document=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(purchasePlanProjectDocumentUploadType, self).__init__(guid, entityGuid, placer, additionalDocumentsCount, documentNumber, document,  **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, purchasePlanProjectDocumentUploadType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if purchasePlanProjectDocumentUploadType.subclass:
            return purchasePlanProjectDocumentUploadType.subclass(*args_, **kwargs_)
        else:
            return purchasePlanProjectDocumentUploadType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(purchasePlanProjectDocumentUploadType, self).hasContent_()
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(purchasePlanProjectDocumentUploadType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(purchasePlanProjectDocumentUploadType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class purchasePlanProjectDocumentUploadType


class purchaseContractAccountDocumentUploadType(documentUploadBaseData):
    """Документы отчетности о договорах"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = documentUploadBaseData
    def __init__(self, guid=None, entityGuid=None, placer=None, additionalDocumentsCount=None, documentNumber=None, document=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(purchaseContractAccountDocumentUploadType, self).__init__(guid, entityGuid, placer, additionalDocumentsCount, documentNumber, document,  **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, purchaseContractAccountDocumentUploadType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if purchaseContractAccountDocumentUploadType.subclass:
            return purchaseContractAccountDocumentUploadType.subclass(*args_, **kwargs_)
        else:
            return purchaseContractAccountDocumentUploadType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(purchaseContractAccountDocumentUploadType, self).hasContent_()
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(purchaseContractAccountDocumentUploadType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(purchaseContractAccountDocumentUploadType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class purchaseContractAccountDocumentUploadType


class purchaseRejectionDocumentUploadType(documentUploadBaseData):
    """Документы извещения об отказе"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = documentUploadBaseData
    def __init__(self, guid=None, entityGuid=None, placer=None, additionalDocumentsCount=None, documentNumber=None, document=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(purchaseRejectionDocumentUploadType, self).__init__(guid, entityGuid, placer, additionalDocumentsCount, documentNumber, document,  **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, purchaseRejectionDocumentUploadType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if purchaseRejectionDocumentUploadType.subclass:
            return purchaseRejectionDocumentUploadType.subclass(*args_, **kwargs_)
        else:
            return purchaseRejectionDocumentUploadType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(purchaseRejectionDocumentUploadType, self).hasContent_()
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(purchaseRejectionDocumentUploadType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(purchaseRejectionDocumentUploadType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class purchaseRejectionDocumentUploadType


class explanationDocumentUploadType(documentUploadBaseData):
    """Документы разъяснения"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = documentUploadBaseData
    def __init__(self, guid=None, entityGuid=None, placer=None, additionalDocumentsCount=None, documentNumber=None, document=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(explanationDocumentUploadType, self).__init__(guid, entityGuid, placer, additionalDocumentsCount, documentNumber, document,  **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, explanationDocumentUploadType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if explanationDocumentUploadType.subclass:
            return explanationDocumentUploadType.subclass(*args_, **kwargs_)
        else:
            return explanationDocumentUploadType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(explanationDocumentUploadType, self).hasContent_()
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(explanationDocumentUploadType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(explanationDocumentUploadType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class explanationDocumentUploadType


class explanationRequestDocumentUploadType(documentUploadBaseData):
    """Документы запросов заказчика о разъяснении положений заявки"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = documentUploadBaseData
    def __init__(self, guid=None, entityGuid=None, placer=None, additionalDocumentsCount=None, documentNumber=None, document=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(explanationRequestDocumentUploadType, self).__init__(guid, entityGuid, placer, additionalDocumentsCount, documentNumber, document,  **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, explanationRequestDocumentUploadType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if explanationRequestDocumentUploadType.subclass:
            return explanationRequestDocumentUploadType.subclass(*args_, **kwargs_)
        else:
            return explanationRequestDocumentUploadType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(explanationRequestDocumentUploadType, self).hasContent_()
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(explanationRequestDocumentUploadType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(explanationRequestDocumentUploadType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class explanationRequestDocumentUploadType


class changeRequirementsDocumentUploadType(documentUploadBaseData):
    """Документы уточненных требований"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = documentUploadBaseData
    def __init__(self, guid=None, entityGuid=None, placer=None, additionalDocumentsCount=None, documentNumber=None, document=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(changeRequirementsDocumentUploadType, self).__init__(guid, entityGuid, placer, additionalDocumentsCount, documentNumber, document,  **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, changeRequirementsDocumentUploadType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if changeRequirementsDocumentUploadType.subclass:
            return changeRequirementsDocumentUploadType.subclass(*args_, **kwargs_)
        else:
            return changeRequirementsDocumentUploadType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(changeRequirementsDocumentUploadType, self).hasContent_()
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(changeRequirementsDocumentUploadType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(changeRequirementsDocumentUploadType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class changeRequirementsDocumentUploadType


class contractDocumentUploadType(documentUploadBaseData):
    """Документы договора"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = documentUploadBaseData
    def __init__(self, guid=None, entityGuid=None, placer=None, additionalDocumentsCount=None, documentNumber=None, document=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(contractDocumentUploadType, self).__init__(guid, entityGuid, placer, additionalDocumentsCount, documentNumber, document,  **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, contractDocumentUploadType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if contractDocumentUploadType.subclass:
            return contractDocumentUploadType.subclass(*args_, **kwargs_)
        else:
            return contractDocumentUploadType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(contractDocumentUploadType, self).hasContent_()
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(contractDocumentUploadType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(contractDocumentUploadType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class contractDocumentUploadType


class contractCompletionDocumentUploadType(documentUploadBaseData):
    """Документы сведений об исполнении договора"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = documentUploadBaseData
    def __init__(self, guid=None, entityGuid=None, placer=None, additionalDocumentsCount=None, documentNumber=None, document=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(contractCompletionDocumentUploadType, self).__init__(guid, entityGuid, placer, additionalDocumentsCount, documentNumber, document,  **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, contractCompletionDocumentUploadType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if contractCompletionDocumentUploadType.subclass:
            return contractCompletionDocumentUploadType.subclass(*args_, **kwargs_)
        else:
            return contractCompletionDocumentUploadType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(contractCompletionDocumentUploadType, self).hasContent_()
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(contractCompletionDocumentUploadType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(contractCompletionDocumentUploadType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class contractCompletionDocumentUploadType


class contractCancellationDocumentUploadType(documentUploadBaseData):
    """Документы сведений о расторжении договора"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = documentUploadBaseData
    def __init__(self, guid=None, entityGuid=None, placer=None, additionalDocumentsCount=None, documentNumber=None, document=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(contractCancellationDocumentUploadType, self).__init__(guid, entityGuid, placer, additionalDocumentsCount, documentNumber, document,  **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, contractCancellationDocumentUploadType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if contractCancellationDocumentUploadType.subclass:
            return contractCancellationDocumentUploadType.subclass(*args_, **kwargs_)
        else:
            return contractCancellationDocumentUploadType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(contractCancellationDocumentUploadType, self).hasContent_()
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(contractCancellationDocumentUploadType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(contractCancellationDocumentUploadType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class contractCancellationDocumentUploadType


class bodyType3(GeneratedsSuper):
    """Данные информационного пакета"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'refguid': MemberSpec_('refguid', ['guidType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'refguid', 'type': 'xs:string'}, None),
        'result': MemberSpec_('result', ['resultType', 'xs:string'], 0, 0, {'name': 'result', 'type': 'xs:string'}, None),
        'itemResults': MemberSpec_('itemResults', 'itemResultListType', 0, 1, {'minOccurs': '0', 'name': 'itemResults', 'type': 'itemResultListType'}, None),
        'violations': MemberSpec_('violations', 'violationListType', 0, 1, {'minOccurs': '0', 'name': 'violations', 'type': 'violationListType'}, None),
        'refFileName': MemberSpec_('refFileName', ['nonEmptyString', 'xs:string'], 0, 0, {'name': 'refFileName', 'type': 'xs:string'}, None),
        'messageId': MemberSpec_('messageId', 'xs:string', 0, 1, {'minOccurs': '0', 'name': 'messageId', 'type': 'xs:string'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, refguid=None, result=None, itemResults=None, violations=None, refFileName=None, messageId=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.refguid = refguid
        self.validate_guidType(self.refguid)
        self.refguid_nsprefix_ = None
        self.result = result
        self.validate_resultType(self.result)
        self.result_nsprefix_ = None
        self.itemResults = itemResults
        self.itemResults_nsprefix_ = None
        self.violations = violations
        self.violations_nsprefix_ = None
        self.refFileName = refFileName
        self.validate_nonEmptyString(self.refFileName)
        self.refFileName_nsprefix_ = None
        self.messageId = messageId
        self.messageId_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, bodyType3)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if bodyType3.subclass:
            return bodyType3.subclass(*args_, **kwargs_)
        else:
            return bodyType3(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_guidType(self, value):
        result = True
        # Validate type guidType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) != 36:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd length restriction on guidType' % {"value": encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_guidType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_guidType_patterns_, ))
                result = False
        return result
    validate_guidType_patterns_ = [['^([a-fA-F0-9]{8}\\-[a-fA-F0-9]{4}\\-[a-fA-F0-9]{4}\\-[a-fA-F0-9]{4}\\-[a-fA-F0-9]{12})$']]
    def validate_resultType(self, value):
        result = True
        # Validate type resultType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['success', 'failure']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on resultType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_nonEmptyString(self, value):
        result = True
        # Validate type nonEmptyString, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on nonEmptyString' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.refguid is not None or
            self.result is not None or
            self.itemResults is not None or
            self.violations is not None or
            self.refFileName is not None or
            self.messageId is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'refguid':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'refguid')
            value_ = self.gds_validate_string(value_, node, 'refguid')
            self.refguid = value_
            self.refguid_nsprefix_ = child_.prefix
            # validate type guidType
            self.validate_guidType(self.refguid)
        elif nodeName_ == 'result':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'result')
            value_ = self.gds_validate_string(value_, node, 'result')
            self.result = value_
            self.result_nsprefix_ = child_.prefix
            # validate type resultType
            self.validate_resultType(self.result)
        elif nodeName_ == 'itemResults':
            obj_ = itemResultListType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.itemResults = obj_
            obj_.original_tagname_ = 'itemResults'
        elif nodeName_ == 'violations':
            obj_ = violationListType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.violations = obj_
            obj_.original_tagname_ = 'violations'
        elif nodeName_ == 'refFileName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'refFileName')
            value_ = self.gds_validate_string(value_, node, 'refFileName')
            self.refFileName = value_
            self.refFileName_nsprefix_ = child_.prefix
            # validate type nonEmptyString
            self.validate_nonEmptyString(self.refFileName)
        elif nodeName_ == 'messageId':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'messageId')
            value_ = self.gds_validate_string(value_, node, 'messageId')
            self.messageId = value_
            self.messageId_nsprefix_ = child_.prefix
# end class bodyType3


class bodyType4(GeneratedsSuper):
    """Данные информационного пакета"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'messages': MemberSpec_('messages', 'messagesType', 0, 0, {'name': 'messages', 'type': 'messagesType'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, messages=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.messages = messages
        self.messages_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, bodyType4)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if bodyType4.subclass:
            return bodyType4.subclass(*args_, **kwargs_)
        else:
            return bodyType4(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.messages is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'messages':
            obj_ = messagesType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.messages = obj_
            obj_.original_tagname_ = 'messages'
# end class bodyType4


class messagesType(GeneratedsSuper):
    """Сообщения для асинхронного взаимодействия"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'message': MemberSpec_('message', 'messageType', 1, 0, {'maxOccurs': '1000', 'name': 'message', 'type': 'messageType'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, message=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if message is None:
            self.message = []
        else:
            self.message = message
        self.message_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, messagesType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if messagesType.subclass:
            return messagesType.subclass(*args_, **kwargs_)
        else:
            return messagesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.message
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'message':
            obj_ = messageType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.message.append(obj_)
            obj_.original_tagname_ = 'message'
# end class messagesType


class messageType(GeneratedsSuper):
    """Сообщение для асинхронного взаимодействия"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'messageId': MemberSpec_('messageId', 'xs:string', 0, 0, {'name': 'messageId', 'type': 'xs:string'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, messageId=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.messageId = messageId
        self.messageId_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, messageType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if messageType.subclass:
            return messageType.subclass(*args_, **kwargs_)
        else:
            return messageType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.messageId is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'messageId':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'messageId')
            value_ = self.gds_validate_string(value_, node, 'messageId')
            self.messageId = value_
            self.messageId_nsprefix_ = child_.prefix
# end class messageType


class bodyType5(GeneratedsSuper):
    """Данные информационного пакета"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'refguid': MemberSpec_('refguid', ['guidType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'refguid', 'type': 'xs:string'}, None),
        'result': MemberSpec_('result', ['resultType', 'xs:string'], 0, 0, {'name': 'result', 'type': 'xs:string'}, None),
        'violations': MemberSpec_('violations', 'violationListType', 0, 1, {'minOccurs': '0', 'name': 'violations', 'type': 'violationListType'}, None),
        'infos': MemberSpec_('infos', 'infosType', 0, 1, {'minOccurs': '0', 'name': 'infos', 'type': 'infosType'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, refguid=None, result=None, violations=None, infos=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.refguid = refguid
        self.validate_guidType(self.refguid)
        self.refguid_nsprefix_ = None
        self.result = result
        self.validate_resultType(self.result)
        self.result_nsprefix_ = None
        self.violations = violations
        self.violations_nsprefix_ = None
        self.infos = infos
        self.infos_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, bodyType5)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if bodyType5.subclass:
            return bodyType5.subclass(*args_, **kwargs_)
        else:
            return bodyType5(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_guidType(self, value):
        result = True
        # Validate type guidType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) != 36:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd length restriction on guidType' % {"value": encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_guidType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_guidType_patterns_, ))
                result = False
        return result
    validate_guidType_patterns_ = [['^([a-fA-F0-9]{8}\\-[a-fA-F0-9]{4}\\-[a-fA-F0-9]{4}\\-[a-fA-F0-9]{4}\\-[a-fA-F0-9]{12})$']]
    def validate_resultType(self, value):
        result = True
        # Validate type resultType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['success', 'failure']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on resultType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.refguid is not None or
            self.result is not None or
            self.violations is not None or
            self.infos is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'refguid':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'refguid')
            value_ = self.gds_validate_string(value_, node, 'refguid')
            self.refguid = value_
            self.refguid_nsprefix_ = child_.prefix
            # validate type guidType
            self.validate_guidType(self.refguid)
        elif nodeName_ == 'result':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'result')
            value_ = self.gds_validate_string(value_, node, 'result')
            self.result = value_
            self.result_nsprefix_ = child_.prefix
            # validate type resultType
            self.validate_resultType(self.result)
        elif nodeName_ == 'violations':
            obj_ = violationListType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.violations = obj_
            obj_.original_tagname_ = 'violations'
        elif nodeName_ == 'infos':
            obj_ = infosType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.infos = obj_
            obj_.original_tagname_ = 'infos'
# end class bodyType5


class infosType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'info': MemberSpec_('info', 'infoType', 1, 0, {'maxOccurs': '1000', 'minOccurs': '1', 'name': 'info', 'type': 'infoType'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, info=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if info is None:
            self.info = []
        else:
            self.info = info
        self.info_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, infosType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if infosType.subclass:
            return infosType.subclass(*args_, **kwargs_)
        else:
            return infosType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.info
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'info':
            obj_ = infoType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.info.append(obj_)
            obj_.original_tagname_ = 'info'
# end class infosType


class infoType(GeneratedsSuper):
    """Информаиця о загружаемых сведениях"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'guid': MemberSpec_('guid', ['guidType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'guid', 'type': 'xs:string'}, None),
        'regNum': MemberSpec_('regNum', 'xs:string', 0, 1, {'minOccurs': '0', 'name': 'regNum', 'type': 'xs:string'}, None),
        'placeDate': MemberSpec_('placeDate', 'xs:dateTime', 0, 1, {'minOccurs': '0', 'name': 'placeDate', 'type': 'xs:dateTime'}, None),
        'version': MemberSpec_('version', 'xs:int', 0, 1, {'minOccurs': '0', 'name': 'version', 'type': 'xs:int'}, None),
        'placer': MemberSpec_('placer', 'placerType', 0, 1, {'minOccurs': '0', 'name': 'placer', 'type': 'placerType'}, None),
        'status': MemberSpec_('status', ['statusType', 'xs:string'], 0, 0, {'name': 'status', 'type': 'xs:string'}, None),
        'violations': MemberSpec_('violations', 'violationListType', 0, 1, {'minOccurs': '0', 'name': 'violations', 'type': 'violationListType'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, guid=None, regNum=None, placeDate=None, version=None, placer=None, status=None, violations=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.guid = guid
        self.validate_guidType(self.guid)
        self.guid_nsprefix_ = None
        self.regNum = regNum
        self.regNum_nsprefix_ = None
        if isinstance(placeDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(placeDate, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = placeDate
        self.placeDate = initvalue_
        self.placeDate_nsprefix_ = None
        self.version = version
        self.version_nsprefix_ = None
        self.placer = placer
        self.placer_nsprefix_ = None
        self.status = status
        self.validate_statusType(self.status)
        self.status_nsprefix_ = None
        self.violations = violations
        self.violations_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, infoType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if infoType.subclass:
            return infoType.subclass(*args_, **kwargs_)
        else:
            return infoType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_guidType(self, value):
        result = True
        # Validate type guidType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) != 36:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd length restriction on guidType' % {"value": encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_guidType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_guidType_patterns_, ))
                result = False
        return result
    validate_guidType_patterns_ = [['^([a-fA-F0-9]{8}\\-[a-fA-F0-9]{4}\\-[a-fA-F0-9]{4}\\-[a-fA-F0-9]{4}\\-[a-fA-F0-9]{12})$']]
    def validate_statusType(self, value):
        result = True
        # Validate type statusType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['success', 'failure', 'queued', 'processing']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on statusType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.guid is not None or
            self.regNum is not None or
            self.placeDate is not None or
            self.version is not None or
            self.placer is not None or
            self.status is not None or
            self.violations is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'guid':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'guid')
            value_ = self.gds_validate_string(value_, node, 'guid')
            self.guid = value_
            self.guid_nsprefix_ = child_.prefix
            # validate type guidType
            self.validate_guidType(self.guid)
        elif nodeName_ == 'regNum':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'regNum')
            value_ = self.gds_validate_string(value_, node, 'regNum')
            self.regNum = value_
            self.regNum_nsprefix_ = child_.prefix
        elif nodeName_ == 'placeDate':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.placeDate = dval_
            self.placeDate_nsprefix_ = child_.prefix
        elif nodeName_ == 'version' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'version')
            ival_ = self.gds_validate_integer(ival_, node, 'version')
            self.version = ival_
            self.version_nsprefix_ = child_.prefix
        elif nodeName_ == 'placer':
            obj_ = placerType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.placer = obj_
            obj_.original_tagname_ = 'placer'
        elif nodeName_ == 'status':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'status')
            value_ = self.gds_validate_string(value_, node, 'status')
            self.status = value_
            self.status_nsprefix_ = child_.prefix
            # validate type statusType
            self.validate_statusType(self.status)
        elif nodeName_ == 'violations':
            obj_ = violationListType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.violations = obj_
            obj_.original_tagname_ = 'violations'
# end class infoType


class placerType(GeneratedsSuper):
    """Информация об организации, разместившей сведения"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'name': MemberSpec_('name', 'xs:string', 0, 1, {'minOccurs': '0', 'name': 'name', 'type': 'xs:string'}, None),
        'inn': MemberSpec_('inn', ['innType', 'nonEmptyString', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'inn', 'type': 'xs:string'}, None),
        'kpp': MemberSpec_('kpp', ['kppType', 'nonEmptyString', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'kpp', 'type': 'xs:string'}, None),
        'ogrn': MemberSpec_('ogrn', ['ogrnType', 'nonEmptyString', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'ogrn', 'type': 'xs:string'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, name=None, inn=None, kpp=None, ogrn=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.name = name
        self.name_nsprefix_ = None
        self.inn = inn
        self.validate_innType(self.inn)
        self.inn_nsprefix_ = None
        self.kpp = kpp
        self.validate_kppType(self.kpp)
        self.kpp_nsprefix_ = None
        self.ogrn = ogrn
        self.validate_ogrnType(self.ogrn)
        self.ogrn_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, placerType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if placerType.subclass:
            return placerType.subclass(*args_, **kwargs_)
        else:
            return placerType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_innType(self, value):
        result = True
        # Validate type innType, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on innType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_innType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_innType_patterns_, ))
                result = False
        return result
    validate_innType_patterns_ = [['^(\\d{10}|\\d{12})$']]
    def validate_kppType(self, value):
        result = True
        # Validate type kppType, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on kppType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_kppType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_kppType_patterns_, ))
                result = False
        return result
    validate_kppType_patterns_ = [['^(\\d{9})$']]
    def validate_ogrnType(self, value):
        result = True
        # Validate type ogrnType, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ogrnType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_ogrnType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_ogrnType_patterns_, ))
                result = False
        return result
    validate_ogrnType_patterns_ = [['^(\\d{13})$']]
    def hasContent_(self):
        if (
            self.name is not None or
            self.inn is not None or
            self.kpp is not None or
            self.ogrn is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'name')
            value_ = self.gds_validate_string(value_, node, 'name')
            self.name = value_
            self.name_nsprefix_ = child_.prefix
        elif nodeName_ == 'inn':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'inn')
            value_ = self.gds_validate_string(value_, node, 'inn')
            self.inn = value_
            self.inn_nsprefix_ = child_.prefix
            # validate type innType
            self.validate_innType(self.inn)
        elif nodeName_ == 'kpp':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'kpp')
            value_ = self.gds_validate_string(value_, node, 'kpp')
            self.kpp = value_
            self.kpp_nsprefix_ = child_.prefix
            # validate type kppType
            self.validate_kppType(self.kpp)
        elif nodeName_ == 'ogrn':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'ogrn')
            value_ = self.gds_validate_string(value_, node, 'ogrn')
            self.ogrn = value_
            self.ogrn_nsprefix_ = child_.prefix
            # validate type ogrnType
            self.validate_ogrnType(self.ogrn)
# end class placerType


class signatureType6(GeneratedsSuper):
    """ЭЦПТип ЭЦП:
    CAdES-BES;
    CAdES-A"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'type_': MemberSpec_('type_', 'signatureType', 0, 1, {'use': 'optional'}),
        'valueOf_': MemberSpec_('valueOf_', 'xs:base64Binary', 0),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_) + ['valueOf_']
    subclass = None
    superclass = None
    def __init__(self, type_=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, signatureType6)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if signatureType6.subclass:
            return signatureType6.subclass(*args_, **kwargs_)
        else:
            return signatureType6(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_signatureType(self, value):
        # Validate type signatureType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['CAdES-BES', 'CAdES-A']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on signatureType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
            self.validate_signatureType(self.type_)    # validate type signatureType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class signatureType6


class prevDocumentType(GeneratedsSuper):
    """Документы, загруженные в предыдущих размещенных версиях сведений"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'guid': MemberSpec_('guid', ['guidType', 'xs:string'], 0, 0, {'name': 'guid', 'type': 'xs:string'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, guid=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.guid = guid
        self.validate_guidType(self.guid)
        self.guid_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, prevDocumentType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if prevDocumentType.subclass:
            return prevDocumentType.subclass(*args_, **kwargs_)
        else:
            return prevDocumentType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_guidType(self, value):
        result = True
        # Validate type guidType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) != 36:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd length restriction on guidType' % {"value": encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_guidType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_guidType_patterns_, ))
                result = False
        return result
    validate_guidType_patterns_ = [['^([a-fA-F0-9]{8}\\-[a-fA-F0-9]{4}\\-[a-fA-F0-9]{4}\\-[a-fA-F0-9]{4}\\-[a-fA-F0-9]{12})$']]
    def hasContent_(self):
        if (
            self.guid is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'guid':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'guid')
            value_ = self.gds_validate_string(value_, node, 'guid')
            self.guid = value_
            self.guid_nsprefix_ = child_.prefix
            # validate type guidType
            self.validate_guidType(self.guid)
# end class prevDocumentType


class lotDataType(GeneratedsSuper):
    """Данные лота"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'subject': MemberSpec_('subject', ['subjectType', 'nonEmptyString', 'xs:string'], 0, 0, {'name': 'subject', 'type': 'xs:string'}, None),
        'currency': MemberSpec_('currency', 'currencyType', 0, 0, {'name': 'currency', 'type': 'currencyType'}, 12),
        'exchangeInfo': MemberSpec_('exchangeInfo', 'exchangeInfoType', 0, 1, {'minOccurs': '0', 'name': 'exchangeInfo', 'type': 'exchangeInfoType'}, 12),
        'initialSum': MemberSpec_('initialSum', ['money2', 'xs:decimal'], 0, 0, {'name': 'initialSum', 'type': 'xs:decimal'}, 13),
        'startingContractPriceRub': MemberSpec_('startingContractPriceRub', ['money2', 'xs:decimal'], 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'startingContractPriceRub', 'type': 'xs:decimal'}, 13),
        'priceFormula': MemberSpec_('priceFormula', ['priceFormulaType', 'nonEmptyString', 'xs:string'], 0, 1, {'name': 'priceFormula', 'type': 'xs:string'}, 14),
        'commodityPrice': MemberSpec_('commodityPrice', ['money2', 'xs:decimal'], 0, 1, {'name': 'commodityPrice', 'type': 'xs:decimal'}, 14),
        'commodityPriceRub': MemberSpec_('commodityPriceRub', ['money2', 'xs:decimal'], 0, 1, {'minOccurs': '0', 'name': 'commodityPriceRub', 'type': 'xs:decimal'}, 14),
        'maxContractPrice': MemberSpec_('maxContractPrice', ['money2', 'xs:decimal'], 0, 0, {'maxOccurs': '1', 'minOccurs': '1', 'name': 'maxContractPrice', 'type': 'xs:decimal'}, None),
        'maxContractPriceRub': MemberSpec_('maxContractPriceRub', ['money2', 'xs:decimal'], 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'maxContractPriceRub', 'type': 'xs:decimal'}, None),
        'initialSumInfo': MemberSpec_('initialSumInfo', ['initialSumInfoType', 'nonEmptyString', 'xs:string'], 0, 0, {'name': 'initialSumInfo', 'type': 'xs:string'}, None),
        'orderPricing': MemberSpec_('orderPricing', ['orderPricingType', 'nonEmptyString', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'orderPricing', 'type': 'xs:string'}, None),
        'deliveryPlace': MemberSpec_('deliveryPlace', 'deliveryPlaceType', 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'deliveryPlace', 'type': 'deliveryPlaceType'}, None),
        'lotItems': MemberSpec_('lotItems', 'lotItemListType', 0, 1, {'minOccurs': '0', 'name': 'lotItems', 'type': 'lotItemListType'}, None),
        'forSmallOrMiddle': MemberSpec_('forSmallOrMiddle', 'xs:boolean', 0, 1, {'minOccurs': '0', 'name': 'forSmallOrMiddle', 'type': 'xs:boolean'}, None),
        'excludePurchaseFromPlan': MemberSpec_('excludePurchaseFromPlan', 'xs:boolean', 0, 1, {'minOccurs': '0', 'name': 'excludePurchaseFromPlan', 'type': 'xs:boolean'}, None),
        'subcontractorsRequirement': MemberSpec_('subcontractorsRequirement', 'xs:boolean', 0, 1, {'minOccurs': '0', 'name': 'subcontractorsRequirement', 'type': 'xs:boolean'}, None),
        'ignoredPurchase': MemberSpec_('ignoredPurchase', 'xs:boolean', 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'ignoredPurchase', 'type': 'xs:boolean'}, None),
        'purchaseCategory': MemberSpec_('purchaseCategory', 'purchaseCategory', 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'purchaseCategory', 'type': 'purchaseCategory'}, None),
        'centralized': MemberSpec_('centralized', 'xs:boolean', 0, 1, {'minOccurs': '0', 'name': 'centralized', 'type': 'xs:boolean'}, None),
        'purchaseDescription': MemberSpec_('purchaseDescription', ['purchaseDescriptionType', 'nonEmptyString', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'purchaseDescription', 'type': 'xs:string'}, None),
        'applicationSupplyNeeded': MemberSpec_('applicationSupplyNeeded', 'xs:boolean', 0, 1, {'minOccurs': '0', 'name': 'applicationSupplyNeeded', 'type': 'xs:boolean'}, None),
        'applicationSupplySumm': MemberSpec_('applicationSupplySumm', ['money2', 'xs:decimal'], 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'applicationSupplySumm', 'type': 'xs:decimal'}, None),
        'applicationSupplyCurrency': MemberSpec_('applicationSupplyCurrency', 'currencyType', 0, 1, {'minOccurs': '0', 'name': 'applicationSupplyCurrency', 'type': 'currencyType'}, None),
        'applicationSupplyExtra': MemberSpec_('applicationSupplyExtra', ['applicationSupplyExtraType', 'nonEmptyString', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'applicationSupplyExtra', 'type': 'xs:string'}, None),
        'majorContractConditions': MemberSpec_('majorContractConditions', ['majorContractConditionsType', 'nonEmptyString', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'majorContractConditions', 'type': 'xs:string'}, None),
        'antimonopolyDecisionTaken': MemberSpec_('antimonopolyDecisionTaken', 'xs:boolean', 0, 1, {'minOccurs': '0', 'name': 'antimonopolyDecisionTaken', 'type': 'xs:boolean'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, subject=None, currency=None, exchangeInfo=None, initialSum=None, startingContractPriceRub=None, priceFormula=None, commodityPrice=None, commodityPriceRub=None, maxContractPrice=None, maxContractPriceRub=None, initialSumInfo=None, orderPricing=None, deliveryPlace=None, lotItems=None, forSmallOrMiddle=None, excludePurchaseFromPlan=None, subcontractorsRequirement=None, ignoredPurchase=None, purchaseCategory=None, centralized=None, purchaseDescription=None, applicationSupplyNeeded=None, applicationSupplySumm=None, applicationSupplyCurrency=None, applicationSupplyExtra=None, majorContractConditions=None, antimonopolyDecisionTaken=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.subject = subject
        self.validate_subjectType(self.subject)
        self.subject_nsprefix_ = None
        self.currency = currency
        self.currency_nsprefix_ = None
        self.exchangeInfo = exchangeInfo
        self.exchangeInfo_nsprefix_ = None
        self.initialSum = initialSum
        self.validate_money2(self.initialSum)
        self.initialSum_nsprefix_ = None
        self.startingContractPriceRub = startingContractPriceRub
        self.validate_money2(self.startingContractPriceRub)
        self.startingContractPriceRub_nsprefix_ = None
        self.priceFormula = priceFormula
        self.validate_priceFormulaType(self.priceFormula)
        self.priceFormula_nsprefix_ = None
        self.commodityPrice = commodityPrice
        self.validate_money2(self.commodityPrice)
        self.commodityPrice_nsprefix_ = None
        self.commodityPriceRub = commodityPriceRub
        self.validate_money2(self.commodityPriceRub)
        self.commodityPriceRub_nsprefix_ = None
        self.maxContractPrice = maxContractPrice
        self.validate_money2(self.maxContractPrice)
        self.maxContractPrice_nsprefix_ = None
        self.maxContractPriceRub = maxContractPriceRub
        self.validate_money2(self.maxContractPriceRub)
        self.maxContractPriceRub_nsprefix_ = None
        self.initialSumInfo = initialSumInfo
        self.validate_initialSumInfoType(self.initialSumInfo)
        self.initialSumInfo_nsprefix_ = None
        self.orderPricing = orderPricing
        self.validate_orderPricingType(self.orderPricing)
        self.orderPricing_nsprefix_ = None
        self.deliveryPlace = deliveryPlace
        self.deliveryPlace_nsprefix_ = None
        self.lotItems = lotItems
        self.lotItems_nsprefix_ = None
        self.forSmallOrMiddle = forSmallOrMiddle
        self.forSmallOrMiddle_nsprefix_ = None
        self.excludePurchaseFromPlan = excludePurchaseFromPlan
        self.excludePurchaseFromPlan_nsprefix_ = None
        self.subcontractorsRequirement = subcontractorsRequirement
        self.subcontractorsRequirement_nsprefix_ = None
        self.ignoredPurchase = ignoredPurchase
        self.ignoredPurchase_nsprefix_ = None
        self.purchaseCategory = purchaseCategory
        self.purchaseCategory_nsprefix_ = None
        self.centralized = centralized
        self.centralized_nsprefix_ = None
        self.purchaseDescription = purchaseDescription
        self.validate_purchaseDescriptionType(self.purchaseDescription)
        self.purchaseDescription_nsprefix_ = None
        self.applicationSupplyNeeded = applicationSupplyNeeded
        self.applicationSupplyNeeded_nsprefix_ = None
        self.applicationSupplySumm = applicationSupplySumm
        self.validate_money2(self.applicationSupplySumm)
        self.applicationSupplySumm_nsprefix_ = None
        self.applicationSupplyCurrency = applicationSupplyCurrency
        self.applicationSupplyCurrency_nsprefix_ = None
        self.applicationSupplyExtra = applicationSupplyExtra
        self.validate_applicationSupplyExtraType(self.applicationSupplyExtra)
        self.applicationSupplyExtra_nsprefix_ = None
        self.majorContractConditions = majorContractConditions
        self.validate_majorContractConditionsType(self.majorContractConditions)
        self.majorContractConditions_nsprefix_ = None
        self.antimonopolyDecisionTaken = antimonopolyDecisionTaken
        self.antimonopolyDecisionTaken_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, lotDataType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if lotDataType.subclass:
            return lotDataType.subclass(*args_, **kwargs_)
        else:
            return lotDataType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_subjectType(self, value):
        result = True
        # Validate type subjectType, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 2000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on subjectType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on subjectType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_money2(self, value):
        result = True
        # Validate type money2, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, decimal_.Decimal):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (decimal_.Decimal)' % {"value": value, "lineno": lineno, })
                return False
            if len(str(value)) >= 20:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd totalDigits restriction on money2' % {"value": value, "lineno": lineno} )
                result = False
        return result
    def validate_priceFormulaType(self, value):
        result = True
        # Validate type priceFormulaType, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 2000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on priceFormulaType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on priceFormulaType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_initialSumInfoType(self, value):
        result = True
        # Validate type initialSumInfoType, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 2000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on initialSumInfoType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on initialSumInfoType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_orderPricingType(self, value):
        result = True
        # Validate type orderPricingType, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 2000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on orderPricingType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on orderPricingType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_purchaseDescriptionType(self, value):
        result = True
        # Validate type purchaseDescriptionType, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 2000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on purchaseDescriptionType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on purchaseDescriptionType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_applicationSupplyExtraType(self, value):
        result = True
        # Validate type applicationSupplyExtraType, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 2000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on applicationSupplyExtraType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on applicationSupplyExtraType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_majorContractConditionsType(self, value):
        result = True
        # Validate type majorContractConditionsType, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 2000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on majorContractConditionsType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on majorContractConditionsType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.subject is not None or
            self.currency is not None or
            self.exchangeInfo is not None or
            self.initialSum is not None or
            self.startingContractPriceRub is not None or
            self.priceFormula is not None or
            self.commodityPrice is not None or
            self.commodityPriceRub is not None or
            self.maxContractPrice is not None or
            self.maxContractPriceRub is not None or
            self.initialSumInfo is not None or
            self.orderPricing is not None or
            self.deliveryPlace is not None or
            self.lotItems is not None or
            self.forSmallOrMiddle is not None or
            self.excludePurchaseFromPlan is not None or
            self.subcontractorsRequirement is not None or
            self.ignoredPurchase is not None or
            self.purchaseCategory is not None or
            self.centralized is not None or
            self.purchaseDescription is not None or
            self.applicationSupplyNeeded is not None or
            self.applicationSupplySumm is not None or
            self.applicationSupplyCurrency is not None or
            self.applicationSupplyExtra is not None or
            self.majorContractConditions is not None or
            self.antimonopolyDecisionTaken is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'subject':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'subject')
            value_ = self.gds_validate_string(value_, node, 'subject')
            self.subject = value_
            self.subject_nsprefix_ = child_.prefix
            # validate type subjectType
            self.validate_subjectType(self.subject)
        elif nodeName_ == 'currency':
            obj_ = currencyType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.currency = obj_
            obj_.original_tagname_ = 'currency'
        elif nodeName_ == 'exchangeInfo':
            obj_ = exchangeInfoType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.exchangeInfo = obj_
            obj_.original_tagname_ = 'exchangeInfo'
        elif nodeName_ == 'initialSum' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'initialSum')
            fval_ = self.gds_validate_decimal(fval_, node, 'initialSum')
            self.initialSum = fval_
            self.initialSum_nsprefix_ = child_.prefix
            # validate type money2
            self.validate_money2(self.initialSum)
        elif nodeName_ == 'startingContractPriceRub' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'startingContractPriceRub')
            fval_ = self.gds_validate_decimal(fval_, node, 'startingContractPriceRub')
            self.startingContractPriceRub = fval_
            self.startingContractPriceRub_nsprefix_ = child_.prefix
            # validate type money2
            self.validate_money2(self.startingContractPriceRub)
        elif nodeName_ == 'priceFormula':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'priceFormula')
            value_ = self.gds_validate_string(value_, node, 'priceFormula')
            self.priceFormula = value_
            self.priceFormula_nsprefix_ = child_.prefix
            # validate type priceFormulaType
            self.validate_priceFormulaType(self.priceFormula)
        elif nodeName_ == 'commodityPrice' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'commodityPrice')
            fval_ = self.gds_validate_decimal(fval_, node, 'commodityPrice')
            self.commodityPrice = fval_
            self.commodityPrice_nsprefix_ = child_.prefix
            # validate type money2
            self.validate_money2(self.commodityPrice)
        elif nodeName_ == 'commodityPriceRub' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'commodityPriceRub')
            fval_ = self.gds_validate_decimal(fval_, node, 'commodityPriceRub')
            self.commodityPriceRub = fval_
            self.commodityPriceRub_nsprefix_ = child_.prefix
            # validate type money2
            self.validate_money2(self.commodityPriceRub)
        elif nodeName_ == 'maxContractPrice' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'maxContractPrice')
            fval_ = self.gds_validate_decimal(fval_, node, 'maxContractPrice')
            self.maxContractPrice = fval_
            self.maxContractPrice_nsprefix_ = child_.prefix
            # validate type money2
            self.validate_money2(self.maxContractPrice)
        elif nodeName_ == 'maxContractPriceRub' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'maxContractPriceRub')
            fval_ = self.gds_validate_decimal(fval_, node, 'maxContractPriceRub')
            self.maxContractPriceRub = fval_
            self.maxContractPriceRub_nsprefix_ = child_.prefix
            # validate type money2
            self.validate_money2(self.maxContractPriceRub)
        elif nodeName_ == 'initialSumInfo':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'initialSumInfo')
            value_ = self.gds_validate_string(value_, node, 'initialSumInfo')
            self.initialSumInfo = value_
            self.initialSumInfo_nsprefix_ = child_.prefix
            # validate type initialSumInfoType
            self.validate_initialSumInfoType(self.initialSumInfo)
        elif nodeName_ == 'orderPricing':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'orderPricing')
            value_ = self.gds_validate_string(value_, node, 'orderPricing')
            self.orderPricing = value_
            self.orderPricing_nsprefix_ = child_.prefix
            # validate type orderPricingType
            self.validate_orderPricingType(self.orderPricing)
        elif nodeName_ == 'deliveryPlace':
            obj_ = deliveryPlaceType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.deliveryPlace = obj_
            obj_.original_tagname_ = 'deliveryPlace'
        elif nodeName_ == 'lotItems':
            obj_ = lotItemListType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.lotItems = obj_
            obj_.original_tagname_ = 'lotItems'
        elif nodeName_ == 'forSmallOrMiddle':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'forSmallOrMiddle')
            ival_ = self.gds_validate_boolean(ival_, node, 'forSmallOrMiddle')
            self.forSmallOrMiddle = ival_
            self.forSmallOrMiddle_nsprefix_ = child_.prefix
        elif nodeName_ == 'excludePurchaseFromPlan':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'excludePurchaseFromPlan')
            ival_ = self.gds_validate_boolean(ival_, node, 'excludePurchaseFromPlan')
            self.excludePurchaseFromPlan = ival_
            self.excludePurchaseFromPlan_nsprefix_ = child_.prefix
        elif nodeName_ == 'subcontractorsRequirement':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'subcontractorsRequirement')
            ival_ = self.gds_validate_boolean(ival_, node, 'subcontractorsRequirement')
            self.subcontractorsRequirement = ival_
            self.subcontractorsRequirement_nsprefix_ = child_.prefix
        elif nodeName_ == 'ignoredPurchase':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'ignoredPurchase')
            ival_ = self.gds_validate_boolean(ival_, node, 'ignoredPurchase')
            self.ignoredPurchase = ival_
            self.ignoredPurchase_nsprefix_ = child_.prefix
        elif nodeName_ == 'purchaseCategory':
            obj_ = purchaseCategory.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.purchaseCategory = obj_
            obj_.original_tagname_ = 'purchaseCategory'
        elif nodeName_ == 'centralized':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'centralized')
            ival_ = self.gds_validate_boolean(ival_, node, 'centralized')
            self.centralized = ival_
            self.centralized_nsprefix_ = child_.prefix
        elif nodeName_ == 'purchaseDescription':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'purchaseDescription')
            value_ = self.gds_validate_string(value_, node, 'purchaseDescription')
            self.purchaseDescription = value_
            self.purchaseDescription_nsprefix_ = child_.prefix
            # validate type purchaseDescriptionType
            self.validate_purchaseDescriptionType(self.purchaseDescription)
        elif nodeName_ == 'applicationSupplyNeeded':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'applicationSupplyNeeded')
            ival_ = self.gds_validate_boolean(ival_, node, 'applicationSupplyNeeded')
            self.applicationSupplyNeeded = ival_
            self.applicationSupplyNeeded_nsprefix_ = child_.prefix
        elif nodeName_ == 'applicationSupplySumm' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'applicationSupplySumm')
            fval_ = self.gds_validate_decimal(fval_, node, 'applicationSupplySumm')
            self.applicationSupplySumm = fval_
            self.applicationSupplySumm_nsprefix_ = child_.prefix
            # validate type money2
            self.validate_money2(self.applicationSupplySumm)
        elif nodeName_ == 'applicationSupplyCurrency':
            obj_ = currencyType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.applicationSupplyCurrency = obj_
            obj_.original_tagname_ = 'applicationSupplyCurrency'
        elif nodeName_ == 'applicationSupplyExtra':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'applicationSupplyExtra')
            value_ = self.gds_validate_string(value_, node, 'applicationSupplyExtra')
            self.applicationSupplyExtra = value_
            self.applicationSupplyExtra_nsprefix_ = child_.prefix
            # validate type applicationSupplyExtraType
            self.validate_applicationSupplyExtraType(self.applicationSupplyExtra)
        elif nodeName_ == 'majorContractConditions':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'majorContractConditions')
            value_ = self.gds_validate_string(value_, node, 'majorContractConditions')
            self.majorContractConditions = value_
            self.majorContractConditions_nsprefix_ = child_.prefix
            # validate type majorContractConditionsType
            self.validate_majorContractConditionsType(self.majorContractConditions)
        elif nodeName_ == 'antimonopolyDecisionTaken':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'antimonopolyDecisionTaken')
            ival_ = self.gds_validate_boolean(ival_, node, 'antimonopolyDecisionTaken')
            self.antimonopolyDecisionTaken = ival_
            self.antimonopolyDecisionTaken_nsprefix_ = child_.prefix
# end class lotDataType


class exchangeInfoType(GeneratedsSuper):
    """Информация о курсе валют"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'exchangeRate': MemberSpec_('exchangeRate', ['money6', 'xs:decimal'], 0, 0, {'maxOccurs': '1', 'minOccurs': '1', 'name': 'exchangeRate', 'type': 'xs:decimal'}, None),
        'exchangeRateDate': MemberSpec_('exchangeRateDate', 'xs:date', 0, 0, {'maxOccurs': '1', 'minOccurs': '1', 'name': 'exchangeRateDate', 'type': 'xs:date'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, exchangeRate=None, exchangeRateDate=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.exchangeRate = exchangeRate
        self.validate_money6(self.exchangeRate)
        self.exchangeRate_nsprefix_ = None
        if isinstance(exchangeRateDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(exchangeRateDate, '%Y-%m-%d').date()
        else:
            initvalue_ = exchangeRateDate
        self.exchangeRateDate = initvalue_
        self.exchangeRateDate_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, exchangeInfoType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if exchangeInfoType.subclass:
            return exchangeInfoType.subclass(*args_, **kwargs_)
        else:
            return exchangeInfoType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_money6(self, value):
        result = True
        # Validate type money6, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, decimal_.Decimal):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (decimal_.Decimal)' % {"value": value, "lineno": lineno, })
                return False
            pass
        return result
    def hasContent_(self):
        if (
            self.exchangeRate is not None or
            self.exchangeRateDate is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'exchangeRate' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'exchangeRate')
            fval_ = self.gds_validate_decimal(fval_, node, 'exchangeRate')
            self.exchangeRate = fval_
            self.exchangeRate_nsprefix_ = child_.prefix
            # validate type money6
            self.validate_money6(self.exchangeRate)
        elif nodeName_ == 'exchangeRateDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.exchangeRateDate = dval_
            self.exchangeRateDate_nsprefix_ = child_.prefix
# end class exchangeInfoType


class jointLotDataType(GeneratedsSuper):
    """Данные по совместной закупке"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'jointLot': MemberSpec_('jointLot', 'xs:boolean', 0, 0, {'name': 'jointLot', 'type': 'xs:boolean'}, None),
        'lotCustomers': MemberSpec_('lotCustomers', 'lotCustomerListType', 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'lotCustomers', 'type': 'lotCustomerListType'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, jointLot=None, lotCustomers=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.jointLot = jointLot
        self.jointLot_nsprefix_ = None
        self.lotCustomers = lotCustomers
        self.lotCustomers_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, jointLotDataType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if jointLotDataType.subclass:
            return jointLotDataType.subclass(*args_, **kwargs_)
        else:
            return jointLotDataType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.jointLot is not None or
            self.lotCustomers is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'jointLot':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'jointLot')
            ival_ = self.gds_validate_boolean(ival_, node, 'jointLot')
            self.jointLot = ival_
            self.jointLot_nsprefix_ = child_.prefix
        elif nodeName_ == 'lotCustomers':
            obj_ = lotCustomerListType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.lotCustomers = obj_
            obj_.original_tagname_ = 'lotCustomers'
# end class jointLotDataType


class lotApplcationsCriteriaType(GeneratedsSuper):
    """Сылка на критерий по лоту протокола"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'lotApplcationsCriteriaGuid': MemberSpec_('lotApplcationsCriteriaGuid', ['guidType', 'xs:string'], 0, 0, {'name': 'lotApplcationsCriteriaGuid', 'type': 'xs:string'}, None),
        'name': MemberSpec_('name', ['nameType37', 'nonEmptyString', 'xs:string'], 0, 0, {'name': 'name', 'type': 'xs:string'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, lotApplcationsCriteriaGuid=None, name=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.lotApplcationsCriteriaGuid = lotApplcationsCriteriaGuid
        self.validate_guidType(self.lotApplcationsCriteriaGuid)
        self.lotApplcationsCriteriaGuid_nsprefix_ = None
        self.name = name
        self.validate_nameType37(self.name)
        self.name_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, lotApplcationsCriteriaType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if lotApplcationsCriteriaType.subclass:
            return lotApplcationsCriteriaType.subclass(*args_, **kwargs_)
        else:
            return lotApplcationsCriteriaType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_guidType(self, value):
        result = True
        # Validate type guidType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) != 36:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd length restriction on guidType' % {"value": encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_guidType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_guidType_patterns_, ))
                result = False
        return result
    validate_guidType_patterns_ = [['^([a-fA-F0-9]{8}\\-[a-fA-F0-9]{4}\\-[a-fA-F0-9]{4}\\-[a-fA-F0-9]{4}\\-[a-fA-F0-9]{12})$']]
    def validate_nameType37(self, value):
        result = True
        # Validate type nameType37, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 500:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on nameType37' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on nameType37' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.lotApplcationsCriteriaGuid is not None or
            self.name is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'lotApplcationsCriteriaGuid':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'lotApplcationsCriteriaGuid')
            value_ = self.gds_validate_string(value_, node, 'lotApplcationsCriteriaGuid')
            self.lotApplcationsCriteriaGuid = value_
            self.lotApplcationsCriteriaGuid_nsprefix_ = child_.prefix
            # validate type guidType
            self.validate_guidType(self.lotApplcationsCriteriaGuid)
        elif nodeName_ == 'name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'name')
            value_ = self.gds_validate_string(value_, node, 'name')
            self.name = value_
            self.name_nsprefix_ = child_.prefix
            # validate type nameType37
            self.validate_nameType37(self.name)
# end class lotApplcationsCriteriaType


class lotCustomerDataType(GeneratedsSuper):
    """Данные лота совместной закупки"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'currency': MemberSpec_('currency', 'currencyType', 0, 0, {'name': 'currency', 'type': 'currencyType'}, None),
        'exchangeInfo': MemberSpec_('exchangeInfo', 'exchangeInfoType42', 0, 1, {'minOccurs': '0', 'name': 'exchangeInfo', 'type': 'exchangeInfoType42'}, None),
        'initialSum': MemberSpec_('initialSum', ['money2', 'xs:decimal'], 0, 0, {'name': 'initialSum', 'type': 'xs:decimal'}, 15),
        'startingContractPriceRub': MemberSpec_('startingContractPriceRub', ['money2', 'xs:decimal'], 0, 1, {'minOccurs': '0', 'name': 'startingContractPriceRub', 'type': 'xs:decimal'}, 15),
        'priceFormula': MemberSpec_('priceFormula', ['priceFormulaType43', 'nonEmptyString', 'xs:string'], 0, 1, {'name': 'priceFormula', 'type': 'xs:string'}, 16),
        'price': MemberSpec_('price', ['money2', 'xs:decimal'], 0, 1, {'name': 'price', 'type': 'xs:decimal'}, 16),
        'priceRub': MemberSpec_('priceRub', ['money2', 'xs:decimal'], 0, 1, {'minOccurs': '0', 'name': 'priceRub', 'type': 'xs:decimal'}, 16),
        'maxContractPrice': MemberSpec_('maxContractPrice', ['money2', 'xs:decimal'], 0, 1, {'minOccurs': '0', 'name': 'maxContractPrice', 'type': 'xs:decimal'}, None),
        'maxContractPriceRub': MemberSpec_('maxContractPriceRub', ['money2', 'xs:decimal'], 0, 1, {'minOccurs': '0', 'name': 'maxContractPriceRub', 'type': 'xs:decimal'}, None),
        'excludePurchaseFromPlan': MemberSpec_('excludePurchaseFromPlan', 'xs:boolean', 0, 1, {'minOccurs': '0', 'name': 'excludePurchaseFromPlan', 'type': 'xs:boolean'}, None),
        'orderPricing': MemberSpec_('orderPricing', ['orderPricingType44', 'nonEmptyString', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'orderPricing', 'type': 'xs:string'}, None),
        'deliveryPlace': MemberSpec_('deliveryPlace', 'deliveryPlaceType', 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'deliveryPlace', 'type': 'deliveryPlaceType'}, None),
        'lotItems': MemberSpec_('lotItems', 'lotItemListType', 0, 1, {'minOccurs': '0', 'name': 'lotItems', 'type': 'lotItemListType'}, None),
        'notInLaw223': MemberSpec_('notInLaw223', 'xs:boolean', 0, 1, {'minOccurs': '0', 'name': 'notInLaw223', 'type': 'xs:boolean'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, currency=None, exchangeInfo=None, initialSum=None, startingContractPriceRub=None, priceFormula=None, price=None, priceRub=None, maxContractPrice=None, maxContractPriceRub=None, excludePurchaseFromPlan=None, orderPricing=None, deliveryPlace=None, lotItems=None, notInLaw223=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.currency = currency
        self.currency_nsprefix_ = None
        self.exchangeInfo = exchangeInfo
        self.exchangeInfo_nsprefix_ = None
        self.initialSum = initialSum
        self.validate_money2(self.initialSum)
        self.initialSum_nsprefix_ = None
        self.startingContractPriceRub = startingContractPriceRub
        self.validate_money2(self.startingContractPriceRub)
        self.startingContractPriceRub_nsprefix_ = None
        self.priceFormula = priceFormula
        self.validate_priceFormulaType43(self.priceFormula)
        self.priceFormula_nsprefix_ = None
        self.price = price
        self.validate_money2(self.price)
        self.price_nsprefix_ = None
        self.priceRub = priceRub
        self.validate_money2(self.priceRub)
        self.priceRub_nsprefix_ = None
        self.maxContractPrice = maxContractPrice
        self.validate_money2(self.maxContractPrice)
        self.maxContractPrice_nsprefix_ = None
        self.maxContractPriceRub = maxContractPriceRub
        self.validate_money2(self.maxContractPriceRub)
        self.maxContractPriceRub_nsprefix_ = None
        self.excludePurchaseFromPlan = excludePurchaseFromPlan
        self.excludePurchaseFromPlan_nsprefix_ = None
        self.orderPricing = orderPricing
        self.validate_orderPricingType44(self.orderPricing)
        self.orderPricing_nsprefix_ = None
        self.deliveryPlace = deliveryPlace
        self.deliveryPlace_nsprefix_ = None
        self.lotItems = lotItems
        self.lotItems_nsprefix_ = None
        self.notInLaw223 = notInLaw223
        self.notInLaw223_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, lotCustomerDataType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if lotCustomerDataType.subclass:
            return lotCustomerDataType.subclass(*args_, **kwargs_)
        else:
            return lotCustomerDataType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_money2(self, value):
        result = True
        # Validate type money2, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, decimal_.Decimal):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (decimal_.Decimal)' % {"value": value, "lineno": lineno, })
                return False
            if len(str(value)) >= 20:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd totalDigits restriction on money2' % {"value": value, "lineno": lineno} )
                result = False
        return result
    def validate_priceFormulaType43(self, value):
        result = True
        # Validate type priceFormulaType43, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 2000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on priceFormulaType43' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on priceFormulaType43' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_orderPricingType44(self, value):
        result = True
        # Validate type orderPricingType44, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 2000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on orderPricingType44' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on orderPricingType44' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.currency is not None or
            self.exchangeInfo is not None or
            self.initialSum is not None or
            self.startingContractPriceRub is not None or
            self.priceFormula is not None or
            self.price is not None or
            self.priceRub is not None or
            self.maxContractPrice is not None or
            self.maxContractPriceRub is not None or
            self.excludePurchaseFromPlan is not None or
            self.orderPricing is not None or
            self.deliveryPlace is not None or
            self.lotItems is not None or
            self.notInLaw223 is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'currency':
            obj_ = currencyType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.currency = obj_
            obj_.original_tagname_ = 'currency'
        elif nodeName_ == 'exchangeInfo':
            obj_ = exchangeInfoType42.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.exchangeInfo = obj_
            obj_.original_tagname_ = 'exchangeInfo'
        elif nodeName_ == 'initialSum' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'initialSum')
            fval_ = self.gds_validate_decimal(fval_, node, 'initialSum')
            self.initialSum = fval_
            self.initialSum_nsprefix_ = child_.prefix
            # validate type money2
            self.validate_money2(self.initialSum)
        elif nodeName_ == 'startingContractPriceRub' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'startingContractPriceRub')
            fval_ = self.gds_validate_decimal(fval_, node, 'startingContractPriceRub')
            self.startingContractPriceRub = fval_
            self.startingContractPriceRub_nsprefix_ = child_.prefix
            # validate type money2
            self.validate_money2(self.startingContractPriceRub)
        elif nodeName_ == 'priceFormula':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'priceFormula')
            value_ = self.gds_validate_string(value_, node, 'priceFormula')
            self.priceFormula = value_
            self.priceFormula_nsprefix_ = child_.prefix
            # validate type priceFormulaType43
            self.validate_priceFormulaType43(self.priceFormula)
        elif nodeName_ == 'price' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'price')
            fval_ = self.gds_validate_decimal(fval_, node, 'price')
            self.price = fval_
            self.price_nsprefix_ = child_.prefix
            # validate type money2
            self.validate_money2(self.price)
        elif nodeName_ == 'priceRub' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'priceRub')
            fval_ = self.gds_validate_decimal(fval_, node, 'priceRub')
            self.priceRub = fval_
            self.priceRub_nsprefix_ = child_.prefix
            # validate type money2
            self.validate_money2(self.priceRub)
        elif nodeName_ == 'maxContractPrice' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'maxContractPrice')
            fval_ = self.gds_validate_decimal(fval_, node, 'maxContractPrice')
            self.maxContractPrice = fval_
            self.maxContractPrice_nsprefix_ = child_.prefix
            # validate type money2
            self.validate_money2(self.maxContractPrice)
        elif nodeName_ == 'maxContractPriceRub' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'maxContractPriceRub')
            fval_ = self.gds_validate_decimal(fval_, node, 'maxContractPriceRub')
            self.maxContractPriceRub = fval_
            self.maxContractPriceRub_nsprefix_ = child_.prefix
            # validate type money2
            self.validate_money2(self.maxContractPriceRub)
        elif nodeName_ == 'excludePurchaseFromPlan':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'excludePurchaseFromPlan')
            ival_ = self.gds_validate_boolean(ival_, node, 'excludePurchaseFromPlan')
            self.excludePurchaseFromPlan = ival_
            self.excludePurchaseFromPlan_nsprefix_ = child_.prefix
        elif nodeName_ == 'orderPricing':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'orderPricing')
            value_ = self.gds_validate_string(value_, node, 'orderPricing')
            self.orderPricing = value_
            self.orderPricing_nsprefix_ = child_.prefix
            # validate type orderPricingType44
            self.validate_orderPricingType44(self.orderPricing)
        elif nodeName_ == 'deliveryPlace':
            obj_ = deliveryPlaceType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.deliveryPlace = obj_
            obj_.original_tagname_ = 'deliveryPlace'
        elif nodeName_ == 'lotItems':
            obj_ = lotItemListType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.lotItems = obj_
            obj_.original_tagname_ = 'lotItems'
        elif nodeName_ == 'notInLaw223':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'notInLaw223')
            ival_ = self.gds_validate_boolean(ival_, node, 'notInLaw223')
            self.notInLaw223 = ival_
            self.notInLaw223_nsprefix_ = child_.prefix
# end class lotCustomerDataType


class exchangeInfoType42(GeneratedsSuper):
    """Информация о курсе валют"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'exchangeRate': MemberSpec_('exchangeRate', ['money6', 'xs:decimal'], 0, 0, {'name': 'exchangeRate', 'type': 'xs:decimal'}, None),
        'exchangeRateDate': MemberSpec_('exchangeRateDate', 'xs:date', 0, 0, {'name': 'exchangeRateDate', 'type': 'xs:date'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, exchangeRate=None, exchangeRateDate=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.exchangeRate = exchangeRate
        self.validate_money6(self.exchangeRate)
        self.exchangeRate_nsprefix_ = None
        if isinstance(exchangeRateDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(exchangeRateDate, '%Y-%m-%d').date()
        else:
            initvalue_ = exchangeRateDate
        self.exchangeRateDate = initvalue_
        self.exchangeRateDate_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, exchangeInfoType42)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if exchangeInfoType42.subclass:
            return exchangeInfoType42.subclass(*args_, **kwargs_)
        else:
            return exchangeInfoType42(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_money6(self, value):
        result = True
        # Validate type money6, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, decimal_.Decimal):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (decimal_.Decimal)' % {"value": value, "lineno": lineno, })
                return False
            pass
        return result
    def hasContent_(self):
        if (
            self.exchangeRate is not None or
            self.exchangeRateDate is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'exchangeRate' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'exchangeRate')
            fval_ = self.gds_validate_decimal(fval_, node, 'exchangeRate')
            self.exchangeRate = fval_
            self.exchangeRate_nsprefix_ = child_.prefix
            # validate type money6
            self.validate_money6(self.exchangeRate)
        elif nodeName_ == 'exchangeRateDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.exchangeRateDate = dval_
            self.exchangeRateDate_nsprefix_ = child_.prefix
# end class exchangeInfoType42


class lotDataType58(GeneratedsSuper):
    """Данные о лоте"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'guid': MemberSpec_('guid', ['guidType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'guid', 'type': 'xs:string'}, None),
        'ordinalNumber': MemberSpec_('ordinalNumber', 'xs:int', 0, 1, {'name': 'ordinalNumber', 'type': 'xs:int'}, 17),
        'ordinalNumberText': MemberSpec_('ordinalNumberText', ['ordinalNumberTextType', 'nonEmptyString', 'xs:string'], 0, 1, {'name': 'ordinalNumberText', 'type': 'xs:string'}, 17),
        'lotName': MemberSpec_('lotName', ['lotNameType', 'nonEmptyString', 'xs:string'], 0, 0, {'name': 'lotName', 'type': 'xs:string'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, guid=None, ordinalNumber=None, ordinalNumberText=None, lotName=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.guid = guid
        self.validate_guidType(self.guid)
        self.guid_nsprefix_ = None
        self.ordinalNumber = ordinalNumber
        self.ordinalNumber_nsprefix_ = None
        self.ordinalNumberText = ordinalNumberText
        self.validate_ordinalNumberTextType(self.ordinalNumberText)
        self.ordinalNumberText_nsprefix_ = None
        self.lotName = lotName
        self.validate_lotNameType(self.lotName)
        self.lotName_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, lotDataType58)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if lotDataType58.subclass:
            return lotDataType58.subclass(*args_, **kwargs_)
        else:
            return lotDataType58(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_guidType(self, value):
        result = True
        # Validate type guidType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) != 36:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd length restriction on guidType' % {"value": encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_guidType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_guidType_patterns_, ))
                result = False
        return result
    validate_guidType_patterns_ = [['^([a-fA-F0-9]{8}\\-[a-fA-F0-9]{4}\\-[a-fA-F0-9]{4}\\-[a-fA-F0-9]{4}\\-[a-fA-F0-9]{12})$']]
    def validate_ordinalNumberTextType(self, value):
        result = True
        # Validate type ordinalNumberTextType, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 100:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ordinalNumberTextType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ordinalNumberTextType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_lotNameType(self, value):
        result = True
        # Validate type lotNameType, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 2000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on lotNameType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on lotNameType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.guid is not None or
            self.ordinalNumber is not None or
            self.ordinalNumberText is not None or
            self.lotName is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'guid':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'guid')
            value_ = self.gds_validate_string(value_, node, 'guid')
            self.guid = value_
            self.guid_nsprefix_ = child_.prefix
            # validate type guidType
            self.validate_guidType(self.guid)
        elif nodeName_ == 'ordinalNumber' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'ordinalNumber')
            ival_ = self.gds_validate_integer(ival_, node, 'ordinalNumber')
            self.ordinalNumber = ival_
            self.ordinalNumber_nsprefix_ = child_.prefix
        elif nodeName_ == 'ordinalNumberText':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'ordinalNumberText')
            value_ = self.gds_validate_string(value_, node, 'ordinalNumberText')
            self.ordinalNumberText = value_
            self.ordinalNumberText_nsprefix_ = child_.prefix
            # validate type ordinalNumberTextType
            self.validate_ordinalNumberTextType(self.ordinalNumberText)
        elif nodeName_ == 'lotName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'lotName')
            value_ = self.gds_validate_string(value_, node, 'lotName')
            self.lotName = value_
            self.lotName_nsprefix_ = child_.prefix
            # validate type lotNameType
            self.validate_lotNameType(self.lotName)
# end class lotDataType58


class fixedColumnsDataType(GeneratedsSuper):
    """Значения для строк, выводимых в первой колонке табличного представления
    с фиксированным количеством строк"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'colValue': MemberSpec_('colValue', ['colValueType', 'nonEmptyString', 'xs:string'], 1, 0, {'maxOccurs': 'unbounded', 'minOccurs': '1', 'name': 'colValue', 'type': 'xs:string'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, colValue=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if colValue is None:
            self.colValue = []
        else:
            self.colValue = colValue
        self.colValue_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, fixedColumnsDataType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if fixedColumnsDataType.subclass:
            return fixedColumnsDataType.subclass(*args_, **kwargs_)
        else:
            return fixedColumnsDataType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_colValueType(self, value):
        result = True
        # Validate type colValueType, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 100:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on colValueType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on colValueType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.colValue
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'colValue':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'colValue')
            value_ = self.gds_validate_string(value_, node, 'colValue')
            self.colValue.append(value_)
            self.colValue_nsprefix_ = child_.prefix
            # validate type colValueType
            self.validate_colValueType(self.colValue[-1])
# end class fixedColumnsDataType


class columnsType(GeneratedsSuper):
    """Столбцы табличного представления"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'column': MemberSpec_('column', 'templateTableColumnType', 1, 0, {'maxOccurs': '10', 'minOccurs': '1', 'name': 'column', 'type': 'templateTableColumnType'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, column=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if column is None:
            self.column = []
        else:
            self.column = column
        self.column_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, columnsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if columnsType.subclass:
            return columnsType.subclass(*args_, **kwargs_)
        else:
            return columnsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.column
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'column':
            obj_ = templateTableColumnType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.column.append(obj_)
            obj_.original_tagname_ = 'column'
# end class columnsType


class nsiType(GeneratedsSuper):
    """Значение из справочника"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'currency': MemberSpec_('currency', 'currencyType', 0, 0, {'name': 'currency', 'type': 'currencyType'}, 18),
        'okei': MemberSpec_('okei', 'okeiProductType', 0, 0, {'name': 'okei', 'type': 'okeiProductType'}, 18),
        'okdp': MemberSpec_('okdp', 'okdpProductType', 0, 0, {'name': 'okdp', 'type': 'okdpProductType'}, 18),
        'okpd2': MemberSpec_('okpd2', 'okpd2ProductType', 0, 0, {'name': 'okpd2', 'type': 'okpd2ProductType'}, 18),
        'okved': MemberSpec_('okved', 'okvedProductType', 0, 0, {'name': 'okved', 'type': 'okvedProductType'}, 18),
        'okved2': MemberSpec_('okved2', 'okved2ProductType', 0, 0, {'name': 'okved2', 'type': 'okved2ProductType'}, 18),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, currency=None, okei=None, okdp=None, okpd2=None, okved=None, okved2=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.currency = currency
        self.currency_nsprefix_ = None
        self.okei = okei
        self.okei_nsprefix_ = None
        self.okdp = okdp
        self.okdp_nsprefix_ = None
        self.okpd2 = okpd2
        self.okpd2_nsprefix_ = None
        self.okved = okved
        self.okved_nsprefix_ = None
        self.okved2 = okved2
        self.okved2_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, nsiType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if nsiType.subclass:
            return nsiType.subclass(*args_, **kwargs_)
        else:
            return nsiType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.currency is not None or
            self.okei is not None or
            self.okdp is not None or
            self.okpd2 is not None or
            self.okved is not None or
            self.okved2 is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'currency':
            obj_ = currencyType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.currency = obj_
            obj_.original_tagname_ = 'currency'
        elif nodeName_ == 'okei':
            obj_ = okeiProductType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.okei = obj_
            obj_.original_tagname_ = 'okei'
        elif nodeName_ == 'okdp':
            obj_ = okdpProductType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.okdp = obj_
            obj_.original_tagname_ = 'okdp'
        elif nodeName_ == 'okpd2':
            obj_ = okpd2ProductType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.okpd2 = obj_
            obj_.original_tagname_ = 'okpd2'
        elif nodeName_ == 'okved':
            obj_ = okvedProductType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.okved = obj_
            obj_.original_tagname_ = 'okved'
        elif nodeName_ == 'okved2':
            obj_ = okved2ProductType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.okved2 = obj_
            obj_.original_tagname_ = 'okved2'
# end class nsiType


class tableType(GeneratedsSuper):
    """Табличное представление"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'rows': MemberSpec_('rows', 'rowsType', 0, 0, {'name': 'rows', 'type': 'rowsType'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, rows=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.rows = rows
        self.rows_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tableType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tableType.subclass:
            return tableType.subclass(*args_, **kwargs_)
        else:
            return tableType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.rows is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'rows':
            obj_ = rowsType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.rows = obj_
            obj_.original_tagname_ = 'rows'
# end class tableType


class rowsType(GeneratedsSuper):
    """Строки табличного представления"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'row': MemberSpec_('row', 'extendTableRowType', 1, 0, {'maxOccurs': 'unbounded', 'minOccurs': '1', 'name': 'row', 'type': 'extendTableRowType'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, row=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if row is None:
            self.row = []
        else:
            self.row = row
        self.row_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, rowsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if rowsType.subclass:
            return rowsType.subclass(*args_, **kwargs_)
        else:
            return rowsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.row
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'row':
            obj_ = extendTableRowType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.row.append(obj_)
            obj_.original_tagname_ = 'row'
# end class rowsType


class nsiType74(GeneratedsSuper):
    """Значение из справочника"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'currency': MemberSpec_('currency', 'currencyType', 0, 0, {'name': 'currency', 'type': 'currencyType'}, 19),
        'okei': MemberSpec_('okei', 'okeiProductType', 0, 0, {'name': 'okei', 'type': 'okeiProductType'}, 19),
        'okdp': MemberSpec_('okdp', 'okdpProductType', 0, 0, {'name': 'okdp', 'type': 'okdpProductType'}, 19),
        'okpd2': MemberSpec_('okpd2', 'okpd2ProductType', 0, 0, {'name': 'okpd2', 'type': 'okpd2ProductType'}, 19),
        'okved': MemberSpec_('okved', 'okvedProductType', 0, 0, {'name': 'okved', 'type': 'okvedProductType'}, 19),
        'okved2': MemberSpec_('okved2', 'okved2ProductType', 0, 0, {'name': 'okved2', 'type': 'okved2ProductType'}, 19),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, currency=None, okei=None, okdp=None, okpd2=None, okved=None, okved2=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.currency = currency
        self.currency_nsprefix_ = None
        self.okei = okei
        self.okei_nsprefix_ = None
        self.okdp = okdp
        self.okdp_nsprefix_ = None
        self.okpd2 = okpd2
        self.okpd2_nsprefix_ = None
        self.okved = okved
        self.okved_nsprefix_ = None
        self.okved2 = okved2
        self.okved2_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, nsiType74)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if nsiType74.subclass:
            return nsiType74.subclass(*args_, **kwargs_)
        else:
            return nsiType74(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.currency is not None or
            self.okei is not None or
            self.okdp is not None or
            self.okpd2 is not None or
            self.okved is not None or
            self.okved2 is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'currency':
            obj_ = currencyType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.currency = obj_
            obj_.original_tagname_ = 'currency'
        elif nodeName_ == 'okei':
            obj_ = okeiProductType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.okei = obj_
            obj_.original_tagname_ = 'okei'
        elif nodeName_ == 'okdp':
            obj_ = okdpProductType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.okdp = obj_
            obj_.original_tagname_ = 'okdp'
        elif nodeName_ == 'okpd2':
            obj_ = okpd2ProductType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.okpd2 = obj_
            obj_.original_tagname_ = 'okpd2'
        elif nodeName_ == 'okved':
            obj_ = okvedProductType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.okved = obj_
            obj_.original_tagname_ = 'okved'
        elif nodeName_ == 'okved2':
            obj_ = okved2ProductType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.okved2 = obj_
            obj_.original_tagname_ = 'okved2'
# end class nsiType74


class sectionType(GeneratedsSuper):
    """Описание раздела шаблона"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'sectionOrdinal': MemberSpec_('sectionOrdinal', 'xs:long', 0, 0, {'name': 'sectionOrdinal', 'type': 'xs:long'}, None),
        'sectionName': MemberSpec_('sectionName', ['sectionNameType77', 'nonEmptyString', 'xs:string'], 0, 0, {'name': 'sectionName', 'type': 'xs:string'}, None),
        'fixedName': MemberSpec_('fixedName', ['fixedNameType78', 'nonEmptyString', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'fixedName', 'type': 'xs:string'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, sectionOrdinal=None, sectionName=None, fixedName=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.sectionOrdinal = sectionOrdinal
        self.sectionOrdinal_nsprefix_ = None
        self.sectionName = sectionName
        self.validate_sectionNameType77(self.sectionName)
        self.sectionName_nsprefix_ = None
        self.fixedName = fixedName
        self.validate_fixedNameType78(self.fixedName)
        self.fixedName_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, sectionType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if sectionType.subclass:
            return sectionType.subclass(*args_, **kwargs_)
        else:
            return sectionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_sectionNameType77(self, value):
        result = True
        # Validate type sectionNameType77, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 130:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on sectionNameType77' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on sectionNameType77' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_fixedNameType78(self, value):
        result = True
        # Validate type fixedNameType78, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 130:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on fixedNameType78' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on fixedNameType78' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.sectionOrdinal is not None or
            self.sectionName is not None or
            self.fixedName is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'sectionOrdinal' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'sectionOrdinal')
            ival_ = self.gds_validate_integer(ival_, node, 'sectionOrdinal')
            self.sectionOrdinal = ival_
            self.sectionOrdinal_nsprefix_ = child_.prefix
        elif nodeName_ == 'sectionName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'sectionName')
            value_ = self.gds_validate_string(value_, node, 'sectionName')
            self.sectionName = value_
            self.sectionName_nsprefix_ = child_.prefix
            # validate type sectionNameType77
            self.validate_sectionNameType77(self.sectionName)
        elif nodeName_ == 'fixedName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'fixedName')
            value_ = self.gds_validate_string(value_, node, 'fixedName')
            self.fixedName = value_
            self.fixedName_nsprefix_ = child_.prefix
            # validate type fixedNameType78
            self.validate_fixedNameType78(self.fixedName)
# end class sectionType


class lotApplicationsCriteriaType(baseCriteriaType):
    """Критерий по лоту протокола"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = baseCriteriaType
    def __init__(self, guid=None, name=None, description=None, maxValue=None, weight=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(lotApplicationsCriteriaType, self).__init__(guid, name, description, maxValue, weight,  **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, lotApplicationsCriteriaType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if lotApplicationsCriteriaType.subclass:
            return lotApplicationsCriteriaType.subclass(*args_, **kwargs_)
        else:
            return lotApplicationsCriteriaType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(lotApplicationsCriteriaType, self).hasContent_()
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(lotApplicationsCriteriaType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(lotApplicationsCriteriaType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class lotApplicationsCriteriaType


class lotCriteriaType(baseCriteriaType):
    """Критерий по лоту"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = baseCriteriaType
    def __init__(self, guid=None, name=None, description=None, maxValue=None, weight=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(lotCriteriaType, self).__init__(guid, name, description, maxValue, weight,  **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, lotCriteriaType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if lotCriteriaType.subclass:
            return lotCriteriaType.subclass(*args_, **kwargs_)
        else:
            return lotCriteriaType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(lotCriteriaType, self).hasContent_()
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(lotCriteriaType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(lotCriteriaType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class lotCriteriaType


class processingInfoResponse(packetType):
    """Ответ на запрос статуса загрузки"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'body': MemberSpec_('body', 'bodyType5', 0, 0, {'name': 'body', 'type': 'bodyType5'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = packetType
    def __init__(self, header=None, signature=None, body=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(processingInfoResponse, self).__init__(header, signature,  **kwargs_)
        self.body = body
        self.body_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, processingInfoResponse)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if processingInfoResponse.subclass:
            return processingInfoResponse.subclass(*args_, **kwargs_)
        else:
            return processingInfoResponse(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.body is not None or
            super(processingInfoResponse, self).hasContent_()
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(processingInfoResponse, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'body':
            obj_ = bodyType5.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.body = obj_
            obj_.original_tagname_ = 'body'
        super(processingInfoResponse, self).buildChildren(child_, node, nodeName_, True)
# end class processingInfoResponse


class processingInfoRequest(packetType):
    """Запрос статуса загрузки"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'body': MemberSpec_('body', 'bodyType4', 0, 0, {'name': 'body', 'type': 'bodyType4'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = packetType
    def __init__(self, header=None, signature=None, body=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(processingInfoRequest, self).__init__(header, signature,  **kwargs_)
        self.body = body
        self.body_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, processingInfoRequest)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if processingInfoRequest.subclass:
            return processingInfoRequest.subclass(*args_, **kwargs_)
        else:
            return processingInfoRequest(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.body is not None or
            super(processingInfoRequest, self).hasContent_()
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(processingInfoRequest, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'body':
            obj_ = bodyType4.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.body = obj_
            obj_.original_tagname_ = 'body'
        super(processingInfoRequest, self).buildChildren(child_, node, nodeName_, True)
# end class processingInfoRequest


class confirmation(packetType):
    """Протокол загрузки информационного пакета"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'body': MemberSpec_('body', 'bodyType3', 0, 0, {'name': 'body', 'type': 'bodyType3'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = packetType
    def __init__(self, header=None, signature=None, body=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(confirmation, self).__init__(header, signature,  **kwargs_)
        self.body = body
        self.body_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, confirmation)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if confirmation.subclass:
            return confirmation.subclass(*args_, **kwargs_)
        else:
            return confirmation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.body is not None or
            super(confirmation, self).hasContent_()
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(confirmation, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'body':
            obj_ = bodyType3.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.body = obj_
            obj_.original_tagname_ = 'body'
        super(confirmation, self).buildChildren(child_, node, nodeName_, True)
# end class confirmation


class documentUpload(packetType):
    """Загрузка дополнительного документа"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'body': MemberSpec_('body', 'bodyType2', 0, 0, {'name': 'body', 'type': 'bodyType2'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = packetType
    def __init__(self, header=None, signature=None, body=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(documentUpload, self).__init__(header, signature,  **kwargs_)
        self.body = body
        self.body_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, documentUpload)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if documentUpload.subclass:
            return documentUpload.subclass(*args_, **kwargs_)
        else:
            return documentUpload(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.body is not None or
            super(documentUpload, self).hasContent_()
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(documentUpload, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'body':
            obj_ = bodyType2.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.body = obj_
            obj_.original_tagname_ = 'body'
        super(documentUpload, self).buildChildren(child_, node, nodeName_, True)
# end class documentUpload


class nsiAgencyRelationsItemType(itemType):
    """Данные позиции в пакете"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'nsiAgencyRelationsData': MemberSpec_('nsiAgencyRelationsData', 'nsiAgencyRelationsDataType', 0, 0, {'name': 'nsiAgencyRelationsData', 'type': 'nsiAgencyRelationsDataType'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = itemType
    def __init__(self, guid=None, nsiAgencyRelationsData=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(nsiAgencyRelationsItemType, self).__init__(guid,  **kwargs_)
        self.nsiAgencyRelationsData = nsiAgencyRelationsData
        self.nsiAgencyRelationsData_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, nsiAgencyRelationsItemType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if nsiAgencyRelationsItemType.subclass:
            return nsiAgencyRelationsItemType.subclass(*args_, **kwargs_)
        else:
            return nsiAgencyRelationsItemType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.nsiAgencyRelationsData is not None or
            super(nsiAgencyRelationsItemType, self).hasContent_()
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(nsiAgencyRelationsItemType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'nsiAgencyRelationsData':
            obj_ = nsiAgencyRelationsDataType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.nsiAgencyRelationsData = obj_
            obj_.original_tagname_ = 'nsiAgencyRelationsData'
        super(nsiAgencyRelationsItemType, self).buildChildren(child_, node, nodeName_, True)
# end class nsiAgencyRelationsItemType


class nsiAgencyRelations(packetType):
    """Связь между организациями"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'body': MemberSpec_('body', 'bodyType', 0, 0, {'name': 'body', 'type': 'bodyType'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = packetType
    def __init__(self, header=None, signature=None, body=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(nsiAgencyRelations, self).__init__(header, signature,  **kwargs_)
        self.body = body
        self.body_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, nsiAgencyRelations)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if nsiAgencyRelations.subclass:
            return nsiAgencyRelations.subclass(*args_, **kwargs_)
        else:
            return nsiAgencyRelations(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.body is not None or
            super(nsiAgencyRelations, self).hasContent_()
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(nsiAgencyRelations, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'body':
            obj_ = bodyType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.body = obj_
            obj_.original_tagname_ = 'body'
        super(nsiAgencyRelations, self).buildChildren(child_, node, nodeName_, True)
# end class nsiAgencyRelations


GDSClassesMapping = {
}


USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""


def usage():
    print(USAGE_TEXT)
    sys.exit(1)


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    rootClass = GDSClassesMapping.get(tag)
    if rootClass is None:
        rootClass = globals().get(tag)
    return tag, rootClass


def get_required_ns_prefix_defs(rootNode):
    '''Get all name space prefix definitions required in this XML doc.
    Return a dictionary of definitions and a char string of definitions.
    '''
    nsmap = {
        prefix: uri
        for node in rootNode.iter()
        for (prefix, uri) in node.nsmap.items()
        if prefix is not None
    }
    namespacedefs = ' '.join([
        'xmlns:{}="{}"'.format(prefix, uri)
        for prefix, uri in nsmap.items()
    ])
    return nsmap, namespacedefs


def parse(inFileName, silence=False, print_warnings=True):
    global CapturedNsmap_
    gds_collector = GdsCollector_()
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'agencyRelation'
        rootClass = agencyRelation
    rootObj = rootClass.factory()
    rootObj.build(rootNode, gds_collector_=gds_collector)
    CapturedNsmap_, namespacedefs = get_required_ns_prefix_defs(rootNode)
    if not SaveElementTreeNode:
        doc = None
        rootNode = None
##     if not silence:
##         sys.stdout.write('<?xml version="1.0" ?>\n')
##         rootObj.export(
##             sys.stdout, 0, name_=rootTag,
##             namespacedef_=namespacedefs,
##             pretty_print=True)
    if print_warnings and len(gds_collector.get_messages()) > 0:
        separator = ('-' * 50) + '\n'
        sys.stderr.write(separator)
        sys.stderr.write('----- Warnings -- count: {} -----\n'.format(
            len(gds_collector.get_messages()), ))
        gds_collector.write_messages(sys.stderr)
        sys.stderr.write(separator)
    return rootObj


def parseEtree(inFileName, silence=False, print_warnings=True,
               mapping=None, nsmap=None):
    parser = None
    doc = parsexml_(inFileName, parser)
    gds_collector = GdsCollector_()
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'agencyRelation'
        rootClass = agencyRelation
    rootObj = rootClass.factory()
    rootObj.build(rootNode, gds_collector_=gds_collector)
    # Enable Python to collect the space used by the DOM.
    if mapping is None:
        mapping = {}
    rootElement = rootObj.to_etree(
        None, name_=rootTag, mapping_=mapping, nsmap_=nsmap)
    reverse_mapping = rootObj.gds_reverse_node_mapping(mapping)
    if not SaveElementTreeNode:
        doc = None
        rootNode = None
##     if not silence:
##         content = etree_.tostring(
##             rootElement, pretty_print=True,
##             xml_declaration=True, encoding="utf-8")
##         sys.stdout.write(str(content))
##         sys.stdout.write('\n')
    if print_warnings and len(gds_collector.get_messages()) > 0:
        separator = ('-' * 50) + '\n'
        sys.stderr.write(separator)
        sys.stderr.write('----- Warnings -- count: {} -----\n'.format(
            len(gds_collector.get_messages()), ))
        gds_collector.write_messages(sys.stderr)
        sys.stderr.write(separator)
    return rootObj, rootElement, mapping, reverse_mapping


def parseString(inString, silence=False, print_warnings=True):
    '''Parse a string, create the object tree, and export it.

    Arguments:
    - inString -- A string.  This XML fragment should not start
      with an XML declaration containing an encoding.
    - silence -- A boolean.  If False, export the object.
    Returns -- The root object in the tree.
    '''
    parser = None
    rootNode= parsexmlstring_(inString, parser)
    gds_collector = GdsCollector_()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'agencyRelation'
        rootClass = agencyRelation
    rootObj = rootClass.factory()
    rootObj.build(rootNode, gds_collector_=gds_collector)
    if not SaveElementTreeNode:
        rootNode = None
##     if not silence:
##         sys.stdout.write('<?xml version="1.0" ?>\n')
##         rootObj.export(
##             sys.stdout, 0, name_=rootTag,
##             namespacedef_='')
    if print_warnings and len(gds_collector.get_messages()) > 0:
        separator = ('-' * 50) + '\n'
        sys.stderr.write(separator)
        sys.stderr.write('----- Warnings -- count: {} -----\n'.format(
            len(gds_collector.get_messages()), ))
        gds_collector.write_messages(sys.stderr)
        sys.stderr.write(separator)
    return rootObj


def parseLiteral(inFileName, silence=False, print_warnings=True):
    parser = None
    doc = parsexml_(inFileName, parser)
    gds_collector = GdsCollector_()
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'agencyRelation'
        rootClass = agencyRelation
    rootObj = rootClass.factory()
    rootObj.build(rootNode, gds_collector_=gds_collector)
    # Enable Python to collect the space used by the DOM.
    if not SaveElementTreeNode:
        doc = None
        rootNode = None
##     if not silence:
##         sys.stdout.write('#from agency_relation import *\n\n')
##         sys.stdout.write('import agency_relation as model_\n\n')
##         sys.stdout.write('rootObj = model_.rootClass(\n')
##         rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
##         sys.stdout.write(')\n')
    if print_warnings and len(gds_collector.get_messages()) > 0:
        separator = ('-' * 50) + '\n'
        sys.stderr.write(separator)
        sys.stderr.write('----- Warnings -- count: {} -----\n'.format(
            len(gds_collector.get_messages()), ))
        gds_collector.write_messages(sys.stderr)
        sys.stderr.write(separator)
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()

RenameMappings_ = {
}

#
# Mapping of namespaces to types defined in them
# and the file in which each is defined.
# simpleTypes are marked "ST" and complexTypes "CT".
NamespaceToDefMappings_ = {'http://zakupki.gov.ru/223fz/agencyRelation/1': [('agencyRelationType',
                                                   'exanho/eis223/ds/xsd/10.2.310/agencyRelation.xsd',
                                                   'ST'),
                                                  ('agencyRelationStatus',
                                                   'exanho/eis223/ds/xsd/10.2.310/agencyRelation.xsd',
                                                   'ST'),
                                                  ('nsiAgencyRelationsItemType',
                                                   'exanho/eis223/ds/xsd/10.2.310/agencyRelation.xsd',
                                                   'CT'),
                                                  ('nsiAgencyRelationsDataType',
                                                   'exanho/eis223/ds/xsd/10.2.310/agencyRelation.xsd',
                                                   'CT')],
 'http://zakupki.gov.ru/223fz/types/1': [('deliveryPlaceIndicationType',
                                          'exanho/eis223/ds/xsd/10.2.310/Types.xsd',
                                          'ST'),
                                         ('lotPlanPositionType',
                                          'exanho/eis223/ds/xsd/10.2.310/Types.xsd',
                                          'ST'),
                                         ('organizationCodeType',
                                          'exanho/eis223/ds/xsd/10.2.310/Types.xsd',
                                          'ST'),
                                         ('codeEgrulType',
                                          'exanho/eis223/ds/xsd/10.2.310/Types.xsd',
                                          'ST'),
                                         ('codeOkatoType',
                                          'exanho/eis223/ds/xsd/10.2.310/Types.xsd',
                                          'ST'),
                                         ('codeOkdpType',
                                          'exanho/eis223/ds/xsd/10.2.310/Types.xsd',
                                          'ST'),
                                         ('codeOkpd2Type',
                                          'exanho/eis223/ds/xsd/10.2.310/Types.xsd',
                                          'ST'),
                                         ('codeOkeiType',
                                          'exanho/eis223/ds/xsd/10.2.310/Types.xsd',
                                          'ST'),
                                         ('codeOkfsType',
                                          'exanho/eis223/ds/xsd/10.2.310/Types.xsd',
                                          'ST'),
                                         ('codeOkoguType',
                                          'exanho/eis223/ds/xsd/10.2.310/Types.xsd',
                                          'ST'),
                                         ('codeOkopfType',
                                          'exanho/eis223/ds/xsd/10.2.310/Types.xsd',
                                          'ST'),
                                         ('codeOktmoType',
                                          'exanho/eis223/ds/xsd/10.2.310/Types.xsd',
                                          'ST'),
                                         ('codeOkpoType',
                                          'exanho/eis223/ds/xsd/10.2.310/Types.xsd',
                                          'ST'),
                                         ('customerCodeOkpoType',
                                          'exanho/eis223/ds/xsd/10.2.310/Types.xsd',
                                          'ST'),
                                         ('codeOkvedType',
                                          'exanho/eis223/ds/xsd/10.2.310/Types.xsd',
                                          'ST'),
                                         ('codeOkved2Type',
                                          'exanho/eis223/ds/xsd/10.2.310/Types.xsd',
                                          'ST'),
                                         ('emailType',
                                          'exanho/eis223/ds/xsd/10.2.310/Types.xsd',
                                          'ST'),
                                         ('guidType',
                                          'exanho/eis223/ds/xsd/10.2.310/Types.xsd',
                                          'ST'),
                                         ('ikoType',
                                          'exanho/eis223/ds/xsd/10.2.310/Types.xsd',
                                          'ST'),
                                         ('innType',
                                          'exanho/eis223/ds/xsd/10.2.310/Types.xsd',
                                          'ST'),
                                         ('kppType',
                                          'exanho/eis223/ds/xsd/10.2.310/Types.xsd',
                                          'ST'),
                                         ('money2',
                                          'exanho/eis223/ds/xsd/10.2.310/Types.xsd',
                                          'ST'),
                                         ('unsignedMoney2',
                                          'exanho/eis223/ds/xsd/10.2.310/Types.xsd',
                                          'ST'),
                                         ('decimal20_2',
                                          'exanho/eis223/ds/xsd/10.2.310/Types.xsd',
                                          'ST'),
                                         ('money3',
                                          'exanho/eis223/ds/xsd/10.2.310/Types.xsd',
                                          'ST'),
                                         ('money4',
                                          'exanho/eis223/ds/xsd/10.2.310/Types.xsd',
                                          'ST'),
                                         ('money6',
                                          'exanho/eis223/ds/xsd/10.2.310/Types.xsd',
                                          'ST'),
                                         ('lotItemQtyType',
                                          'exanho/eis223/ds/xsd/10.2.310/Types.xsd',
                                          'ST'),
                                         ('ogrnType',
                                          'exanho/eis223/ds/xsd/10.2.310/Types.xsd',
                                          'ST'),
                                         ('innovVolumeChecked',
                                          'exanho/eis223/ds/xsd/10.2.310/Types.xsd',
                                          'ST'),
                                         ('orderClauseStatusType',
                                          'exanho/eis223/ds/xsd/10.2.310/Types.xsd',
                                          'ST'),
                                         ('phoneType',
                                          'exanho/eis223/ds/xsd/10.2.310/Types.xsd',
                                          'ST'),
                                         ('purchaseContractStatusType',
                                          'exanho/eis223/ds/xsd/10.2.310/Types.xsd',
                                          'ST'),
                                         ('purchaseContractTypeInfoType',
                                          'exanho/eis223/ds/xsd/10.2.310/Types.xsd',
                                          'ST'),
                                         ('listGWSStatusType',
                                          'exanho/eis223/ds/xsd/10.2.310/Types.xsd',
                                          'ST'),
                                         ('listInnovStatusType',
                                          'exanho/eis223/ds/xsd/10.2.310/Types.xsd',
                                          'ST'),
                                         ('volumePurchaseStatusType',
                                          'exanho/eis223/ds/xsd/10.2.310/Types.xsd',
                                          'ST'),
                                         ('stopCommodityStatus',
                                          'exanho/eis223/ds/xsd/10.2.310/Types.xsd',
                                          'ST'),
                                         ('disagreementsProtocolStatus',
                                          'exanho/eis223/ds/xsd/10.2.310/Types.xsd',
                                          'ST'),
                                         ('purchaseNoticeStatusType',
                                          'exanho/eis223/ds/xsd/10.2.310/Types.xsd',
                                          'ST'),
                                         ('purchaseContractTypeCodeType',
                                          'exanho/eis223/ds/xsd/10.2.310/Types.xsd',
                                          'ST'),
                                         ('purchaseContractAccountStatusType',
                                          'exanho/eis223/ds/xsd/10.2.310/Types.xsd',
                                          'ST'),
                                         ('purchasePlanItemStatusType',
                                          'exanho/eis223/ds/xsd/10.2.310/Types.xsd',
                                          'ST'),
                                         ('purchasePlanStatusType',
                                          'exanho/eis223/ds/xsd/10.2.310/Types.xsd',
                                          'ST'),
                                         ('explanationStatusType',
                                          'exanho/eis223/ds/xsd/10.2.310/Types.xsd',
                                          'ST'),
                                         ('explanationRequestStatusType',
                                          'exanho/eis223/ds/xsd/10.2.310/Types.xsd',
                                          'ST'),
                                         ('purchaseProtocolStatusType',
                                          'exanho/eis223/ds/xsd/10.2.310/Types.xsd',
                                          'ST'),
                                         ('purchaseStageType',
                                          'exanho/eis223/ds/xsd/10.2.310/Types.xsd',
                                          'ST'),
                                         ('registrationNumberType',
                                          'exanho/eis223/ds/xsd/10.2.310/Types.xsd',
                                          'ST'),
                                         ('registrationNumber11Type',
                                          'exanho/eis223/ds/xsd/10.2.310/Types.xsd',
                                          'ST'),
                                         ('registrationNumber14Type',
                                          'exanho/eis223/ds/xsd/10.2.310/Types.xsd',
                                          'ST'),
                                         ('registrationNumber17Type',
                                          'exanho/eis223/ds/xsd/10.2.310/Types.xsd',
                                          'ST'),
                                         ('registrationNumber11-2Type',
                                          'exanho/eis223/ds/xsd/10.2.310/Types.xsd',
                                          'ST'),
                                         ('registrationNumber28Type',
                                          'exanho/eis223/ds/xsd/10.2.310/Types.xsd',
                                          'ST'),
                                         ('resultType',
                                          'exanho/eis223/ds/xsd/10.2.310/Types.xsd',
                                          'ST'),
                                         ('signatureType',
                                          'exanho/eis223/ds/xsd/10.2.310/Types.xsd',
                                          'ST'),
                                         ('violation.levelType',
                                          'exanho/eis223/ds/xsd/10.2.310/Types.xsd',
                                          'ST'),
                                         ('supplierType',
                                          'exanho/eis223/ds/xsd/10.2.310/Types.xsd',
                                          'ST'),
                                         ('winnerIndication',
                                          'exanho/eis223/ds/xsd/10.2.310/Types.xsd',
                                          'ST'),
                                         ('winnerIndication3',
                                          'exanho/eis223/ds/xsd/10.2.310/Types.xsd',
                                          'ST'),
                                         ('acceptedType2',
                                          'exanho/eis223/ds/xsd/10.2.310/Types.xsd',
                                          'ST'),
                                         ('acceptedType',
                                          'exanho/eis223/ds/xsd/10.2.310/Types.xsd',
                                          'ST'),
                                         ('templateExtendPurchaseTypes',
                                          'exanho/eis223/ds/xsd/10.2.310/Types.xsd',
                                          'ST'),
                                         ('extendFieldType',
                                          'exanho/eis223/ds/xsd/10.2.310/Types.xsd',
                                          'ST'),
                                         ('versionType',
                                          'exanho/eis223/ds/xsd/10.2.310/Types.xsd',
                                          'ST'),
                                         ('templateVersionType',
                                          'exanho/eis223/ds/xsd/10.2.310/Types.xsd',
                                          'ST'),
                                         ('templateStatusType',
                                          'exanho/eis223/ds/xsd/10.2.310/Types.xsd',
                                          'ST'),
                                         ('noticeTemplateFieldLevelType',
                                          'exanho/eis223/ds/xsd/10.2.310/Types.xsd',
                                          'ST'),
                                         ('protocolTemplateFieldLevelType',
                                          'exanho/eis223/ds/xsd/10.2.310/Types.xsd',
                                          'ST'),
                                         ('integrCodeType',
                                          'exanho/eis223/ds/xsd/10.2.310/Types.xsd',
                                          'ST'),
                                         ('agencyStatusType',
                                          'exanho/eis223/ds/xsd/10.2.310/Types.xsd',
                                          'ST'),
                                         ('purchaseMethodClassType',
                                          'exanho/eis223/ds/xsd/10.2.310/Types.xsd',
                                          'ST'),
                                         ('lotCancellationType',
                                          'exanho/eis223/ds/xsd/10.2.310/Types.xsd',
                                          'ST'),
                                         ('nonEmptyString',
                                          'exanho/eis223/ds/xsd/10.2.310/Types.xsd',
                                          'ST'),
                                         ('registrationNumber23Type',
                                          'exanho/eis223/ds/xsd/10.2.310/Types.xsd',
                                          'ST'),
                                         ('noticeDeliveryPlaceIndicationType',
                                          'exanho/eis223/ds/xsd/10.2.310/Types.xsd',
                                          'ST'),
                                         ('planInformationType',
                                          'exanho/eis223/ds/xsd/10.2.310/Types.xsd',
                                          'ST'),
                                         ('commissionIsFunctionalCharacteristicsRefineNeededType',
                                          'exanho/eis223/ds/xsd/10.2.310/Types.xsd',
                                          'ST'),
                                         ('statusType',
                                          'exanho/eis223/ds/xsd/10.2.310/Types.xsd',
                                          'ST'),
                                         ('positiveIntegerWithoutSigns',
                                          'exanho/eis223/ds/xsd/10.2.310/Types.xsd',
                                          'ST'),
                                         ('documentUploadBaseData',
                                          'exanho/eis223/ds/xsd/10.2.310/Types.xsd',
                                          'CT'),
                                         ('contactInfoType',
                                          'exanho/eis223/ds/xsd/10.2.310/Types.xsd',
                                          'CT'),
                                         ('cryptoSignsType',
                                          'exanho/eis223/ds/xsd/10.2.310/Types.xsd',
                                          'CT'),
                                         ('currencyType',
                                          'exanho/eis223/ds/xsd/10.2.310/Types.xsd',
                                          'CT'),
                                         ('customerInfoType',
                                          'exanho/eis223/ds/xsd/10.2.310/Types.xsd',
                                          'CT'),
                                         ('supplierInfoType',
                                          'exanho/eis223/ds/xsd/10.2.310/Types.xsd',
                                          'CT'),
                                         ('supplierMainInfoType',
                                          'exanho/eis223/ds/xsd/10.2.310/Types.xsd',
                                          'CT'),
                                         ('nonResidentInfoType',
                                          'exanho/eis223/ds/xsd/10.2.310/Types.xsd',
                                          'CT'),
                                         ('nonResidentLotCustomerInfoType',
                                          'exanho/eis223/ds/xsd/10.2.310/Types.xsd',
                                          'CT'),
                                         ('contractItemType',
                                          'exanho/eis223/ds/xsd/10.2.310/Types.xsd',
                                          'CT'),
                                         ('customerInfo2Type',
                                          'exanho/eis223/ds/xsd/10.2.310/Types.xsd',
                                          'CT'),
                                         ('customerInfo3Type',
                                          'exanho/eis223/ds/xsd/10.2.310/Types.xsd',
                                          'CT'),
                                         ('customerMainInfoType',
                                          'exanho/eis223/ds/xsd/10.2.310/Types.xsd',
                                          'CT'),
                                         ('customerRegistryInfoType',
                                          'exanho/eis223/ds/xsd/10.2.310/Types.xsd',
                                          'CT'),
                                         ('ikulType',
                                          'exanho/eis223/ds/xsd/10.2.310/Types.xsd',
                                          'CT'),
                                         ('grantedUserWoAttorneyType',
                                          'exanho/eis223/ds/xsd/10.2.310/Types.xsd',
                                          'CT'),
                                         ('capitalStockAgencyType',
                                          'exanho/eis223/ds/xsd/10.2.310/Types.xsd',
                                          'CT'),
                                         ('fz223type',
                                          'exanho/eis223/ds/xsd/10.2.310/Types.xsd',
                                          'CT'),
                                         ('timeZoneType',
                                          'exanho/eis223/ds/xsd/10.2.310/Types.xsd',
                                          'CT'),
                                         ('customerMainInfo2Type',
                                          'exanho/eis223/ds/xsd/10.2.310/Types.xsd',
                                          'CT'),
                                         ('customerMainInfo3Type',
                                          'exanho/eis223/ds/xsd/10.2.310/Types.xsd',
                                          'CT'),
                                         ('docDeliveryInfoType',
                                          'exanho/eis223/ds/xsd/10.2.310/Types.xsd',
                                          'CT'),
                                         ('docDeliveryPaymentType',
                                          'exanho/eis223/ds/xsd/10.2.310/Types.xsd',
                                          'CT'),
                                         ('documentListType',
                                          'exanho/eis223/ds/xsd/10.2.310/Types.xsd',
                                          'CT'),
                                         ('documentType',
                                          'exanho/eis223/ds/xsd/10.2.310/Types.xsd',
                                          'CT'),
                                         ('electronicPlaceInfoType',
                                          'exanho/eis223/ds/xsd/10.2.310/Types.xsd',
                                          'CT'),
                                         ('headerType',
                                          'exanho/eis223/ds/xsd/10.2.310/Types.xsd',
                                          'CT'),
                                         ('itemResultListType',
                                          'exanho/eis223/ds/xsd/10.2.310/Types.xsd',
                                          'CT'),
                                         ('itemResultType',
                                          'exanho/eis223/ds/xsd/10.2.310/Types.xsd',
                                          'CT'),
                                         ('itemType',
                                          'exanho/eis223/ds/xsd/10.2.310/Types.xsd',
                                          'CT'),
                                         ('lotItemListType',
                                          'exanho/eis223/ds/xsd/10.2.310/Types.xsd',
                                          'CT'),
                                         ('lotItemType',
                                          'exanho/eis223/ds/xsd/10.2.310/Types.xsd',
                                          'CT'),
                                         ('lotListType',
                                          'exanho/eis223/ds/xsd/10.2.310/Types.xsd',
                                          'CT'),
                                         ('lotISListType',
                                          'exanho/eis223/ds/xsd/10.2.310/Types.xsd',
                                          'CT'),
                                         ('lotType',
                                          'exanho/eis223/ds/xsd/10.2.310/Types.xsd',
                                          'CT'),
                                         ('lotCriteriaListType',
                                          'exanho/eis223/ds/xsd/10.2.310/Types.xsd',
                                          'CT'),
                                         ('lotApplicationsCriteriaListType',
                                          'exanho/eis223/ds/xsd/10.2.310/Types.xsd',
                                          'CT'),
                                         ('lotCriteriaType',
                                          'exanho/eis223/ds/xsd/10.2.310/Types.xsd',
                                          'CT'),
                                         ('lotApplicationsCriteriaType',
                                          'exanho/eis223/ds/xsd/10.2.310/Types.xsd',
                                          'CT'),
                                         ('baseCriteriaType',
                                          'exanho/eis223/ds/xsd/10.2.310/Types.xsd',
                                          'CT'),
                                         ('applicationLotCriteriaListType',
                                          'exanho/eis223/ds/xsd/10.2.310/Types.xsd',
                                          'CT'),
                                         ('applicationLotCriteriaType',
                                          'exanho/eis223/ds/xsd/10.2.310/Types.xsd',
                                          'CT'),
                                         ('lotCancellationInfoType',
                                          'exanho/eis223/ds/xsd/10.2.310/Types.xsd',
                                          'CT'),
                                         ('lotAllocationReferenceType',
                                          'exanho/eis223/ds/xsd/10.2.310/Types.xsd',
                                          'CT'),
                                         ('lotAllocationInfoType',
                                          'exanho/eis223/ds/xsd/10.2.310/Types.xsd',
                                          'CT'),
                                         ('deliveryPlaceType',
                                          'exanho/eis223/ds/xsd/10.2.310/Types.xsd',
                                          'CT'),
                                         ('planInfoType',
                                          'exanho/eis223/ds/xsd/10.2.310/Types.xsd',
                                          'CT'),
                                         ('lotCustomerListType',
                                          'exanho/eis223/ds/xsd/10.2.310/Types.xsd',
                                          'CT'),
                                         ('lotCustomerListShortType',
                                          'exanho/eis223/ds/xsd/10.2.310/Types.xsd',
                                          'CT'),
                                         ('lotCustomerBaseType',
                                          'exanho/eis223/ds/xsd/10.2.310/Types.xsd',
                                          'CT'),
                                         ('lotCustomerType',
                                          'exanho/eis223/ds/xsd/10.2.310/Types.xsd',
                                          'CT'),
                                         ('lotCustomerShortType',
                                          'exanho/eis223/ds/xsd/10.2.310/Types.xsd',
                                          'CT'),
                                         ('lotTypeIS',
                                          'exanho/eis223/ds/xsd/10.2.310/Types.xsd',
                                          'CT'),
                                         ('lotLinkType',
                                          'exanho/eis223/ds/xsd/10.2.310/Types.xsd',
                                          'CT'),
                                         ('okeiProductType',
                                          'exanho/eis223/ds/xsd/10.2.310/Types.xsd',
                                          'CT'),
                                         ('okvedProductType',
                                          'exanho/eis223/ds/xsd/10.2.310/Types.xsd',
                                          'CT'),
                                         ('okved2ProductType',
                                          'exanho/eis223/ds/xsd/10.2.310/Types.xsd',
                                          'CT'),
                                         ('okpdProductType',
                                          'exanho/eis223/ds/xsd/10.2.310/Types.xsd',
                                          'CT'),
                                         ('okpd2ProductType',
                                          'exanho/eis223/ds/xsd/10.2.310/Types.xsd',
                                          'CT'),
                                         ('okdpProductType',
                                          'exanho/eis223/ds/xsd/10.2.310/Types.xsd',
                                          'CT'),
                                         ('eisXmlDoc',
                                          'exanho/eis223/ds/xsd/10.2.310/Types.xsd',
                                          'CT'),
                                         ('packetType',
                                          'exanho/eis223/ds/xsd/10.2.310/Types.xsd',
                                          'CT'),
                                         ('purchaseInfoType',
                                          'exanho/eis223/ds/xsd/10.2.310/Types.xsd',
                                          'CT'),
                                         ('contractInfoType',
                                          'exanho/eis223/ds/xsd/10.2.310/Types.xsd',
                                          'CT'),
                                         ('purchaseInfo2Type',
                                          'exanho/eis223/ds/xsd/10.2.310/Types.xsd',
                                          'CT'),
                                         ('violationListType',
                                          'exanho/eis223/ds/xsd/10.2.310/Types.xsd',
                                          'CT'),
                                         ('violationType',
                                          'exanho/eis223/ds/xsd/10.2.310/Types.xsd',
                                          'CT'),
                                         ('userType',
                                          'exanho/eis223/ds/xsd/10.2.310/Types.xsd',
                                          'CT'),
                                         ('countryType',
                                          'exanho/eis223/ds/xsd/10.2.310/Types.xsd',
                                          'CT'),
                                         ('baseTemplateType',
                                          'exanho/eis223/ds/xsd/10.2.310/Types.xsd',
                                          'CT'),
                                         ('protocolTemplateHideBlocks',
                                          'exanho/eis223/ds/xsd/10.2.310/Types.xsd',
                                          'CT'),
                                         ('protocolTemplateType',
                                          'exanho/eis223/ds/xsd/10.2.310/Types.xsd',
                                          'CT'),
                                         ('orderClauseTemplateType',
                                          'exanho/eis223/ds/xsd/10.2.310/Types.xsd',
                                          'CT'),
                                         ('noticeTemplateType',
                                          'exanho/eis223/ds/xsd/10.2.310/Types.xsd',
                                          'CT'),
                                         ('templateTableType',
                                          'exanho/eis223/ds/xsd/10.2.310/Types.xsd',
                                          'CT'),
                                         ('templateTableColumnType',
                                          'exanho/eis223/ds/xsd/10.2.310/Types.xsd',
                                          'CT'),
                                         ('baseTemplateFieldType',
                                          'exanho/eis223/ds/xsd/10.2.310/Types.xsd',
                                          'CT'),
                                         ('templateFieldPositionType',
                                          'exanho/eis223/ds/xsd/10.2.310/Types.xsd',
                                          'CT'),
                                         ('orderClauseTemplateFieldType',
                                          'exanho/eis223/ds/xsd/10.2.310/Types.xsd',
                                          'CT'),
                                         ('noticeTemplateFieldType',
                                          'exanho/eis223/ds/xsd/10.2.310/Types.xsd',
                                          'CT'),
                                         ('protocolTemplateFieldType',
                                          'exanho/eis223/ds/xsd/10.2.310/Types.xsd',
                                          'CT'),
                                         ('orderClauseTemplateFieldList',
                                          'exanho/eis223/ds/xsd/10.2.310/Types.xsd',
                                          'CT'),
                                         ('noticeTemplateFieldList',
                                          'exanho/eis223/ds/xsd/10.2.310/Types.xsd',
                                          'CT'),
                                         ('protocolTemplateFieldList',
                                          'exanho/eis223/ds/xsd/10.2.310/Types.xsd',
                                          'CT'),
                                         ('noticeExtendFieldValueListType',
                                          'exanho/eis223/ds/xsd/10.2.310/Types.xsd',
                                          'CT'),
                                         ('protocolExtendFieldValueListType',
                                          'exanho/eis223/ds/xsd/10.2.310/Types.xsd',
                                          'CT'),
                                         ('orderClauseExtendFieldValueListType',
                                          'exanho/eis223/ds/xsd/10.2.310/Types.xsd',
                                          'CT'),
                                         ('baseExtendFieldType',
                                          'exanho/eis223/ds/xsd/10.2.310/Types.xsd',
                                          'CT'),
                                         ('baseExtendBlockFieldType',
                                          'exanho/eis223/ds/xsd/10.2.310/Types.xsd',
                                          'CT'),
                                         ('noticeExtendBlockFieldType',
                                          'exanho/eis223/ds/xsd/10.2.310/Types.xsd',
                                          'CT'),
                                         ('protocolExtendBlockFieldType',
                                          'exanho/eis223/ds/xsd/10.2.310/Types.xsd',
                                          'CT'),
                                         ('orderClauseExtendBlockFieldType',
                                          'exanho/eis223/ds/xsd/10.2.310/Types.xsd',
                                          'CT'),
                                         ('fieldValueType',
                                          'exanho/eis223/ds/xsd/10.2.310/Types.xsd',
                                          'CT'),
                                         ('extendTableRowType',
                                          'exanho/eis223/ds/xsd/10.2.310/Types.xsd',
                                          'CT'),
                                         ('extendTableColumnType',
                                          'exanho/eis223/ds/xsd/10.2.310/Types.xsd',
                                          'CT'),
                                         ('tableColumnValueType',
                                          'exanho/eis223/ds/xsd/10.2.310/Types.xsd',
                                          'CT'),
                                         ('protocolRequisitesType',
                                          'exanho/eis223/ds/xsd/10.2.310/Types.xsd',
                                          'CT'),
                                         ('protocolRequisitesType2',
                                          'exanho/eis223/ds/xsd/10.2.310/Types.xsd',
                                          'CT'),
                                         ('extendedAddressType',
                                          'exanho/eis223/ds/xsd/10.2.310/Types.xsd',
                                          'CT'),
                                         ('templateStructureTabType',
                                          'exanho/eis223/ds/xsd/10.2.310/Types.xsd',
                                          'CT'),
                                         ('purchaseCategory',
                                          'exanho/eis223/ds/xsd/10.2.310/Types.xsd',
                                          'CT'),
                                         ('hiddenFzFields',
                                          'exanho/eis223/ds/xsd/10.2.310/Types.xsd',
                                          'CT')]}

__all__ = [
    "agencyRelation",
    "applicationLotCriteriaListType",
    "applicationLotCriteriaType",
    "baseCriteriaType",
    "baseExtendBlockFieldType",
    "baseExtendFieldType",
    "baseTemplateFieldType",
    "baseTemplateType",
    "bodyType",
    "bodyType2",
    "bodyType3",
    "bodyType4",
    "bodyType5",
    "capitalStockAgencyType",
    "changeRequirementsDocumentUploadType",
    "columnsType",
    "confirmation",
    "contactInfoType",
    "contractCancellationDocumentUploadType",
    "contractCompletionDocumentUploadType",
    "contractDocumentUploadType",
    "contractInfoType",
    "contractItemType",
    "countryType",
    "cryptoSignsType",
    "currencyType",
    "customerInfo2Type",
    "customerInfo3Type",
    "customerInfoType",
    "customerMainInfo2Type",
    "customerMainInfo3Type",
    "customerMainInfoType",
    "customerRegistryInfoType",
    "deliveryPlaceType",
    "docDeliveryInfoType",
    "docDeliveryPaymentType",
    "documentListType",
    "documentType",
    "documentUpload",
    "documentUploadBaseData",
    "eisXmlDoc",
    "electronicPlaceInfoType",
    "exchangeInfoType",
    "exchangeInfoType42",
    "explanationDocumentUploadType",
    "explanationRequestDocumentUploadType",
    "extendTableColumnType",
    "extendTableRowType",
    "extendedAddressType",
    "fieldValueType",
    "fixedColumnsDataType",
    "fz223type",
    "grantedUserWoAttorneyType",
    "headerType",
    "hiddenFzFields",
    "ikulType",
    "infoType",
    "infosType",
    "itemResultListType",
    "itemResultType",
    "itemType",
    "jointLotDataType",
    "lotAllocationInfoType",
    "lotAllocationReferenceType",
    "lotApplcationsCriteriaType",
    "lotApplicationsCriteriaListType",
    "lotApplicationsCriteriaType",
    "lotCancellationInfoType",
    "lotCriteriaListType",
    "lotCriteriaType",
    "lotCustomerBaseType",
    "lotCustomerDataType",
    "lotCustomerListShortType",
    "lotCustomerListType",
    "lotCustomerShortType",
    "lotCustomerType",
    "lotDataType",
    "lotDataType58",
    "lotISListType",
    "lotItemListType",
    "lotItemType",
    "lotLinkType",
    "lotListType",
    "lotType",
    "lotTypeIS",
    "messageType",
    "messagesType",
    "nonResidentInfoType",
    "nonResidentLotCustomerInfoType",
    "noticeDocumentUploadType",
    "noticeExtendBlockFieldType",
    "noticeExtendFieldValueListType",
    "noticeTemplateFieldList",
    "noticeTemplateFieldType",
    "noticeTemplateType",
    "nsiAgencyRelations",
    "nsiAgencyRelationsDataType",
    "nsiAgencyRelationsItemType",
    "nsiType",
    "nsiType74",
    "okdpProductType",
    "okeiProductType",
    "okpd2ProductType",
    "okpdProductType",
    "okved2ProductType",
    "okvedProductType",
    "orderClauseDocumentUploadType",
    "orderClauseExtendBlockFieldType",
    "orderClauseExtendFieldValueListType",
    "orderClauseTemplateFieldList",
    "orderClauseTemplateFieldType",
    "orderClauseTemplateType",
    "packetType",
    "placerType",
    "planInfoType",
    "prevDocumentType",
    "processingInfoRequest",
    "processingInfoResponse",
    "protocolDocumentUploadType",
    "protocolExtendBlockFieldType",
    "protocolExtendFieldValueListType",
    "protocolRequisitesType",
    "protocolRequisitesType2",
    "protocolTemplateFieldList",
    "protocolTemplateFieldType",
    "protocolTemplateHideBlocks",
    "protocolTemplateType",
    "purchaseCategory",
    "purchaseContractAccountDocumentUploadType",
    "purchaseContractDocumentUploadType",
    "purchaseInfo2Type",
    "purchaseInfoType",
    "purchasePlanDocumentUploadType",
    "purchasePlanProjectDocumentUploadType",
    "purchaseRejectionDocumentUploadType",
    "relationType",
    "relationsType",
    "rowsType",
    "sectionType",
    "signatureType6",
    "supplierInfoType",
    "supplierMainInfoType",
    "tableColumnValueType",
    "tableType",
    "templateFieldPositionType",
    "templateStructureTabType",
    "templateTableColumnType",
    "templateTableType",
    "timeZoneType",
    "userType",
    "violationListType",
    "violationType"
]

#!/usr/bin/env python
# -*- coding: utf-8 -*-

#
# Generated Thu Nov 12 11:58:16 2020 by generateDS.py version 2.36.6.
# Python 3.7.3 (default, Jul 25 2020, 13:03:44)  [GCC 8.3.0]
#
# Command line options:
#   ('--use-getter-setter', 'none')
#   ('--enable-slots', '')
#   ('--member-specs', 'dict')
#   ('--export', '')
#   ('--silence', '')
#   ('-u', 'gends_user_methods.py')
#   ('-o', 'reference.py')
#
# Command line arguments:
#   reference.xsd
#
# Command line:
#   /home/kks/.local/bin/generateDS.py --use-getter-setter="none" --enable-slots --member-specs="dict" --export --silence -u "gends_user_methods.py" -o "reference.py" reference.xsd
#
# Current working directory (os.getcwd()):
#   eis223DS
#

from itertools import islice
import os
import sys
import re as re_
import base64
import datetime as datetime_
import decimal as decimal_
try:
    from lxml import etree as etree_
except ImportError:
    from xml.etree import ElementTree as etree_


Validate_simpletypes_ = True
SaveElementTreeNode = True
if sys.version_info.major == 2:
    BaseStrType_ = basestring
else:
    BaseStrType_ = str


def parsexml_(infile, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        try:
            parser = etree_.ETCompatXMLParser()
        except AttributeError:
            # fallback to xml.etree
            parser = etree_.XMLParser()
    try:
        if isinstance(infile, os.PathLike):
            infile = os.path.join(infile)
    except AttributeError:
        pass
    doc = etree_.parse(infile, parser=parser, **kwargs)
    return doc

def parsexmlstring_(instring, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        try:
            parser = etree_.ETCompatXMLParser()
        except AttributeError:
            # fallback to xml.etree
            parser = etree_.XMLParser()
    element = etree_.fromstring(instring, parser=parser, **kwargs)
    return element

#
# Namespace prefix definition table (and other attributes, too)
#
# The module generatedsnamespaces, if it is importable, must contain
# a dictionary named GeneratedsNamespaceDefs.  This Python dictionary
# should map element type names (strings) to XML schema namespace prefix
# definitions.  The export method for any class for which there is
# a namespace prefix definition, will export that definition in the
# XML representation of that element.  See the export method of
# any generated element type class for an example of the use of this
# table.
# A sample table is:
#
#     # File: generatedsnamespaces.py
#
#     GenerateDSNamespaceDefs = {
#         "ElementtypeA": "http://www.xxx.com/namespaceA",
#         "ElementtypeB": "http://www.xxx.com/namespaceB",
#     }
#
# Additionally, the generatedsnamespaces module can contain a python
# dictionary named GenerateDSNamespaceTypePrefixes that associates element
# types with the namespace prefixes that are to be added to the
# "xsi:type" attribute value.  See the exportAttributes method of
# any generated element type and the generation of "xsi:type" for an
# example of the use of this table.
# An example table:
#
#     # File: generatedsnamespaces.py
#
#     GenerateDSNamespaceTypePrefixes = {
#         "ElementtypeC": "aaa:",
#         "ElementtypeD": "bbb:",
#     }
#

try:
    from generatedsnamespaces import GenerateDSNamespaceDefs as GenerateDSNamespaceDefs_
except ImportError:
    GenerateDSNamespaceDefs_ = {}
try:
    from generatedsnamespaces import GenerateDSNamespaceTypePrefixes as GenerateDSNamespaceTypePrefixes_
except ImportError:
    GenerateDSNamespaceTypePrefixes_ = {}

#
# You can replace the following class definition by defining an
# importable module named "generatedscollector" containing a class
# named "GdsCollector".  See the default class definition below for
# clues about the possible content of that class.
#
try:
    from generatedscollector import GdsCollector as GdsCollector_
except ImportError:

    class GdsCollector_(object):

        def __init__(self, messages=None):
            if messages is None:
                self.messages = []
            else:
                self.messages = messages

        def add_message(self, msg):
            self.messages.append(msg)

        def get_messages(self):
            return self.messages

        def clear_messages(self):
            self.messages = []

        def print_messages(self):
            for msg in self.messages:
                print("Warning: {}".format(msg))

        def write_messages(self, outstream):
            for msg in self.messages:
                outstream.write("Warning: {}\n".format(msg))


#
# The super-class for enum types
#

try:
    from enum import Enum
except ImportError:
    Enum = object

#
# The root super-class for element type classes
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ImportError as exp:
    
    class GeneratedsSuper(object):
        __slots__ = ['gds_collector_', 'gds_elementtree_node_', 'original_tagname_', 'parent_object_', 'ns_prefix_']
        __hash__ = object.__hash__
        tzoff_pattern = re_.compile(r'(\+|-)((0\d|1[0-3]):[0-5]\d|14:00)$')
        class _FixedOffsetTZ(datetime_.tzinfo):
            def __init__(self, offset, name):
                self.__offset = datetime_.timedelta(minutes=offset)
                self.__name = name
            def utcoffset(self, dt):
                return self.__offset
            def tzname(self, dt):
                return self.__name
            def dst(self, dt):
                return None
        @staticmethod
        def gds_subclass_slots(member_data_items):
            slots = []
            for member in member_data_items:
                slots.append(member)
                slots.append("%s_nsprefix_" % member)
            return slots
        def gds_format_string(self, input_data, input_name=''):
            return input_data
        def gds_parse_string(self, input_data, node=None, input_name=''):
            return input_data
        def gds_validate_string(self, input_data, node=None, input_name=''):
            if not input_data:
                return ''
            else:
                return input_data
        def gds_format_base64(self, input_data, input_name=''):
            return base64.b64encode(input_data)
        def gds_validate_base64(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer(self, input_data, input_name=''):
            return '%d' % input_data
        def gds_parse_integer(self, input_data, node=None, input_name=''):
            try:
                ival = int(input_data)
            except (TypeError, ValueError) as exp:
                raise_parse_error(node, 'Requires integer value: %s' % exp)
            return ival
        def gds_validate_integer(self, input_data, node=None, input_name=''):
            try:
                value = int(input_data)
            except (TypeError, ValueError):
                raise_parse_error(node, 'Requires integer value')
            return value
        def gds_format_integer_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_integer_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    int(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of integer valuess')
            return values
        def gds_format_float(self, input_data, input_name=''):
            return ('%.15f' % input_data).rstrip('0')
        def gds_parse_float(self, input_data, node=None, input_name=''):
            try:
                fval_ = float(input_data)
            except (TypeError, ValueError) as exp:
                raise_parse_error(node, 'Requires float or double value: %s' % exp)
            return fval_
        def gds_validate_float(self, input_data, node=None, input_name=''):
            try:
                value = float(input_data)
            except (TypeError, ValueError):
                raise_parse_error(node, 'Requires float value')
            return value
        def gds_format_float_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_float_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of float values')
            return values
        def gds_format_decimal(self, input_data, input_name=''):
            return_value = '%s' % input_data
            if '.' in return_value:
                return_value = return_value.rstrip('0')
                if return_value.endswith('.'):
                    return_value = return_value.rstrip('.')
            return return_value
        def gds_parse_decimal(self, input_data, node=None, input_name=''):
            try:
                decimal_value = decimal_.Decimal(input_data)
            except (TypeError, ValueError):
                raise_parse_error(node, 'Requires decimal value')
            return decimal_value
        def gds_validate_decimal(self, input_data, node=None, input_name=''):
            try:
                value = decimal_.Decimal(input_data)
            except (TypeError, ValueError):
                raise_parse_error(node, 'Requires decimal value')
            return value
        def gds_format_decimal_list(self, input_data, input_name=''):
            return ' '.join([self.gds_format_decimal(item) for item in input_data])
        def gds_validate_decimal_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    decimal_.Decimal(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of decimal values')
            return values
        def gds_format_double(self, input_data, input_name=''):
            return '%e' % input_data
        def gds_parse_double(self, input_data, node=None, input_name=''):
            try:
                fval_ = float(input_data)
            except (TypeError, ValueError) as exp:
                raise_parse_error(node, 'Requires double or float value: %s' % exp)
            return fval_
        def gds_validate_double(self, input_data, node=None, input_name=''):
            try:
                value = float(input_data)
            except (TypeError, ValueError):
                raise_parse_error(node, 'Requires double or float value')
            return value
        def gds_format_double_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_double_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(
                        node, 'Requires sequence of double or float values')
            return values
        def gds_format_boolean(self, input_data, input_name=''):
            return ('%s' % input_data).lower()
        def gds_parse_boolean(self, input_data, node=None, input_name=''):
            if input_data in ('true', '1'):
                bval = True
            elif input_data in ('false', '0'):
                bval = False
            else:
                raise_parse_error(node, 'Requires boolean value')
            return bval
        def gds_validate_boolean(self, input_data, node=None, input_name=''):
            if input_data not in (True, 1, False, 0, ):
                raise_parse_error(
                    node,
                    'Requires boolean value '
                    '(one of True, 1, False, 0)')
            return input_data
        def gds_format_boolean_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_boolean_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                if value not in (True, 1, False, 0, ):
                    raise_parse_error(
                        node,
                        'Requires sequence of boolean values '
                        '(one of True, 1, False, 0)')
            return values
        def gds_validate_datetime(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_datetime(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d.%s' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        @classmethod
        def gds_parse_datetime(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            time_parts = input_data.split('.')
            if len(time_parts) > 1:
                micro_seconds = int(float('0.' + time_parts[1]) * 1000000)
                input_data = '%s.%s' % (
                    time_parts[0], "{}".format(micro_seconds).rjust(6, "0"), )
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt
        def gds_validate_date(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_date(self, input_data, input_name=''):
            _svalue = '%04d-%02d-%02d' % (
                input_data.year,
                input_data.month,
                input_data.day,
            )
            try:
                if input_data.tzinfo is not None:
                    tzoff = input_data.tzinfo.utcoffset(input_data)
                    if tzoff is not None:
                        total_seconds = tzoff.seconds + (86400 * tzoff.days)
                        if total_seconds == 0:
                            _svalue += 'Z'
                        else:
                            if total_seconds < 0:
                                _svalue += '-'
                                total_seconds *= -1
                            else:
                                _svalue += '+'
                            hours = total_seconds // 3600
                            minutes = (total_seconds - (hours * 3600)) // 60
                            _svalue += '{0:02d}:{1:02d}'.format(
                                hours, minutes)
            except AttributeError:
                pass
            return _svalue
        @classmethod
        def gds_parse_date(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            dt = datetime_.datetime.strptime(input_data, '%Y-%m-%d')
            dt = dt.replace(tzinfo=tz)
            return dt.date()
        def gds_validate_time(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_time(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%02d:%02d:%02d' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%02d:%02d:%02d.%s' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        def gds_validate_simple_patterns(self, patterns, target):
            # pat is a list of lists of strings/patterns.
            # The target value must match at least one of the patterns
            # in order for the test to succeed.
            found1 = True
            for patterns1 in patterns:
                found2 = False
                for patterns2 in patterns1:
                    mo = re_.search(patterns2, target)
                    if mo is not None and len(mo.group(0)) == len(target):
                        found2 = True
                        break
                if not found2:
                    found1 = False
                    break
            return found1
        @classmethod
        def gds_parse_time(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            if len(input_data.split('.')) > 1:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt.time()
        def gds_check_cardinality_(
                self, value, input_name,
                min_occurs=0, max_occurs=1, required=None):
            if value is None:
                length = 0
            elif isinstance(value, list):
                length = len(value)
            else:
                length = 1
            if required is not None :
                if required and length < 1:
                    self.gds_collector_.add_message(
                        "Required value {}{} is missing".format(
                            input_name, self.gds_get_node_lineno_()))
            if length < min_occurs:
                self.gds_collector_.add_message(
                    "Number of values for {}{} is below "
                    "the minimum allowed, "
                    "expected at least {}, found {}".format(
                        input_name, self.gds_get_node_lineno_(),
                        min_occurs, length))
            elif length > max_occurs:
                self.gds_collector_.add_message(
                    "Number of values for {}{} is above "
                    "the maximum allowed, "
                    "expected at most {}, found {}".format(
                        input_name, self.gds_get_node_lineno_(),
                        max_occurs, length))
        def gds_validate_builtin_ST_(
                self, validator, value, input_name,
                min_occurs=None, max_occurs=None, required=None):
            if value is not None:
                try:
                    validator(value, input_name=input_name)
                except GDSParseError as parse_error:
                    self.gds_collector_.add_message(str(parse_error))
        def gds_validate_defined_ST_(
                self, validator, value, input_name,
                min_occurs=None, max_occurs=None, required=None):
            if value is not None:
                try:
                    validator(value)
                except GDSParseError as parse_error:
                    self.gds_collector_.add_message(str(parse_error))
        def gds_str_lower(self, instring):
            return instring.lower()
        def get_path_(self, node):
            path_list = []
            self.get_path_list_(node, path_list)
            path_list.reverse()
            path = '/'.join(path_list)
            return path
        Tag_strip_pattern_ = re_.compile(r'\{.*\}')
        def get_path_list_(self, node, path_list):
            if node is None:
                return
            tag = GeneratedsSuper.Tag_strip_pattern_.sub('', node.tag)
            if tag:
                path_list.append(tag)
            self.get_path_list_(node.getparent(), path_list)
        def get_class_obj_(self, node, default_class=None):
            class_obj1 = default_class
            if 'xsi' in node.nsmap:
                classname = node.get('{%s}type' % node.nsmap['xsi'])
                if classname is not None:
                    names = classname.split(':')
                    if len(names) == 2:
                        classname = names[1]
                    class_obj2 = globals().get(classname)
                    if class_obj2 is not None:
                        class_obj1 = class_obj2
            return class_obj1
        def gds_build_any(self, node, type_name=None):
            # provide default value in case option --disable-xml is used.
            content = ""
            content = etree_.tostring(node, encoding="unicode")
            return content
        @classmethod
        def gds_reverse_node_mapping(cls, mapping):
            return dict(((v, k) for k, v in mapping.items()))
        @staticmethod
        def gds_encode(instring):
            if sys.version_info.major == 2:
                if ExternalEncoding:
                    encoding = ExternalEncoding
                else:
                    encoding = 'utf-8'
                return instring.encode(encoding)
            else:
                return instring
        @staticmethod
        def convert_unicode(instring):
            if isinstance(instring, str):
                result = quote_xml(instring)
            elif sys.version_info.major == 2 and isinstance(instring, unicode):
                result = quote_xml(instring).encode('utf8')
            else:
                result = GeneratedsSuper.gds_encode(str(instring))
            return result
        def __eq__(self, other):
            if type(self) != type(other):
                return False
            mro = self.__class__.__mro__
            return all(
                getattr(self, attribute) == getattr(other, attribute)
                for cls in islice(mro, 0, len(mro) - 2)
                for attribute in cls.member_data_items_)
        def __ne__(self, other):
            return not self.__eq__(other)
        # Django ETL transform hooks.
        def gds_djo_etl_transform(self):
            pass
        def gds_djo_etl_transform_db_obj(self, dbobj):
            pass
        # SQLAlchemy ETL transform hooks.
        def gds_sqa_etl_transform(self):
            return 0, None
        def gds_sqa_etl_transform_db_obj(self, dbobj):
            pass
        def gds_get_node_lineno_(self):
            if (hasattr(self, "gds_elementtree_node_") and
                    self.gds_elementtree_node_ is not None):
                return ' near line {}'.format(
                    self.gds_elementtree_node_.sourceline)
            else:
                return ""
    
    
    def getSubclassFromModule_(module, class_):
        '''Get the subclass of a class from a specific module.'''
        name = class_.__name__ + 'Sub'
        if hasattr(module, name):
            return getattr(module, name)
        else:
            return None


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = ''
# Set this to false in order to deactivate during export, the use of
# name space prefixes captured from the input document.
UseCapturedNS_ = True
CapturedNsmap_ = {}
Tag_pattern_ = re_.compile(r'({.*})?(.*)')
String_cleanup_pat_ = re_.compile(r"[\n\r\s]+")
Namespace_extract_pat_ = re_.compile(r'{(.*)}(.*)')
CDATA_pattern_ = re_.compile(r"<!\[CDATA\[.*?\]\]>", re_.DOTALL)

# Change this to redirect the generated superclass module to use a
# specific subclass module.
CurrentSubclassModule_ = None

#
# Support/utility functions.
#


def showIndent(outfile, level, pretty_print=True):
    if pretty_print:
        for idx in range(level):
            outfile.write('    ')


def quote_xml(inStr):
    "Escape markup chars, but do not modify CDATA sections."
    if not inStr:
        return ''
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s2 = ''
    pos = 0
    matchobjects = CDATA_pattern_.finditer(s1)
    for mo in matchobjects:
        s3 = s1[pos:mo.start()]
        s2 += quote_xml_aux(s3)
        s2 += s1[mo.start():mo.end()]
        pos = mo.end()
    s3 = s1[pos:]
    s2 += quote_xml_aux(s3)
    return s2


def quote_xml_aux(inStr):
    s1 = inStr.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1


def quote_attrib(inStr):
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1


def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1


def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text


def find_attr_value_(attr_name, node):
    attrs = node.attrib
    attr_parts = attr_name.split(':')
    value = None
    if len(attr_parts) == 1:
        value = attrs.get(attr_name)
    elif len(attr_parts) == 2:
        prefix, name = attr_parts
        namespace = node.nsmap.get(prefix)
        if namespace is not None:
            value = attrs.get('{%s}%s' % (namespace, name, ))
    return value


def encode_str_2_3(instr):
    return instr


class GDSParseError(Exception):
    pass


def raise_parse_error(node, msg):
    if node is not None:
        msg = '%s (element %s/line %d)' % (msg, node.tag, node.sourceline, )
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    TypeBase64 = 8
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace,
               pretty_print=True):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(
                outfile, level, namespace, name_=name,
                pretty_print=pretty_print)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeBase64:
            outfile.write('<%s>%s</%s>' % (
                self.name,
                base64.b64encode(self.value),
                self.name))
    def to_etree(self, element, mapping_=None, nsmap_=None):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                if len(element) > 0:
                    if element[-1].tail is None:
                        element[-1].tail = self.value
                    else:
                        element[-1].tail += self.value
                else:
                    if element.text is None:
                        element.text = self.value
                    else:
                        element.text += self.value
        elif self.category == MixedContainer.CategorySimple:
            subelement = etree_.SubElement(
                element, '%s' % self.name)
            subelement.text = self.to_etree_simple()
        else:    # category == MixedContainer.CategoryComplex
            self.value.to_etree(element)
    def to_etree_simple(self, mapping_=None, nsmap_=None):
        if self.content_type == MixedContainer.TypeString:
            text = self.value
        elif (self.content_type == MixedContainer.TypeInteger or
                self.content_type == MixedContainer.TypeBoolean):
            text = '%d' % self.value
        elif (self.content_type == MixedContainer.TypeFloat or
                self.content_type == MixedContainer.TypeDecimal):
            text = '%f' % self.value
        elif self.content_type == MixedContainer.TypeDouble:
            text = '%g' % self.value
        elif self.content_type == MixedContainer.TypeBase64:
            text = '%s' % base64.b64encode(self.value)
        return text
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type,
                    self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type,
                    self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s",\n' % (
                    self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0,
            optional=0, child_attrs=None, choice=None):
        self.name = name
        self.data_type = data_type
        self.container = container
        self.child_attrs = child_attrs
        self.choice = choice
        self.optional = optional
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container
    def set_child_attrs(self, child_attrs): self.child_attrs = child_attrs
    def get_child_attrs(self): return self.child_attrs
    def set_choice(self, choice): self.choice = choice
    def get_choice(self): return self.choice
    def set_optional(self, optional): self.optional = optional
    def get_optional(self): return self.optional


def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)

#
# Data representation classes.
#


class acceptedType(str, Enum):
    """Признак допуска"""
    T='T' # Допущен
    F='F' # Не допущен


class acceptedType2(str, Enum):
    """Признак допуска"""
    T='T' # Допущен
    F='F' # Не допущен
    N='N' # Не указывается в данном протоколе


class agencyStatusType(str, Enum):
    """Статус организации в ППА
    BLOCKED("Заблокирована"),
    REGISTERED("Зарегистрирована"),
    REJECTED("Отказано в регистрации"),
    PENDING("На регистрации"),
    ON_HOLD("Приостановлено действие");"""
    BLOCKED='BLOCKED' # Заблокирована
    REGISTERED='REGISTERED' # Зарегистрирована
    REJECTED='REJECTED' # Отказано в регистрации
    PENDING='PENDING' # На регистрации
    ON_HOLD='ON_HOLD' # Приостановлено действие


class businessStatusType(str, Enum):
    """Статус"""
    _8_01='801' # Включена
    _8_66='866' # Исключена


class commissionIsFunctionalCharacteristicsRefineNeededType(str, Enum):
    """Принятое решение о необходимости уточнения функциональных
    характеристик"""
    NEEDED='NEEDED' # Требуется уточнение функциональных характеристик
    NOT_NEEDED='NOT_NEEDED' # Не требуется уточнение функциональных характеристик


class deliveryPlaceIndicationType(str, Enum):
    """Признак указания места поставки"""
    GL='GL' # Указывается общее для лота
    ELP='ELP' # Указывается для каждой позиции лота
    LC='LC' # Указывается в сведениях по участнику совместной закупки
    GA='GA' # Указывается общее для организации
    EP='EP' # Указывается для каждой позиции


class disagreementsProtocolStatus(str, Enum):
    """Статус протокола разногласий"""
    F='F' # Новый
    P='P' # Размещено
    I='I' # Отказано


class explanationRequestStatusType(str, Enum):
    """Статус запроса на разъяснение"""
    F='F' # Редактирование
    P='P' # Размещено


class explanationStatusType(str, Enum):
    """Статус разъяснения"""
    F='F' # Редактирование
    P='P' # Размещено


class extendFieldType(str, Enum):
    """Тип данных"""
    STRING='STRING' # Строка
    TEXT='TEXT' # Текст
    INTEGER='INTEGER' # Целое число
    NUMBER='NUMBER' # Число
    BOOLEAN='BOOLEAN' # Логический
    TIME='TIME' # Время
    DATETIME='DATETIME' # Дата / время
    DATE='DATE' # Дата
    LINK='LINK' # Гиперссылка
    FILE='FILE' # Файл
    REGEXP='REGEXP' # Значение по шаблону
    CURRENCY='CURRENCY' # Справочник «Валюта»
    UNITS='UNITS' # Справочник «Единицы измерения»
    OKDP='OKDP' # Справочник «ОКДП»
    OKPD_2='OKPD2' # Справочник «ОКПД2»
    OKVED='OKVED' # Справочник «ОКВЭД»
    OKVED_2='OKVED2' # Справочник «ОКВЭД2»
    TABLE='TABLE' # Табличное представление из справочника


class listGWSStatusType(str, Enum):
    """Статус перечня ТРУ"""
    F='F' # Редактирование
    P='P' # Размещено
    I='I' # Недействительно
    M='M' # Изменение


class listInnovStatusType(str, Enum):
    """Статус перечня ИПВП"""
    F='F' # Редактирование
    P='P' # Размещено
    I='I' # Недействительно
    M='M' # Изменение


class lotCancellationType(str, Enum):
    """Флаг места хранения информации об отмене лота:
    * COMMON - причина отмены записывается в саму сущность LotCancellation
    * VARIOUS - причина отмены записывается своя индивидуально в каждый
    отменяемый лот"""
    COMMON='COMMON' # Общая причина отмены всех лотов
    VARIOUS='VARIOUS' # Различные причины отмены лотов


class lotPlanPositionType(str, Enum):
    """Признак указания места поставки"""
    COMMODITY='COMMODITY' # Обычный план
    INNOVATION='INNOVATION' # Инновационный план


class noticeDeliveryPlaceIndicationType(str, Enum):
    """Признак указания места поставки для закупки"""
    SINGLE_PLACE='SINGLE_PLACE' # Единое место поставки лотов
    DIFFERENT_PLACE='DIFFERENT_PLACE' # Различные места поставки лотов


class noticeTemplateFieldLevelType(str, Enum):
    """Уровень размещения вкладки"""
    NOTICE='NOTICE' # Извещение
    LOT='LOT' # Лот
    LOT_CUSTOMER='LOT_CUSTOMER' # Сведения по заказчику


class orderClauseStatusType(str, Enum):
    """Статус положения о закупках"""
    F='F' # Проект
    P='P' # Размещено
    I='I' # Недействительно
    M='M' # Изменение


class planInformationType(str, Enum):
    """Тип сведений плана"""
    PLAN_PROJECT='PLAN_PROJECT' # Проект плана закупки
    PLAN_PROJECT_MODIFICATION='PLAN_PROJECT_MODIFICATION' # Проект изменений плана закупки
    PLAN='PLAN' # План закупки
    PLAN_MODIFICATION='PLAN_MODIFICATION' # Изменение плана закупки
    SMB='SMB' # Отчет МСП
    SMB_MODIFICATION='SMB_MODIFICATION' # Изменение отчета МСП
    HIGH_TECH='HIGH_TECH' # Отчет ИПВП
    HIGH_TECH_MODIFICATION='HIGH_TECH_MODIFICATION' # Изменение отчета ИПВП


class protocolKindType(str, Enum):
    """Вид протокола"""
    PROTOCOL_OF_STAGE='PROTOCOL_OF_STAGE' # Протокол этапа
    FINAL_PROTOCOL='FINAL_PROTOCOL' # Итоговый протокол
    NONE='NONE' # Не выбрано


class protocolTemplateFieldLevelType(str, Enum):
    """Уровень размещения вкладки"""
    PROTOCOL='PROTOCOL' # Протокол
    APPLICATION='APPLICATION' # Заявка поставщика


class purchaseContractAccountStatusType(str, Enum):
    """Статус отчетности о договорах"""
    F='F' # Редактирование
    P='P' # Размещено
    I='I' # Недействительно
    M='M' # Изменение


class purchaseContractStatusType(str, Enum):
    """Статус договора закупки"""
    F='F' # Редактирование
    P='P' # Размещено
    I='I' # Недействительно
    M='M' # Изменение


class purchaseContractTypeCodeType(str, Enum):
    """Тип отчетности о договорах"""
    _1='1' # Договора по результатам закупок
    _2='2' # Договора, заключенные заказчиком по результатам закупки у единственного поставщика (исполнителя, подрядчика)
    _3='3' # Договора, заключенные заказчиком по результатам закупки, сведения о которой составляют государственную тайну или в отношении которой приняты решения Правительства Российской Федерации
    _4='4' # Договоры, заключенные заказчиком по результатам закупки у субъектов малого и среднего предпринимательства
    _5='5' # Договоры, заключенные заказчиком с единственным поставщиком (исполнителем, подрядчиком) по результатам несостоявшейся конкурентной закупки


class purchaseContractTypeInfoType(str, Enum):
    """Тип сведений договора"""
    N='N' # Первоначальные сведения о договоре
    C='C' # Сведения об изменении в договоре


class purchaseMethodClassType(str, Enum):
    """Cпособ закупки"""
    OK='OK' # Открытый конкурс (до 01.07.18)
    OA='OA' # Открытый аукцион (до 01.07.18)
    AE='AE' # Открытый аукцион в электронной форме (до 01.07.18)
    AE_94='AE94' # Открытый аукцион в электронной форме (по 94ФЗ) (до 01.07.18)
    ZK='ZK' # Запрос котировок (до 01.07.18)
    EP='EP' # Закупка у единственного поставщика (исполнителя, подрядчика) (до 01.07.18)
    KESMBO='KESMBO' # Конкурс в электронной форме, участниками которого могут являться только субъекты малого и среднего предпринимательства
    AESMBO='AESMBO' # Аукцион в электронной форме, участниками которого могут являться только субъекты малого и среднего предпринимательства
    ZKESMBO='ZKESMBO' # Запрос котировок в электронной форме, участниками которого могут являться только субъекты малого и среднего предпринимательства
    ZPESMBO='ZPESMBO' # Запрос предложений в электронной форме, участниками которого могут являться только субъекты малого и среднего предпринимательства
    IS='IS' # Иной способ
    TSK='TSK' # Типовой способ с видом «Конкурс»
    TSA='TSA' # Типовой способ с видом «Аукцион»
    TSZK='TSZK' # Типовой способ с видом «Запрос котировок»
    TSZP='TSZP' # Типовой способ с видом «Запрос предложений»
    TSEP='TSEP' # Типовой способ с видом «Закупка у единственного поставщика (подрядчика, исполнителя)»


class purchaseNoticeStatusType(str, Enum):
    """Статус извещения"""
    F='F' # Редактирование
    P='P' # Размещено
    I='I' # Недействительно
    M='M' # Изменение


class purchasePlanItemStatusType(str, Enum):
    """Статус позиции плана закупок"""
    N='N' # Новая
    P='P' # Размещена
    C='C' # Изменена
    A='A' # Аннулирована


class purchasePlanStatusType(str, Enum):
    """Статус сведений плана закупок"""
    P='P' # Проект плана закупки
    M='M' # Проект изменений плана закупки
    A='A' # Утвержден


class purchaseProtocolStatusType(str, Enum):
    """Статус протокола закупки"""
    F='F' # Редактирование
    P='P' # Размещено
    I='I' # Недействительно
    M='M' # Изменение


class purchaseStageType(str, Enum):
    """Этап извещения о закупке"""
    NOTICE_FORMATION='NOTICE_FORMATION' # Формирование извещения
    APPLICATION_FILING='APPLICATION_FILING' # Подача заявок
    COMMISSION_ACTIVITIES='COMMISSION_ACTIVITIES' # Работа комиссии
    PLACEMENT_COMPLETE='PLACEMENT_COMPLETE' # Размещение завершено
    PLACEMENT_CANCELED='PLACEMENT_CANCELED' # Размещение отменено


class resultType(str, Enum):
    """Результат операции"""
    SUCCESS='success'
    FAILURE='failure'


class signatureType(str, Enum):
    """Тип электронной подписи"""
    C_AD_ESBES='CAdES-BES'
    C_AD_ESA='CAdES-A'


class statusType(str, Enum):
    """Статус обработки пакета"""
    SUCCESS='success'
    FAILURE='failure'
    QUEUED='queued'
    PROCESSING='processing'


class stopCommodityStatus(str, Enum):
    """Статус перечня ТРУ для приостановки"""
    N='N' # Новый
    P='P' # Размещено


class supplierType(str, Enum):
    """Тип организации поставщика"""
    L='L' # Юридическое лицо
    P='P' # Физическое лицо


class templateExtendPurchaseTypes(str, Enum):
    """Источник копирования полей
    OK(Открытый конкурс),
    OA(Открытый аукцион),
    OE(Открытый аукцион в электронной форме),
    ZK(Запрос котировок),
    ZE(Закупка у единственного поставщика),
    IS(Иной способ (состав данных согласно Федеральному закону 223-ФЗ)),
    ES(Иной способ в электронной форме (выбор ВСРЗ для проведения закупки));"""
    OK='OK' # Открытый конкурс
    OA='OA' # Открытый аукцион
    OE='OE' # Открытый аукцион в электронной форме
    ZK='ZK' # Запрос котировок
    ZE='ZE' # Закупка у единственного поставщика
    IS='IS' # Иной способ (состав данных согласно Федеральному закону 223-ФЗ)
    ES='ES' # Иной способ в электронной форме (выбор ВСРЗ для проведения закупки)


class templateStatusType(str, Enum):
    """Статус шаблона"""
    I='I' # Неактуальная версия
    P='P' # Актуальная версия


class typalKindType(str, Enum):
    """Вид типового способа"""
    TSK='TSK' # Типовой способ с видом «Конкурс»
    TSA='TSA' # Типовой способ с видом «Аукцион»
    TSZK='TSZK' # Типовой способ с видом «Запрос котировок»
    TSZP='TSZP' # Типовой способ с видом «Запрос предложений»
    TSEP='TSEP' # Типовой способ с видом «Закупка у единственного поставщика (подрядчика, исполнителя)»


class violation_levelType(str, Enum):
    """Тип ошибки"""
    ERROR='error'
    WARNING='warning'


class volumePurchaseStatusType(str, Enum):
    """Статус годового отчета о закупки у МСП"""
    F='F' # Редактирование
    P='P' # Размещено
    I='I' # Недействительно
    M='M' # Изменение


class winnerIndication(str, Enum):
    """Результат"""
    F='F' # Победитель
    S='S' # Второе место
    T='T' # Третье место
    B='B' # Ниже третьего
    N='N' # Не указывается в данном протоколе


class winnerIndication3(str, Enum):
    """Результат"""
    W='W' # Победитель
    F='F' # Участник, предложивший цену победителя
    S='S' # Участник, предложивший цену, следующую после победителя


class nsiOkatoDataType(GeneratedsSuper):
    """Общероссийский классификатор объектов административно-территориального
    деления"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'guid': MemberSpec_('guid', ['guidType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'guid', 'type': 'xs:string'}, None),
        'changeDateTime': MemberSpec_('changeDateTime', 'xs:dateTime', 0, 1, {'minOccurs': '0', 'name': 'changeDateTime', 'type': 'xs:dateTime'}, None),
        'startDateActive': MemberSpec_('startDateActive', 'xs:date', 0, 1, {'minOccurs': '0', 'name': 'startDateActive', 'type': 'xs:date'}, None),
        'endDateActive': MemberSpec_('endDateActive', 'xs:date', 0, 1, {'minOccurs': '0', 'name': 'endDateActive', 'type': 'xs:date'}, None),
        'businessStatus': MemberSpec_('businessStatus', ['businessStatusType', 'xs:string'], 0, 0, {'name': 'businessStatus', 'type': 'xs:string'}, None),
        'code': MemberSpec_('code', ['codeOkatoType', 'nonEmptyString', 'xs:string'], 0, 0, {'name': 'code', 'type': 'xs:string'}, None),
        'name': MemberSpec_('name', ['nameType', 't:nonEmptyString'], 0, 0, {'name': 'name', 'type': 'xs:string'}, None),
        'parentCode': MemberSpec_('parentCode', ['codeOkatoType', 'nonEmptyString', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'parentCode', 'type': 'xs:string'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, guid=None, changeDateTime=None, startDateActive=None, endDateActive=None, businessStatus=None, code=None, name=None, parentCode=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.guid = guid
        self.validate_guidType(self.guid)
        self.guid_nsprefix_ = None
        if isinstance(changeDateTime, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(changeDateTime, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = changeDateTime
        self.changeDateTime = initvalue_
        self.changeDateTime_nsprefix_ = None
        if isinstance(startDateActive, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(startDateActive, '%Y-%m-%d').date()
        else:
            initvalue_ = startDateActive
        self.startDateActive = initvalue_
        self.startDateActive_nsprefix_ = None
        if isinstance(endDateActive, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(endDateActive, '%Y-%m-%d').date()
        else:
            initvalue_ = endDateActive
        self.endDateActive = initvalue_
        self.endDateActive_nsprefix_ = None
        self.businessStatus = businessStatus
        self.validate_businessStatusType(self.businessStatus)
        self.businessStatus_nsprefix_ = None
        self.code = code
        self.validate_codeOkatoType(self.code)
        self.code_nsprefix_ = None
        self.name = name
        self.validate_nameType(self.name)
        self.name_nsprefix_ = None
        self.parentCode = parentCode
        self.validate_codeOkatoType(self.parentCode)
        self.parentCode_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, nsiOkatoDataType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if nsiOkatoDataType.subclass:
            return nsiOkatoDataType.subclass(*args_, **kwargs_)
        else:
            return nsiOkatoDataType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_guidType(self, value):
        result = True
        # Validate type guidType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) != 36:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd length restriction on guidType' % {"value": encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_guidType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_guidType_patterns_, ))
                result = False
        return result
    validate_guidType_patterns_ = [['^([a-fA-F0-9]{8}\\-[a-fA-F0-9]{4}\\-[a-fA-F0-9]{4}\\-[a-fA-F0-9]{4}\\-[a-fA-F0-9]{12})$']]
    def validate_businessStatusType(self, value):
        result = True
        # Validate type businessStatusType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['801', '866']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on businessStatusType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_codeOkatoType(self, value):
        result = True
        # Validate type codeOkatoType, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on codeOkatoType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_codeOkatoType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_codeOkatoType_patterns_, ))
                result = False
        return result
    validate_codeOkatoType_patterns_ = [['^(\\d{11})$']]
    def validate_nameType(self, value):
        result = True
        # Validate type nameType, a restriction on t:nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 200:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on nameType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on nameType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.guid is not None or
            self.changeDateTime is not None or
            self.startDateActive is not None or
            self.endDateActive is not None or
            self.businessStatus is not None or
            self.code is not None or
            self.name is not None or
            self.parentCode is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'guid':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'guid')
            value_ = self.gds_validate_string(value_, node, 'guid')
            self.guid = value_
            self.guid_nsprefix_ = child_.prefix
            # validate type guidType
            self.validate_guidType(self.guid)
        elif nodeName_ == 'changeDateTime':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.changeDateTime = dval_
            self.changeDateTime_nsprefix_ = child_.prefix
        elif nodeName_ == 'startDateActive':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.startDateActive = dval_
            self.startDateActive_nsprefix_ = child_.prefix
        elif nodeName_ == 'endDateActive':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.endDateActive = dval_
            self.endDateActive_nsprefix_ = child_.prefix
        elif nodeName_ == 'businessStatus':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'businessStatus')
            value_ = self.gds_validate_string(value_, node, 'businessStatus')
            self.businessStatus = value_
            self.businessStatus_nsprefix_ = child_.prefix
            # validate type businessStatusType
            self.validate_businessStatusType(self.businessStatus)
        elif nodeName_ == 'code':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'code')
            value_ = self.gds_validate_string(value_, node, 'code')
            self.code = value_
            self.code_nsprefix_ = child_.prefix
            # validate type codeOkatoType
            self.validate_codeOkatoType(self.code)
        elif nodeName_ == 'name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'name')
            value_ = self.gds_validate_string(value_, node, 'name')
            self.name = value_
            self.name_nsprefix_ = child_.prefix
            # validate type nameType
            self.validate_nameType(self.name)
        elif nodeName_ == 'parentCode':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'parentCode')
            value_ = self.gds_validate_string(value_, node, 'parentCode')
            self.parentCode = value_
            self.parentCode_nsprefix_ = child_.prefix
            # validate type codeOkatoType
            self.validate_codeOkatoType(self.parentCode)
# end class nsiOkatoDataType


class nsiOkdpDataType(GeneratedsSuper):
    """Общероссийский классификатор видов экономической деятельности, продукции
    и услуг"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'guid': MemberSpec_('guid', ['guidType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'guid', 'type': 'xs:string'}, None),
        'changeDateTime': MemberSpec_('changeDateTime', 'xs:dateTime', 0, 1, {'minOccurs': '0', 'name': 'changeDateTime', 'type': 'xs:dateTime'}, None),
        'startDateActive': MemberSpec_('startDateActive', 'xs:date', 0, 1, {'minOccurs': '0', 'name': 'startDateActive', 'type': 'xs:date'}, None),
        'endDateActive': MemberSpec_('endDateActive', 'xs:date', 0, 1, {'minOccurs': '0', 'name': 'endDateActive', 'type': 'xs:date'}, None),
        'businessStatus': MemberSpec_('businessStatus', ['businessStatusType', 'xs:string'], 0, 0, {'name': 'businessStatus', 'type': 'xs:string'}, None),
        'code': MemberSpec_('code', ['codeOkdpType', 'nonEmptyString', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'code', 'type': 'xs:string'}, None),
        'name': MemberSpec_('name', ['nameType1', 't:nonEmptyString'], 0, 0, {'name': 'name', 'type': 'xs:string'}, None),
        'parentCode': MemberSpec_('parentCode', ['codeOkdpType', 'nonEmptyString', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'parentCode', 'type': 'xs:string'}, None),
        'section': MemberSpec_('section', ['sectionType', 't:nonEmptyString'], 0, 1, {'minOccurs': '0', 'name': 'section', 'type': 'xs:string'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, guid=None, changeDateTime=None, startDateActive=None, endDateActive=None, businessStatus=None, code=None, name=None, parentCode=None, section=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.guid = guid
        self.validate_guidType(self.guid)
        self.guid_nsprefix_ = None
        if isinstance(changeDateTime, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(changeDateTime, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = changeDateTime
        self.changeDateTime = initvalue_
        self.changeDateTime_nsprefix_ = None
        if isinstance(startDateActive, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(startDateActive, '%Y-%m-%d').date()
        else:
            initvalue_ = startDateActive
        self.startDateActive = initvalue_
        self.startDateActive_nsprefix_ = None
        if isinstance(endDateActive, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(endDateActive, '%Y-%m-%d').date()
        else:
            initvalue_ = endDateActive
        self.endDateActive = initvalue_
        self.endDateActive_nsprefix_ = None
        self.businessStatus = businessStatus
        self.validate_businessStatusType(self.businessStatus)
        self.businessStatus_nsprefix_ = None
        self.code = code
        self.validate_codeOkdpType(self.code)
        self.code_nsprefix_ = None
        self.name = name
        self.validate_nameType1(self.name)
        self.name_nsprefix_ = None
        self.parentCode = parentCode
        self.validate_codeOkdpType(self.parentCode)
        self.parentCode_nsprefix_ = None
        self.section = section
        self.validate_sectionType(self.section)
        self.section_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, nsiOkdpDataType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if nsiOkdpDataType.subclass:
            return nsiOkdpDataType.subclass(*args_, **kwargs_)
        else:
            return nsiOkdpDataType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_guidType(self, value):
        result = True
        # Validate type guidType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) != 36:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd length restriction on guidType' % {"value": encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_guidType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_guidType_patterns_, ))
                result = False
        return result
    validate_guidType_patterns_ = [['^([a-fA-F0-9]{8}\\-[a-fA-F0-9]{4}\\-[a-fA-F0-9]{4}\\-[a-fA-F0-9]{4}\\-[a-fA-F0-9]{12})$']]
    def validate_businessStatusType(self, value):
        result = True
        # Validate type businessStatusType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['801', '866']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on businessStatusType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_codeOkdpType(self, value):
        result = True
        # Validate type codeOkdpType, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on codeOkdpType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_codeOkdpType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_codeOkdpType_patterns_, ))
                result = False
        return result
    validate_codeOkdpType_patterns_ = [['^(\\d{7}|[A-Q]{1})$']]
    def validate_nameType1(self, value):
        result = True
        # Validate type nameType1, a restriction on t:nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 500:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on nameType1' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on nameType1' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_sectionType(self, value):
        result = True
        # Validate type sectionType, a restriction on t:nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on sectionType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on sectionType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.guid is not None or
            self.changeDateTime is not None or
            self.startDateActive is not None or
            self.endDateActive is not None or
            self.businessStatus is not None or
            self.code is not None or
            self.name is not None or
            self.parentCode is not None or
            self.section is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'guid':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'guid')
            value_ = self.gds_validate_string(value_, node, 'guid')
            self.guid = value_
            self.guid_nsprefix_ = child_.prefix
            # validate type guidType
            self.validate_guidType(self.guid)
        elif nodeName_ == 'changeDateTime':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.changeDateTime = dval_
            self.changeDateTime_nsprefix_ = child_.prefix
        elif nodeName_ == 'startDateActive':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.startDateActive = dval_
            self.startDateActive_nsprefix_ = child_.prefix
        elif nodeName_ == 'endDateActive':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.endDateActive = dval_
            self.endDateActive_nsprefix_ = child_.prefix
        elif nodeName_ == 'businessStatus':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'businessStatus')
            value_ = self.gds_validate_string(value_, node, 'businessStatus')
            self.businessStatus = value_
            self.businessStatus_nsprefix_ = child_.prefix
            # validate type businessStatusType
            self.validate_businessStatusType(self.businessStatus)
        elif nodeName_ == 'code':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'code')
            value_ = self.gds_validate_string(value_, node, 'code')
            self.code = value_
            self.code_nsprefix_ = child_.prefix
            # validate type codeOkdpType
            self.validate_codeOkdpType(self.code)
        elif nodeName_ == 'name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'name')
            value_ = self.gds_validate_string(value_, node, 'name')
            self.name = value_
            self.name_nsprefix_ = child_.prefix
            # validate type nameType1
            self.validate_nameType1(self.name)
        elif nodeName_ == 'parentCode':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'parentCode')
            value_ = self.gds_validate_string(value_, node, 'parentCode')
            self.parentCode = value_
            self.parentCode_nsprefix_ = child_.prefix
            # validate type codeOkdpType
            self.validate_codeOkdpType(self.parentCode)
        elif nodeName_ == 'section':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'section')
            value_ = self.gds_validate_string(value_, node, 'section')
            self.section = value_
            self.section_nsprefix_ = child_.prefix
            # validate type sectionType
            self.validate_sectionType(self.section)
# end class nsiOkdpDataType


class nsiOkpd2DataType(GeneratedsSuper):
    """Общероссийский классификатор продукции по видам экономической
    деятельности 2"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'guid': MemberSpec_('guid', ['guidType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'guid', 'type': 'xs:string'}, None),
        'changeDateTime': MemberSpec_('changeDateTime', 'xs:dateTime', 0, 1, {'minOccurs': '0', 'name': 'changeDateTime', 'type': 'xs:dateTime'}, None),
        'businessStatus': MemberSpec_('businessStatus', ['businessStatusType', 'xs:string'], 0, 0, {'name': 'businessStatus', 'type': 'xs:string'}, None),
        'code': MemberSpec_('code', ['codeOkpd2Type', 'nonEmptyString', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'code', 'type': 'xs:string'}, None),
        'name': MemberSpec_('name', ['nameType2', 't:nonEmptyString'], 0, 0, {'name': 'name', 'type': 'xs:string'}, None),
        'parentCode': MemberSpec_('parentCode', ['codeOkpd2Type', 'nonEmptyString', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'parentCode', 'type': 'xs:string'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, guid=None, changeDateTime=None, businessStatus=None, code=None, name=None, parentCode=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.guid = guid
        self.validate_guidType(self.guid)
        self.guid_nsprefix_ = None
        if isinstance(changeDateTime, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(changeDateTime, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = changeDateTime
        self.changeDateTime = initvalue_
        self.changeDateTime_nsprefix_ = None
        self.businessStatus = businessStatus
        self.validate_businessStatusType(self.businessStatus)
        self.businessStatus_nsprefix_ = None
        self.code = code
        self.validate_codeOkpd2Type(self.code)
        self.code_nsprefix_ = None
        self.name = name
        self.validate_nameType2(self.name)
        self.name_nsprefix_ = None
        self.parentCode = parentCode
        self.validate_codeOkpd2Type(self.parentCode)
        self.parentCode_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, nsiOkpd2DataType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if nsiOkpd2DataType.subclass:
            return nsiOkpd2DataType.subclass(*args_, **kwargs_)
        else:
            return nsiOkpd2DataType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_guidType(self, value):
        result = True
        # Validate type guidType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) != 36:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd length restriction on guidType' % {"value": encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_guidType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_guidType_patterns_, ))
                result = False
        return result
    validate_guidType_patterns_ = [['^([a-fA-F0-9]{8}\\-[a-fA-F0-9]{4}\\-[a-fA-F0-9]{4}\\-[a-fA-F0-9]{4}\\-[a-fA-F0-9]{12})$']]
    def validate_businessStatusType(self, value):
        result = True
        # Validate type businessStatusType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['801', '866']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on businessStatusType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_codeOkpd2Type(self, value):
        result = True
        # Validate type codeOkpd2Type, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on codeOkpd2Type' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_codeOkpd2Type_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_codeOkpd2Type_patterns_, ))
                result = False
        return result
    validate_codeOkpd2Type_patterns_ = [['^(\\d{7}|[A-Q]{1})$']]
    def validate_nameType2(self, value):
        result = True
        # Validate type nameType2, a restriction on t:nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 500:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on nameType2' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on nameType2' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.guid is not None or
            self.changeDateTime is not None or
            self.businessStatus is not None or
            self.code is not None or
            self.name is not None or
            self.parentCode is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'guid':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'guid')
            value_ = self.gds_validate_string(value_, node, 'guid')
            self.guid = value_
            self.guid_nsprefix_ = child_.prefix
            # validate type guidType
            self.validate_guidType(self.guid)
        elif nodeName_ == 'changeDateTime':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.changeDateTime = dval_
            self.changeDateTime_nsprefix_ = child_.prefix
        elif nodeName_ == 'businessStatus':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'businessStatus')
            value_ = self.gds_validate_string(value_, node, 'businessStatus')
            self.businessStatus = value_
            self.businessStatus_nsprefix_ = child_.prefix
            # validate type businessStatusType
            self.validate_businessStatusType(self.businessStatus)
        elif nodeName_ == 'code':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'code')
            value_ = self.gds_validate_string(value_, node, 'code')
            self.code = value_
            self.code_nsprefix_ = child_.prefix
            # validate type codeOkpd2Type
            self.validate_codeOkpd2Type(self.code)
        elif nodeName_ == 'name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'name')
            value_ = self.gds_validate_string(value_, node, 'name')
            self.name = value_
            self.name_nsprefix_ = child_.prefix
            # validate type nameType2
            self.validate_nameType2(self.name)
        elif nodeName_ == 'parentCode':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'parentCode')
            value_ = self.gds_validate_string(value_, node, 'parentCode')
            self.parentCode = value_
            self.parentCode_nsprefix_ = child_.prefix
            # validate type codeOkpd2Type
            self.validate_codeOkpd2Type(self.parentCode)
# end class nsiOkpd2DataType


class nsiOkeiDataType(GeneratedsSuper):
    """Общероссийский классификатор единиц измерения"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'guid': MemberSpec_('guid', ['guidType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'guid', 'type': 'xs:string'}, None),
        'changeDateTime': MemberSpec_('changeDateTime', 'xs:dateTime', 0, 1, {'minOccurs': '0', 'name': 'changeDateTime', 'type': 'xs:dateTime'}, None),
        'startDateActive': MemberSpec_('startDateActive', 'xs:date', 0, 1, {'minOccurs': '0', 'name': 'startDateActive', 'type': 'xs:date'}, None),
        'endDateActive': MemberSpec_('endDateActive', 'xs:date', 0, 1, {'minOccurs': '0', 'name': 'endDateActive', 'type': 'xs:date'}, None),
        'businessStatus': MemberSpec_('businessStatus', ['businessStatusType', 'xs:string'], 0, 0, {'name': 'businessStatus', 'type': 'xs:string'}, None),
        'code': MemberSpec_('code', ['codeOkeiType', 'nonEmptyString', 'xs:string'], 0, 0, {'name': 'code', 'type': 'xs:string'}, None),
        'name': MemberSpec_('name', ['nameType3', 't:nonEmptyString'], 0, 0, {'name': 'name', 'type': 'xs:string'}, None),
        'symbol': MemberSpec_('symbol', ['symbolType', 't:nonEmptyString'], 0, 1, {'minOccurs': '0', 'name': 'symbol', 'type': 'xs:string'}, None),
        'section': MemberSpec_('section', 'sectionType4', 0, 0, {'name': 'section', 'type': 'sectionType4'}, None),
        'group': MemberSpec_('group', 'groupType', 0, 0, {'name': 'group', 'type': 'groupType'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, guid=None, changeDateTime=None, startDateActive=None, endDateActive=None, businessStatus=None, code=None, name=None, symbol=None, section=None, group=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.guid = guid
        self.validate_guidType(self.guid)
        self.guid_nsprefix_ = None
        if isinstance(changeDateTime, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(changeDateTime, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = changeDateTime
        self.changeDateTime = initvalue_
        self.changeDateTime_nsprefix_ = None
        if isinstance(startDateActive, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(startDateActive, '%Y-%m-%d').date()
        else:
            initvalue_ = startDateActive
        self.startDateActive = initvalue_
        self.startDateActive_nsprefix_ = None
        if isinstance(endDateActive, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(endDateActive, '%Y-%m-%d').date()
        else:
            initvalue_ = endDateActive
        self.endDateActive = initvalue_
        self.endDateActive_nsprefix_ = None
        self.businessStatus = businessStatus
        self.validate_businessStatusType(self.businessStatus)
        self.businessStatus_nsprefix_ = None
        self.code = code
        self.validate_codeOkeiType(self.code)
        self.code_nsprefix_ = None
        self.name = name
        self.validate_nameType3(self.name)
        self.name_nsprefix_ = None
        self.symbol = symbol
        self.validate_symbolType(self.symbol)
        self.symbol_nsprefix_ = None
        self.section = section
        self.section_nsprefix_ = None
        self.group = group
        self.group_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, nsiOkeiDataType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if nsiOkeiDataType.subclass:
            return nsiOkeiDataType.subclass(*args_, **kwargs_)
        else:
            return nsiOkeiDataType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_guidType(self, value):
        result = True
        # Validate type guidType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) != 36:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd length restriction on guidType' % {"value": encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_guidType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_guidType_patterns_, ))
                result = False
        return result
    validate_guidType_patterns_ = [['^([a-fA-F0-9]{8}\\-[a-fA-F0-9]{4}\\-[a-fA-F0-9]{4}\\-[a-fA-F0-9]{4}\\-[a-fA-F0-9]{12})$']]
    def validate_businessStatusType(self, value):
        result = True
        # Validate type businessStatusType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['801', '866']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on businessStatusType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_codeOkeiType(self, value):
        result = True
        # Validate type codeOkeiType, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on codeOkeiType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_codeOkeiType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_codeOkeiType_patterns_, ))
                result = False
        return result
    validate_codeOkeiType_patterns_ = [['^(\\d{3})$']]
    def validate_nameType3(self, value):
        result = True
        # Validate type nameType3, a restriction on t:nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on nameType3' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on nameType3' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_symbolType(self, value):
        result = True
        # Validate type symbolType, a restriction on t:nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 30:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on symbolType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on symbolType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.guid is not None or
            self.changeDateTime is not None or
            self.startDateActive is not None or
            self.endDateActive is not None or
            self.businessStatus is not None or
            self.code is not None or
            self.name is not None or
            self.symbol is not None or
            self.section is not None or
            self.group is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'guid':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'guid')
            value_ = self.gds_validate_string(value_, node, 'guid')
            self.guid = value_
            self.guid_nsprefix_ = child_.prefix
            # validate type guidType
            self.validate_guidType(self.guid)
        elif nodeName_ == 'changeDateTime':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.changeDateTime = dval_
            self.changeDateTime_nsprefix_ = child_.prefix
        elif nodeName_ == 'startDateActive':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.startDateActive = dval_
            self.startDateActive_nsprefix_ = child_.prefix
        elif nodeName_ == 'endDateActive':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.endDateActive = dval_
            self.endDateActive_nsprefix_ = child_.prefix
        elif nodeName_ == 'businessStatus':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'businessStatus')
            value_ = self.gds_validate_string(value_, node, 'businessStatus')
            self.businessStatus = value_
            self.businessStatus_nsprefix_ = child_.prefix
            # validate type businessStatusType
            self.validate_businessStatusType(self.businessStatus)
        elif nodeName_ == 'code':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'code')
            value_ = self.gds_validate_string(value_, node, 'code')
            self.code = value_
            self.code_nsprefix_ = child_.prefix
            # validate type codeOkeiType
            self.validate_codeOkeiType(self.code)
        elif nodeName_ == 'name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'name')
            value_ = self.gds_validate_string(value_, node, 'name')
            self.name = value_
            self.name_nsprefix_ = child_.prefix
            # validate type nameType3
            self.validate_nameType3(self.name)
        elif nodeName_ == 'symbol':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'symbol')
            value_ = self.gds_validate_string(value_, node, 'symbol')
            self.symbol = value_
            self.symbol_nsprefix_ = child_.prefix
            # validate type symbolType
            self.validate_symbolType(self.symbol)
        elif nodeName_ == 'section':
            obj_ = sectionType4.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.section = obj_
            obj_.original_tagname_ = 'section'
        elif nodeName_ == 'group':
            obj_ = groupType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.group = obj_
            obj_.original_tagname_ = 'group'
# end class nsiOkeiDataType


class nsiOkfsDataType(GeneratedsSuper):
    """Общероссийский классификатор форм собственности"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'guid': MemberSpec_('guid', ['guidType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'guid', 'type': 'xs:string'}, None),
        'changeDateTime': MemberSpec_('changeDateTime', 'xs:dateTime', 0, 1, {'minOccurs': '0', 'name': 'changeDateTime', 'type': 'xs:dateTime'}, None),
        'startDateActive': MemberSpec_('startDateActive', 'xs:date', 0, 1, {'minOccurs': '0', 'name': 'startDateActive', 'type': 'xs:date'}, None),
        'endDateActive': MemberSpec_('endDateActive', 'xs:date', 0, 1, {'minOccurs': '0', 'name': 'endDateActive', 'type': 'xs:date'}, None),
        'businessStatus': MemberSpec_('businessStatus', ['businessStatusType', 'xs:string'], 0, 0, {'name': 'businessStatus', 'type': 'xs:string'}, None),
        'code': MemberSpec_('code', ['codeOkfsType', 'nonEmptyString', 'xs:string'], 0, 0, {'name': 'code', 'type': 'xs:string'}, None),
        'name': MemberSpec_('name', ['nameType7', 't:nonEmptyString'], 0, 0, {'name': 'name', 'type': 'xs:string'}, None),
        'parentCode': MemberSpec_('parentCode', ['codeOkfsType', 'nonEmptyString', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'parentCode', 'type': 'xs:string'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, guid=None, changeDateTime=None, startDateActive=None, endDateActive=None, businessStatus=None, code=None, name=None, parentCode=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.guid = guid
        self.validate_guidType(self.guid)
        self.guid_nsprefix_ = None
        if isinstance(changeDateTime, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(changeDateTime, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = changeDateTime
        self.changeDateTime = initvalue_
        self.changeDateTime_nsprefix_ = None
        if isinstance(startDateActive, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(startDateActive, '%Y-%m-%d').date()
        else:
            initvalue_ = startDateActive
        self.startDateActive = initvalue_
        self.startDateActive_nsprefix_ = None
        if isinstance(endDateActive, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(endDateActive, '%Y-%m-%d').date()
        else:
            initvalue_ = endDateActive
        self.endDateActive = initvalue_
        self.endDateActive_nsprefix_ = None
        self.businessStatus = businessStatus
        self.validate_businessStatusType(self.businessStatus)
        self.businessStatus_nsprefix_ = None
        self.code = code
        self.validate_codeOkfsType(self.code)
        self.code_nsprefix_ = None
        self.name = name
        self.validate_nameType7(self.name)
        self.name_nsprefix_ = None
        self.parentCode = parentCode
        self.validate_codeOkfsType(self.parentCode)
        self.parentCode_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, nsiOkfsDataType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if nsiOkfsDataType.subclass:
            return nsiOkfsDataType.subclass(*args_, **kwargs_)
        else:
            return nsiOkfsDataType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_guidType(self, value):
        result = True
        # Validate type guidType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) != 36:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd length restriction on guidType' % {"value": encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_guidType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_guidType_patterns_, ))
                result = False
        return result
    validate_guidType_patterns_ = [['^([a-fA-F0-9]{8}\\-[a-fA-F0-9]{4}\\-[a-fA-F0-9]{4}\\-[a-fA-F0-9]{4}\\-[a-fA-F0-9]{12})$']]
    def validate_businessStatusType(self, value):
        result = True
        # Validate type businessStatusType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['801', '866']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on businessStatusType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_codeOkfsType(self, value):
        result = True
        # Validate type codeOkfsType, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on codeOkfsType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_codeOkfsType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_codeOkfsType_patterns_, ))
                result = False
        return result
    validate_codeOkfsType_patterns_ = [['^(\\d{2})$']]
    def validate_nameType7(self, value):
        result = True
        # Validate type nameType7, a restriction on t:nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 250:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on nameType7' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on nameType7' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.guid is not None or
            self.changeDateTime is not None or
            self.startDateActive is not None or
            self.endDateActive is not None or
            self.businessStatus is not None or
            self.code is not None or
            self.name is not None or
            self.parentCode is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'guid':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'guid')
            value_ = self.gds_validate_string(value_, node, 'guid')
            self.guid = value_
            self.guid_nsprefix_ = child_.prefix
            # validate type guidType
            self.validate_guidType(self.guid)
        elif nodeName_ == 'changeDateTime':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.changeDateTime = dval_
            self.changeDateTime_nsprefix_ = child_.prefix
        elif nodeName_ == 'startDateActive':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.startDateActive = dval_
            self.startDateActive_nsprefix_ = child_.prefix
        elif nodeName_ == 'endDateActive':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.endDateActive = dval_
            self.endDateActive_nsprefix_ = child_.prefix
        elif nodeName_ == 'businessStatus':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'businessStatus')
            value_ = self.gds_validate_string(value_, node, 'businessStatus')
            self.businessStatus = value_
            self.businessStatus_nsprefix_ = child_.prefix
            # validate type businessStatusType
            self.validate_businessStatusType(self.businessStatus)
        elif nodeName_ == 'code':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'code')
            value_ = self.gds_validate_string(value_, node, 'code')
            self.code = value_
            self.code_nsprefix_ = child_.prefix
            # validate type codeOkfsType
            self.validate_codeOkfsType(self.code)
        elif nodeName_ == 'name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'name')
            value_ = self.gds_validate_string(value_, node, 'name')
            self.name = value_
            self.name_nsprefix_ = child_.prefix
            # validate type nameType7
            self.validate_nameType7(self.name)
        elif nodeName_ == 'parentCode':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'parentCode')
            value_ = self.gds_validate_string(value_, node, 'parentCode')
            self.parentCode = value_
            self.parentCode_nsprefix_ = child_.prefix
            # validate type codeOkfsType
            self.validate_codeOkfsType(self.parentCode)
# end class nsiOkfsDataType


class nsiOktmoDataType(GeneratedsSuper):
    """Общероссийский классификатор территорий муниципальных образований"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'guid': MemberSpec_('guid', ['guidType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'guid', 'type': 'xs:string'}, None),
        'changeDateTime': MemberSpec_('changeDateTime', 'xs:dateTime', 0, 1, {'minOccurs': '0', 'name': 'changeDateTime', 'type': 'xs:dateTime'}, None),
        'startDateActive': MemberSpec_('startDateActive', 'xs:date', 0, 1, {'minOccurs': '0', 'name': 'startDateActive', 'type': 'xs:date'}, None),
        'endDateActive': MemberSpec_('endDateActive', 'xs:date', 0, 1, {'minOccurs': '0', 'name': 'endDateActive', 'type': 'xs:date'}, None),
        'businessStatus': MemberSpec_('businessStatus', ['businessStatusType', 'xs:string'], 0, 0, {'name': 'businessStatus', 'type': 'xs:string'}, None),
        'code': MemberSpec_('code', ['codeOktmoType', 'nonEmptyString', 'xs:string'], 0, 0, {'name': 'code', 'type': 'xs:string'}, None),
        'name': MemberSpec_('name', ['nameType8', 't:nonEmptyString'], 0, 0, {'name': 'name', 'type': 'xs:string'}, None),
        'parentCode': MemberSpec_('parentCode', ['codeOktmoType', 'nonEmptyString', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'parentCode', 'type': 'xs:string'}, None),
        'okato': MemberSpec_('okato', ['okatoType', 't:nonEmptyString'], 0, 1, {'minOccurs': '0', 'name': 'okato', 'type': 'xs:string'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, guid=None, changeDateTime=None, startDateActive=None, endDateActive=None, businessStatus=None, code=None, name=None, parentCode=None, okato=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.guid = guid
        self.validate_guidType(self.guid)
        self.guid_nsprefix_ = None
        if isinstance(changeDateTime, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(changeDateTime, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = changeDateTime
        self.changeDateTime = initvalue_
        self.changeDateTime_nsprefix_ = None
        if isinstance(startDateActive, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(startDateActive, '%Y-%m-%d').date()
        else:
            initvalue_ = startDateActive
        self.startDateActive = initvalue_
        self.startDateActive_nsprefix_ = None
        if isinstance(endDateActive, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(endDateActive, '%Y-%m-%d').date()
        else:
            initvalue_ = endDateActive
        self.endDateActive = initvalue_
        self.endDateActive_nsprefix_ = None
        self.businessStatus = businessStatus
        self.validate_businessStatusType(self.businessStatus)
        self.businessStatus_nsprefix_ = None
        self.code = code
        self.validate_codeOktmoType(self.code)
        self.code_nsprefix_ = None
        self.name = name
        self.validate_nameType8(self.name)
        self.name_nsprefix_ = None
        self.parentCode = parentCode
        self.validate_codeOktmoType(self.parentCode)
        self.parentCode_nsprefix_ = None
        self.okato = okato
        self.validate_okatoType(self.okato)
        self.okato_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, nsiOktmoDataType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if nsiOktmoDataType.subclass:
            return nsiOktmoDataType.subclass(*args_, **kwargs_)
        else:
            return nsiOktmoDataType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_guidType(self, value):
        result = True
        # Validate type guidType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) != 36:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd length restriction on guidType' % {"value": encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_guidType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_guidType_patterns_, ))
                result = False
        return result
    validate_guidType_patterns_ = [['^([a-fA-F0-9]{8}\\-[a-fA-F0-9]{4}\\-[a-fA-F0-9]{4}\\-[a-fA-F0-9]{4}\\-[a-fA-F0-9]{12})$']]
    def validate_businessStatusType(self, value):
        result = True
        # Validate type businessStatusType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['801', '866']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on businessStatusType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_codeOktmoType(self, value):
        result = True
        # Validate type codeOktmoType, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on codeOktmoType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_codeOktmoType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_codeOktmoType_patterns_, ))
                result = False
        return result
    validate_codeOktmoType_patterns_ = [['^(\\d{2,11})$']]
    def validate_nameType8(self, value):
        result = True
        # Validate type nameType8, a restriction on t:nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 500:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on nameType8' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on nameType8' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_okatoType(self, value):
        result = True
        # Validate type okatoType, a restriction on t:nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 4000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on okatoType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on okatoType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.guid is not None or
            self.changeDateTime is not None or
            self.startDateActive is not None or
            self.endDateActive is not None or
            self.businessStatus is not None or
            self.code is not None or
            self.name is not None or
            self.parentCode is not None or
            self.okato is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'guid':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'guid')
            value_ = self.gds_validate_string(value_, node, 'guid')
            self.guid = value_
            self.guid_nsprefix_ = child_.prefix
            # validate type guidType
            self.validate_guidType(self.guid)
        elif nodeName_ == 'changeDateTime':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.changeDateTime = dval_
            self.changeDateTime_nsprefix_ = child_.prefix
        elif nodeName_ == 'startDateActive':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.startDateActive = dval_
            self.startDateActive_nsprefix_ = child_.prefix
        elif nodeName_ == 'endDateActive':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.endDateActive = dval_
            self.endDateActive_nsprefix_ = child_.prefix
        elif nodeName_ == 'businessStatus':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'businessStatus')
            value_ = self.gds_validate_string(value_, node, 'businessStatus')
            self.businessStatus = value_
            self.businessStatus_nsprefix_ = child_.prefix
            # validate type businessStatusType
            self.validate_businessStatusType(self.businessStatus)
        elif nodeName_ == 'code':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'code')
            value_ = self.gds_validate_string(value_, node, 'code')
            self.code = value_
            self.code_nsprefix_ = child_.prefix
            # validate type codeOktmoType
            self.validate_codeOktmoType(self.code)
        elif nodeName_ == 'name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'name')
            value_ = self.gds_validate_string(value_, node, 'name')
            self.name = value_
            self.name_nsprefix_ = child_.prefix
            # validate type nameType8
            self.validate_nameType8(self.name)
        elif nodeName_ == 'parentCode':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'parentCode')
            value_ = self.gds_validate_string(value_, node, 'parentCode')
            self.parentCode = value_
            self.parentCode_nsprefix_ = child_.prefix
            # validate type codeOktmoType
            self.validate_codeOktmoType(self.parentCode)
        elif nodeName_ == 'okato':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'okato')
            value_ = self.gds_validate_string(value_, node, 'okato')
            self.okato = value_
            self.okato_nsprefix_ = child_.prefix
            # validate type okatoType
            self.validate_okatoType(self.okato)
# end class nsiOktmoDataType


class nsiOkoguDataType(GeneratedsSuper):
    """Общероссийский классификатор органов государственной власти и
    управления"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'guid': MemberSpec_('guid', ['guidType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'guid', 'type': 'xs:string'}, None),
        'changeDateTime': MemberSpec_('changeDateTime', 'xs:dateTime', 0, 1, {'minOccurs': '0', 'name': 'changeDateTime', 'type': 'xs:dateTime'}, None),
        'startDateActive': MemberSpec_('startDateActive', 'xs:date', 0, 1, {'minOccurs': '0', 'name': 'startDateActive', 'type': 'xs:date'}, None),
        'endDateActive': MemberSpec_('endDateActive', 'xs:date', 0, 1, {'minOccurs': '0', 'name': 'endDateActive', 'type': 'xs:date'}, None),
        'businessStatus': MemberSpec_('businessStatus', ['businessStatusType', 'xs:string'], 0, 0, {'name': 'businessStatus', 'type': 'xs:string'}, None),
        'code': MemberSpec_('code', ['codeOkoguType', 'nonEmptyString', 'xs:string'], 0, 0, {'name': 'code', 'type': 'xs:string'}, None),
        'name': MemberSpec_('name', ['nameType9', 't:nonEmptyString'], 0, 0, {'name': 'name', 'type': 'xs:string'}, None),
        'parentCode': MemberSpec_('parentCode', ['codeOkoguType', 'nonEmptyString', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'parentCode', 'type': 'xs:string'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, guid=None, changeDateTime=None, startDateActive=None, endDateActive=None, businessStatus=None, code=None, name=None, parentCode=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.guid = guid
        self.validate_guidType(self.guid)
        self.guid_nsprefix_ = None
        if isinstance(changeDateTime, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(changeDateTime, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = changeDateTime
        self.changeDateTime = initvalue_
        self.changeDateTime_nsprefix_ = None
        if isinstance(startDateActive, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(startDateActive, '%Y-%m-%d').date()
        else:
            initvalue_ = startDateActive
        self.startDateActive = initvalue_
        self.startDateActive_nsprefix_ = None
        if isinstance(endDateActive, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(endDateActive, '%Y-%m-%d').date()
        else:
            initvalue_ = endDateActive
        self.endDateActive = initvalue_
        self.endDateActive_nsprefix_ = None
        self.businessStatus = businessStatus
        self.validate_businessStatusType(self.businessStatus)
        self.businessStatus_nsprefix_ = None
        self.code = code
        self.validate_codeOkoguType(self.code)
        self.code_nsprefix_ = None
        self.name = name
        self.validate_nameType9(self.name)
        self.name_nsprefix_ = None
        self.parentCode = parentCode
        self.validate_codeOkoguType(self.parentCode)
        self.parentCode_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, nsiOkoguDataType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if nsiOkoguDataType.subclass:
            return nsiOkoguDataType.subclass(*args_, **kwargs_)
        else:
            return nsiOkoguDataType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_guidType(self, value):
        result = True
        # Validate type guidType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) != 36:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd length restriction on guidType' % {"value": encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_guidType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_guidType_patterns_, ))
                result = False
        return result
    validate_guidType_patterns_ = [['^([a-fA-F0-9]{8}\\-[a-fA-F0-9]{4}\\-[a-fA-F0-9]{4}\\-[a-fA-F0-9]{4}\\-[a-fA-F0-9]{12})$']]
    def validate_businessStatusType(self, value):
        result = True
        # Validate type businessStatusType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['801', '866']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on businessStatusType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_codeOkoguType(self, value):
        result = True
        # Validate type codeOkoguType, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on codeOkoguType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_codeOkoguType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_codeOkoguType_patterns_, ))
                result = False
        return result
    validate_codeOkoguType_patterns_ = [['^(\\d{7}|\\d{5})$']]
    def validate_nameType9(self, value):
        result = True
        # Validate type nameType9, a restriction on t:nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 250:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on nameType9' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on nameType9' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.guid is not None or
            self.changeDateTime is not None or
            self.startDateActive is not None or
            self.endDateActive is not None or
            self.businessStatus is not None or
            self.code is not None or
            self.name is not None or
            self.parentCode is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'guid':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'guid')
            value_ = self.gds_validate_string(value_, node, 'guid')
            self.guid = value_
            self.guid_nsprefix_ = child_.prefix
            # validate type guidType
            self.validate_guidType(self.guid)
        elif nodeName_ == 'changeDateTime':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.changeDateTime = dval_
            self.changeDateTime_nsprefix_ = child_.prefix
        elif nodeName_ == 'startDateActive':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.startDateActive = dval_
            self.startDateActive_nsprefix_ = child_.prefix
        elif nodeName_ == 'endDateActive':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.endDateActive = dval_
            self.endDateActive_nsprefix_ = child_.prefix
        elif nodeName_ == 'businessStatus':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'businessStatus')
            value_ = self.gds_validate_string(value_, node, 'businessStatus')
            self.businessStatus = value_
            self.businessStatus_nsprefix_ = child_.prefix
            # validate type businessStatusType
            self.validate_businessStatusType(self.businessStatus)
        elif nodeName_ == 'code':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'code')
            value_ = self.gds_validate_string(value_, node, 'code')
            self.code = value_
            self.code_nsprefix_ = child_.prefix
            # validate type codeOkoguType
            self.validate_codeOkoguType(self.code)
        elif nodeName_ == 'name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'name')
            value_ = self.gds_validate_string(value_, node, 'name')
            self.name = value_
            self.name_nsprefix_ = child_.prefix
            # validate type nameType9
            self.validate_nameType9(self.name)
        elif nodeName_ == 'parentCode':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'parentCode')
            value_ = self.gds_validate_string(value_, node, 'parentCode')
            self.parentCode = value_
            self.parentCode_nsprefix_ = child_.prefix
            # validate type codeOkoguType
            self.validate_codeOkoguType(self.parentCode)
# end class nsiOkoguDataType


class nsiOkopfDataType(GeneratedsSuper):
    """Общероссийский классификатор организационно-правовых форм"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'guid': MemberSpec_('guid', ['guidType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'guid', 'type': 'xs:string'}, None),
        'changeDateTime': MemberSpec_('changeDateTime', 'xs:dateTime', 0, 1, {'minOccurs': '0', 'name': 'changeDateTime', 'type': 'xs:dateTime'}, None),
        'startDateActive': MemberSpec_('startDateActive', 'xs:date', 0, 1, {'minOccurs': '0', 'name': 'startDateActive', 'type': 'xs:date'}, None),
        'endDateActive': MemberSpec_('endDateActive', 'xs:date', 0, 1, {'minOccurs': '0', 'name': 'endDateActive', 'type': 'xs:date'}, None),
        'businessStatus': MemberSpec_('businessStatus', ['businessStatusType', 'xs:string'], 0, 0, {'name': 'businessStatus', 'type': 'xs:string'}, None),
        'code': MemberSpec_('code', ['codeOkopfType', 'nonEmptyString', 'xs:string'], 0, 0, {'name': 'code', 'type': 'xs:string'}, None),
        'name': MemberSpec_('name', ['nameType10', 't:nonEmptyString'], 0, 0, {'name': 'name', 'type': 'xs:string'}, None),
        'parentCode': MemberSpec_('parentCode', ['codeOkopfType', 'nonEmptyString', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'parentCode', 'type': 'xs:string'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, guid=None, changeDateTime=None, startDateActive=None, endDateActive=None, businessStatus=None, code=None, name=None, parentCode=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.guid = guid
        self.validate_guidType(self.guid)
        self.guid_nsprefix_ = None
        if isinstance(changeDateTime, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(changeDateTime, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = changeDateTime
        self.changeDateTime = initvalue_
        self.changeDateTime_nsprefix_ = None
        if isinstance(startDateActive, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(startDateActive, '%Y-%m-%d').date()
        else:
            initvalue_ = startDateActive
        self.startDateActive = initvalue_
        self.startDateActive_nsprefix_ = None
        if isinstance(endDateActive, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(endDateActive, '%Y-%m-%d').date()
        else:
            initvalue_ = endDateActive
        self.endDateActive = initvalue_
        self.endDateActive_nsprefix_ = None
        self.businessStatus = businessStatus
        self.validate_businessStatusType(self.businessStatus)
        self.businessStatus_nsprefix_ = None
        self.code = code
        self.validate_codeOkopfType(self.code)
        self.code_nsprefix_ = None
        self.name = name
        self.validate_nameType10(self.name)
        self.name_nsprefix_ = None
        self.parentCode = parentCode
        self.validate_codeOkopfType(self.parentCode)
        self.parentCode_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, nsiOkopfDataType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if nsiOkopfDataType.subclass:
            return nsiOkopfDataType.subclass(*args_, **kwargs_)
        else:
            return nsiOkopfDataType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_guidType(self, value):
        result = True
        # Validate type guidType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) != 36:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd length restriction on guidType' % {"value": encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_guidType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_guidType_patterns_, ))
                result = False
        return result
    validate_guidType_patterns_ = [['^([a-fA-F0-9]{8}\\-[a-fA-F0-9]{4}\\-[a-fA-F0-9]{4}\\-[a-fA-F0-9]{4}\\-[a-fA-F0-9]{12})$']]
    def validate_businessStatusType(self, value):
        result = True
        # Validate type businessStatusType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['801', '866']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on businessStatusType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_codeOkopfType(self, value):
        result = True
        # Validate type codeOkopfType, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on codeOkopfType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_codeOkopfType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_codeOkopfType_patterns_, ))
                result = False
        return result
    validate_codeOkopfType_patterns_ = [['^(\\d{2}|\\d{5})$']]
    def validate_nameType10(self, value):
        result = True
        # Validate type nameType10, a restriction on t:nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 200:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on nameType10' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on nameType10' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.guid is not None or
            self.changeDateTime is not None or
            self.startDateActive is not None or
            self.endDateActive is not None or
            self.businessStatus is not None or
            self.code is not None or
            self.name is not None or
            self.parentCode is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'guid':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'guid')
            value_ = self.gds_validate_string(value_, node, 'guid')
            self.guid = value_
            self.guid_nsprefix_ = child_.prefix
            # validate type guidType
            self.validate_guidType(self.guid)
        elif nodeName_ == 'changeDateTime':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.changeDateTime = dval_
            self.changeDateTime_nsprefix_ = child_.prefix
        elif nodeName_ == 'startDateActive':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.startDateActive = dval_
            self.startDateActive_nsprefix_ = child_.prefix
        elif nodeName_ == 'endDateActive':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.endDateActive = dval_
            self.endDateActive_nsprefix_ = child_.prefix
        elif nodeName_ == 'businessStatus':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'businessStatus')
            value_ = self.gds_validate_string(value_, node, 'businessStatus')
            self.businessStatus = value_
            self.businessStatus_nsprefix_ = child_.prefix
            # validate type businessStatusType
            self.validate_businessStatusType(self.businessStatus)
        elif nodeName_ == 'code':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'code')
            value_ = self.gds_validate_string(value_, node, 'code')
            self.code = value_
            self.code_nsprefix_ = child_.prefix
            # validate type codeOkopfType
            self.validate_codeOkopfType(self.code)
        elif nodeName_ == 'name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'name')
            value_ = self.gds_validate_string(value_, node, 'name')
            self.name = value_
            self.name_nsprefix_ = child_.prefix
            # validate type nameType10
            self.validate_nameType10(self.name)
        elif nodeName_ == 'parentCode':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'parentCode')
            value_ = self.gds_validate_string(value_, node, 'parentCode')
            self.parentCode = value_
            self.parentCode_nsprefix_ = child_.prefix
            # validate type codeOkopfType
            self.validate_codeOkopfType(self.parentCode)
# end class nsiOkopfDataType


class nsiOkvDataType(GeneratedsSuper):
    """Общероссийский классификатор валют"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'guid': MemberSpec_('guid', ['guidType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'guid', 'type': 'xs:string'}, None),
        'changeDateTime': MemberSpec_('changeDateTime', 'xs:dateTime', 0, 1, {'minOccurs': '0', 'name': 'changeDateTime', 'type': 'xs:dateTime'}, None),
        'startDateActive': MemberSpec_('startDateActive', 'xs:date', 0, 1, {'minOccurs': '0', 'name': 'startDateActive', 'type': 'xs:date'}, None),
        'endDateActive': MemberSpec_('endDateActive', 'xs:date', 0, 1, {'minOccurs': '0', 'name': 'endDateActive', 'type': 'xs:date'}, None),
        'businessStatus': MemberSpec_('businessStatus', ['businessStatusType', 'xs:string'], 0, 0, {'name': 'businessStatus', 'type': 'xs:string'}, None),
        'code': MemberSpec_('code', ['codeType11', 't:nonEmptyString'], 0, 0, {'name': 'code', 'type': 'xs:string'}, None),
        'digitalCode': MemberSpec_('digitalCode', ['digitalCodeType', 't:nonEmptyString'], 0, 0, {'name': 'digitalCode', 'type': 'xs:string'}, None),
        'name': MemberSpec_('name', ['nameType12', 't:nonEmptyString'], 0, 0, {'name': 'name', 'type': 'xs:string'}, None),
        'shortName': MemberSpec_('shortName', ['shortNameType', 't:nonEmptyString'], 0, 1, {'minOccurs': '0', 'name': 'shortName', 'type': 'xs:string'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, guid=None, changeDateTime=None, startDateActive=None, endDateActive=None, businessStatus=None, code=None, digitalCode=None, name=None, shortName=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.guid = guid
        self.validate_guidType(self.guid)
        self.guid_nsprefix_ = None
        if isinstance(changeDateTime, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(changeDateTime, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = changeDateTime
        self.changeDateTime = initvalue_
        self.changeDateTime_nsprefix_ = None
        if isinstance(startDateActive, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(startDateActive, '%Y-%m-%d').date()
        else:
            initvalue_ = startDateActive
        self.startDateActive = initvalue_
        self.startDateActive_nsprefix_ = None
        if isinstance(endDateActive, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(endDateActive, '%Y-%m-%d').date()
        else:
            initvalue_ = endDateActive
        self.endDateActive = initvalue_
        self.endDateActive_nsprefix_ = None
        self.businessStatus = businessStatus
        self.validate_businessStatusType(self.businessStatus)
        self.businessStatus_nsprefix_ = None
        self.code = code
        self.validate_codeType11(self.code)
        self.code_nsprefix_ = None
        self.digitalCode = digitalCode
        self.validate_digitalCodeType(self.digitalCode)
        self.digitalCode_nsprefix_ = None
        self.name = name
        self.validate_nameType12(self.name)
        self.name_nsprefix_ = None
        self.shortName = shortName
        self.validate_shortNameType(self.shortName)
        self.shortName_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, nsiOkvDataType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if nsiOkvDataType.subclass:
            return nsiOkvDataType.subclass(*args_, **kwargs_)
        else:
            return nsiOkvDataType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_guidType(self, value):
        result = True
        # Validate type guidType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) != 36:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd length restriction on guidType' % {"value": encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_guidType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_guidType_patterns_, ))
                result = False
        return result
    validate_guidType_patterns_ = [['^([a-fA-F0-9]{8}\\-[a-fA-F0-9]{4}\\-[a-fA-F0-9]{4}\\-[a-fA-F0-9]{4}\\-[a-fA-F0-9]{12})$']]
    def validate_businessStatusType(self, value):
        result = True
        # Validate type businessStatusType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['801', '866']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on businessStatusType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_codeType11(self, value):
        result = True
        # Validate type codeType11, a restriction on t:nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 3:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on codeType11' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on codeType11' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_digitalCodeType(self, value):
        result = True
        # Validate type digitalCodeType, a restriction on t:nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on digitalCodeType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_digitalCodeType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_digitalCodeType_patterns_, ))
                result = False
        return result
    validate_digitalCodeType_patterns_ = [['^(\\d{3})$']]
    def validate_nameType12(self, value):
        result = True
        # Validate type nameType12, a restriction on t:nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 500:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on nameType12' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on nameType12' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_shortNameType(self, value):
        result = True
        # Validate type shortNameType, a restriction on t:nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 500:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on shortNameType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on shortNameType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.guid is not None or
            self.changeDateTime is not None or
            self.startDateActive is not None or
            self.endDateActive is not None or
            self.businessStatus is not None or
            self.code is not None or
            self.digitalCode is not None or
            self.name is not None or
            self.shortName is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'guid':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'guid')
            value_ = self.gds_validate_string(value_, node, 'guid')
            self.guid = value_
            self.guid_nsprefix_ = child_.prefix
            # validate type guidType
            self.validate_guidType(self.guid)
        elif nodeName_ == 'changeDateTime':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.changeDateTime = dval_
            self.changeDateTime_nsprefix_ = child_.prefix
        elif nodeName_ == 'startDateActive':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.startDateActive = dval_
            self.startDateActive_nsprefix_ = child_.prefix
        elif nodeName_ == 'endDateActive':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.endDateActive = dval_
            self.endDateActive_nsprefix_ = child_.prefix
        elif nodeName_ == 'businessStatus':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'businessStatus')
            value_ = self.gds_validate_string(value_, node, 'businessStatus')
            self.businessStatus = value_
            self.businessStatus_nsprefix_ = child_.prefix
            # validate type businessStatusType
            self.validate_businessStatusType(self.businessStatus)
        elif nodeName_ == 'code':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'code')
            value_ = self.gds_validate_string(value_, node, 'code')
            self.code = value_
            self.code_nsprefix_ = child_.prefix
            # validate type codeType11
            self.validate_codeType11(self.code)
        elif nodeName_ == 'digitalCode':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'digitalCode')
            value_ = self.gds_validate_string(value_, node, 'digitalCode')
            self.digitalCode = value_
            self.digitalCode_nsprefix_ = child_.prefix
            # validate type digitalCodeType
            self.validate_digitalCodeType(self.digitalCode)
        elif nodeName_ == 'name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'name')
            value_ = self.gds_validate_string(value_, node, 'name')
            self.name = value_
            self.name_nsprefix_ = child_.prefix
            # validate type nameType12
            self.validate_nameType12(self.name)
        elif nodeName_ == 'shortName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'shortName')
            value_ = self.gds_validate_string(value_, node, 'shortName')
            self.shortName = value_
            self.shortName_nsprefix_ = child_.prefix
            # validate type shortNameType
            self.validate_shortNameType(self.shortName)
# end class nsiOkvDataType


class nsiOkvedDataType(GeneratedsSuper):
    """Общероссийский классификатор видов экономической деятельности"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'guid': MemberSpec_('guid', ['guidType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'guid', 'type': 'xs:string'}, None),
        'changeDateTime': MemberSpec_('changeDateTime', 'xs:dateTime', 0, 1, {'minOccurs': '0', 'name': 'changeDateTime', 'type': 'xs:dateTime'}, None),
        'startDateActive': MemberSpec_('startDateActive', 'xs:date', 0, 1, {'minOccurs': '0', 'name': 'startDateActive', 'type': 'xs:date'}, None),
        'endDateActive': MemberSpec_('endDateActive', 'xs:date', 0, 1, {'minOccurs': '0', 'name': 'endDateActive', 'type': 'xs:date'}, None),
        'businessStatus': MemberSpec_('businessStatus', ['businessStatusType', 'xs:string'], 0, 0, {'name': 'businessStatus', 'type': 'xs:string'}, None),
        'code': MemberSpec_('code', ['codeOkvedType', 'nonEmptyString', 'xs:string'], 0, 0, {'name': 'code', 'type': 'xs:string'}, None),
        'name': MemberSpec_('name', ['nameType13', 't:nonEmptyString'], 0, 0, {'name': 'name', 'type': 'xs:string'}, None),
        'parentCode': MemberSpec_('parentCode', ['codeOkvedType', 'nonEmptyString', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'parentCode', 'type': 'xs:string'}, None),
        'section': MemberSpec_('section', ['sectionType14', 't:nonEmptyString'], 0, 0, {'name': 'section', 'type': 'xs:string'}, None),
        'subsection': MemberSpec_('subsection', ['subsectionType', 't:nonEmptyString'], 0, 1, {'minOccurs': '0', 'name': 'subsection', 'type': 'xs:string'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, guid=None, changeDateTime=None, startDateActive=None, endDateActive=None, businessStatus=None, code=None, name=None, parentCode=None, section=None, subsection=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.guid = guid
        self.validate_guidType(self.guid)
        self.guid_nsprefix_ = None
        if isinstance(changeDateTime, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(changeDateTime, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = changeDateTime
        self.changeDateTime = initvalue_
        self.changeDateTime_nsprefix_ = None
        if isinstance(startDateActive, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(startDateActive, '%Y-%m-%d').date()
        else:
            initvalue_ = startDateActive
        self.startDateActive = initvalue_
        self.startDateActive_nsprefix_ = None
        if isinstance(endDateActive, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(endDateActive, '%Y-%m-%d').date()
        else:
            initvalue_ = endDateActive
        self.endDateActive = initvalue_
        self.endDateActive_nsprefix_ = None
        self.businessStatus = businessStatus
        self.validate_businessStatusType(self.businessStatus)
        self.businessStatus_nsprefix_ = None
        self.code = code
        self.validate_codeOkvedType(self.code)
        self.code_nsprefix_ = None
        self.name = name
        self.validate_nameType13(self.name)
        self.name_nsprefix_ = None
        self.parentCode = parentCode
        self.validate_codeOkvedType(self.parentCode)
        self.parentCode_nsprefix_ = None
        self.section = section
        self.validate_sectionType14(self.section)
        self.section_nsprefix_ = None
        self.subsection = subsection
        self.validate_subsectionType(self.subsection)
        self.subsection_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, nsiOkvedDataType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if nsiOkvedDataType.subclass:
            return nsiOkvedDataType.subclass(*args_, **kwargs_)
        else:
            return nsiOkvedDataType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_guidType(self, value):
        result = True
        # Validate type guidType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) != 36:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd length restriction on guidType' % {"value": encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_guidType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_guidType_patterns_, ))
                result = False
        return result
    validate_guidType_patterns_ = [['^([a-fA-F0-9]{8}\\-[a-fA-F0-9]{4}\\-[a-fA-F0-9]{4}\\-[a-fA-F0-9]{4}\\-[a-fA-F0-9]{12})$']]
    def validate_businessStatusType(self, value):
        result = True
        # Validate type businessStatusType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['801', '866']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on businessStatusType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_codeOkvedType(self, value):
        result = True
        # Validate type codeOkvedType, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on codeOkvedType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_codeOkvedType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_codeOkvedType_patterns_, ))
                result = False
        return result
    validate_codeOkvedType_patterns_ = [['^([A-Q]{1,2}|(\\d{2}((\\.\\d{1,2})|(\\.\\d{2}\\.\\d{1,2}))?))$']]
    def validate_nameType13(self, value):
        result = True
        # Validate type nameType13, a restriction on t:nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 500:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on nameType13' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on nameType13' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_sectionType14(self, value):
        result = True
        # Validate type sectionType14, a restriction on t:nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on sectionType14' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_sectionType14_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_sectionType14_patterns_, ))
                result = False
        return result
    validate_sectionType14_patterns_ = [['^([A-Q])$']]
    def validate_subsectionType(self, value):
        result = True
        # Validate type subsectionType, a restriction on t:nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on subsectionType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_subsectionType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_subsectionType_patterns_, ))
                result = False
        return result
    validate_subsectionType_patterns_ = [['^([A-Q]{2})$']]
    def hasContent_(self):
        if (
            self.guid is not None or
            self.changeDateTime is not None or
            self.startDateActive is not None or
            self.endDateActive is not None or
            self.businessStatus is not None or
            self.code is not None or
            self.name is not None or
            self.parentCode is not None or
            self.section is not None or
            self.subsection is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'guid':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'guid')
            value_ = self.gds_validate_string(value_, node, 'guid')
            self.guid = value_
            self.guid_nsprefix_ = child_.prefix
            # validate type guidType
            self.validate_guidType(self.guid)
        elif nodeName_ == 'changeDateTime':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.changeDateTime = dval_
            self.changeDateTime_nsprefix_ = child_.prefix
        elif nodeName_ == 'startDateActive':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.startDateActive = dval_
            self.startDateActive_nsprefix_ = child_.prefix
        elif nodeName_ == 'endDateActive':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.endDateActive = dval_
            self.endDateActive_nsprefix_ = child_.prefix
        elif nodeName_ == 'businessStatus':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'businessStatus')
            value_ = self.gds_validate_string(value_, node, 'businessStatus')
            self.businessStatus = value_
            self.businessStatus_nsprefix_ = child_.prefix
            # validate type businessStatusType
            self.validate_businessStatusType(self.businessStatus)
        elif nodeName_ == 'code':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'code')
            value_ = self.gds_validate_string(value_, node, 'code')
            self.code = value_
            self.code_nsprefix_ = child_.prefix
            # validate type codeOkvedType
            self.validate_codeOkvedType(self.code)
        elif nodeName_ == 'name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'name')
            value_ = self.gds_validate_string(value_, node, 'name')
            self.name = value_
            self.name_nsprefix_ = child_.prefix
            # validate type nameType13
            self.validate_nameType13(self.name)
        elif nodeName_ == 'parentCode':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'parentCode')
            value_ = self.gds_validate_string(value_, node, 'parentCode')
            self.parentCode = value_
            self.parentCode_nsprefix_ = child_.prefix
            # validate type codeOkvedType
            self.validate_codeOkvedType(self.parentCode)
        elif nodeName_ == 'section':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'section')
            value_ = self.gds_validate_string(value_, node, 'section')
            self.section = value_
            self.section_nsprefix_ = child_.prefix
            # validate type sectionType14
            self.validate_sectionType14(self.section)
        elif nodeName_ == 'subsection':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'subsection')
            value_ = self.gds_validate_string(value_, node, 'subsection')
            self.subsection = value_
            self.subsection_nsprefix_ = child_.prefix
            # validate type subsectionType
            self.validate_subsectionType(self.subsection)
# end class nsiOkvedDataType


class nsiOkved2DataType(GeneratedsSuper):
    """Общероссийский классификатор видов экономической деятельности 2"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'guid': MemberSpec_('guid', ['guidType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'guid', 'type': 'xs:string'}, None),
        'changeDateTime': MemberSpec_('changeDateTime', 'xs:dateTime', 0, 1, {'minOccurs': '0', 'name': 'changeDateTime', 'type': 'xs:dateTime'}, None),
        'startDateActive': MemberSpec_('startDateActive', 'xs:date', 0, 1, {'minOccurs': '0', 'name': 'startDateActive', 'type': 'xs:date'}, None),
        'endDateActive': MemberSpec_('endDateActive', 'xs:date', 0, 1, {'minOccurs': '0', 'name': 'endDateActive', 'type': 'xs:date'}, None),
        'businessStatus': MemberSpec_('businessStatus', ['businessStatusType', 'xs:string'], 0, 0, {'name': 'businessStatus', 'type': 'xs:string'}, None),
        'code': MemberSpec_('code', ['codeOkved2Type', 'nonEmptyString', 'xs:string'], 0, 0, {'name': 'code', 'type': 'xs:string'}, None),
        'name': MemberSpec_('name', ['nameType15', 't:nonEmptyString'], 0, 0, {'name': 'name', 'type': 'xs:string'}, None),
        'parentCode': MemberSpec_('parentCode', ['codeOkved2Type', 'nonEmptyString', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'parentCode', 'type': 'xs:string'}, None),
        'section': MemberSpec_('section', ['sectionType16', 't:nonEmptyString'], 0, 0, {'name': 'section', 'type': 'xs:string'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, guid=None, changeDateTime=None, startDateActive=None, endDateActive=None, businessStatus=None, code=None, name=None, parentCode=None, section=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.guid = guid
        self.validate_guidType(self.guid)
        self.guid_nsprefix_ = None
        if isinstance(changeDateTime, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(changeDateTime, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = changeDateTime
        self.changeDateTime = initvalue_
        self.changeDateTime_nsprefix_ = None
        if isinstance(startDateActive, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(startDateActive, '%Y-%m-%d').date()
        else:
            initvalue_ = startDateActive
        self.startDateActive = initvalue_
        self.startDateActive_nsprefix_ = None
        if isinstance(endDateActive, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(endDateActive, '%Y-%m-%d').date()
        else:
            initvalue_ = endDateActive
        self.endDateActive = initvalue_
        self.endDateActive_nsprefix_ = None
        self.businessStatus = businessStatus
        self.validate_businessStatusType(self.businessStatus)
        self.businessStatus_nsprefix_ = None
        self.code = code
        self.validate_codeOkved2Type(self.code)
        self.code_nsprefix_ = None
        self.name = name
        self.validate_nameType15(self.name)
        self.name_nsprefix_ = None
        self.parentCode = parentCode
        self.validate_codeOkved2Type(self.parentCode)
        self.parentCode_nsprefix_ = None
        self.section = section
        self.validate_sectionType16(self.section)
        self.section_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, nsiOkved2DataType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if nsiOkved2DataType.subclass:
            return nsiOkved2DataType.subclass(*args_, **kwargs_)
        else:
            return nsiOkved2DataType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_guidType(self, value):
        result = True
        # Validate type guidType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) != 36:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd length restriction on guidType' % {"value": encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_guidType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_guidType_patterns_, ))
                result = False
        return result
    validate_guidType_patterns_ = [['^([a-fA-F0-9]{8}\\-[a-fA-F0-9]{4}\\-[a-fA-F0-9]{4}\\-[a-fA-F0-9]{4}\\-[a-fA-F0-9]{12})$']]
    def validate_businessStatusType(self, value):
        result = True
        # Validate type businessStatusType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['801', '866']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on businessStatusType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_codeOkved2Type(self, value):
        result = True
        # Validate type codeOkved2Type, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on codeOkved2Type' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_codeOkved2Type_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_codeOkved2Type_patterns_, ))
                result = False
        return result
    validate_codeOkved2Type_patterns_ = [['^([A-Q]{1,2}|(\\d{2}((\\.\\d{1,2})|(\\.\\d{2}\\.\\d{1,2}))?))$']]
    def validate_nameType15(self, value):
        result = True
        # Validate type nameType15, a restriction on t:nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 500:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on nameType15' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on nameType15' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_sectionType16(self, value):
        result = True
        # Validate type sectionType16, a restriction on t:nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on sectionType16' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_sectionType16_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_sectionType16_patterns_, ))
                result = False
        return result
    validate_sectionType16_patterns_ = [['^([A-Q])$']]
    def hasContent_(self):
        if (
            self.guid is not None or
            self.changeDateTime is not None or
            self.startDateActive is not None or
            self.endDateActive is not None or
            self.businessStatus is not None or
            self.code is not None or
            self.name is not None or
            self.parentCode is not None or
            self.section is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'guid':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'guid')
            value_ = self.gds_validate_string(value_, node, 'guid')
            self.guid = value_
            self.guid_nsprefix_ = child_.prefix
            # validate type guidType
            self.validate_guidType(self.guid)
        elif nodeName_ == 'changeDateTime':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.changeDateTime = dval_
            self.changeDateTime_nsprefix_ = child_.prefix
        elif nodeName_ == 'startDateActive':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.startDateActive = dval_
            self.startDateActive_nsprefix_ = child_.prefix
        elif nodeName_ == 'endDateActive':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.endDateActive = dval_
            self.endDateActive_nsprefix_ = child_.prefix
        elif nodeName_ == 'businessStatus':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'businessStatus')
            value_ = self.gds_validate_string(value_, node, 'businessStatus')
            self.businessStatus = value_
            self.businessStatus_nsprefix_ = child_.prefix
            # validate type businessStatusType
            self.validate_businessStatusType(self.businessStatus)
        elif nodeName_ == 'code':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'code')
            value_ = self.gds_validate_string(value_, node, 'code')
            self.code = value_
            self.code_nsprefix_ = child_.prefix
            # validate type codeOkved2Type
            self.validate_codeOkved2Type(self.code)
        elif nodeName_ == 'name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'name')
            value_ = self.gds_validate_string(value_, node, 'name')
            self.name = value_
            self.name_nsprefix_ = child_.prefix
            # validate type nameType15
            self.validate_nameType15(self.name)
        elif nodeName_ == 'parentCode':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'parentCode')
            value_ = self.gds_validate_string(value_, node, 'parentCode')
            self.parentCode = value_
            self.parentCode_nsprefix_ = child_.prefix
            # validate type codeOkved2Type
            self.validate_codeOkved2Type(self.parentCode)
        elif nodeName_ == 'section':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'section')
            value_ = self.gds_validate_string(value_, node, 'section')
            self.section = value_
            self.section_nsprefix_ = child_.prefix
            # validate type sectionType16
            self.validate_sectionType16(self.section)
# end class nsiOkved2DataType


class nsiOrganizationDataType(GeneratedsSuper):
    """Справочник организаций"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'guid': MemberSpec_('guid', ['guidType', 'xs:string'], 0, 0, {'name': 'guid', 'type': 'xs:string'}, None),
        'code': MemberSpec_('code', ['organizationCodeType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'code', 'type': 'xs:string'}, None),
        'codeAssignDateTime': MemberSpec_('codeAssignDateTime', 'xs:dateTime', 0, 1, {'minOccurs': '0', 'name': 'codeAssignDateTime', 'type': 'xs:dateTime'}, None),
        'codeInvalidateDateTime': MemberSpec_('codeInvalidateDateTime', 'xs:dateTime', 0, 1, {'minOccurs': '0', 'name': 'codeInvalidateDateTime', 'type': 'xs:dateTime'}, None),
        'createDateTime': MemberSpec_('createDateTime', 'xs:dateTime', 0, 1, {'minOccurs': '0', 'name': 'createDateTime', 'type': 'xs:dateTime'}, None),
        'changeDateTime': MemberSpec_('changeDateTime', 'xs:dateTime', 0, 1, {'minOccurs': '0', 'name': 'changeDateTime', 'type': 'xs:dateTime'}, None),
        'blockDateTime': MemberSpec_('blockDateTime', 'xs:dateTime', 0, 1, {'minOccurs': '0', 'name': 'blockDateTime', 'type': 'xs:dateTime'}, None),
        'changeESIADateTime': MemberSpec_('changeESIADateTime', 'xs:dateTime', 0, 1, {'minOccurs': '0', 'name': 'changeESIADateTime', 'type': 'xs:dateTime'}, None),
        'startDateActive': MemberSpec_('startDateActive', 'xs:date', 0, 1, {'minOccurs': '0', 'name': 'startDateActive', 'type': 'xs:date'}, None),
        'endDateActive': MemberSpec_('endDateActive', 'xs:date', 0, 1, {'minOccurs': '0', 'name': 'endDateActive', 'type': 'xs:date'}, None),
        'mainInfo': MemberSpec_('mainInfo', 'customerMainInfoType', 0, 0, {'name': 'mainInfo', 'type': 'customerMainInfoType'}, None),
        'status': MemberSpec_('status', ['agencyStatusType', 'xs:string'], 0, 0, {'name': 'status', 'type': 'xs:string'}, None),
        'classification': MemberSpec_('classification', 'classificationType', 0, 0, {'name': 'classification', 'type': 'classificationType'}, None),
        'additionalInfo': MemberSpec_('additionalInfo', 'additionalInfoType', 0, 0, {'name': 'additionalInfo', 'type': 'additionalInfoType'}, None),
        'isDetachedDepartment': MemberSpec_('isDetachedDepartment', 'xs:boolean', 0, 1, {'default': 'false', 'minOccurs': '0', 'name': 'isDetachedDepartment', 'type': 'xs:boolean'}, None),
        'authority': MemberSpec_('authority', 'authorityType', 0, 0, {'name': 'authority', 'type': 'authorityType'}, None),
        'contactInfo': MemberSpec_('contactInfo', 'contactInfoType24', 0, 1, {'minOccurs': '0', 'name': 'contactInfo', 'type': 'contactInfoType24'}, None),
        'comment': MemberSpec_('comment', ['commentType', 't:nonEmptyString'], 0, 1, {'minOccurs': '0', 'name': 'comment', 'type': 'xs:string'}, None),
        'successionInfo': MemberSpec_('successionInfo', 'SuccessionInfo', 0, 1, {'minOccurs': '0', 'name': 'successionInfo', 'type': 'SuccessionInfo'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, guid=None, code=None, codeAssignDateTime=None, codeInvalidateDateTime=None, createDateTime=None, changeDateTime=None, blockDateTime=None, changeESIADateTime=None, startDateActive=None, endDateActive=None, mainInfo=None, status=None, classification=None, additionalInfo=None, isDetachedDepartment=False, authority=None, contactInfo=None, comment=None, successionInfo=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.guid = guid
        self.validate_guidType(self.guid)
        self.guid_nsprefix_ = None
        self.code = code
        self.validate_organizationCodeType(self.code)
        self.code_nsprefix_ = None
        if isinstance(codeAssignDateTime, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(codeAssignDateTime, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = codeAssignDateTime
        self.codeAssignDateTime = initvalue_
        self.codeAssignDateTime_nsprefix_ = None
        if isinstance(codeInvalidateDateTime, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(codeInvalidateDateTime, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = codeInvalidateDateTime
        self.codeInvalidateDateTime = initvalue_
        self.codeInvalidateDateTime_nsprefix_ = None
        if isinstance(createDateTime, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(createDateTime, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = createDateTime
        self.createDateTime = initvalue_
        self.createDateTime_nsprefix_ = None
        if isinstance(changeDateTime, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(changeDateTime, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = changeDateTime
        self.changeDateTime = initvalue_
        self.changeDateTime_nsprefix_ = None
        if isinstance(blockDateTime, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(blockDateTime, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = blockDateTime
        self.blockDateTime = initvalue_
        self.blockDateTime_nsprefix_ = None
        if isinstance(changeESIADateTime, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(changeESIADateTime, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = changeESIADateTime
        self.changeESIADateTime = initvalue_
        self.changeESIADateTime_nsprefix_ = None
        if isinstance(startDateActive, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(startDateActive, '%Y-%m-%d').date()
        else:
            initvalue_ = startDateActive
        self.startDateActive = initvalue_
        self.startDateActive_nsprefix_ = None
        if isinstance(endDateActive, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(endDateActive, '%Y-%m-%d').date()
        else:
            initvalue_ = endDateActive
        self.endDateActive = initvalue_
        self.endDateActive_nsprefix_ = None
        self.mainInfo = mainInfo
        self.mainInfo_nsprefix_ = None
        self.status = status
        self.validate_agencyStatusType(self.status)
        self.status_nsprefix_ = None
        self.classification = classification
        self.classification_nsprefix_ = None
        self.additionalInfo = additionalInfo
        self.additionalInfo_nsprefix_ = None
        self.isDetachedDepartment = isDetachedDepartment
        self.isDetachedDepartment_nsprefix_ = None
        self.authority = authority
        self.authority_nsprefix_ = None
        self.contactInfo = contactInfo
        self.contactInfo_nsprefix_ = None
        self.comment = comment
        self.validate_commentType(self.comment)
        self.comment_nsprefix_ = None
        self.successionInfo = successionInfo
        self.successionInfo_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, nsiOrganizationDataType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if nsiOrganizationDataType.subclass:
            return nsiOrganizationDataType.subclass(*args_, **kwargs_)
        else:
            return nsiOrganizationDataType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_guidType(self, value):
        result = True
        # Validate type guidType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) != 36:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd length restriction on guidType' % {"value": encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_guidType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_guidType_patterns_, ))
                result = False
        return result
    validate_guidType_patterns_ = [['^([a-fA-F0-9]{8}\\-[a-fA-F0-9]{4}\\-[a-fA-F0-9]{4}\\-[a-fA-F0-9]{4}\\-[a-fA-F0-9]{12})$']]
    def validate_organizationCodeType(self, value):
        result = True
        # Validate type organizationCodeType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_organizationCodeType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_organizationCodeType_patterns_, ))
                result = False
        return result
    validate_organizationCodeType_patterns_ = [['^(\\d{20})$']]
    def validate_agencyStatusType(self, value):
        result = True
        # Validate type agencyStatusType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['BLOCKED', 'REGISTERED', 'REJECTED', 'PENDING', 'ON_HOLD']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on agencyStatusType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_commentType(self, value):
        result = True
        # Validate type commentType, a restriction on t:nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 500:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on commentType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on commentType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.guid is not None or
            self.code is not None or
            self.codeAssignDateTime is not None or
            self.codeInvalidateDateTime is not None or
            self.createDateTime is not None or
            self.changeDateTime is not None or
            self.blockDateTime is not None or
            self.changeESIADateTime is not None or
            self.startDateActive is not None or
            self.endDateActive is not None or
            self.mainInfo is not None or
            self.status is not None or
            self.classification is not None or
            self.additionalInfo is not None or
            self.isDetachedDepartment or
            self.authority is not None or
            self.contactInfo is not None or
            self.comment is not None or
            self.successionInfo is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'guid':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'guid')
            value_ = self.gds_validate_string(value_, node, 'guid')
            self.guid = value_
            self.guid_nsprefix_ = child_.prefix
            # validate type guidType
            self.validate_guidType(self.guid)
        elif nodeName_ == 'code':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'code')
            value_ = self.gds_validate_string(value_, node, 'code')
            self.code = value_
            self.code_nsprefix_ = child_.prefix
            # validate type organizationCodeType
            self.validate_organizationCodeType(self.code)
        elif nodeName_ == 'codeAssignDateTime':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.codeAssignDateTime = dval_
            self.codeAssignDateTime_nsprefix_ = child_.prefix
        elif nodeName_ == 'codeInvalidateDateTime':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.codeInvalidateDateTime = dval_
            self.codeInvalidateDateTime_nsprefix_ = child_.prefix
        elif nodeName_ == 'createDateTime':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.createDateTime = dval_
            self.createDateTime_nsprefix_ = child_.prefix
        elif nodeName_ == 'changeDateTime':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.changeDateTime = dval_
            self.changeDateTime_nsprefix_ = child_.prefix
        elif nodeName_ == 'blockDateTime':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.blockDateTime = dval_
            self.blockDateTime_nsprefix_ = child_.prefix
        elif nodeName_ == 'changeESIADateTime':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.changeESIADateTime = dval_
            self.changeESIADateTime_nsprefix_ = child_.prefix
        elif nodeName_ == 'startDateActive':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.startDateActive = dval_
            self.startDateActive_nsprefix_ = child_.prefix
        elif nodeName_ == 'endDateActive':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.endDateActive = dval_
            self.endDateActive_nsprefix_ = child_.prefix
        elif nodeName_ == 'mainInfo':
            obj_ = customerMainInfoType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.mainInfo = obj_
            obj_.original_tagname_ = 'mainInfo'
        elif nodeName_ == 'status':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'status')
            value_ = self.gds_validate_string(value_, node, 'status')
            self.status = value_
            self.status_nsprefix_ = child_.prefix
            # validate type agencyStatusType
            self.validate_agencyStatusType(self.status)
        elif nodeName_ == 'classification':
            obj_ = classificationType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.classification = obj_
            obj_.original_tagname_ = 'classification'
        elif nodeName_ == 'additionalInfo':
            obj_ = additionalInfoType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.additionalInfo = obj_
            obj_.original_tagname_ = 'additionalInfo'
        elif nodeName_ == 'isDetachedDepartment':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'isDetachedDepartment')
            ival_ = self.gds_validate_boolean(ival_, node, 'isDetachedDepartment')
            self.isDetachedDepartment = ival_
            self.isDetachedDepartment_nsprefix_ = child_.prefix
        elif nodeName_ == 'authority':
            obj_ = authorityType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.authority = obj_
            obj_.original_tagname_ = 'authority'
        elif nodeName_ == 'contactInfo':
            obj_ = contactInfoType24.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.contactInfo = obj_
            obj_.original_tagname_ = 'contactInfo'
        elif nodeName_ == 'comment':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'comment')
            value_ = self.gds_validate_string(value_, node, 'comment')
            self.comment = value_
            self.comment_nsprefix_ = child_.prefix
            # validate type commentType
            self.validate_commentType(self.comment)
        elif nodeName_ == 'successionInfo':
            obj_ = SuccessionInfo.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.successionInfo = obj_
            obj_.original_tagname_ = 'successionInfo'
# end class nsiOrganizationDataType


class SuccessionInfo(GeneratedsSuper):
    """Сведения о правопреемстве"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'successor': MemberSpec_('successor', 'SuccessorType', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'successor', 'type': 'SuccessorType'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, successor=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if successor is None:
            self.successor = []
        else:
            self.successor = successor
        self.successor_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SuccessionInfo)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SuccessionInfo.subclass:
            return SuccessionInfo.subclass(*args_, **kwargs_)
        else:
            return SuccessionInfo(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.successor
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'successor':
            obj_ = SuccessorType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.successor.append(obj_)
            obj_.original_tagname_ = 'successor'
# end class SuccessionInfo


class SuccessorType(GeneratedsSuper):
    """Сведения о юридическом лице - правопреемнике при
    прекращении деятельности в результате
    реорганизации или при реорганизации в форме
    выделения"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'inn': MemberSpec_('inn', ['innType', 'nonEmptyString', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'inn', 'type': 'xs:string'}, None),
        'ogrn': MemberSpec_('ogrn', ['ogrnType', 'nonEmptyString', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'ogrn', 'type': 'xs:string'}, None),
        'kpp': MemberSpec_('kpp', ['kppType', 'nonEmptyString', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'kpp', 'type': 'xs:string'}, None),
        'fullName': MemberSpec_('fullName', 'xs:string', 0, 0, {'name': 'fullName', 'type': 'xs:string'}, None),
        'shortName': MemberSpec_('shortName', 'xs:string', 0, 1, {'minOccurs': '0', 'name': 'shortName', 'type': 'xs:string'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, inn=None, ogrn=None, kpp=None, fullName=None, shortName=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.inn = inn
        self.validate_innType(self.inn)
        self.inn_nsprefix_ = None
        self.ogrn = ogrn
        self.validate_ogrnType(self.ogrn)
        self.ogrn_nsprefix_ = None
        self.kpp = kpp
        self.validate_kppType(self.kpp)
        self.kpp_nsprefix_ = None
        self.fullName = fullName
        self.fullName_nsprefix_ = None
        self.shortName = shortName
        self.shortName_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SuccessorType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SuccessorType.subclass:
            return SuccessorType.subclass(*args_, **kwargs_)
        else:
            return SuccessorType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_innType(self, value):
        result = True
        # Validate type innType, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on innType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_innType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_innType_patterns_, ))
                result = False
        return result
    validate_innType_patterns_ = [['^(\\d{10}|\\d{12})$']]
    def validate_ogrnType(self, value):
        result = True
        # Validate type ogrnType, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ogrnType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_ogrnType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_ogrnType_patterns_, ))
                result = False
        return result
    validate_ogrnType_patterns_ = [['^(\\d{13})$']]
    def validate_kppType(self, value):
        result = True
        # Validate type kppType, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on kppType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_kppType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_kppType_patterns_, ))
                result = False
        return result
    validate_kppType_patterns_ = [['^(\\d{9})$']]
    def hasContent_(self):
        if (
            self.inn is not None or
            self.ogrn is not None or
            self.kpp is not None or
            self.fullName is not None or
            self.shortName is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'inn':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'inn')
            value_ = self.gds_validate_string(value_, node, 'inn')
            self.inn = value_
            self.inn_nsprefix_ = child_.prefix
            # validate type innType
            self.validate_innType(self.inn)
        elif nodeName_ == 'ogrn':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'ogrn')
            value_ = self.gds_validate_string(value_, node, 'ogrn')
            self.ogrn = value_
            self.ogrn_nsprefix_ = child_.prefix
            # validate type ogrnType
            self.validate_ogrnType(self.ogrn)
        elif nodeName_ == 'kpp':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'kpp')
            value_ = self.gds_validate_string(value_, node, 'kpp')
            self.kpp = value_
            self.kpp_nsprefix_ = child_.prefix
            # validate type kppType
            self.validate_kppType(self.kpp)
        elif nodeName_ == 'fullName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'fullName')
            value_ = self.gds_validate_string(value_, node, 'fullName')
            self.fullName = value_
            self.fullName_nsprefix_ = child_.prefix
        elif nodeName_ == 'shortName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'shortName')
            value_ = self.gds_validate_string(value_, node, 'shortName')
            self.shortName = value_
            self.shortName_nsprefix_ = child_.prefix
# end class SuccessorType


class nsiOrderClauseTypeDataType(GeneratedsSuper):
    """Справочник "Шаблоны положений о закупках" """
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'guid': MemberSpec_('guid', ['guidType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'guid', 'type': 'xs:string'}, None),
        'changeDateTime': MemberSpec_('changeDateTime', 'xs:dateTime', 0, 1, {'minOccurs': '0', 'name': 'changeDateTime', 'type': 'xs:dateTime'}, None),
        'businessStatus': MemberSpec_('businessStatus', ['businessStatusType', 'xs:string'], 0, 0, {'name': 'businessStatus', 'type': 'xs:string'}, None),
        'name': MemberSpec_('name', ['nameType25', 't:nonEmptyString'], 0, 0, {'name': 'name', 'type': 'xs:string'}, None),
        'orderNumber': MemberSpec_('orderNumber', 'xs:int', 0, 0, {'name': 'orderNumber', 'type': 'xs:int'}, None),
        'creator': MemberSpec_('creator', 'customerMainInfoType', 0, 1, {'minOccurs': '0', 'name': 'creator', 'type': 'customerMainInfoType'}, None),
        'templates': MemberSpec_('templates', 'templatesType', 0, 1, {'minOccurs': '0', 'name': 'templates', 'type': 'templatesType'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, guid=None, changeDateTime=None, businessStatus=None, name=None, orderNumber=None, creator=None, templates=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.guid = guid
        self.validate_guidType(self.guid)
        self.guid_nsprefix_ = None
        if isinstance(changeDateTime, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(changeDateTime, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = changeDateTime
        self.changeDateTime = initvalue_
        self.changeDateTime_nsprefix_ = None
        self.businessStatus = businessStatus
        self.validate_businessStatusType(self.businessStatus)
        self.businessStatus_nsprefix_ = None
        self.name = name
        self.validate_nameType25(self.name)
        self.name_nsprefix_ = None
        self.orderNumber = orderNumber
        self.orderNumber_nsprefix_ = None
        self.creator = creator
        self.creator_nsprefix_ = None
        self.templates = templates
        self.templates_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, nsiOrderClauseTypeDataType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if nsiOrderClauseTypeDataType.subclass:
            return nsiOrderClauseTypeDataType.subclass(*args_, **kwargs_)
        else:
            return nsiOrderClauseTypeDataType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_guidType(self, value):
        result = True
        # Validate type guidType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) != 36:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd length restriction on guidType' % {"value": encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_guidType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_guidType_patterns_, ))
                result = False
        return result
    validate_guidType_patterns_ = [['^([a-fA-F0-9]{8}\\-[a-fA-F0-9]{4}\\-[a-fA-F0-9]{4}\\-[a-fA-F0-9]{4}\\-[a-fA-F0-9]{12})$']]
    def validate_businessStatusType(self, value):
        result = True
        # Validate type businessStatusType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['801', '866']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on businessStatusType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_nameType25(self, value):
        result = True
        # Validate type nameType25, a restriction on t:nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 2000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on nameType25' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on nameType25' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.guid is not None or
            self.changeDateTime is not None or
            self.businessStatus is not None or
            self.name is not None or
            self.orderNumber is not None or
            self.creator is not None or
            self.templates is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'guid':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'guid')
            value_ = self.gds_validate_string(value_, node, 'guid')
            self.guid = value_
            self.guid_nsprefix_ = child_.prefix
            # validate type guidType
            self.validate_guidType(self.guid)
        elif nodeName_ == 'changeDateTime':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.changeDateTime = dval_
            self.changeDateTime_nsprefix_ = child_.prefix
        elif nodeName_ == 'businessStatus':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'businessStatus')
            value_ = self.gds_validate_string(value_, node, 'businessStatus')
            self.businessStatus = value_
            self.businessStatus_nsprefix_ = child_.prefix
            # validate type businessStatusType
            self.validate_businessStatusType(self.businessStatus)
        elif nodeName_ == 'name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'name')
            value_ = self.gds_validate_string(value_, node, 'name')
            self.name = value_
            self.name_nsprefix_ = child_.prefix
            # validate type nameType25
            self.validate_nameType25(self.name)
        elif nodeName_ == 'orderNumber' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'orderNumber')
            ival_ = self.gds_validate_integer(ival_, node, 'orderNumber')
            self.orderNumber = ival_
            self.orderNumber_nsprefix_ = child_.prefix
        elif nodeName_ == 'creator':
            obj_ = customerMainInfoType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.creator = obj_
            obj_.original_tagname_ = 'creator'
        elif nodeName_ == 'templates':
            obj_ = templatesType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templates = obj_
            obj_.original_tagname_ = 'templates'
# end class nsiOrderClauseTypeDataType


class nsiProtocolTypeDataType(GeneratedsSuper):
    """Справочник типов протоколов"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'guid': MemberSpec_('guid', ['guidType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'guid', 'type': 'xs:string'}, None),
        'createDateTime': MemberSpec_('createDateTime', 'xs:dateTime', 0, 0, {'name': 'createDateTime', 'type': 'xs:dateTime'}, None),
        'changeDateTime': MemberSpec_('changeDateTime', 'xs:dateTime', 0, 1, {'minOccurs': '0', 'name': 'changeDateTime', 'type': 'xs:dateTime'}, None),
        'startDateActive': MemberSpec_('startDateActive', 'xs:date', 0, 1, {'minOccurs': '0', 'name': 'startDateActive', 'type': 'xs:date'}, None),
        'endDateActive': MemberSpec_('endDateActive', 'xs:date', 0, 1, {'minOccurs': '0', 'name': 'endDateActive', 'type': 'xs:date'}, None),
        'businessStatus': MemberSpec_('businessStatus', ['businessStatusType', 'xs:string'], 0, 0, {'name': 'businessStatus', 'type': 'xs:string'}, None),
        'code': MemberSpec_('code', 'xs:long', 0, 0, {'name': 'code', 'type': 'xs:long'}, None),
        'name': MemberSpec_('name', ['nameType26', 't:nonEmptyString'], 0, 0, {'name': 'name', 'type': 'xs:string'}, None),
        'orderNumber': MemberSpec_('orderNumber', 'xs:int', 0, 0, {'name': 'orderNumber', 'type': 'xs:int'}, None),
        'purchaseMethod': MemberSpec_('purchaseMethod', 'xs:long', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'purchaseMethod', 'type': 'xs:long'}, None),
        'extended': MemberSpec_('extended', 'xs:boolean', 0, 0, {'name': 'extended', 'type': 'xs:boolean'}, None),
        'templates': MemberSpec_('templates', 'templatesType27', 0, 1, {'minOccurs': '0', 'name': 'templates', 'type': 'templatesType27'}, None),
        'protocolKind': MemberSpec_('protocolKind', ['protocolKindType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'protocolKind', 'type': 'xs:string'}, None),
        'lotOriented': MemberSpec_('lotOriented', 'xs:boolean', 0, 0, {'name': 'lotOriented', 'type': 'xs:boolean'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, guid=None, createDateTime=None, changeDateTime=None, startDateActive=None, endDateActive=None, businessStatus=None, code=None, name=None, orderNumber=None, purchaseMethod=None, extended=None, templates=None, protocolKind=None, lotOriented=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.guid = guid
        self.validate_guidType(self.guid)
        self.guid_nsprefix_ = None
        if isinstance(createDateTime, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(createDateTime, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = createDateTime
        self.createDateTime = initvalue_
        self.createDateTime_nsprefix_ = None
        if isinstance(changeDateTime, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(changeDateTime, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = changeDateTime
        self.changeDateTime = initvalue_
        self.changeDateTime_nsprefix_ = None
        if isinstance(startDateActive, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(startDateActive, '%Y-%m-%d').date()
        else:
            initvalue_ = startDateActive
        self.startDateActive = initvalue_
        self.startDateActive_nsprefix_ = None
        if isinstance(endDateActive, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(endDateActive, '%Y-%m-%d').date()
        else:
            initvalue_ = endDateActive
        self.endDateActive = initvalue_
        self.endDateActive_nsprefix_ = None
        self.businessStatus = businessStatus
        self.validate_businessStatusType(self.businessStatus)
        self.businessStatus_nsprefix_ = None
        self.code = code
        self.code_nsprefix_ = None
        self.name = name
        self.validate_nameType26(self.name)
        self.name_nsprefix_ = None
        self.orderNumber = orderNumber
        self.orderNumber_nsprefix_ = None
        if purchaseMethod is None:
            self.purchaseMethod = []
        else:
            self.purchaseMethod = purchaseMethod
        self.purchaseMethod_nsprefix_ = None
        self.extended = extended
        self.extended_nsprefix_ = None
        self.templates = templates
        self.templates_nsprefix_ = None
        self.protocolKind = protocolKind
        self.validate_protocolKindType(self.protocolKind)
        self.protocolKind_nsprefix_ = None
        self.lotOriented = lotOriented
        self.lotOriented_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, nsiProtocolTypeDataType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if nsiProtocolTypeDataType.subclass:
            return nsiProtocolTypeDataType.subclass(*args_, **kwargs_)
        else:
            return nsiProtocolTypeDataType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_guidType(self, value):
        result = True
        # Validate type guidType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) != 36:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd length restriction on guidType' % {"value": encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_guidType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_guidType_patterns_, ))
                result = False
        return result
    validate_guidType_patterns_ = [['^([a-fA-F0-9]{8}\\-[a-fA-F0-9]{4}\\-[a-fA-F0-9]{4}\\-[a-fA-F0-9]{4}\\-[a-fA-F0-9]{12})$']]
    def validate_businessStatusType(self, value):
        result = True
        # Validate type businessStatusType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['801', '866']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on businessStatusType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_nameType26(self, value):
        result = True
        # Validate type nameType26, a restriction on t:nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 2000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on nameType26' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on nameType26' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_protocolKindType(self, value):
        result = True
        # Validate type protocolKindType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['PROTOCOL_OF_STAGE', 'FINAL_PROTOCOL', 'NONE']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on protocolKindType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.guid is not None or
            self.createDateTime is not None or
            self.changeDateTime is not None or
            self.startDateActive is not None or
            self.endDateActive is not None or
            self.businessStatus is not None or
            self.code is not None or
            self.name is not None or
            self.orderNumber is not None or
            self.purchaseMethod or
            self.extended is not None or
            self.templates is not None or
            self.protocolKind is not None or
            self.lotOriented is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'guid':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'guid')
            value_ = self.gds_validate_string(value_, node, 'guid')
            self.guid = value_
            self.guid_nsprefix_ = child_.prefix
            # validate type guidType
            self.validate_guidType(self.guid)
        elif nodeName_ == 'createDateTime':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.createDateTime = dval_
            self.createDateTime_nsprefix_ = child_.prefix
        elif nodeName_ == 'changeDateTime':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.changeDateTime = dval_
            self.changeDateTime_nsprefix_ = child_.prefix
        elif nodeName_ == 'startDateActive':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.startDateActive = dval_
            self.startDateActive_nsprefix_ = child_.prefix
        elif nodeName_ == 'endDateActive':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.endDateActive = dval_
            self.endDateActive_nsprefix_ = child_.prefix
        elif nodeName_ == 'businessStatus':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'businessStatus')
            value_ = self.gds_validate_string(value_, node, 'businessStatus')
            self.businessStatus = value_
            self.businessStatus_nsprefix_ = child_.prefix
            # validate type businessStatusType
            self.validate_businessStatusType(self.businessStatus)
        elif nodeName_ == 'code' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'code')
            ival_ = self.gds_validate_integer(ival_, node, 'code')
            self.code = ival_
            self.code_nsprefix_ = child_.prefix
        elif nodeName_ == 'name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'name')
            value_ = self.gds_validate_string(value_, node, 'name')
            self.name = value_
            self.name_nsprefix_ = child_.prefix
            # validate type nameType26
            self.validate_nameType26(self.name)
        elif nodeName_ == 'orderNumber' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'orderNumber')
            ival_ = self.gds_validate_integer(ival_, node, 'orderNumber')
            self.orderNumber = ival_
            self.orderNumber_nsprefix_ = child_.prefix
        elif nodeName_ == 'purchaseMethod' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'purchaseMethod')
            ival_ = self.gds_validate_integer(ival_, node, 'purchaseMethod')
            self.purchaseMethod.append(ival_)
            self.purchaseMethod_nsprefix_ = child_.prefix
        elif nodeName_ == 'extended':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'extended')
            ival_ = self.gds_validate_boolean(ival_, node, 'extended')
            self.extended = ival_
            self.extended_nsprefix_ = child_.prefix
        elif nodeName_ == 'templates':
            obj_ = templatesType27.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templates = obj_
            obj_.original_tagname_ = 'templates'
        elif nodeName_ == 'protocolKind':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'protocolKind')
            value_ = self.gds_validate_string(value_, node, 'protocolKind')
            self.protocolKind = value_
            self.protocolKind_nsprefix_ = child_.prefix
            # validate type protocolKindType
            self.validate_protocolKindType(self.protocolKind)
        elif nodeName_ == 'lotOriented':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'lotOriented')
            ival_ = self.gds_validate_boolean(ival_, node, 'lotOriented')
            self.lotOriented = ival_
            self.lotOriented_nsprefix_ = child_.prefix
# end class nsiProtocolTypeDataType


class nsiPurchaseMethodDataType(GeneratedsSuper):
    """Справочник способов закупки"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'guid': MemberSpec_('guid', ['guidType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'guid', 'type': 'xs:string'}, None),
        'createDateTime': MemberSpec_('createDateTime', 'xs:dateTime', 0, 0, {'name': 'createDateTime', 'type': 'xs:dateTime'}, None),
        'changeDateTime': MemberSpec_('changeDateTime', 'xs:dateTime', 0, 1, {'minOccurs': '0', 'name': 'changeDateTime', 'type': 'xs:dateTime'}, None),
        'startDateActive': MemberSpec_('startDateActive', 'xs:date', 0, 1, {'minOccurs': '0', 'name': 'startDateActive', 'type': 'xs:date'}, None),
        'endDateActive': MemberSpec_('endDateActive', 'xs:date', 0, 1, {'minOccurs': '0', 'name': 'endDateActive', 'type': 'xs:date'}, None),
        'businessStatus': MemberSpec_('businessStatus', ['businessStatusType', 'xs:string'], 0, 0, {'name': 'businessStatus', 'type': 'xs:string'}, None),
        'code': MemberSpec_('code', 'xs:long', 0, 0, {'name': 'code', 'type': 'xs:long'}, None),
        'name': MemberSpec_('name', ['nameType28', 't:nonEmptyString'], 0, 0, {'name': 'name', 'type': 'xs:string'}, None),
        'parentCode': MemberSpec_('parentCode', 'xs:long', 0, 0, {'name': 'parentCode', 'type': 'xs:long'}, None),
        'orderNumber': MemberSpec_('orderNumber', 'xs:int', 0, 0, {'name': 'orderNumber', 'type': 'xs:int'}, None),
        'isElectronic': MemberSpec_('isElectronic', 'xs:boolean', 0, 0, {'default': 'false', 'name': 'isElectronic', 'type': 'xs:boolean'}, None),
        'creator': MemberSpec_('creator', 'customerMainInfoType', 0, 1, {'minOccurs': '0', 'name': 'creator', 'type': 'customerMainInfoType'}, None),
        'extended': MemberSpec_('extended', 'xs:boolean', 0, 0, {'name': 'extended', 'type': 'xs:boolean'}, None),
        'competitive': MemberSpec_('competitive', 'xs:boolean', 0, 0, {'name': 'competitive', 'type': 'xs:boolean'}, None),
        'templates': MemberSpec_('templates', 'templatesType29', 0, 1, {'minOccurs': '0', 'name': 'templates', 'type': 'templatesType29'}, None),
        'protocols': MemberSpec_('protocols', 'protocolListType', 0, 0, {'name': 'protocols', 'type': 'protocolListType'}, 1),
        'phases': MemberSpec_('phases', 'purchasePhaseListType', 0, 0, {'name': 'phases', 'type': 'purchasePhaseListType'}, 1),
        'hasPhases': MemberSpec_('hasPhases', 'xs:boolean', 0, 0, {'name': 'hasPhases', 'type': 'xs:boolean'}, None),
        'typal': MemberSpec_('typal', 'xs:boolean', 0, 0, {'name': 'typal', 'type': 'xs:boolean'}, None),
        'typalKind': MemberSpec_('typalKind', ['typalKindType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'typalKind', 'type': 'xs:string'}, None),
        'lotOriented': MemberSpec_('lotOriented', 'xs:boolean', 0, 0, {'name': 'lotOriented', 'type': 'xs:boolean'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, guid=None, createDateTime=None, changeDateTime=None, startDateActive=None, endDateActive=None, businessStatus=None, code=None, name=None, parentCode=None, orderNumber=None, isElectronic=False, creator=None, extended=None, competitive=None, templates=None, protocols=None, phases=None, hasPhases=None, typal=None, typalKind=None, lotOriented=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.guid = guid
        self.validate_guidType(self.guid)
        self.guid_nsprefix_ = None
        if isinstance(createDateTime, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(createDateTime, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = createDateTime
        self.createDateTime = initvalue_
        self.createDateTime_nsprefix_ = None
        if isinstance(changeDateTime, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(changeDateTime, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = changeDateTime
        self.changeDateTime = initvalue_
        self.changeDateTime_nsprefix_ = None
        if isinstance(startDateActive, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(startDateActive, '%Y-%m-%d').date()
        else:
            initvalue_ = startDateActive
        self.startDateActive = initvalue_
        self.startDateActive_nsprefix_ = None
        if isinstance(endDateActive, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(endDateActive, '%Y-%m-%d').date()
        else:
            initvalue_ = endDateActive
        self.endDateActive = initvalue_
        self.endDateActive_nsprefix_ = None
        self.businessStatus = businessStatus
        self.validate_businessStatusType(self.businessStatus)
        self.businessStatus_nsprefix_ = None
        self.code = code
        self.code_nsprefix_ = None
        self.name = name
        self.validate_nameType28(self.name)
        self.name_nsprefix_ = None
        self.parentCode = parentCode
        self.parentCode_nsprefix_ = None
        self.orderNumber = orderNumber
        self.orderNumber_nsprefix_ = None
        self.isElectronic = isElectronic
        self.isElectronic_nsprefix_ = None
        self.creator = creator
        self.creator_nsprefix_ = None
        self.extended = extended
        self.extended_nsprefix_ = None
        self.competitive = competitive
        self.competitive_nsprefix_ = None
        self.templates = templates
        self.templates_nsprefix_ = None
        self.protocols = protocols
        self.protocols_nsprefix_ = None
        self.phases = phases
        self.phases_nsprefix_ = None
        self.hasPhases = hasPhases
        self.hasPhases_nsprefix_ = None
        self.typal = typal
        self.typal_nsprefix_ = None
        self.typalKind = typalKind
        self.validate_typalKindType(self.typalKind)
        self.typalKind_nsprefix_ = None
        self.lotOriented = lotOriented
        self.lotOriented_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, nsiPurchaseMethodDataType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if nsiPurchaseMethodDataType.subclass:
            return nsiPurchaseMethodDataType.subclass(*args_, **kwargs_)
        else:
            return nsiPurchaseMethodDataType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_guidType(self, value):
        result = True
        # Validate type guidType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) != 36:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd length restriction on guidType' % {"value": encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_guidType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_guidType_patterns_, ))
                result = False
        return result
    validate_guidType_patterns_ = [['^([a-fA-F0-9]{8}\\-[a-fA-F0-9]{4}\\-[a-fA-F0-9]{4}\\-[a-fA-F0-9]{4}\\-[a-fA-F0-9]{12})$']]
    def validate_businessStatusType(self, value):
        result = True
        # Validate type businessStatusType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['801', '866']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on businessStatusType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_nameType28(self, value):
        result = True
        # Validate type nameType28, a restriction on t:nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 3000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on nameType28' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on nameType28' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_typalKindType(self, value):
        result = True
        # Validate type typalKindType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['TSK', 'TSA', 'TSZK', 'TSZP', 'TSEP']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on typalKindType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.guid is not None or
            self.createDateTime is not None or
            self.changeDateTime is not None or
            self.startDateActive is not None or
            self.endDateActive is not None or
            self.businessStatus is not None or
            self.code is not None or
            self.name is not None or
            self.parentCode is not None or
            self.orderNumber is not None or
            self.isElectronic or
            self.creator is not None or
            self.extended is not None or
            self.competitive is not None or
            self.templates is not None or
            self.protocols is not None or
            self.phases is not None or
            self.hasPhases is not None or
            self.typal is not None or
            self.typalKind is not None or
            self.lotOriented is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'guid':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'guid')
            value_ = self.gds_validate_string(value_, node, 'guid')
            self.guid = value_
            self.guid_nsprefix_ = child_.prefix
            # validate type guidType
            self.validate_guidType(self.guid)
        elif nodeName_ == 'createDateTime':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.createDateTime = dval_
            self.createDateTime_nsprefix_ = child_.prefix
        elif nodeName_ == 'changeDateTime':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.changeDateTime = dval_
            self.changeDateTime_nsprefix_ = child_.prefix
        elif nodeName_ == 'startDateActive':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.startDateActive = dval_
            self.startDateActive_nsprefix_ = child_.prefix
        elif nodeName_ == 'endDateActive':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.endDateActive = dval_
            self.endDateActive_nsprefix_ = child_.prefix
        elif nodeName_ == 'businessStatus':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'businessStatus')
            value_ = self.gds_validate_string(value_, node, 'businessStatus')
            self.businessStatus = value_
            self.businessStatus_nsprefix_ = child_.prefix
            # validate type businessStatusType
            self.validate_businessStatusType(self.businessStatus)
        elif nodeName_ == 'code' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'code')
            ival_ = self.gds_validate_integer(ival_, node, 'code')
            self.code = ival_
            self.code_nsprefix_ = child_.prefix
        elif nodeName_ == 'name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'name')
            value_ = self.gds_validate_string(value_, node, 'name')
            self.name = value_
            self.name_nsprefix_ = child_.prefix
            # validate type nameType28
            self.validate_nameType28(self.name)
        elif nodeName_ == 'parentCode' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'parentCode')
            ival_ = self.gds_validate_integer(ival_, node, 'parentCode')
            self.parentCode = ival_
            self.parentCode_nsprefix_ = child_.prefix
        elif nodeName_ == 'orderNumber' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'orderNumber')
            ival_ = self.gds_validate_integer(ival_, node, 'orderNumber')
            self.orderNumber = ival_
            self.orderNumber_nsprefix_ = child_.prefix
        elif nodeName_ == 'isElectronic':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'isElectronic')
            ival_ = self.gds_validate_boolean(ival_, node, 'isElectronic')
            self.isElectronic = ival_
            self.isElectronic_nsprefix_ = child_.prefix
        elif nodeName_ == 'creator':
            obj_ = customerMainInfoType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.creator = obj_
            obj_.original_tagname_ = 'creator'
        elif nodeName_ == 'extended':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'extended')
            ival_ = self.gds_validate_boolean(ival_, node, 'extended')
            self.extended = ival_
            self.extended_nsprefix_ = child_.prefix
        elif nodeName_ == 'competitive':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'competitive')
            ival_ = self.gds_validate_boolean(ival_, node, 'competitive')
            self.competitive = ival_
            self.competitive_nsprefix_ = child_.prefix
        elif nodeName_ == 'templates':
            obj_ = templatesType29.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templates = obj_
            obj_.original_tagname_ = 'templates'
        elif nodeName_ == 'protocols':
            obj_ = protocolListType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.protocols = obj_
            obj_.original_tagname_ = 'protocols'
        elif nodeName_ == 'phases':
            obj_ = purchasePhaseListType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.phases = obj_
            obj_.original_tagname_ = 'phases'
        elif nodeName_ == 'hasPhases':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'hasPhases')
            ival_ = self.gds_validate_boolean(ival_, node, 'hasPhases')
            self.hasPhases = ival_
            self.hasPhases_nsprefix_ = child_.prefix
        elif nodeName_ == 'typal':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'typal')
            ival_ = self.gds_validate_boolean(ival_, node, 'typal')
            self.typal = ival_
            self.typal_nsprefix_ = child_.prefix
        elif nodeName_ == 'typalKind':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'typalKind')
            value_ = self.gds_validate_string(value_, node, 'typalKind')
            self.typalKind = value_
            self.typalKind_nsprefix_ = child_.prefix
            # validate type typalKindType
            self.validate_typalKindType(self.typalKind)
        elif nodeName_ == 'lotOriented':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'lotOriented')
            ival_ = self.gds_validate_boolean(ival_, node, 'lotOriented')
            self.lotOriented = ival_
            self.lotOriented_nsprefix_ = child_.prefix
# end class nsiPurchaseMethodDataType


class phaseTransitionsListType(GeneratedsSuper):
    """Автоматизированные переходы на другие подэтапы"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'transition': MemberSpec_('transition', 'phaseTransition', 1, 0, {'maxOccurs': 'unbounded', 'name': 'transition', 'type': 'phaseTransition'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, transition=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if transition is None:
            self.transition = []
        else:
            self.transition = transition
        self.transition_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, phaseTransitionsListType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if phaseTransitionsListType.subclass:
            return phaseTransitionsListType.subclass(*args_, **kwargs_)
        else:
            return phaseTransitionsListType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.transition
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'transition':
            obj_ = phaseTransition.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.transition.append(obj_)
            obj_.original_tagname_ = 'transition'
# end class phaseTransitionsListType


class phaseTransition(GeneratedsSuper):
    """Переход"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'protocolCode': MemberSpec_('protocolCode', 'xs:long', 0, 0, {'name': 'protocolCode', 'type': 'xs:long'}, None),
        'phaseCode': MemberSpec_('phaseCode', 'xs:long', 0, 0, {'name': 'phaseCode', 'type': 'xs:long'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, protocolCode=None, phaseCode=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.protocolCode = protocolCode
        self.protocolCode_nsprefix_ = None
        self.phaseCode = phaseCode
        self.phaseCode_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, phaseTransition)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if phaseTransition.subclass:
            return phaseTransition.subclass(*args_, **kwargs_)
        else:
            return phaseTransition(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.protocolCode is not None or
            self.phaseCode is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'protocolCode' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'protocolCode')
            ival_ = self.gds_validate_integer(ival_, node, 'protocolCode')
            self.protocolCode = ival_
            self.protocolCode_nsprefix_ = child_.prefix
        elif nodeName_ == 'phaseCode' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'phaseCode')
            ival_ = self.gds_validate_integer(ival_, node, 'phaseCode')
            self.phaseCode = ival_
            self.phaseCode_nsprefix_ = child_.prefix
# end class phaseTransition


class purchasePhaseListType(GeneratedsSuper):
    """Перечень подэтапов"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'phase': MemberSpec_('phase', 'purchasePhase', 1, 0, {'maxOccurs': 'unbounded', 'name': 'phase', 'type': 'purchasePhase'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, phase=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if phase is None:
            self.phase = []
        else:
            self.phase = phase
        self.phase_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, purchasePhaseListType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if purchasePhaseListType.subclass:
            return purchasePhaseListType.subclass(*args_, **kwargs_)
        else:
            return purchasePhaseListType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.phase
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'phase':
            obj_ = purchasePhase.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.phase.append(obj_)
            obj_.original_tagname_ = 'phase'
# end class purchasePhaseListType


class purchasePhase(GeneratedsSuper):
    """Подэтап"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'orderNumber': MemberSpec_('orderNumber', 'xs:int', 0, 0, {'name': 'orderNumber', 'type': 'xs:int'}, None),
        'code': MemberSpec_('code', 'xs:long', 0, 0, {'name': 'code', 'type': 'xs:long'}, None),
        'name': MemberSpec_('name', ['nameType30', 't:nonEmptyString'], 0, 0, {'name': 'name', 'type': 'xs:string'}, None),
        'editEnabled': MemberSpec_('editEnabled', 'xs:boolean', 0, 0, {'name': 'editEnabled', 'type': 'xs:boolean'}, None),
        'protocols': MemberSpec_('protocols', 'protocolListType', 0, 0, {'name': 'protocols', 'type': 'protocolListType'}, None),
        'phaseTransitions': MemberSpec_('phaseTransitions', 'phaseTransitionsListType', 0, 1, {'minOccurs': '0', 'name': 'phaseTransitions', 'type': 'phaseTransitionsListType'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, orderNumber=None, code=None, name=None, editEnabled=None, protocols=None, phaseTransitions=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.orderNumber = orderNumber
        self.orderNumber_nsprefix_ = None
        self.code = code
        self.code_nsprefix_ = None
        self.name = name
        self.validate_nameType30(self.name)
        self.name_nsprefix_ = None
        self.editEnabled = editEnabled
        self.editEnabled_nsprefix_ = None
        self.protocols = protocols
        self.protocols_nsprefix_ = None
        self.phaseTransitions = phaseTransitions
        self.phaseTransitions_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, purchasePhase)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if purchasePhase.subclass:
            return purchasePhase.subclass(*args_, **kwargs_)
        else:
            return purchasePhase(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_nameType30(self, value):
        result = True
        # Validate type nameType30, a restriction on t:nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 200:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on nameType30' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on nameType30' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.orderNumber is not None or
            self.code is not None or
            self.name is not None or
            self.editEnabled is not None or
            self.protocols is not None or
            self.phaseTransitions is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'orderNumber' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'orderNumber')
            ival_ = self.gds_validate_integer(ival_, node, 'orderNumber')
            self.orderNumber = ival_
            self.orderNumber_nsprefix_ = child_.prefix
        elif nodeName_ == 'code' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'code')
            ival_ = self.gds_validate_integer(ival_, node, 'code')
            self.code = ival_
            self.code_nsprefix_ = child_.prefix
        elif nodeName_ == 'name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'name')
            value_ = self.gds_validate_string(value_, node, 'name')
            self.name = value_
            self.name_nsprefix_ = child_.prefix
            # validate type nameType30
            self.validate_nameType30(self.name)
        elif nodeName_ == 'editEnabled':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'editEnabled')
            ival_ = self.gds_validate_boolean(ival_, node, 'editEnabled')
            self.editEnabled = ival_
            self.editEnabled_nsprefix_ = child_.prefix
        elif nodeName_ == 'protocols':
            obj_ = protocolListType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.protocols = obj_
            obj_.original_tagname_ = 'protocols'
        elif nodeName_ == 'phaseTransitions':
            obj_ = phaseTransitionsListType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.phaseTransitions = obj_
            obj_.original_tagname_ = 'phaseTransitions'
# end class purchasePhase


class protocolListType(GeneratedsSuper):
    """Перечень протоколов"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'controlledOrder': MemberSpec_('controlledOrder', 'xs:boolean', 0, 0, {'name': 'controlledOrder', 'type': 'xs:boolean'}, None),
        'protocol': MemberSpec_('protocol', 'purchaseProtocol', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'protocol', 'type': 'purchaseProtocol'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, controlledOrder=None, protocol=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.controlledOrder = controlledOrder
        self.controlledOrder_nsprefix_ = None
        if protocol is None:
            self.protocol = []
        else:
            self.protocol = protocol
        self.protocol_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, protocolListType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if protocolListType.subclass:
            return protocolListType.subclass(*args_, **kwargs_)
        else:
            return protocolListType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.controlledOrder is not None or
            self.protocol
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'controlledOrder':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'controlledOrder')
            ival_ = self.gds_validate_boolean(ival_, node, 'controlledOrder')
            self.controlledOrder = ival_
            self.controlledOrder_nsprefix_ = child_.prefix
        elif nodeName_ == 'protocol':
            obj_ = purchaseProtocol.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.protocol.append(obj_)
            obj_.original_tagname_ = 'protocol'
# end class protocolListType


class purchaseProtocol(GeneratedsSuper):
    """Данные о протоколе"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'code': MemberSpec_('code', 'xs:long', 0, 0, {'name': 'code', 'type': 'xs:long'}, None),
        'name': MemberSpec_('name', ['nameType31', 't:nonEmptyString'], 0, 0, {'name': 'name', 'type': 'xs:string'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, code=None, name=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.code = code
        self.code_nsprefix_ = None
        self.name = name
        self.validate_nameType31(self.name)
        self.name_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, purchaseProtocol)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if purchaseProtocol.subclass:
            return purchaseProtocol.subclass(*args_, **kwargs_)
        else:
            return purchaseProtocol(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_nameType31(self, value):
        result = True
        # Validate type nameType31, a restriction on t:nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 2000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on nameType31' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on nameType31' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.code is not None or
            self.name is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'code' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'code')
            ival_ = self.gds_validate_integer(ival_, node, 'code')
            self.code = ival_
            self.code_nsprefix_ = child_.prefix
        elif nodeName_ == 'name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'name')
            value_ = self.gds_validate_string(value_, node, 'name')
            self.name = value_
            self.name_nsprefix_ = child_.prefix
            # validate type nameType31
            self.validate_nameType31(self.name)
# end class purchaseProtocol


class documentUploadBaseData(GeneratedsSuper):
    """Базовый тип для загружаемого документа"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'guid': MemberSpec_('guid', ['guidType', 'xs:string'], 0, 0, {'name': 'guid', 'type': 'xs:string'}, None),
        'entityGuid': MemberSpec_('entityGuid', ['guidType', 'xs:string'], 0, 0, {'name': 'entityGuid', 'type': 'xs:string'}, None),
        'placer': MemberSpec_('placer', 'customerInfoType', 0, 0, {'name': 'placer', 'type': 'customerInfoType'}, None),
        'additionalDocumentsCount': MemberSpec_('additionalDocumentsCount', 'xs:positiveInteger', 0, 0, {'name': 'additionalDocumentsCount', 'type': 'xs:positiveInteger'}, None),
        'documentNumber': MemberSpec_('documentNumber', 'xs:positiveInteger', 0, 0, {'name': 'documentNumber', 'type': 'xs:positiveInteger'}, None),
        'document': MemberSpec_('document', 'documentType', 0, 0, {'name': 'document', 'type': 'documentType'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_) + ['extensiontype_']
    subclass = None
    superclass = None
    def __init__(self, guid=None, entityGuid=None, placer=None, additionalDocumentsCount=None, documentNumber=None, document=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.guid = guid
        self.validate_guidType(self.guid)
        self.guid_nsprefix_ = None
        self.entityGuid = entityGuid
        self.validate_guidType(self.entityGuid)
        self.entityGuid_nsprefix_ = None
        self.placer = placer
        self.placer_nsprefix_ = None
        self.additionalDocumentsCount = additionalDocumentsCount
        self.additionalDocumentsCount_nsprefix_ = None
        self.documentNumber = documentNumber
        self.documentNumber_nsprefix_ = None
        self.document = document
        self.document_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, documentUploadBaseData)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if documentUploadBaseData.subclass:
            return documentUploadBaseData.subclass(*args_, **kwargs_)
        else:
            return documentUploadBaseData(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_guidType(self, value):
        result = True
        # Validate type guidType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) != 36:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd length restriction on guidType' % {"value": encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_guidType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_guidType_patterns_, ))
                result = False
        return result
    validate_guidType_patterns_ = [['^([a-fA-F0-9]{8}\\-[a-fA-F0-9]{4}\\-[a-fA-F0-9]{4}\\-[a-fA-F0-9]{4}\\-[a-fA-F0-9]{12})$']]
    def hasContent_(self):
        if (
            self.guid is not None or
            self.entityGuid is not None or
            self.placer is not None or
            self.additionalDocumentsCount is not None or
            self.documentNumber is not None or
            self.document is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'guid':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'guid')
            value_ = self.gds_validate_string(value_, node, 'guid')
            self.guid = value_
            self.guid_nsprefix_ = child_.prefix
            # validate type guidType
            self.validate_guidType(self.guid)
        elif nodeName_ == 'entityGuid':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'entityGuid')
            value_ = self.gds_validate_string(value_, node, 'entityGuid')
            self.entityGuid = value_
            self.entityGuid_nsprefix_ = child_.prefix
            # validate type guidType
            self.validate_guidType(self.entityGuid)
        elif nodeName_ == 'placer':
            obj_ = customerInfoType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.placer = obj_
            obj_.original_tagname_ = 'placer'
        elif nodeName_ == 'additionalDocumentsCount' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'additionalDocumentsCount')
            if ival_ <= 0:
                raise_parse_error(child_, 'requires positiveInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'additionalDocumentsCount')
            self.additionalDocumentsCount = ival_
            self.additionalDocumentsCount_nsprefix_ = child_.prefix
        elif nodeName_ == 'documentNumber' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'documentNumber')
            if ival_ <= 0:
                raise_parse_error(child_, 'requires positiveInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'documentNumber')
            self.documentNumber = ival_
            self.documentNumber_nsprefix_ = child_.prefix
        elif nodeName_ == 'document':
            obj_ = documentType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.document = obj_
            obj_.original_tagname_ = 'document'
# end class documentUploadBaseData


class contactInfoType(GeneratedsSuper):
    """Информация о контактном лице"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'firstName': MemberSpec_('firstName', ['firstNameType', 'nonEmptyString', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'firstName', 'type': 'xs:string'}, None),
        'middleName': MemberSpec_('middleName', ['middleNameType', 'nonEmptyString', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'middleName', 'type': 'xs:string'}, None),
        'lastName': MemberSpec_('lastName', ['lastNameType', 'nonEmptyString', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'lastName', 'type': 'xs:string'}, None),
        'phone': MemberSpec_('phone', ['phoneType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'phone', 'type': 'xs:string'}, None),
        'fax': MemberSpec_('fax', ['phoneType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'fax', 'type': 'xs:string'}, None),
        'email': MemberSpec_('email', ['emailType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'email', 'type': 'xs:string'}, None),
        'additionalContactInfo': MemberSpec_('additionalContactInfo', ['additionalContactInfoType', 'nonEmptyString', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'additionalContactInfo', 'type': 'xs:string'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, firstName=None, middleName=None, lastName=None, phone=None, fax=None, email=None, additionalContactInfo=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.firstName = firstName
        self.validate_firstNameType(self.firstName)
        self.firstName_nsprefix_ = None
        self.middleName = middleName
        self.validate_middleNameType(self.middleName)
        self.middleName_nsprefix_ = None
        self.lastName = lastName
        self.validate_lastNameType(self.lastName)
        self.lastName_nsprefix_ = None
        self.phone = phone
        self.validate_phoneType(self.phone)
        self.phone_nsprefix_ = None
        self.fax = fax
        self.validate_phoneType(self.fax)
        self.fax_nsprefix_ = None
        self.email = email
        self.validate_emailType(self.email)
        self.email_nsprefix_ = None
        self.additionalContactInfo = additionalContactInfo
        self.validate_additionalContactInfoType(self.additionalContactInfo)
        self.additionalContactInfo_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, contactInfoType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if contactInfoType.subclass:
            return contactInfoType.subclass(*args_, **kwargs_)
        else:
            return contactInfoType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_firstNameType(self, value):
        result = True
        # Validate type firstNameType, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 300:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on firstNameType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on firstNameType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_middleNameType(self, value):
        result = True
        # Validate type middleNameType, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 300:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on middleNameType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on middleNameType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_lastNameType(self, value):
        result = True
        # Validate type lastNameType, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 300:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on lastNameType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on lastNameType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_phoneType(self, value):
        result = True
        # Validate type phoneType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 300:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on phoneType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on phoneType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_emailType(self, value):
        result = True
        # Validate type emailType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 300:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on emailType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on emailType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_emailType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_emailType_patterns_, ))
                result = False
        return result
    validate_emailType_patterns_ = [["^(([\\-a-zA-Zа-яА-Я0-9!#%&'\\*\\+/=\\?\\^_`\\{\\|\\}~]+(\\.[\\-a-zA-Zа-яА-Я0-9!#%&'\\*\\+/=\\?\\^_`\\{\\|\\}~]+)*@([a-zA-Zа-яА-Я0-9]([\\-_a-zA-Zа-яА-Я0-9]{0,61}[a-zA-Zа-яА-Я0-9])?\\.)*[\\-a-zA-Zа-яА-Я0-9]+(\\.[\\-a-zA-Zа-яА-Я0-9]+)*)+(,\\s?[\\-a-zA-Zа-яА-Я0-9!#%&'\\*\\+/=\\?\\^_`\\{\\|\\}~]+(\\.[\\-a-zA-Zа-яА-Я0-9!#%&'\\*\\+/=\\?\\^_`\\{\\|\\}~]+)*@([a-zA-Zа-яА-Я0-9]([\\-_a-zA-Zа-яА-Я0-9]{0,61}[a-zA-Zа-яА-Я0-9])?\\.)*[\\-a-zA-Zа-яА-Я0-9]+(\\.[\\-a-zA-Zа-яА-Я0-9]+)*)*)$"]]
    def validate_additionalContactInfoType(self, value):
        result = True
        # Validate type additionalContactInfoType, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 2000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on additionalContactInfoType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on additionalContactInfoType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.firstName is not None or
            self.middleName is not None or
            self.lastName is not None or
            self.phone is not None or
            self.fax is not None or
            self.email is not None or
            self.additionalContactInfo is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'firstName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'firstName')
            value_ = self.gds_validate_string(value_, node, 'firstName')
            self.firstName = value_
            self.firstName_nsprefix_ = child_.prefix
            # validate type firstNameType
            self.validate_firstNameType(self.firstName)
        elif nodeName_ == 'middleName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'middleName')
            value_ = self.gds_validate_string(value_, node, 'middleName')
            self.middleName = value_
            self.middleName_nsprefix_ = child_.prefix
            # validate type middleNameType
            self.validate_middleNameType(self.middleName)
        elif nodeName_ == 'lastName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'lastName')
            value_ = self.gds_validate_string(value_, node, 'lastName')
            self.lastName = value_
            self.lastName_nsprefix_ = child_.prefix
            # validate type lastNameType
            self.validate_lastNameType(self.lastName)
        elif nodeName_ == 'phone':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'phone')
            value_ = self.gds_validate_string(value_, node, 'phone')
            self.phone = value_
            self.phone_nsprefix_ = child_.prefix
            # validate type phoneType
            self.validate_phoneType(self.phone)
        elif nodeName_ == 'fax':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'fax')
            value_ = self.gds_validate_string(value_, node, 'fax')
            self.fax = value_
            self.fax_nsprefix_ = child_.prefix
            # validate type phoneType
            self.validate_phoneType(self.fax)
        elif nodeName_ == 'email':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'email')
            value_ = self.gds_validate_string(value_, node, 'email')
            self.email = value_
            self.email_nsprefix_ = child_.prefix
            # validate type emailType
            self.validate_emailType(self.email)
        elif nodeName_ == 'additionalContactInfo':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'additionalContactInfo')
            value_ = self.gds_validate_string(value_, node, 'additionalContactInfo')
            self.additionalContactInfo = value_
            self.additionalContactInfo_nsprefix_ = child_.prefix
            # validate type additionalContactInfoType
            self.validate_additionalContactInfoType(self.additionalContactInfo)
# end class contactInfoType


class cryptoSignsType(GeneratedsSuper):
    """ЭЦП документа"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'signature': MemberSpec_('signature', 'signatureType50', 1, 0, {'maxOccurs': 'unbounded', 'name': 'signature', 'type': 'signatureType50'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, signature=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if signature is None:
            self.signature = []
        else:
            self.signature = signature
        self.signature_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, cryptoSignsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if cryptoSignsType.subclass:
            return cryptoSignsType.subclass(*args_, **kwargs_)
        else:
            return cryptoSignsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.signature
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'signature':
            obj_ = signatureType50.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.signature.append(obj_)
            obj_.original_tagname_ = 'signature'
# end class cryptoSignsType


class currencyType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'letterCode': MemberSpec_('letterCode', ['letterCodeType', 'nonEmptyString', 'xs:string'], 0, 0, {'name': 'letterCode', 'type': 'xs:string'}, 2),
        'code': MemberSpec_('code', ['codeType51', 'nonEmptyString', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'code', 'type': 'xs:string'}, 2),
        'digitalCode': MemberSpec_('digitalCode', ['digitalCodeType52', 'nonEmptyString', 'xs:string'], 0, 0, {'name': 'digitalCode', 'type': 'xs:string'}, 2),
        'name': MemberSpec_('name', ['nameType53', 'nonEmptyString', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'name', 'type': 'xs:string'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, letterCode=None, code=None, digitalCode=None, name=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.letterCode = letterCode
        self.validate_letterCodeType(self.letterCode)
        self.letterCode_nsprefix_ = None
        self.code = code
        self.validate_codeType51(self.code)
        self.code_nsprefix_ = None
        self.digitalCode = digitalCode
        self.validate_digitalCodeType52(self.digitalCode)
        self.digitalCode_nsprefix_ = None
        self.name = name
        self.validate_nameType53(self.name)
        self.name_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, currencyType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if currencyType.subclass:
            return currencyType.subclass(*args_, **kwargs_)
        else:
            return currencyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_letterCodeType(self, value):
        result = True
        # Validate type letterCodeType, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 3:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on letterCodeType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on letterCodeType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_codeType51(self, value):
        result = True
        # Validate type codeType51, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 3:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on codeType51' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on codeType51' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_digitalCodeType52(self, value):
        result = True
        # Validate type digitalCodeType52, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 3:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on digitalCodeType52' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on digitalCodeType52' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_nameType53(self, value):
        result = True
        # Validate type nameType53, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 50:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on nameType53' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on nameType53' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.letterCode is not None or
            self.code is not None or
            self.digitalCode is not None or
            self.name is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'letterCode':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'letterCode')
            value_ = self.gds_validate_string(value_, node, 'letterCode')
            self.letterCode = value_
            self.letterCode_nsprefix_ = child_.prefix
            # validate type letterCodeType
            self.validate_letterCodeType(self.letterCode)
        elif nodeName_ == 'code':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'code')
            value_ = self.gds_validate_string(value_, node, 'code')
            self.code = value_
            self.code_nsprefix_ = child_.prefix
            # validate type codeType51
            self.validate_codeType51(self.code)
        elif nodeName_ == 'digitalCode':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'digitalCode')
            value_ = self.gds_validate_string(value_, node, 'digitalCode')
            self.digitalCode = value_
            self.digitalCode_nsprefix_ = child_.prefix
            # validate type digitalCodeType52
            self.validate_digitalCodeType52(self.digitalCode)
        elif nodeName_ == 'name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'name')
            value_ = self.gds_validate_string(value_, node, 'name')
            self.name = value_
            self.name_nsprefix_ = child_.prefix
            # validate type nameType53
            self.validate_nameType53(self.name)
# end class currencyType


class customerInfoType(GeneratedsSuper):
    """Данные заказчика"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'mainInfo': MemberSpec_('mainInfo', 'customerMainInfoType', 0, 0, {'name': 'mainInfo', 'type': 'customerMainInfoType'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, mainInfo=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.mainInfo = mainInfo
        self.mainInfo_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, customerInfoType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if customerInfoType.subclass:
            return customerInfoType.subclass(*args_, **kwargs_)
        else:
            return customerInfoType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.mainInfo is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'mainInfo':
            obj_ = customerMainInfoType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.mainInfo = obj_
            obj_.original_tagname_ = 'mainInfo'
# end class customerInfoType


class supplierInfoType(GeneratedsSuper):
    """Данные поставщика"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'mainInfo': MemberSpec_('mainInfo', 'supplierMainInfoType', 0, 0, {'name': 'mainInfo', 'type': 'supplierMainInfoType'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, mainInfo=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.mainInfo = mainInfo
        self.mainInfo_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, supplierInfoType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if supplierInfoType.subclass:
            return supplierInfoType.subclass(*args_, **kwargs_)
        else:
            return supplierInfoType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.mainInfo is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'mainInfo':
            obj_ = supplierMainInfoType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.mainInfo = obj_
            obj_.original_tagname_ = 'mainInfo'
# end class supplierInfoType


class supplierMainInfoType(GeneratedsSuper):
    """Основная информация об организации поставщика"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'name': MemberSpec_('name', ['nameType54', 'nonEmptyString', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'name', 'type': 'xs:string'}, None),
        'inn': MemberSpec_('inn', ['innType', 'nonEmptyString', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'inn', 'type': 'xs:string'}, None),
        'kpp': MemberSpec_('kpp', ['kppType', 'nonEmptyString', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'kpp', 'type': 'xs:string'}, None),
        'ogrn': MemberSpec_('ogrn', ['ogrnType', 'nonEmptyString', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'ogrn', 'type': 'xs:string'}, None),
        'type_': MemberSpec_('type_', ['supplierType', 'xs:string'], 0, 0, {'name': 'type', 'type': 'xs:string'}, None),
        'address': MemberSpec_('address', ['addressType', 'nonEmptyString', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'address', 'type': 'xs:string'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, name=None, inn=None, kpp=None, ogrn=None, type_=None, address=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.name = name
        self.validate_nameType54(self.name)
        self.name_nsprefix_ = None
        self.inn = inn
        self.validate_innType(self.inn)
        self.inn_nsprefix_ = None
        self.kpp = kpp
        self.validate_kppType(self.kpp)
        self.kpp_nsprefix_ = None
        self.ogrn = ogrn
        self.validate_ogrnType(self.ogrn)
        self.ogrn_nsprefix_ = None
        self.type_ = type_
        self.validate_supplierType(self.type_)
        self.type__nsprefix_ = None
        self.address = address
        self.validate_addressType(self.address)
        self.address_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, supplierMainInfoType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if supplierMainInfoType.subclass:
            return supplierMainInfoType.subclass(*args_, **kwargs_)
        else:
            return supplierMainInfoType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_nameType54(self, value):
        result = True
        # Validate type nameType54, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on nameType54' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on nameType54' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_innType(self, value):
        result = True
        # Validate type innType, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on innType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_innType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_innType_patterns_, ))
                result = False
        return result
    validate_innType_patterns_ = [['^(\\d{10}|\\d{12})$']]
    def validate_kppType(self, value):
        result = True
        # Validate type kppType, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on kppType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_kppType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_kppType_patterns_, ))
                result = False
        return result
    validate_kppType_patterns_ = [['^(\\d{9})$']]
    def validate_ogrnType(self, value):
        result = True
        # Validate type ogrnType, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ogrnType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_ogrnType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_ogrnType_patterns_, ))
                result = False
        return result
    validate_ogrnType_patterns_ = [['^(\\d{13})$']]
    def validate_supplierType(self, value):
        result = True
        # Validate type supplierType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['L', 'P']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on supplierType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_addressType(self, value):
        result = True
        # Validate type addressType, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on addressType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on addressType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.name is not None or
            self.inn is not None or
            self.kpp is not None or
            self.ogrn is not None or
            self.type_ is not None or
            self.address is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'name')
            value_ = self.gds_validate_string(value_, node, 'name')
            self.name = value_
            self.name_nsprefix_ = child_.prefix
            # validate type nameType54
            self.validate_nameType54(self.name)
        elif nodeName_ == 'inn':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'inn')
            value_ = self.gds_validate_string(value_, node, 'inn')
            self.inn = value_
            self.inn_nsprefix_ = child_.prefix
            # validate type innType
            self.validate_innType(self.inn)
        elif nodeName_ == 'kpp':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'kpp')
            value_ = self.gds_validate_string(value_, node, 'kpp')
            self.kpp = value_
            self.kpp_nsprefix_ = child_.prefix
            # validate type kppType
            self.validate_kppType(self.kpp)
        elif nodeName_ == 'ogrn':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'ogrn')
            value_ = self.gds_validate_string(value_, node, 'ogrn')
            self.ogrn = value_
            self.ogrn_nsprefix_ = child_.prefix
            # validate type ogrnType
            self.validate_ogrnType(self.ogrn)
        elif nodeName_ == 'type':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'type')
            value_ = self.gds_validate_string(value_, node, 'type')
            self.type_ = value_
            self.type_nsprefix_ = child_.prefix
            # validate type supplierType
            self.validate_supplierType(self.type_)
        elif nodeName_ == 'address':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'address')
            value_ = self.gds_validate_string(value_, node, 'address')
            self.address = value_
            self.address_nsprefix_ = child_.prefix
            # validate type addressType
            self.validate_addressType(self.address)
# end class supplierMainInfoType


class nonResidentInfoType(GeneratedsSuper):
    """Сведения о нерезиденте РФ"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'info': MemberSpec_('info', ['infoType55', 'nonEmptyString', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'info', 'type': 'xs:string'}, None),
        'type_': MemberSpec_('type_', ['supplierType', 'xs:string'], 0, 0, {'name': 'type', 'type': 'xs:string'}, None),
        'name': MemberSpec_('name', ['nameType56', 'nonEmptyString', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'name', 'type': 'xs:string'}, None),
        'code': MemberSpec_('code', ['codeType57', 'nonEmptyString', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'code', 'type': 'xs:string'}, None),
        'additionalCode': MemberSpec_('additionalCode', ['additionalCodeType', 'nonEmptyString', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'additionalCode', 'type': 'xs:string'}, None),
        'country': MemberSpec_('country', 'countryType', 0, 1, {'minOccurs': '0', 'name': 'country', 'type': 'countryType'}, None),
        'address': MemberSpec_('address', ['addressType58', 'nonEmptyString', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'address', 'type': 'xs:string'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, info=None, type_=None, name=None, code=None, additionalCode=None, country=None, address=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.info = info
        self.validate_infoType55(self.info)
        self.info_nsprefix_ = None
        self.type_ = type_
        self.validate_supplierType(self.type_)
        self.type__nsprefix_ = None
        self.name = name
        self.validate_nameType56(self.name)
        self.name_nsprefix_ = None
        self.code = code
        self.validate_codeType57(self.code)
        self.code_nsprefix_ = None
        self.additionalCode = additionalCode
        self.validate_additionalCodeType(self.additionalCode)
        self.additionalCode_nsprefix_ = None
        self.country = country
        self.country_nsprefix_ = None
        self.address = address
        self.validate_addressType58(self.address)
        self.address_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, nonResidentInfoType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if nonResidentInfoType.subclass:
            return nonResidentInfoType.subclass(*args_, **kwargs_)
        else:
            return nonResidentInfoType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_infoType55(self, value):
        result = True
        # Validate type infoType55, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 2000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on infoType55' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on infoType55' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_supplierType(self, value):
        result = True
        # Validate type supplierType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['L', 'P']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on supplierType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_nameType56(self, value):
        result = True
        # Validate type nameType56, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on nameType56' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on nameType56' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_codeType57(self, value):
        result = True
        # Validate type codeType57, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 200:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on codeType57' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on codeType57' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_additionalCodeType(self, value):
        result = True
        # Validate type additionalCodeType, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 200:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on additionalCodeType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on additionalCodeType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_addressType58(self, value):
        result = True
        # Validate type addressType58, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on addressType58' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on addressType58' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.info is not None or
            self.type_ is not None or
            self.name is not None or
            self.code is not None or
            self.additionalCode is not None or
            self.country is not None or
            self.address is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'info':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'info')
            value_ = self.gds_validate_string(value_, node, 'info')
            self.info = value_
            self.info_nsprefix_ = child_.prefix
            # validate type infoType55
            self.validate_infoType55(self.info)
        elif nodeName_ == 'type':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'type')
            value_ = self.gds_validate_string(value_, node, 'type')
            self.type_ = value_
            self.type_nsprefix_ = child_.prefix
            # validate type supplierType
            self.validate_supplierType(self.type_)
        elif nodeName_ == 'name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'name')
            value_ = self.gds_validate_string(value_, node, 'name')
            self.name = value_
            self.name_nsprefix_ = child_.prefix
            # validate type nameType56
            self.validate_nameType56(self.name)
        elif nodeName_ == 'code':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'code')
            value_ = self.gds_validate_string(value_, node, 'code')
            self.code = value_
            self.code_nsprefix_ = child_.prefix
            # validate type codeType57
            self.validate_codeType57(self.code)
        elif nodeName_ == 'additionalCode':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'additionalCode')
            value_ = self.gds_validate_string(value_, node, 'additionalCode')
            self.additionalCode = value_
            self.additionalCode_nsprefix_ = child_.prefix
            # validate type additionalCodeType
            self.validate_additionalCodeType(self.additionalCode)
        elif nodeName_ == 'country':
            obj_ = countryType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.country = obj_
            obj_.original_tagname_ = 'country'
        elif nodeName_ == 'address':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'address')
            value_ = self.gds_validate_string(value_, node, 'address')
            self.address = value_
            self.address_nsprefix_ = child_.prefix
            # validate type addressType58
            self.validate_addressType58(self.address)
# end class nonResidentInfoType


class nonResidentLotCustomerInfoType(GeneratedsSuper):
    """Сведения о нерезиденте РФ"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'name': MemberSpec_('name', ['nameType59', 'nonEmptyString', 'xs:string'], 0, 0, {'name': 'name', 'type': 'xs:string'}, None),
        'code': MemberSpec_('code', ['codeType60', 'nonEmptyString', 'xs:string'], 0, 0, {'name': 'code', 'type': 'xs:string'}, None),
        'country': MemberSpec_('country', 'countryType', 0, 0, {'name': 'country', 'type': 'countryType'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, name=None, code=None, country=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.name = name
        self.validate_nameType59(self.name)
        self.name_nsprefix_ = None
        self.code = code
        self.validate_codeType60(self.code)
        self.code_nsprefix_ = None
        self.country = country
        self.country_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, nonResidentLotCustomerInfoType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if nonResidentLotCustomerInfoType.subclass:
            return nonResidentLotCustomerInfoType.subclass(*args_, **kwargs_)
        else:
            return nonResidentLotCustomerInfoType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_nameType59(self, value):
        result = True
        # Validate type nameType59, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on nameType59' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on nameType59' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_codeType60(self, value):
        result = True
        # Validate type codeType60, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 200:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on codeType60' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on codeType60' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.name is not None or
            self.code is not None or
            self.country is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'name')
            value_ = self.gds_validate_string(value_, node, 'name')
            self.name = value_
            self.name_nsprefix_ = child_.prefix
            # validate type nameType59
            self.validate_nameType59(self.name)
        elif nodeName_ == 'code':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'code')
            value_ = self.gds_validate_string(value_, node, 'code')
            self.code = value_
            self.code_nsprefix_ = child_.prefix
            # validate type codeType60
            self.validate_codeType60(self.code)
        elif nodeName_ == 'country':
            obj_ = countryType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.country = obj_
            obj_.original_tagname_ = 'country'
# end class nonResidentLotCustomerInfoType


class contractItemType(GeneratedsSuper):
    """Информация о товаре, работе, услуге"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'okdp': MemberSpec_('okdp', 'okdpProductType', 0, 0, {'name': 'okdp', 'type': 'okdpProductType'}, 3),
        'okpd2': MemberSpec_('okpd2', 'okpd2ProductType', 0, 0, {'name': 'okpd2', 'type': 'okpd2ProductType'}, 3),
        'okved': MemberSpec_('okved', 'okvedProductType', 0, 0, {'name': 'okved', 'type': 'okvedProductType'}, 4),
        'okved2': MemberSpec_('okved2', 'okved2ProductType', 0, 0, {'name': 'okved2', 'type': 'okved2ProductType'}, 4),
        'okei': MemberSpec_('okei', 'okeiProductType', 0, 1, {'minOccurs': '0', 'name': 'okei', 'type': 'okeiProductType'}, None),
        'qty': MemberSpec_('qty', ['lotItemQtyType', 'xs:decimal'], 0, 1, {'minOccurs': '0', 'name': 'qty', 'type': 'xs:decimal'}, None),
        'deliveryPlace': MemberSpec_('deliveryPlace', 'deliveryPlaceType', 0, 1, {'minOccurs': '0', 'name': 'deliveryPlace', 'type': 'deliveryPlaceType'}, None),
        'additionalInfo': MemberSpec_('additionalInfo', ['additionalInfoType61', 'nonEmptyString', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'additionalInfo', 'type': 'xs:string'}, None),
        'ordinalNumber': MemberSpec_('ordinalNumber', 'xs:int', 0, 0, {'name': 'ordinalNumber', 'type': 'xs:int'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, okdp=None, okpd2=None, okved=None, okved2=None, okei=None, qty=None, deliveryPlace=None, additionalInfo=None, ordinalNumber=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.okdp = okdp
        self.okdp_nsprefix_ = None
        self.okpd2 = okpd2
        self.okpd2_nsprefix_ = None
        self.okved = okved
        self.okved_nsprefix_ = None
        self.okved2 = okved2
        self.okved2_nsprefix_ = None
        self.okei = okei
        self.okei_nsprefix_ = None
        self.qty = qty
        self.validate_lotItemQtyType(self.qty)
        self.qty_nsprefix_ = None
        self.deliveryPlace = deliveryPlace
        self.deliveryPlace_nsprefix_ = None
        self.additionalInfo = additionalInfo
        self.validate_additionalInfoType61(self.additionalInfo)
        self.additionalInfo_nsprefix_ = None
        self.ordinalNumber = ordinalNumber
        self.ordinalNumber_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, contractItemType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if contractItemType.subclass:
            return contractItemType.subclass(*args_, **kwargs_)
        else:
            return contractItemType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_lotItemQtyType(self, value):
        result = True
        # Validate type lotItemQtyType, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, decimal_.Decimal):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (decimal_.Decimal)' % {"value": value, "lineno": lineno, })
                return False
            if len(str(value)) >= 25:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd totalDigits restriction on lotItemQtyType' % {"value": value, "lineno": lineno} )
                result = False
        return result
    def validate_additionalInfoType61(self, value):
        result = True
        # Validate type additionalInfoType61, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on additionalInfoType61' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on additionalInfoType61' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.okdp is not None or
            self.okpd2 is not None or
            self.okved is not None or
            self.okved2 is not None or
            self.okei is not None or
            self.qty is not None or
            self.deliveryPlace is not None or
            self.additionalInfo is not None or
            self.ordinalNumber is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'okdp':
            obj_ = okdpProductType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.okdp = obj_
            obj_.original_tagname_ = 'okdp'
        elif nodeName_ == 'okpd2':
            obj_ = okpd2ProductType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.okpd2 = obj_
            obj_.original_tagname_ = 'okpd2'
        elif nodeName_ == 'okved':
            obj_ = okvedProductType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.okved = obj_
            obj_.original_tagname_ = 'okved'
        elif nodeName_ == 'okved2':
            obj_ = okved2ProductType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.okved2 = obj_
            obj_.original_tagname_ = 'okved2'
        elif nodeName_ == 'okei':
            obj_ = okeiProductType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.okei = obj_
            obj_.original_tagname_ = 'okei'
        elif nodeName_ == 'qty' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'qty')
            fval_ = self.gds_validate_decimal(fval_, node, 'qty')
            self.qty = fval_
            self.qty_nsprefix_ = child_.prefix
            # validate type lotItemQtyType
            self.validate_lotItemQtyType(self.qty)
        elif nodeName_ == 'deliveryPlace':
            obj_ = deliveryPlaceType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.deliveryPlace = obj_
            obj_.original_tagname_ = 'deliveryPlace'
        elif nodeName_ == 'additionalInfo':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'additionalInfo')
            value_ = self.gds_validate_string(value_, node, 'additionalInfo')
            self.additionalInfo = value_
            self.additionalInfo_nsprefix_ = child_.prefix
            # validate type additionalInfoType61
            self.validate_additionalInfoType61(self.additionalInfo)
        elif nodeName_ == 'ordinalNumber' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'ordinalNumber')
            ival_ = self.gds_validate_integer(ival_, node, 'ordinalNumber')
            self.ordinalNumber = ival_
            self.ordinalNumber_nsprefix_ = child_.prefix
# end class contractItemType


class customerInfo2Type(GeneratedsSuper):
    """Данные заказчика"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'mainInfo': MemberSpec_('mainInfo', 'customerMainInfo2Type', 0, 0, {'name': 'mainInfo', 'type': 'customerMainInfo2Type'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, mainInfo=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.mainInfo = mainInfo
        self.mainInfo_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, customerInfo2Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if customerInfo2Type.subclass:
            return customerInfo2Type.subclass(*args_, **kwargs_)
        else:
            return customerInfo2Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.mainInfo is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'mainInfo':
            obj_ = customerMainInfo2Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.mainInfo = obj_
            obj_.original_tagname_ = 'mainInfo'
# end class customerInfo2Type


class customerInfo3Type(GeneratedsSuper):
    """Данные заказчика"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'mainInfo': MemberSpec_('mainInfo', 'customerMainInfo3Type', 0, 0, {'name': 'mainInfo', 'type': 'customerMainInfo3Type'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, mainInfo=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.mainInfo = mainInfo
        self.mainInfo_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, customerInfo3Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if customerInfo3Type.subclass:
            return customerInfo3Type.subclass(*args_, **kwargs_)
        else:
            return customerInfo3Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.mainInfo is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'mainInfo':
            obj_ = customerMainInfo3Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.mainInfo = obj_
            obj_.original_tagname_ = 'mainInfo'
# end class customerInfo3Type


class customerMainInfoType(GeneratedsSuper):
    """Основная информация об организации"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'fullName': MemberSpec_('fullName', ['fullNameType', 'nonEmptyString', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'fullName', 'type': 'xs:string'}, None),
        'shortName': MemberSpec_('shortName', ['shortNameType62', 'nonEmptyString', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'shortName', 'type': 'xs:string'}, None),
        'iko': MemberSpec_('iko', ['ikoType', 'nonEmptyString', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'iko', 'type': 'xs:string'}, None),
        'inn': MemberSpec_('inn', ['innType', 'nonEmptyString', 'xs:string'], 0, 0, {'name': 'inn', 'type': 'xs:string'}, None),
        'kpp': MemberSpec_('kpp', ['kppType', 'nonEmptyString', 'xs:string'], 0, 0, {'name': 'kpp', 'type': 'xs:string'}, None),
        'ogrn': MemberSpec_('ogrn', ['ogrnType', 'nonEmptyString', 'xs:string'], 0, 0, {'name': 'ogrn', 'type': 'xs:string'}, None),
        'legalAddress': MemberSpec_('legalAddress', ['legalAddressType', 'nonEmptyString', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'legalAddress', 'type': 'xs:string'}, None),
        'postalAddress': MemberSpec_('postalAddress', ['postalAddressType', 'nonEmptyString', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'postalAddress', 'type': 'xs:string'}, None),
        'phone': MemberSpec_('phone', ['phoneType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'phone', 'type': 'xs:string'}, None),
        'fax': MemberSpec_('fax', ['phoneType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'fax', 'type': 'xs:string'}, None),
        'email': MemberSpec_('email', ['emailType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'email', 'type': 'xs:string'}, None),
        'okato': MemberSpec_('okato', ['codeOkatoType', 'nonEmptyString', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'okato', 'type': 'xs:string'}, None),
        'okopf': MemberSpec_('okopf', ['codeOkopfType', 'nonEmptyString', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'okopf', 'type': 'xs:string'}, None),
        'okopfName': MemberSpec_('okopfName', ['okopfNameType', 'nonEmptyString', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'okopfName', 'type': 'xs:string'}, None),
        'okpo': MemberSpec_('okpo', ['customerCodeOkpoType', 'nonEmptyString', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'okpo', 'type': 'xs:string'}, None),
        'customerRegistrationDate': MemberSpec_('customerRegistrationDate', 'xs:dateTime', 0, 1, {'minOccurs': '0', 'name': 'customerRegistrationDate', 'type': 'xs:dateTime'}, None),
        'timeZone': MemberSpec_('timeZone', 'timeZoneType', 0, 1, {'minOccurs': '0', 'name': 'timeZone', 'type': 'timeZoneType'}, None),
        'region': MemberSpec_('region', ['regionType', 'nonEmptyString', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'region', 'type': 'xs:string'}, None),
        'customerAssessedCompliance': MemberSpec_('customerAssessedCompliance', 'xs:boolean', 0, 1, {'minOccurs': '0', 'name': 'customerAssessedCompliance', 'type': 'xs:boolean'}, None),
        'customerMonitoredCompliance': MemberSpec_('customerMonitoredCompliance', 'xs:boolean', 0, 1, {'minOccurs': '0', 'name': 'customerMonitoredCompliance', 'type': 'xs:boolean'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, fullName=None, shortName=None, iko=None, inn=None, kpp=None, ogrn=None, legalAddress=None, postalAddress=None, phone=None, fax=None, email=None, okato=None, okopf=None, okopfName=None, okpo=None, customerRegistrationDate=None, timeZone=None, region=None, customerAssessedCompliance=None, customerMonitoredCompliance=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.fullName = fullName
        self.validate_fullNameType(self.fullName)
        self.fullName_nsprefix_ = None
        self.shortName = shortName
        self.validate_shortNameType62(self.shortName)
        self.shortName_nsprefix_ = None
        self.iko = iko
        self.validate_ikoType(self.iko)
        self.iko_nsprefix_ = None
        self.inn = inn
        self.validate_innType(self.inn)
        self.inn_nsprefix_ = None
        self.kpp = kpp
        self.validate_kppType(self.kpp)
        self.kpp_nsprefix_ = None
        self.ogrn = ogrn
        self.validate_ogrnType(self.ogrn)
        self.ogrn_nsprefix_ = None
        self.legalAddress = legalAddress
        self.validate_legalAddressType(self.legalAddress)
        self.legalAddress_nsprefix_ = None
        self.postalAddress = postalAddress
        self.validate_postalAddressType(self.postalAddress)
        self.postalAddress_nsprefix_ = None
        self.phone = phone
        self.validate_phoneType(self.phone)
        self.phone_nsprefix_ = None
        self.fax = fax
        self.validate_phoneType(self.fax)
        self.fax_nsprefix_ = None
        self.email = email
        self.validate_emailType(self.email)
        self.email_nsprefix_ = None
        self.okato = okato
        self.validate_codeOkatoType(self.okato)
        self.okato_nsprefix_ = None
        self.okopf = okopf
        self.validate_codeOkopfType(self.okopf)
        self.okopf_nsprefix_ = None
        self.okopfName = okopfName
        self.validate_okopfNameType(self.okopfName)
        self.okopfName_nsprefix_ = None
        self.okpo = okpo
        self.validate_customerCodeOkpoType(self.okpo)
        self.okpo_nsprefix_ = None
        if isinstance(customerRegistrationDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(customerRegistrationDate, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = customerRegistrationDate
        self.customerRegistrationDate = initvalue_
        self.customerRegistrationDate_nsprefix_ = None
        self.timeZone = timeZone
        self.timeZone_nsprefix_ = None
        self.region = region
        self.validate_regionType(self.region)
        self.region_nsprefix_ = None
        self.customerAssessedCompliance = customerAssessedCompliance
        self.customerAssessedCompliance_nsprefix_ = None
        self.customerMonitoredCompliance = customerMonitoredCompliance
        self.customerMonitoredCompliance_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, customerMainInfoType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if customerMainInfoType.subclass:
            return customerMainInfoType.subclass(*args_, **kwargs_)
        else:
            return customerMainInfoType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_fullNameType(self, value):
        result = True
        # Validate type fullNameType, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on fullNameType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on fullNameType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_shortNameType62(self, value):
        result = True
        # Validate type shortNameType62, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 500:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on shortNameType62' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on shortNameType62' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_ikoType(self, value):
        result = True
        # Validate type ikoType, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ikoType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_ikoType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_ikoType_patterns_, ))
                result = False
        return result
    validate_ikoType_patterns_ = [['^(\\d{20}|\\d{22})$']]
    def validate_innType(self, value):
        result = True
        # Validate type innType, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on innType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_innType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_innType_patterns_, ))
                result = False
        return result
    validate_innType_patterns_ = [['^(\\d{10}|\\d{12})$']]
    def validate_kppType(self, value):
        result = True
        # Validate type kppType, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on kppType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_kppType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_kppType_patterns_, ))
                result = False
        return result
    validate_kppType_patterns_ = [['^(\\d{9})$']]
    def validate_ogrnType(self, value):
        result = True
        # Validate type ogrnType, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ogrnType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_ogrnType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_ogrnType_patterns_, ))
                result = False
        return result
    validate_ogrnType_patterns_ = [['^(\\d{13})$']]
    def validate_legalAddressType(self, value):
        result = True
        # Validate type legalAddressType, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 2000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on legalAddressType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on legalAddressType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_postalAddressType(self, value):
        result = True
        # Validate type postalAddressType, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 2000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on postalAddressType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on postalAddressType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_phoneType(self, value):
        result = True
        # Validate type phoneType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 300:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on phoneType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on phoneType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_emailType(self, value):
        result = True
        # Validate type emailType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 300:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on emailType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on emailType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_emailType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_emailType_patterns_, ))
                result = False
        return result
    validate_emailType_patterns_ = [["^(([\\-a-zA-Zа-яА-Я0-9!#%&'\\*\\+/=\\?\\^_`\\{\\|\\}~]+(\\.[\\-a-zA-Zа-яА-Я0-9!#%&'\\*\\+/=\\?\\^_`\\{\\|\\}~]+)*@([a-zA-Zа-яА-Я0-9]([\\-_a-zA-Zа-яА-Я0-9]{0,61}[a-zA-Zа-яА-Я0-9])?\\.)*[\\-a-zA-Zа-яА-Я0-9]+(\\.[\\-a-zA-Zа-яА-Я0-9]+)*)+(,\\s?[\\-a-zA-Zа-яА-Я0-9!#%&'\\*\\+/=\\?\\^_`\\{\\|\\}~]+(\\.[\\-a-zA-Zа-яА-Я0-9!#%&'\\*\\+/=\\?\\^_`\\{\\|\\}~]+)*@([a-zA-Zа-яА-Я0-9]([\\-_a-zA-Zа-яА-Я0-9]{0,61}[a-zA-Zа-яА-Я0-9])?\\.)*[\\-a-zA-Zа-яА-Я0-9]+(\\.[\\-a-zA-Zа-яА-Я0-9]+)*)*)$"]]
    def validate_codeOkatoType(self, value):
        result = True
        # Validate type codeOkatoType, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on codeOkatoType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_codeOkatoType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_codeOkatoType_patterns_, ))
                result = False
        return result
    validate_codeOkatoType_patterns_ = [['^(\\d{11})$']]
    def validate_codeOkopfType(self, value):
        result = True
        # Validate type codeOkopfType, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on codeOkopfType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_codeOkopfType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_codeOkopfType_patterns_, ))
                result = False
        return result
    validate_codeOkopfType_patterns_ = [['^(\\d{2}|\\d{5})$']]
    def validate_okopfNameType(self, value):
        result = True
        # Validate type okopfNameType, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 200:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on okopfNameType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on okopfNameType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_customerCodeOkpoType(self, value):
        result = True
        # Validate type customerCodeOkpoType, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on customerCodeOkpoType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_customerCodeOkpoType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_customerCodeOkpoType_patterns_, ))
                result = False
        return result
    validate_customerCodeOkpoType_patterns_ = [['^(\\d{8})$']]
    def validate_regionType(self, value):
        result = True
        # Validate type regionType, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 200:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on regionType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on regionType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.fullName is not None or
            self.shortName is not None or
            self.iko is not None or
            self.inn is not None or
            self.kpp is not None or
            self.ogrn is not None or
            self.legalAddress is not None or
            self.postalAddress is not None or
            self.phone is not None or
            self.fax is not None or
            self.email is not None or
            self.okato is not None or
            self.okopf is not None or
            self.okopfName is not None or
            self.okpo is not None or
            self.customerRegistrationDate is not None or
            self.timeZone is not None or
            self.region is not None or
            self.customerAssessedCompliance is not None or
            self.customerMonitoredCompliance is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'fullName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'fullName')
            value_ = self.gds_validate_string(value_, node, 'fullName')
            self.fullName = value_
            self.fullName_nsprefix_ = child_.prefix
            # validate type fullNameType
            self.validate_fullNameType(self.fullName)
        elif nodeName_ == 'shortName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'shortName')
            value_ = self.gds_validate_string(value_, node, 'shortName')
            self.shortName = value_
            self.shortName_nsprefix_ = child_.prefix
            # validate type shortNameType62
            self.validate_shortNameType62(self.shortName)
        elif nodeName_ == 'iko':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'iko')
            value_ = self.gds_validate_string(value_, node, 'iko')
            self.iko = value_
            self.iko_nsprefix_ = child_.prefix
            # validate type ikoType
            self.validate_ikoType(self.iko)
        elif nodeName_ == 'inn':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'inn')
            value_ = self.gds_validate_string(value_, node, 'inn')
            self.inn = value_
            self.inn_nsprefix_ = child_.prefix
            # validate type innType
            self.validate_innType(self.inn)
        elif nodeName_ == 'kpp':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'kpp')
            value_ = self.gds_validate_string(value_, node, 'kpp')
            self.kpp = value_
            self.kpp_nsprefix_ = child_.prefix
            # validate type kppType
            self.validate_kppType(self.kpp)
        elif nodeName_ == 'ogrn':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'ogrn')
            value_ = self.gds_validate_string(value_, node, 'ogrn')
            self.ogrn = value_
            self.ogrn_nsprefix_ = child_.prefix
            # validate type ogrnType
            self.validate_ogrnType(self.ogrn)
        elif nodeName_ == 'legalAddress':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'legalAddress')
            value_ = self.gds_validate_string(value_, node, 'legalAddress')
            self.legalAddress = value_
            self.legalAddress_nsprefix_ = child_.prefix
            # validate type legalAddressType
            self.validate_legalAddressType(self.legalAddress)
        elif nodeName_ == 'postalAddress':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'postalAddress')
            value_ = self.gds_validate_string(value_, node, 'postalAddress')
            self.postalAddress = value_
            self.postalAddress_nsprefix_ = child_.prefix
            # validate type postalAddressType
            self.validate_postalAddressType(self.postalAddress)
        elif nodeName_ == 'phone':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'phone')
            value_ = self.gds_validate_string(value_, node, 'phone')
            self.phone = value_
            self.phone_nsprefix_ = child_.prefix
            # validate type phoneType
            self.validate_phoneType(self.phone)
        elif nodeName_ == 'fax':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'fax')
            value_ = self.gds_validate_string(value_, node, 'fax')
            self.fax = value_
            self.fax_nsprefix_ = child_.prefix
            # validate type phoneType
            self.validate_phoneType(self.fax)
        elif nodeName_ == 'email':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'email')
            value_ = self.gds_validate_string(value_, node, 'email')
            self.email = value_
            self.email_nsprefix_ = child_.prefix
            # validate type emailType
            self.validate_emailType(self.email)
        elif nodeName_ == 'okato':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'okato')
            value_ = self.gds_validate_string(value_, node, 'okato')
            self.okato = value_
            self.okato_nsprefix_ = child_.prefix
            # validate type codeOkatoType
            self.validate_codeOkatoType(self.okato)
        elif nodeName_ == 'okopf':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'okopf')
            value_ = self.gds_validate_string(value_, node, 'okopf')
            self.okopf = value_
            self.okopf_nsprefix_ = child_.prefix
            # validate type codeOkopfType
            self.validate_codeOkopfType(self.okopf)
        elif nodeName_ == 'okopfName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'okopfName')
            value_ = self.gds_validate_string(value_, node, 'okopfName')
            self.okopfName = value_
            self.okopfName_nsprefix_ = child_.prefix
            # validate type okopfNameType
            self.validate_okopfNameType(self.okopfName)
        elif nodeName_ == 'okpo':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'okpo')
            value_ = self.gds_validate_string(value_, node, 'okpo')
            self.okpo = value_
            self.okpo_nsprefix_ = child_.prefix
            # validate type customerCodeOkpoType
            self.validate_customerCodeOkpoType(self.okpo)
        elif nodeName_ == 'customerRegistrationDate':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.customerRegistrationDate = dval_
            self.customerRegistrationDate_nsprefix_ = child_.prefix
        elif nodeName_ == 'timeZone':
            obj_ = timeZoneType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.timeZone = obj_
            obj_.original_tagname_ = 'timeZone'
        elif nodeName_ == 'region':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'region')
            value_ = self.gds_validate_string(value_, node, 'region')
            self.region = value_
            self.region_nsprefix_ = child_.prefix
            # validate type regionType
            self.validate_regionType(self.region)
        elif nodeName_ == 'customerAssessedCompliance':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'customerAssessedCompliance')
            ival_ = self.gds_validate_boolean(ival_, node, 'customerAssessedCompliance')
            self.customerAssessedCompliance = ival_
            self.customerAssessedCompliance_nsprefix_ = child_.prefix
        elif nodeName_ == 'customerMonitoredCompliance':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'customerMonitoredCompliance')
            ival_ = self.gds_validate_boolean(ival_, node, 'customerMonitoredCompliance')
            self.customerMonitoredCompliance = ival_
            self.customerMonitoredCompliance_nsprefix_ = child_.prefix
# end class customerMainInfoType


class customerRegistryInfoType(GeneratedsSuper):
    """Регистрационные данные юридического лица"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'fullName': MemberSpec_('fullName', ['fullNameType63', 'nonEmptyString', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'fullName', 'type': 'xs:string'}, None),
        'ogrn': MemberSpec_('ogrn', ['ogrnType', 'nonEmptyString', 'xs:string'], 0, 0, {'name': 'ogrn', 'type': 'xs:string'}, None),
        'inn': MemberSpec_('inn', ['innType', 'nonEmptyString', 'xs:string'], 0, 0, {'name': 'inn', 'type': 'xs:string'}, None),
        'kpp': MemberSpec_('kpp', ['kppType', 'nonEmptyString', 'xs:string'], 0, 0, {'name': 'kpp', 'type': 'xs:string'}, None),
        'customerRegistrationDate': MemberSpec_('customerRegistrationDate', 'xs:dateTime', 0, 1, {'minOccurs': '0', 'name': 'customerRegistrationDate', 'type': 'xs:dateTime'}, None),
        'legalAddress': MemberSpec_('legalAddress', ['legalAddressType64', 'nonEmptyString', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'legalAddress', 'type': 'xs:string'}, None),
        'website': MemberSpec_('website', ['websiteType65', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'website', 'type': 'xs:string'}, None),
        'iko': MemberSpec_('iko', ['ikoType', 'nonEmptyString', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'iko', 'type': 'xs:string'}, None),
        'createIkoDate': MemberSpec_('createIkoDate', 'xs:dateTime', 0, 1, {'minOccurs': '0', 'name': 'createIkoDate', 'type': 'xs:dateTime'}, None),
        'timeZone': MemberSpec_('timeZone', 'timeZoneType', 0, 1, {'minOccurs': '0', 'name': 'timeZone', 'type': 'timeZoneType'}, None),
        'postalAddress': MemberSpec_('postalAddress', ['postalAddressType66', 'nonEmptyString', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'postalAddress', 'type': 'xs:string'}, None),
        'emailSystem': MemberSpec_('emailSystem', ['emailType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'emailSystem', 'type': 'xs:string'}, None),
        'email': MemberSpec_('email', ['emailType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'email', 'type': 'xs:string'}, None),
        'phone': MemberSpec_('phone', ['phoneType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'phone', 'type': 'xs:string'}, None),
        'fax': MemberSpec_('fax', ['phoneType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'fax', 'type': 'xs:string'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, fullName=None, ogrn=None, inn=None, kpp=None, customerRegistrationDate=None, legalAddress=None, website=None, iko=None, createIkoDate=None, timeZone=None, postalAddress=None, emailSystem=None, email=None, phone=None, fax=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.fullName = fullName
        self.validate_fullNameType63(self.fullName)
        self.fullName_nsprefix_ = None
        self.ogrn = ogrn
        self.validate_ogrnType(self.ogrn)
        self.ogrn_nsprefix_ = None
        self.inn = inn
        self.validate_innType(self.inn)
        self.inn_nsprefix_ = None
        self.kpp = kpp
        self.validate_kppType(self.kpp)
        self.kpp_nsprefix_ = None
        if isinstance(customerRegistrationDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(customerRegistrationDate, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = customerRegistrationDate
        self.customerRegistrationDate = initvalue_
        self.customerRegistrationDate_nsprefix_ = None
        self.legalAddress = legalAddress
        self.validate_legalAddressType64(self.legalAddress)
        self.legalAddress_nsprefix_ = None
        self.website = website
        self.validate_websiteType65(self.website)
        self.website_nsprefix_ = None
        self.iko = iko
        self.validate_ikoType(self.iko)
        self.iko_nsprefix_ = None
        if isinstance(createIkoDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(createIkoDate, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = createIkoDate
        self.createIkoDate = initvalue_
        self.createIkoDate_nsprefix_ = None
        self.timeZone = timeZone
        self.timeZone_nsprefix_ = None
        self.postalAddress = postalAddress
        self.validate_postalAddressType66(self.postalAddress)
        self.postalAddress_nsprefix_ = None
        self.emailSystem = emailSystem
        self.validate_emailType(self.emailSystem)
        self.emailSystem_nsprefix_ = None
        self.email = email
        self.validate_emailType(self.email)
        self.email_nsprefix_ = None
        self.phone = phone
        self.validate_phoneType(self.phone)
        self.phone_nsprefix_ = None
        self.fax = fax
        self.validate_phoneType(self.fax)
        self.fax_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, customerRegistryInfoType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if customerRegistryInfoType.subclass:
            return customerRegistryInfoType.subclass(*args_, **kwargs_)
        else:
            return customerRegistryInfoType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_fullNameType63(self, value):
        result = True
        # Validate type fullNameType63, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on fullNameType63' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on fullNameType63' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_ogrnType(self, value):
        result = True
        # Validate type ogrnType, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ogrnType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_ogrnType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_ogrnType_patterns_, ))
                result = False
        return result
    validate_ogrnType_patterns_ = [['^(\\d{13})$']]
    def validate_innType(self, value):
        result = True
        # Validate type innType, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on innType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_innType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_innType_patterns_, ))
                result = False
        return result
    validate_innType_patterns_ = [['^(\\d{10}|\\d{12})$']]
    def validate_kppType(self, value):
        result = True
        # Validate type kppType, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on kppType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_kppType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_kppType_patterns_, ))
                result = False
        return result
    validate_kppType_patterns_ = [['^(\\d{9})$']]
    def validate_legalAddressType64(self, value):
        result = True
        # Validate type legalAddressType64, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 2000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on legalAddressType64' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on legalAddressType64' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_websiteType65(self, value):
        result = True
        # Validate type websiteType65, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 300:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on websiteType65' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_ikoType(self, value):
        result = True
        # Validate type ikoType, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ikoType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_ikoType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_ikoType_patterns_, ))
                result = False
        return result
    validate_ikoType_patterns_ = [['^(\\d{20}|\\d{22})$']]
    def validate_postalAddressType66(self, value):
        result = True
        # Validate type postalAddressType66, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 2000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on postalAddressType66' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on postalAddressType66' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_emailType(self, value):
        result = True
        # Validate type emailType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 300:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on emailType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on emailType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_emailType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_emailType_patterns_, ))
                result = False
        return result
    validate_emailType_patterns_ = [["^(([\\-a-zA-Zа-яА-Я0-9!#%&'\\*\\+/=\\?\\^_`\\{\\|\\}~]+(\\.[\\-a-zA-Zа-яА-Я0-9!#%&'\\*\\+/=\\?\\^_`\\{\\|\\}~]+)*@([a-zA-Zа-яА-Я0-9]([\\-_a-zA-Zа-яА-Я0-9]{0,61}[a-zA-Zа-яА-Я0-9])?\\.)*[\\-a-zA-Zа-яА-Я0-9]+(\\.[\\-a-zA-Zа-яА-Я0-9]+)*)+(,\\s?[\\-a-zA-Zа-яА-Я0-9!#%&'\\*\\+/=\\?\\^_`\\{\\|\\}~]+(\\.[\\-a-zA-Zа-яА-Я0-9!#%&'\\*\\+/=\\?\\^_`\\{\\|\\}~]+)*@([a-zA-Zа-яА-Я0-9]([\\-_a-zA-Zа-яА-Я0-9]{0,61}[a-zA-Zа-яА-Я0-9])?\\.)*[\\-a-zA-Zа-яА-Я0-9]+(\\.[\\-a-zA-Zа-яА-Я0-9]+)*)*)$"]]
    def validate_phoneType(self, value):
        result = True
        # Validate type phoneType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 300:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on phoneType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on phoneType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.fullName is not None or
            self.ogrn is not None or
            self.inn is not None or
            self.kpp is not None or
            self.customerRegistrationDate is not None or
            self.legalAddress is not None or
            self.website is not None or
            self.iko is not None or
            self.createIkoDate is not None or
            self.timeZone is not None or
            self.postalAddress is not None or
            self.emailSystem is not None or
            self.email is not None or
            self.phone is not None or
            self.fax is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'fullName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'fullName')
            value_ = self.gds_validate_string(value_, node, 'fullName')
            self.fullName = value_
            self.fullName_nsprefix_ = child_.prefix
            # validate type fullNameType63
            self.validate_fullNameType63(self.fullName)
        elif nodeName_ == 'ogrn':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'ogrn')
            value_ = self.gds_validate_string(value_, node, 'ogrn')
            self.ogrn = value_
            self.ogrn_nsprefix_ = child_.prefix
            # validate type ogrnType
            self.validate_ogrnType(self.ogrn)
        elif nodeName_ == 'inn':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'inn')
            value_ = self.gds_validate_string(value_, node, 'inn')
            self.inn = value_
            self.inn_nsprefix_ = child_.prefix
            # validate type innType
            self.validate_innType(self.inn)
        elif nodeName_ == 'kpp':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'kpp')
            value_ = self.gds_validate_string(value_, node, 'kpp')
            self.kpp = value_
            self.kpp_nsprefix_ = child_.prefix
            # validate type kppType
            self.validate_kppType(self.kpp)
        elif nodeName_ == 'customerRegistrationDate':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.customerRegistrationDate = dval_
            self.customerRegistrationDate_nsprefix_ = child_.prefix
        elif nodeName_ == 'legalAddress':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'legalAddress')
            value_ = self.gds_validate_string(value_, node, 'legalAddress')
            self.legalAddress = value_
            self.legalAddress_nsprefix_ = child_.prefix
            # validate type legalAddressType64
            self.validate_legalAddressType64(self.legalAddress)
        elif nodeName_ == 'website':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'website')
            value_ = self.gds_validate_string(value_, node, 'website')
            self.website = value_
            self.website_nsprefix_ = child_.prefix
            # validate type websiteType65
            self.validate_websiteType65(self.website)
        elif nodeName_ == 'iko':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'iko')
            value_ = self.gds_validate_string(value_, node, 'iko')
            self.iko = value_
            self.iko_nsprefix_ = child_.prefix
            # validate type ikoType
            self.validate_ikoType(self.iko)
        elif nodeName_ == 'createIkoDate':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.createIkoDate = dval_
            self.createIkoDate_nsprefix_ = child_.prefix
        elif nodeName_ == 'timeZone':
            obj_ = timeZoneType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.timeZone = obj_
            obj_.original_tagname_ = 'timeZone'
        elif nodeName_ == 'postalAddress':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'postalAddress')
            value_ = self.gds_validate_string(value_, node, 'postalAddress')
            self.postalAddress = value_
            self.postalAddress_nsprefix_ = child_.prefix
            # validate type postalAddressType66
            self.validate_postalAddressType66(self.postalAddress)
        elif nodeName_ == 'emailSystem':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'emailSystem')
            value_ = self.gds_validate_string(value_, node, 'emailSystem')
            self.emailSystem = value_
            self.emailSystem_nsprefix_ = child_.prefix
            # validate type emailType
            self.validate_emailType(self.emailSystem)
        elif nodeName_ == 'email':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'email')
            value_ = self.gds_validate_string(value_, node, 'email')
            self.email = value_
            self.email_nsprefix_ = child_.prefix
            # validate type emailType
            self.validate_emailType(self.email)
        elif nodeName_ == 'phone':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'phone')
            value_ = self.gds_validate_string(value_, node, 'phone')
            self.phone = value_
            self.phone_nsprefix_ = child_.prefix
            # validate type phoneType
            self.validate_phoneType(self.phone)
        elif nodeName_ == 'fax':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'fax')
            value_ = self.gds_validate_string(value_, node, 'fax')
            self.fax = value_
            self.fax_nsprefix_ = child_.prefix
            # validate type phoneType
            self.validate_phoneType(self.fax)
# end class customerRegistryInfoType


class ikulType(GeneratedsSuper):
    """Идентификационные коды юридического лица (ИКЮЛ)"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'ikulCode': MemberSpec_('ikulCode', ['ikulCodeType', 'nonEmptyString', 'xs:string'], 0, 0, {'name': 'ikulCode', 'type': 'xs:string'}, None),
        'ikulName': MemberSpec_('ikulName', ['ikulNameType', 'nonEmptyString', 'xs:string'], 0, 0, {'name': 'ikulName', 'type': 'xs:string'}, None),
        'assignmentDate': MemberSpec_('assignmentDate', 'xs:dateTime', 0, 1, {'minOccurs': '0', 'name': 'assignmentDate', 'type': 'xs:dateTime'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, ikulCode=None, ikulName=None, assignmentDate=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.ikulCode = ikulCode
        self.validate_ikulCodeType(self.ikulCode)
        self.ikulCode_nsprefix_ = None
        self.ikulName = ikulName
        self.validate_ikulNameType(self.ikulName)
        self.ikulName_nsprefix_ = None
        if isinstance(assignmentDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(assignmentDate, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = assignmentDate
        self.assignmentDate = initvalue_
        self.assignmentDate_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ikulType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ikulType.subclass:
            return ikulType.subclass(*args_, **kwargs_)
        else:
            return ikulType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_ikulCodeType(self, value):
        result = True
        # Validate type ikulCodeType, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 100:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ikulCodeType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ikulCodeType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_ikulNameType(self, value):
        result = True
        # Validate type ikulNameType, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 255:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ikulNameType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ikulNameType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.ikulCode is not None or
            self.ikulName is not None or
            self.assignmentDate is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ikulCode':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'ikulCode')
            value_ = self.gds_validate_string(value_, node, 'ikulCode')
            self.ikulCode = value_
            self.ikulCode_nsprefix_ = child_.prefix
            # validate type ikulCodeType
            self.validate_ikulCodeType(self.ikulCode)
        elif nodeName_ == 'ikulName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'ikulName')
            value_ = self.gds_validate_string(value_, node, 'ikulName')
            self.ikulName = value_
            self.ikulName_nsprefix_ = child_.prefix
            # validate type ikulNameType
            self.validate_ikulNameType(self.ikulName)
        elif nodeName_ == 'assignmentDate':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.assignmentDate = dval_
            self.assignmentDate_nsprefix_ = child_.prefix
# end class ikulType


class grantedUserWoAttorneyType(GeneratedsSuper):
    """Информация о лице, имеющем право действовать без доверенности"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'lastName': MemberSpec_('lastName', ['lastNameType67', 'nonEmptyString', 'xs:string'], 0, 0, {'name': 'lastName', 'type': 'xs:string'}, None),
        'firstName': MemberSpec_('firstName', ['firstNameType68', 'nonEmptyString', 'xs:string'], 0, 0, {'name': 'firstName', 'type': 'xs:string'}, None),
        'middleName': MemberSpec_('middleName', ['middleNameType69', 'nonEmptyString', 'xs:string'], 0, 0, {'name': 'middleName', 'type': 'xs:string'}, None),
        'inn': MemberSpec_('inn', ['innType', 'nonEmptyString', 'xs:string'], 0, 0, {'name': 'inn', 'type': 'xs:string'}, None),
        'position': MemberSpec_('position', ['positionType', 'nonEmptyString', 'xs:string'], 0, 0, {'name': 'position', 'type': 'xs:string'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, lastName=None, firstName=None, middleName=None, inn=None, position=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.lastName = lastName
        self.validate_lastNameType67(self.lastName)
        self.lastName_nsprefix_ = None
        self.firstName = firstName
        self.validate_firstNameType68(self.firstName)
        self.firstName_nsprefix_ = None
        self.middleName = middleName
        self.validate_middleNameType69(self.middleName)
        self.middleName_nsprefix_ = None
        self.inn = inn
        self.validate_innType(self.inn)
        self.inn_nsprefix_ = None
        self.position = position
        self.validate_positionType(self.position)
        self.position_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, grantedUserWoAttorneyType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if grantedUserWoAttorneyType.subclass:
            return grantedUserWoAttorneyType.subclass(*args_, **kwargs_)
        else:
            return grantedUserWoAttorneyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_lastNameType67(self, value):
        result = True
        # Validate type lastNameType67, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 100:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on lastNameType67' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on lastNameType67' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_firstNameType68(self, value):
        result = True
        # Validate type firstNameType68, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 100:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on firstNameType68' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on firstNameType68' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_middleNameType69(self, value):
        result = True
        # Validate type middleNameType69, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 100:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on middleNameType69' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on middleNameType69' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_innType(self, value):
        result = True
        # Validate type innType, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on innType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_innType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_innType_patterns_, ))
                result = False
        return result
    validate_innType_patterns_ = [['^(\\d{10}|\\d{12})$']]
    def validate_positionType(self, value):
        result = True
        # Validate type positionType, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 200:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on positionType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on positionType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.lastName is not None or
            self.firstName is not None or
            self.middleName is not None or
            self.inn is not None or
            self.position is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'lastName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'lastName')
            value_ = self.gds_validate_string(value_, node, 'lastName')
            self.lastName = value_
            self.lastName_nsprefix_ = child_.prefix
            # validate type lastNameType67
            self.validate_lastNameType67(self.lastName)
        elif nodeName_ == 'firstName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'firstName')
            value_ = self.gds_validate_string(value_, node, 'firstName')
            self.firstName = value_
            self.firstName_nsprefix_ = child_.prefix
            # validate type firstNameType68
            self.validate_firstNameType68(self.firstName)
        elif nodeName_ == 'middleName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'middleName')
            value_ = self.gds_validate_string(value_, node, 'middleName')
            self.middleName = value_
            self.middleName_nsprefix_ = child_.prefix
            # validate type middleNameType69
            self.validate_middleNameType69(self.middleName)
        elif nodeName_ == 'inn':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'inn')
            value_ = self.gds_validate_string(value_, node, 'inn')
            self.inn = value_
            self.inn_nsprefix_ = child_.prefix
            # validate type innType
            self.validate_innType(self.inn)
        elif nodeName_ == 'position':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'position')
            value_ = self.gds_validate_string(value_, node, 'position')
            self.position = value_
            self.position_nsprefix_ = child_.prefix
            # validate type positionType
            self.validate_positionType(self.position)
# end class grantedUserWoAttorneyType


class capitalStockAgencyType(GeneratedsSuper):
    """Информация о юридических лицах, перечисленных в пунктах 1, 2 части 2
    статьи 1 Федерального закона № 223-ФЗ"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'fullName': MemberSpec_('fullName', ['fullNameType70', 'nonEmptyString', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'fullName', 'type': 'xs:string'}, None),
        'ogrn': MemberSpec_('ogrn', ['ogrnType', 'nonEmptyString', 'xs:string'], 0, 0, {'name': 'ogrn', 'type': 'xs:string'}, None),
        'inn': MemberSpec_('inn', ['innType', 'nonEmptyString', 'xs:string'], 0, 0, {'name': 'inn', 'type': 'xs:string'}, None),
        'kpp': MemberSpec_('kpp', ['kppType', 'nonEmptyString', 'xs:string'], 0, 0, {'name': 'kpp', 'type': 'xs:string'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, fullName=None, ogrn=None, inn=None, kpp=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.fullName = fullName
        self.validate_fullNameType70(self.fullName)
        self.fullName_nsprefix_ = None
        self.ogrn = ogrn
        self.validate_ogrnType(self.ogrn)
        self.ogrn_nsprefix_ = None
        self.inn = inn
        self.validate_innType(self.inn)
        self.inn_nsprefix_ = None
        self.kpp = kpp
        self.validate_kppType(self.kpp)
        self.kpp_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, capitalStockAgencyType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if capitalStockAgencyType.subclass:
            return capitalStockAgencyType.subclass(*args_, **kwargs_)
        else:
            return capitalStockAgencyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_fullNameType70(self, value):
        result = True
        # Validate type fullNameType70, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on fullNameType70' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on fullNameType70' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_ogrnType(self, value):
        result = True
        # Validate type ogrnType, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ogrnType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_ogrnType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_ogrnType_patterns_, ))
                result = False
        return result
    validate_ogrnType_patterns_ = [['^(\\d{13})$']]
    def validate_innType(self, value):
        result = True
        # Validate type innType, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on innType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_innType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_innType_patterns_, ))
                result = False
        return result
    validate_innType_patterns_ = [['^(\\d{10}|\\d{12})$']]
    def validate_kppType(self, value):
        result = True
        # Validate type kppType, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on kppType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_kppType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_kppType_patterns_, ))
                result = False
        return result
    validate_kppType_patterns_ = [['^(\\d{9})$']]
    def hasContent_(self):
        if (
            self.fullName is not None or
            self.ogrn is not None or
            self.inn is not None or
            self.kpp is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'fullName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'fullName')
            value_ = self.gds_validate_string(value_, node, 'fullName')
            self.fullName = value_
            self.fullName_nsprefix_ = child_.prefix
            # validate type fullNameType70
            self.validate_fullNameType70(self.fullName)
        elif nodeName_ == 'ogrn':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'ogrn')
            value_ = self.gds_validate_string(value_, node, 'ogrn')
            self.ogrn = value_
            self.ogrn_nsprefix_ = child_.prefix
            # validate type ogrnType
            self.validate_ogrnType(self.ogrn)
        elif nodeName_ == 'inn':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'inn')
            value_ = self.gds_validate_string(value_, node, 'inn')
            self.inn = value_
            self.inn_nsprefix_ = child_.prefix
            # validate type innType
            self.validate_innType(self.inn)
        elif nodeName_ == 'kpp':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'kpp')
            value_ = self.gds_validate_string(value_, node, 'kpp')
            self.kpp = value_
            self.kpp_nsprefix_ = child_.prefix
            # validate type kppType
            self.validate_kppType(self.kpp)
# end class capitalStockAgencyType


class fz223type(GeneratedsSuper):
    """Тип организации"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'code': MemberSpec_('code', ['nonEmptyString', 'xs:string'], 0, 0, {'name': 'code', 'type': 'xs:string'}, None),
        'name': MemberSpec_('name', ['nonEmptyString', 'xs:string'], 0, 0, {'name': 'name', 'type': 'xs:string'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, code=None, name=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.code = code
        self.validate_nonEmptyString(self.code)
        self.code_nsprefix_ = None
        self.name = name
        self.validate_nonEmptyString(self.name)
        self.name_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, fz223type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if fz223type.subclass:
            return fz223type.subclass(*args_, **kwargs_)
        else:
            return fz223type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_nonEmptyString(self, value):
        result = True
        # Validate type nonEmptyString, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on nonEmptyString' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.code is not None or
            self.name is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'code':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'code')
            value_ = self.gds_validate_string(value_, node, 'code')
            self.code = value_
            self.code_nsprefix_ = child_.prefix
            # validate type nonEmptyString
            self.validate_nonEmptyString(self.code)
        elif nodeName_ == 'name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'name')
            value_ = self.gds_validate_string(value_, node, 'name')
            self.name = value_
            self.name_nsprefix_ = child_.prefix
            # validate type nonEmptyString
            self.validate_nonEmptyString(self.name)
# end class fz223type


class timeZoneType(GeneratedsSuper):
    """Временная зона"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'offset': MemberSpec_('offset', 'xs:int', 0, 0, {'name': 'offset', 'type': 'xs:int'}, None),
        'name': MemberSpec_('name', ['nameType71', 'nonEmptyString', 'xs:string'], 0, 0, {'name': 'name', 'type': 'xs:string'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, offset=None, name=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.offset = offset
        self.offset_nsprefix_ = None
        self.name = name
        self.validate_nameType71(self.name)
        self.name_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, timeZoneType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if timeZoneType.subclass:
            return timeZoneType.subclass(*args_, **kwargs_)
        else:
            return timeZoneType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_nameType71(self, value):
        result = True
        # Validate type nameType71, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 100:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on nameType71' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on nameType71' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.offset is not None or
            self.name is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'offset' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'offset')
            ival_ = self.gds_validate_integer(ival_, node, 'offset')
            self.offset = ival_
            self.offset_nsprefix_ = child_.prefix
        elif nodeName_ == 'name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'name')
            value_ = self.gds_validate_string(value_, node, 'name')
            self.name = value_
            self.name_nsprefix_ = child_.prefix
            # validate type nameType71
            self.validate_nameType71(self.name)
# end class timeZoneType


class customerMainInfo2Type(GeneratedsSuper):
    """Основная информация об организации - обособленном подразделении"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'fullName': MemberSpec_('fullName', ['fullNameType72', 'nonEmptyString', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'fullName', 'type': 'xs:string'}, None),
        'shortName': MemberSpec_('shortName', ['shortNameType73', 'nonEmptyString', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'shortName', 'type': 'xs:string'}, None),
        'detachedFullName': MemberSpec_('detachedFullName', ['detachedFullNameType', 'nonEmptyString', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'detachedFullName', 'type': 'xs:string'}, None),
        'detachedShortName': MemberSpec_('detachedShortName', ['detachedShortNameType', 'nonEmptyString', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'detachedShortName', 'type': 'xs:string'}, None),
        'inn': MemberSpec_('inn', ['innType', 'nonEmptyString', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'inn', 'type': 'xs:string'}, None),
        'kpp': MemberSpec_('kpp', ['kppType', 'nonEmptyString', 'xs:string'], 0, 0, {'name': 'kpp', 'type': 'xs:string'}, None),
        'ogrn': MemberSpec_('ogrn', ['ogrnType', 'nonEmptyString', 'xs:string'], 0, 0, {'name': 'ogrn', 'type': 'xs:string'}, None),
        'legalAddress': MemberSpec_('legalAddress', ['legalAddressType74', 'nonEmptyString', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'legalAddress', 'type': 'xs:string'}, None),
        'postalAddress': MemberSpec_('postalAddress', ['postalAddressType75', 'nonEmptyString', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'postalAddress', 'type': 'xs:string'}, None),
        'innovVolumeChecked': MemberSpec_('innovVolumeChecked', ['innovVolumeChecked', 'xs:boolean'], 0, 1, {'minOccurs': '0', 'name': 'innovVolumeChecked', 'type': 'xs:boolean'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, fullName=None, shortName=None, detachedFullName=None, detachedShortName=None, inn=None, kpp=None, ogrn=None, legalAddress=None, postalAddress=None, innovVolumeChecked=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.fullName = fullName
        self.validate_fullNameType72(self.fullName)
        self.fullName_nsprefix_ = None
        self.shortName = shortName
        self.validate_shortNameType73(self.shortName)
        self.shortName_nsprefix_ = None
        self.detachedFullName = detachedFullName
        self.validate_detachedFullNameType(self.detachedFullName)
        self.detachedFullName_nsprefix_ = None
        self.detachedShortName = detachedShortName
        self.validate_detachedShortNameType(self.detachedShortName)
        self.detachedShortName_nsprefix_ = None
        self.inn = inn
        self.validate_innType(self.inn)
        self.inn_nsprefix_ = None
        self.kpp = kpp
        self.validate_kppType(self.kpp)
        self.kpp_nsprefix_ = None
        self.ogrn = ogrn
        self.validate_ogrnType(self.ogrn)
        self.ogrn_nsprefix_ = None
        self.legalAddress = legalAddress
        self.validate_legalAddressType74(self.legalAddress)
        self.legalAddress_nsprefix_ = None
        self.postalAddress = postalAddress
        self.validate_postalAddressType75(self.postalAddress)
        self.postalAddress_nsprefix_ = None
        self.innovVolumeChecked = innovVolumeChecked
        self.validate_innovVolumeChecked(self.innovVolumeChecked)
        self.innovVolumeChecked_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, customerMainInfo2Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if customerMainInfo2Type.subclass:
            return customerMainInfo2Type.subclass(*args_, **kwargs_)
        else:
            return customerMainInfo2Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_fullNameType72(self, value):
        result = True
        # Validate type fullNameType72, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on fullNameType72' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on fullNameType72' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_shortNameType73(self, value):
        result = True
        # Validate type shortNameType73, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 500:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on shortNameType73' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on shortNameType73' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_detachedFullNameType(self, value):
        result = True
        # Validate type detachedFullNameType, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on detachedFullNameType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on detachedFullNameType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_detachedShortNameType(self, value):
        result = True
        # Validate type detachedShortNameType, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 500:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on detachedShortNameType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on detachedShortNameType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_innType(self, value):
        result = True
        # Validate type innType, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on innType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_innType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_innType_patterns_, ))
                result = False
        return result
    validate_innType_patterns_ = [['^(\\d{10}|\\d{12})$']]
    def validate_kppType(self, value):
        result = True
        # Validate type kppType, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on kppType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_kppType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_kppType_patterns_, ))
                result = False
        return result
    validate_kppType_patterns_ = [['^(\\d{9})$']]
    def validate_ogrnType(self, value):
        result = True
        # Validate type ogrnType, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ogrnType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_ogrnType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_ogrnType_patterns_, ))
                result = False
        return result
    validate_ogrnType_patterns_ = [['^(\\d{13})$']]
    def validate_legalAddressType74(self, value):
        result = True
        # Validate type legalAddressType74, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 2000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on legalAddressType74' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on legalAddressType74' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_postalAddressType75(self, value):
        result = True
        # Validate type postalAddressType75, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 2000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on postalAddressType75' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on postalAddressType75' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_innovVolumeChecked(self, value):
        result = True
        # Validate type innovVolumeChecked, a restriction on xs:boolean.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            pass
        return result
    def hasContent_(self):
        if (
            self.fullName is not None or
            self.shortName is not None or
            self.detachedFullName is not None or
            self.detachedShortName is not None or
            self.inn is not None or
            self.kpp is not None or
            self.ogrn is not None or
            self.legalAddress is not None or
            self.postalAddress is not None or
            self.innovVolumeChecked is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'fullName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'fullName')
            value_ = self.gds_validate_string(value_, node, 'fullName')
            self.fullName = value_
            self.fullName_nsprefix_ = child_.prefix
            # validate type fullNameType72
            self.validate_fullNameType72(self.fullName)
        elif nodeName_ == 'shortName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'shortName')
            value_ = self.gds_validate_string(value_, node, 'shortName')
            self.shortName = value_
            self.shortName_nsprefix_ = child_.prefix
            # validate type shortNameType73
            self.validate_shortNameType73(self.shortName)
        elif nodeName_ == 'detachedFullName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'detachedFullName')
            value_ = self.gds_validate_string(value_, node, 'detachedFullName')
            self.detachedFullName = value_
            self.detachedFullName_nsprefix_ = child_.prefix
            # validate type detachedFullNameType
            self.validate_detachedFullNameType(self.detachedFullName)
        elif nodeName_ == 'detachedShortName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'detachedShortName')
            value_ = self.gds_validate_string(value_, node, 'detachedShortName')
            self.detachedShortName = value_
            self.detachedShortName_nsprefix_ = child_.prefix
            # validate type detachedShortNameType
            self.validate_detachedShortNameType(self.detachedShortName)
        elif nodeName_ == 'inn':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'inn')
            value_ = self.gds_validate_string(value_, node, 'inn')
            self.inn = value_
            self.inn_nsprefix_ = child_.prefix
            # validate type innType
            self.validate_innType(self.inn)
        elif nodeName_ == 'kpp':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'kpp')
            value_ = self.gds_validate_string(value_, node, 'kpp')
            self.kpp = value_
            self.kpp_nsprefix_ = child_.prefix
            # validate type kppType
            self.validate_kppType(self.kpp)
        elif nodeName_ == 'ogrn':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'ogrn')
            value_ = self.gds_validate_string(value_, node, 'ogrn')
            self.ogrn = value_
            self.ogrn_nsprefix_ = child_.prefix
            # validate type ogrnType
            self.validate_ogrnType(self.ogrn)
        elif nodeName_ == 'legalAddress':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'legalAddress')
            value_ = self.gds_validate_string(value_, node, 'legalAddress')
            self.legalAddress = value_
            self.legalAddress_nsprefix_ = child_.prefix
            # validate type legalAddressType74
            self.validate_legalAddressType74(self.legalAddress)
        elif nodeName_ == 'postalAddress':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'postalAddress')
            value_ = self.gds_validate_string(value_, node, 'postalAddress')
            self.postalAddress = value_
            self.postalAddress_nsprefix_ = child_.prefix
            # validate type postalAddressType75
            self.validate_postalAddressType75(self.postalAddress)
        elif nodeName_ == 'innovVolumeChecked':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'innovVolumeChecked')
            ival_ = self.gds_validate_boolean(ival_, node, 'innovVolumeChecked')
            self.innovVolumeChecked = ival_
            self.innovVolumeChecked_nsprefix_ = child_.prefix
            # validate type innovVolumeChecked
            self.validate_innovVolumeChecked(self.innovVolumeChecked)
# end class customerMainInfo2Type


class customerMainInfo3Type(GeneratedsSuper):
    """Основная информация об организации - обособленном подразделении"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'fullName': MemberSpec_('fullName', ['fullNameType76', 'nonEmptyString', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'fullName', 'type': 'xs:string'}, None),
        'shortName': MemberSpec_('shortName', ['shortNameType77', 'nonEmptyString', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'shortName', 'type': 'xs:string'}, None),
        'detachedFullName': MemberSpec_('detachedFullName', ['detachedFullNameType78', 'nonEmptyString', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'detachedFullName', 'type': 'xs:string'}, None),
        'detachedShortName': MemberSpec_('detachedShortName', ['detachedShortNameType79', 'nonEmptyString', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'detachedShortName', 'type': 'xs:string'}, None),
        'inn': MemberSpec_('inn', ['innType', 'nonEmptyString', 'xs:string'], 0, 0, {'name': 'inn', 'type': 'xs:string'}, None),
        'kpp': MemberSpec_('kpp', ['kppType', 'nonEmptyString', 'xs:string'], 0, 0, {'name': 'kpp', 'type': 'xs:string'}, None),
        'ogrn': MemberSpec_('ogrn', ['ogrnType', 'nonEmptyString', 'xs:string'], 0, 0, {'name': 'ogrn', 'type': 'xs:string'}, None),
        'legalAddress': MemberSpec_('legalAddress', ['legalAddressType80', 'nonEmptyString', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'legalAddress', 'type': 'xs:string'}, None),
        'postalAddress': MemberSpec_('postalAddress', ['postalAddressType81', 'nonEmptyString', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'postalAddress', 'type': 'xs:string'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, fullName=None, shortName=None, detachedFullName=None, detachedShortName=None, inn=None, kpp=None, ogrn=None, legalAddress=None, postalAddress=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.fullName = fullName
        self.validate_fullNameType76(self.fullName)
        self.fullName_nsprefix_ = None
        self.shortName = shortName
        self.validate_shortNameType77(self.shortName)
        self.shortName_nsprefix_ = None
        self.detachedFullName = detachedFullName
        self.validate_detachedFullNameType78(self.detachedFullName)
        self.detachedFullName_nsprefix_ = None
        self.detachedShortName = detachedShortName
        self.validate_detachedShortNameType79(self.detachedShortName)
        self.detachedShortName_nsprefix_ = None
        self.inn = inn
        self.validate_innType(self.inn)
        self.inn_nsprefix_ = None
        self.kpp = kpp
        self.validate_kppType(self.kpp)
        self.kpp_nsprefix_ = None
        self.ogrn = ogrn
        self.validate_ogrnType(self.ogrn)
        self.ogrn_nsprefix_ = None
        self.legalAddress = legalAddress
        self.validate_legalAddressType80(self.legalAddress)
        self.legalAddress_nsprefix_ = None
        self.postalAddress = postalAddress
        self.validate_postalAddressType81(self.postalAddress)
        self.postalAddress_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, customerMainInfo3Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if customerMainInfo3Type.subclass:
            return customerMainInfo3Type.subclass(*args_, **kwargs_)
        else:
            return customerMainInfo3Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_fullNameType76(self, value):
        result = True
        # Validate type fullNameType76, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on fullNameType76' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on fullNameType76' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_shortNameType77(self, value):
        result = True
        # Validate type shortNameType77, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 500:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on shortNameType77' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on shortNameType77' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_detachedFullNameType78(self, value):
        result = True
        # Validate type detachedFullNameType78, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on detachedFullNameType78' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on detachedFullNameType78' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_detachedShortNameType79(self, value):
        result = True
        # Validate type detachedShortNameType79, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 500:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on detachedShortNameType79' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on detachedShortNameType79' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_innType(self, value):
        result = True
        # Validate type innType, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on innType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_innType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_innType_patterns_, ))
                result = False
        return result
    validate_innType_patterns_ = [['^(\\d{10}|\\d{12})$']]
    def validate_kppType(self, value):
        result = True
        # Validate type kppType, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on kppType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_kppType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_kppType_patterns_, ))
                result = False
        return result
    validate_kppType_patterns_ = [['^(\\d{9})$']]
    def validate_ogrnType(self, value):
        result = True
        # Validate type ogrnType, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ogrnType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_ogrnType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_ogrnType_patterns_, ))
                result = False
        return result
    validate_ogrnType_patterns_ = [['^(\\d{13})$']]
    def validate_legalAddressType80(self, value):
        result = True
        # Validate type legalAddressType80, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 2000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on legalAddressType80' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on legalAddressType80' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_postalAddressType81(self, value):
        result = True
        # Validate type postalAddressType81, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 2000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on postalAddressType81' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on postalAddressType81' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.fullName is not None or
            self.shortName is not None or
            self.detachedFullName is not None or
            self.detachedShortName is not None or
            self.inn is not None or
            self.kpp is not None or
            self.ogrn is not None or
            self.legalAddress is not None or
            self.postalAddress is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'fullName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'fullName')
            value_ = self.gds_validate_string(value_, node, 'fullName')
            self.fullName = value_
            self.fullName_nsprefix_ = child_.prefix
            # validate type fullNameType76
            self.validate_fullNameType76(self.fullName)
        elif nodeName_ == 'shortName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'shortName')
            value_ = self.gds_validate_string(value_, node, 'shortName')
            self.shortName = value_
            self.shortName_nsprefix_ = child_.prefix
            # validate type shortNameType77
            self.validate_shortNameType77(self.shortName)
        elif nodeName_ == 'detachedFullName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'detachedFullName')
            value_ = self.gds_validate_string(value_, node, 'detachedFullName')
            self.detachedFullName = value_
            self.detachedFullName_nsprefix_ = child_.prefix
            # validate type detachedFullNameType78
            self.validate_detachedFullNameType78(self.detachedFullName)
        elif nodeName_ == 'detachedShortName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'detachedShortName')
            value_ = self.gds_validate_string(value_, node, 'detachedShortName')
            self.detachedShortName = value_
            self.detachedShortName_nsprefix_ = child_.prefix
            # validate type detachedShortNameType79
            self.validate_detachedShortNameType79(self.detachedShortName)
        elif nodeName_ == 'inn':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'inn')
            value_ = self.gds_validate_string(value_, node, 'inn')
            self.inn = value_
            self.inn_nsprefix_ = child_.prefix
            # validate type innType
            self.validate_innType(self.inn)
        elif nodeName_ == 'kpp':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'kpp')
            value_ = self.gds_validate_string(value_, node, 'kpp')
            self.kpp = value_
            self.kpp_nsprefix_ = child_.prefix
            # validate type kppType
            self.validate_kppType(self.kpp)
        elif nodeName_ == 'ogrn':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'ogrn')
            value_ = self.gds_validate_string(value_, node, 'ogrn')
            self.ogrn = value_
            self.ogrn_nsprefix_ = child_.prefix
            # validate type ogrnType
            self.validate_ogrnType(self.ogrn)
        elif nodeName_ == 'legalAddress':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'legalAddress')
            value_ = self.gds_validate_string(value_, node, 'legalAddress')
            self.legalAddress = value_
            self.legalAddress_nsprefix_ = child_.prefix
            # validate type legalAddressType80
            self.validate_legalAddressType80(self.legalAddress)
        elif nodeName_ == 'postalAddress':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'postalAddress')
            value_ = self.gds_validate_string(value_, node, 'postalAddress')
            self.postalAddress = value_
            self.postalAddress_nsprefix_ = child_.prefix
            # validate type postalAddressType81
            self.validate_postalAddressType81(self.postalAddress)
# end class customerMainInfo3Type


class docDeliveryInfoType(GeneratedsSuper):
    """Информация о предоставлении документации"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'deliveryStartDateTime': MemberSpec_('deliveryStartDateTime', 'xs:date', 0, 0, {'name': 'deliveryStartDateTime', 'type': 'xs:date'}, None),
        'deliveryEndDateTime': MemberSpec_('deliveryEndDateTime', 'xs:date', 0, 0, {'name': 'deliveryEndDateTime', 'type': 'xs:date'}, None),
        'place': MemberSpec_('place', ['placeType', 'nonEmptyString', 'xs:string'], 0, 0, {'name': 'place', 'type': 'xs:string'}, None),
        'procedure': MemberSpec_('procedure', ['procedureType', 'nonEmptyString', 'xs:string'], 0, 0, {'name': 'procedure', 'type': 'xs:string'}, None),
        'payment': MemberSpec_('payment', 'docDeliveryPaymentType', 0, 1, {'minOccurs': '0', 'name': 'payment', 'type': 'docDeliveryPaymentType'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, deliveryStartDateTime=None, deliveryEndDateTime=None, place=None, procedure=None, payment=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if isinstance(deliveryStartDateTime, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(deliveryStartDateTime, '%Y-%m-%d').date()
        else:
            initvalue_ = deliveryStartDateTime
        self.deliveryStartDateTime = initvalue_
        self.deliveryStartDateTime_nsprefix_ = None
        if isinstance(deliveryEndDateTime, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(deliveryEndDateTime, '%Y-%m-%d').date()
        else:
            initvalue_ = deliveryEndDateTime
        self.deliveryEndDateTime = initvalue_
        self.deliveryEndDateTime_nsprefix_ = None
        self.place = place
        self.validate_placeType(self.place)
        self.place_nsprefix_ = None
        self.procedure = procedure
        self.validate_procedureType(self.procedure)
        self.procedure_nsprefix_ = None
        self.payment = payment
        self.payment_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, docDeliveryInfoType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if docDeliveryInfoType.subclass:
            return docDeliveryInfoType.subclass(*args_, **kwargs_)
        else:
            return docDeliveryInfoType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_placeType(self, value):
        result = True
        # Validate type placeType, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 2000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on placeType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on placeType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_procedureType(self, value):
        result = True
        # Validate type procedureType, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 2000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on procedureType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on procedureType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.deliveryStartDateTime is not None or
            self.deliveryEndDateTime is not None or
            self.place is not None or
            self.procedure is not None or
            self.payment is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'deliveryStartDateTime':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.deliveryStartDateTime = dval_
            self.deliveryStartDateTime_nsprefix_ = child_.prefix
        elif nodeName_ == 'deliveryEndDateTime':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.deliveryEndDateTime = dval_
            self.deliveryEndDateTime_nsprefix_ = child_.prefix
        elif nodeName_ == 'place':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'place')
            value_ = self.gds_validate_string(value_, node, 'place')
            self.place = value_
            self.place_nsprefix_ = child_.prefix
            # validate type placeType
            self.validate_placeType(self.place)
        elif nodeName_ == 'procedure':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'procedure')
            value_ = self.gds_validate_string(value_, node, 'procedure')
            self.procedure = value_
            self.procedure_nsprefix_ = child_.prefix
            # validate type procedureType
            self.validate_procedureType(self.procedure)
        elif nodeName_ == 'payment':
            obj_ = docDeliveryPaymentType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.payment = obj_
            obj_.original_tagname_ = 'payment'
# end class docDeliveryInfoType


class docDeliveryPaymentType(GeneratedsSuper):
    """Информация об оплате за предоставление информации"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'currency': MemberSpec_('currency', 'currencyType', 0, 0, {'name': 'currency', 'type': 'currencyType'}, None),
        'sum': MemberSpec_('sum', ['money2', 'xs:decimal'], 0, 0, {'name': 'sum', 'type': 'xs:decimal'}, None),
        'procedure': MemberSpec_('procedure', ['procedureType82', 'nonEmptyString', 'xs:string'], 0, 0, {'name': 'procedure', 'type': 'xs:string'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, currency=None, sum=None, procedure=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.currency = currency
        self.currency_nsprefix_ = None
        self.sum = sum
        self.validate_money2(self.sum)
        self.sum_nsprefix_ = None
        self.procedure = procedure
        self.validate_procedureType82(self.procedure)
        self.procedure_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, docDeliveryPaymentType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if docDeliveryPaymentType.subclass:
            return docDeliveryPaymentType.subclass(*args_, **kwargs_)
        else:
            return docDeliveryPaymentType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_money2(self, value):
        result = True
        # Validate type money2, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, decimal_.Decimal):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (decimal_.Decimal)' % {"value": value, "lineno": lineno, })
                return False
            if len(str(value)) >= 20:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd totalDigits restriction on money2' % {"value": value, "lineno": lineno} )
                result = False
        return result
    def validate_procedureType82(self, value):
        result = True
        # Validate type procedureType82, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 2000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on procedureType82' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on procedureType82' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.currency is not None or
            self.sum is not None or
            self.procedure is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'currency':
            obj_ = currencyType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.currency = obj_
            obj_.original_tagname_ = 'currency'
        elif nodeName_ == 'sum' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'sum')
            fval_ = self.gds_validate_decimal(fval_, node, 'sum')
            self.sum = fval_
            self.sum_nsprefix_ = child_.prefix
            # validate type money2
            self.validate_money2(self.sum)
        elif nodeName_ == 'procedure':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'procedure')
            value_ = self.gds_validate_string(value_, node, 'procedure')
            self.procedure = value_
            self.procedure_nsprefix_ = child_.prefix
            # validate type procedureType82
            self.validate_procedureType82(self.procedure)
# end class docDeliveryPaymentType


class documentListType(GeneratedsSuper):
    """Прикрепленные документы"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'totalDocumentsCount': MemberSpec_('totalDocumentsCount', 'xs:positiveInteger', 0, 1, {'minOccurs': '0', 'name': 'totalDocumentsCount', 'type': 'xs:positiveInteger'}, None),
        'additionalDocumentsCount': MemberSpec_('additionalDocumentsCount', 'xs:nonNegativeInteger', 0, 1, {'minOccurs': '0', 'name': 'additionalDocumentsCount', 'type': 'xs:nonNegativeInteger'}, None),
        'prevDocument': MemberSpec_('prevDocument', 'prevDocumentType', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'prevDocument', 'type': 'prevDocumentType'}, None),
        'document': MemberSpec_('document', 'documentType', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'document', 'type': 'documentType'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, totalDocumentsCount=None, additionalDocumentsCount=None, prevDocument=None, document=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.totalDocumentsCount = totalDocumentsCount
        self.totalDocumentsCount_nsprefix_ = None
        self.additionalDocumentsCount = additionalDocumentsCount
        self.additionalDocumentsCount_nsprefix_ = None
        if prevDocument is None:
            self.prevDocument = []
        else:
            self.prevDocument = prevDocument
        self.prevDocument_nsprefix_ = None
        if document is None:
            self.document = []
        else:
            self.document = document
        self.document_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, documentListType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if documentListType.subclass:
            return documentListType.subclass(*args_, **kwargs_)
        else:
            return documentListType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.totalDocumentsCount is not None or
            self.additionalDocumentsCount is not None or
            self.prevDocument or
            self.document
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'totalDocumentsCount' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'totalDocumentsCount')
            if ival_ <= 0:
                raise_parse_error(child_, 'requires positiveInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'totalDocumentsCount')
            self.totalDocumentsCount = ival_
            self.totalDocumentsCount_nsprefix_ = child_.prefix
        elif nodeName_ == 'additionalDocumentsCount' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'additionalDocumentsCount')
            if ival_ < 0:
                raise_parse_error(child_, 'requires nonNegativeInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'additionalDocumentsCount')
            self.additionalDocumentsCount = ival_
            self.additionalDocumentsCount_nsprefix_ = child_.prefix
        elif nodeName_ == 'prevDocument':
            obj_ = prevDocumentType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.prevDocument.append(obj_)
            obj_.original_tagname_ = 'prevDocument'
        elif nodeName_ == 'document':
            obj_ = documentType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.document.append(obj_)
            obj_.original_tagname_ = 'document'
# end class documentListType


class documentType(GeneratedsSuper):
    """Прикрепленный к сведениям документ"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'guid': MemberSpec_('guid', ['guidType', 'xs:string'], 0, 0, {'name': 'guid', 'type': 'xs:string'}, None),
        'createDateTime': MemberSpec_('createDateTime', 'xs:dateTime', 0, 1, {'minOccurs': '0', 'name': 'createDateTime', 'type': 'xs:dateTime'}, None),
        'fileName': MemberSpec_('fileName', ['fileNameType', 'nonEmptyString', 'xs:string'], 0, 0, {'name': 'fileName', 'type': 'xs:string'}, None),
        'description': MemberSpec_('description', ['descriptionType', 'nonEmptyString', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'description', 'type': 'xs:string'}, None),
        'content': MemberSpec_('content', 'xs:base64Binary', 0, 0, {'name': 'content', 'type': 'xs:base64Binary'}, 5),
        'url': MemberSpec_('url', ['nonEmptyString', 'xs:string'], 0, 0, {'name': 'url', 'type': 'xs:string'}, 5),
        'registrationNumber': MemberSpec_('registrationNumber', ['registrationNumber23Type', 'nonEmptyString', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'registrationNumber', 'type': 'xs:string'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, guid=None, createDateTime=None, fileName=None, description=None, content=None, url=None, registrationNumber=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.guid = guid
        self.validate_guidType(self.guid)
        self.guid_nsprefix_ = None
        if isinstance(createDateTime, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(createDateTime, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = createDateTime
        self.createDateTime = initvalue_
        self.createDateTime_nsprefix_ = None
        self.fileName = fileName
        self.validate_fileNameType(self.fileName)
        self.fileName_nsprefix_ = None
        self.description = description
        self.validate_descriptionType(self.description)
        self.description_nsprefix_ = None
        self.content = content
        self.content_nsprefix_ = None
        self.url = url
        self.validate_nonEmptyString(self.url)
        self.url_nsprefix_ = None
        self.registrationNumber = registrationNumber
        self.validate_registrationNumber23Type(self.registrationNumber)
        self.registrationNumber_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, documentType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if documentType.subclass:
            return documentType.subclass(*args_, **kwargs_)
        else:
            return documentType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_guidType(self, value):
        result = True
        # Validate type guidType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) != 36:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd length restriction on guidType' % {"value": encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_guidType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_guidType_patterns_, ))
                result = False
        return result
    validate_guidType_patterns_ = [['^([a-fA-F0-9]{8}\\-[a-fA-F0-9]{4}\\-[a-fA-F0-9]{4}\\-[a-fA-F0-9]{4}\\-[a-fA-F0-9]{12})$']]
    def validate_fileNameType(self, value):
        result = True
        # Validate type fileNameType, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 255:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on fileNameType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on fileNameType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_descriptionType(self, value):
        result = True
        # Validate type descriptionType, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 2000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on descriptionType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on descriptionType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_nonEmptyString(self, value):
        result = True
        # Validate type nonEmptyString, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on nonEmptyString' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_registrationNumber23Type(self, value):
        result = True
        # Validate type registrationNumber23Type, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on registrationNumber23Type' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_registrationNumber23Type_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_registrationNumber23Type_patterns_, ))
                result = False
        return result
    validate_registrationNumber23Type_patterns_ = [['^(\\d{23})$']]
    def hasContent_(self):
        if (
            self.guid is not None or
            self.createDateTime is not None or
            self.fileName is not None or
            self.description is not None or
            self.content is not None or
            self.url is not None or
            self.registrationNumber is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'guid':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'guid')
            value_ = self.gds_validate_string(value_, node, 'guid')
            self.guid = value_
            self.guid_nsprefix_ = child_.prefix
            # validate type guidType
            self.validate_guidType(self.guid)
        elif nodeName_ == 'createDateTime':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.createDateTime = dval_
            self.createDateTime_nsprefix_ = child_.prefix
        elif nodeName_ == 'fileName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'fileName')
            value_ = self.gds_validate_string(value_, node, 'fileName')
            self.fileName = value_
            self.fileName_nsprefix_ = child_.prefix
            # validate type fileNameType
            self.validate_fileNameType(self.fileName)
        elif nodeName_ == 'description':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'description')
            value_ = self.gds_validate_string(value_, node, 'description')
            self.description = value_
            self.description_nsprefix_ = child_.prefix
            # validate type descriptionType
            self.validate_descriptionType(self.description)
        elif nodeName_ == 'content':
            sval_ = child_.text
            if sval_ is not None:
                try:
                    bval_ = base64.b64decode(sval_)
                except (TypeError, ValueError) as exp:
                    raise_parse_error(child_, 'requires base64 encoded string: %s' % exp)
                bval_ = self.gds_validate_base64(bval_, node, 'content')
            else:
                bval_ = None
            self.content = bval_
            self.content_nsprefix_ = child_.prefix
        elif nodeName_ == 'url':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'url')
            value_ = self.gds_validate_string(value_, node, 'url')
            self.url = value_
            self.url_nsprefix_ = child_.prefix
            # validate type nonEmptyString
            self.validate_nonEmptyString(self.url)
        elif nodeName_ == 'registrationNumber':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'registrationNumber')
            value_ = self.gds_validate_string(value_, node, 'registrationNumber')
            self.registrationNumber = value_
            self.registrationNumber_nsprefix_ = child_.prefix
            # validate type registrationNumber23Type
            self.validate_registrationNumber23Type(self.registrationNumber)
# end class documentType


class electronicPlaceInfoType(GeneratedsSuper):
    """Информация о ЭТП"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'name': MemberSpec_('name', ['nameType83', 'nonEmptyString', 'xs:string'], 0, 0, {'name': 'name', 'type': 'xs:string'}, None),
        'url': MemberSpec_('url', ['urlType', 'nonEmptyString', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'url', 'type': 'xs:string'}, None),
        'electronicPlaceId': MemberSpec_('electronicPlaceId', 'xs:long', 0, 0, {'name': 'electronicPlaceId', 'type': 'xs:long'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, name=None, url=None, electronicPlaceId=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.name = name
        self.validate_nameType83(self.name)
        self.name_nsprefix_ = None
        self.url = url
        self.validate_urlType(self.url)
        self.url_nsprefix_ = None
        self.electronicPlaceId = electronicPlaceId
        self.electronicPlaceId_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, electronicPlaceInfoType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if electronicPlaceInfoType.subclass:
            return electronicPlaceInfoType.subclass(*args_, **kwargs_)
        else:
            return electronicPlaceInfoType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_nameType83(self, value):
        result = True
        # Validate type nameType83, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on nameType83' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on nameType83' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_urlType(self, value):
        result = True
        # Validate type urlType, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on urlType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on urlType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.name is not None or
            self.url is not None or
            self.electronicPlaceId is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'name')
            value_ = self.gds_validate_string(value_, node, 'name')
            self.name = value_
            self.name_nsprefix_ = child_.prefix
            # validate type nameType83
            self.validate_nameType83(self.name)
        elif nodeName_ == 'url':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'url')
            value_ = self.gds_validate_string(value_, node, 'url')
            self.url = value_
            self.url_nsprefix_ = child_.prefix
            # validate type urlType
            self.validate_urlType(self.url)
        elif nodeName_ == 'electronicPlaceId' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'electronicPlaceId')
            ival_ = self.gds_validate_integer(ival_, node, 'electronicPlaceId')
            self.electronicPlaceId = ival_
            self.electronicPlaceId_nsprefix_ = child_.prefix
# end class electronicPlaceInfoType


class headerType(GeneratedsSuper):
    """Заголовок информационного пакета"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'guid': MemberSpec_('guid', ['guidType', 'xs:string'], 0, 0, {'name': 'guid', 'type': 'xs:string'}, None),
        'createDateTime': MemberSpec_('createDateTime', 'xs:dateTime', 0, 0, {'name': 'createDateTime', 'type': 'xs:dateTime'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, guid=None, createDateTime=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.guid = guid
        self.validate_guidType(self.guid)
        self.guid_nsprefix_ = None
        if isinstance(createDateTime, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(createDateTime, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = createDateTime
        self.createDateTime = initvalue_
        self.createDateTime_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, headerType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if headerType.subclass:
            return headerType.subclass(*args_, **kwargs_)
        else:
            return headerType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_guidType(self, value):
        result = True
        # Validate type guidType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) != 36:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd length restriction on guidType' % {"value": encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_guidType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_guidType_patterns_, ))
                result = False
        return result
    validate_guidType_patterns_ = [['^([a-fA-F0-9]{8}\\-[a-fA-F0-9]{4}\\-[a-fA-F0-9]{4}\\-[a-fA-F0-9]{4}\\-[a-fA-F0-9]{12})$']]
    def hasContent_(self):
        if (
            self.guid is not None or
            self.createDateTime is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'guid':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'guid')
            value_ = self.gds_validate_string(value_, node, 'guid')
            self.guid = value_
            self.guid_nsprefix_ = child_.prefix
            # validate type guidType
            self.validate_guidType(self.guid)
        elif nodeName_ == 'createDateTime':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.createDateTime = dval_
            self.createDateTime_nsprefix_ = child_.prefix
# end class headerType


class itemResultListType(GeneratedsSuper):
    """Результат обработки позиции"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'itemResult': MemberSpec_('itemResult', 'itemResultType', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'itemResult', 'type': 'itemResultType'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, itemResult=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if itemResult is None:
            self.itemResult = []
        else:
            self.itemResult = itemResult
        self.itemResult_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, itemResultListType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if itemResultListType.subclass:
            return itemResultListType.subclass(*args_, **kwargs_)
        else:
            return itemResultListType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.itemResult
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'itemResult':
            obj_ = itemResultType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.itemResult.append(obj_)
            obj_.original_tagname_ = 'itemResult'
# end class itemResultListType


class itemResultType(GeneratedsSuper):
    """Результат обработки позиции"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'refguid': MemberSpec_('refguid', ['guidType', 'xs:string'], 0, 0, {'name': 'refguid', 'type': 'xs:string'}, None),
        'entityGuid': MemberSpec_('entityGuid', ['guidType', 'xs:string'], 0, 0, {'name': 'entityGuid', 'type': 'xs:string'}, None),
        'result': MemberSpec_('result', ['resultType', 'xs:string'], 0, 0, {'name': 'result', 'type': 'xs:string'}, None),
        'violations': MemberSpec_('violations', 'violationListType', 0, 1, {'minOccurs': '0', 'name': 'violations', 'type': 'violationListType'}, None),
        'url': MemberSpec_('url', ['nonEmptyString', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'url', 'type': 'xs:string'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, refguid=None, entityGuid=None, result=None, violations=None, url=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.refguid = refguid
        self.validate_guidType(self.refguid)
        self.refguid_nsprefix_ = None
        self.entityGuid = entityGuid
        self.validate_guidType(self.entityGuid)
        self.entityGuid_nsprefix_ = None
        self.result = result
        self.validate_resultType(self.result)
        self.result_nsprefix_ = None
        self.violations = violations
        self.violations_nsprefix_ = None
        self.url = url
        self.validate_nonEmptyString(self.url)
        self.url_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, itemResultType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if itemResultType.subclass:
            return itemResultType.subclass(*args_, **kwargs_)
        else:
            return itemResultType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_guidType(self, value):
        result = True
        # Validate type guidType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) != 36:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd length restriction on guidType' % {"value": encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_guidType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_guidType_patterns_, ))
                result = False
        return result
    validate_guidType_patterns_ = [['^([a-fA-F0-9]{8}\\-[a-fA-F0-9]{4}\\-[a-fA-F0-9]{4}\\-[a-fA-F0-9]{4}\\-[a-fA-F0-9]{12})$']]
    def validate_resultType(self, value):
        result = True
        # Validate type resultType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['success', 'failure']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on resultType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_nonEmptyString(self, value):
        result = True
        # Validate type nonEmptyString, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on nonEmptyString' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.refguid is not None or
            self.entityGuid is not None or
            self.result is not None or
            self.violations is not None or
            self.url is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'refguid':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'refguid')
            value_ = self.gds_validate_string(value_, node, 'refguid')
            self.refguid = value_
            self.refguid_nsprefix_ = child_.prefix
            # validate type guidType
            self.validate_guidType(self.refguid)
        elif nodeName_ == 'entityGuid':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'entityGuid')
            value_ = self.gds_validate_string(value_, node, 'entityGuid')
            self.entityGuid = value_
            self.entityGuid_nsprefix_ = child_.prefix
            # validate type guidType
            self.validate_guidType(self.entityGuid)
        elif nodeName_ == 'result':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'result')
            value_ = self.gds_validate_string(value_, node, 'result')
            self.result = value_
            self.result_nsprefix_ = child_.prefix
            # validate type resultType
            self.validate_resultType(self.result)
        elif nodeName_ == 'violations':
            obj_ = violationListType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.violations = obj_
            obj_.original_tagname_ = 'violations'
        elif nodeName_ == 'url':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'url')
            value_ = self.gds_validate_string(value_, node, 'url')
            self.url = value_
            self.url_nsprefix_ = child_.prefix
            # validate type nonEmptyString
            self.validate_nonEmptyString(self.url)
# end class itemResultType


class itemType(GeneratedsSuper):
    """Данные позиции в пакете"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'guid': MemberSpec_('guid', ['guidType', 'xs:string'], 0, 0, {'name': 'guid', 'type': 'xs:string'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_) + ['extensiontype_']
    subclass = None
    superclass = None
    def __init__(self, guid=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.guid = guid
        self.validate_guidType(self.guid)
        self.guid_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, itemType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if itemType.subclass:
            return itemType.subclass(*args_, **kwargs_)
        else:
            return itemType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_guidType(self, value):
        result = True
        # Validate type guidType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) != 36:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd length restriction on guidType' % {"value": encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_guidType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_guidType_patterns_, ))
                result = False
        return result
    validate_guidType_patterns_ = [['^([a-fA-F0-9]{8}\\-[a-fA-F0-9]{4}\\-[a-fA-F0-9]{4}\\-[a-fA-F0-9]{4}\\-[a-fA-F0-9]{12})$']]
    def hasContent_(self):
        if (
            self.guid is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'guid':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'guid')
            value_ = self.gds_validate_string(value_, node, 'guid')
            self.guid = value_
            self.guid_nsprefix_ = child_.prefix
            # validate type guidType
            self.validate_guidType(self.guid)
# end class itemType


class lotItemListType(GeneratedsSuper):
    """Позиции лота"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'newCodes': MemberSpec_('newCodes', 'xs:boolean', 0, 1, {'minOccurs': '0', 'name': 'newCodes', 'type': 'xs:boolean'}, None),
        'lotItem': MemberSpec_('lotItem', 'lotItemType', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'lotItem', 'type': 'lotItemType'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, newCodes=None, lotItem=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.newCodes = newCodes
        self.newCodes_nsprefix_ = None
        if lotItem is None:
            self.lotItem = []
        else:
            self.lotItem = lotItem
        self.lotItem_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, lotItemListType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if lotItemListType.subclass:
            return lotItemListType.subclass(*args_, **kwargs_)
        else:
            return lotItemListType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.newCodes is not None or
            self.lotItem
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'newCodes':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'newCodes')
            ival_ = self.gds_validate_boolean(ival_, node, 'newCodes')
            self.newCodes = ival_
            self.newCodes_nsprefix_ = child_.prefix
        elif nodeName_ == 'lotItem':
            obj_ = lotItemType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.lotItem.append(obj_)
            obj_.original_tagname_ = 'lotItem'
# end class lotItemListType


class lotItemType(GeneratedsSuper):
    """Позиция лота"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'guid': MemberSpec_('guid', ['guidType', 'xs:string'], 0, 0, {'name': 'guid', 'type': 'xs:string'}, None),
        'ordinalNumber': MemberSpec_('ordinalNumber', 'xs:int', 0, 0, {'name': 'ordinalNumber', 'type': 'xs:int'}, None),
        'okdp': MemberSpec_('okdp', 'okdpProductType', 0, 1, {'minOccurs': '0', 'name': 'okdp', 'type': 'okdpProductType'}, 6),
        'okpd2': MemberSpec_('okpd2', 'okpd2ProductType', 0, 1, {'minOccurs': '0', 'name': 'okpd2', 'type': 'okpd2ProductType'}, 6),
        'okved': MemberSpec_('okved', 'okvedProductType', 0, 1, {'minOccurs': '0', 'name': 'okved', 'type': 'okvedProductType'}, 7),
        'okved2': MemberSpec_('okved2', 'okved2ProductType', 0, 1, {'minOccurs': '0', 'name': 'okved2', 'type': 'okved2ProductType'}, 7),
        'okei': MemberSpec_('okei', 'okeiProductType', 0, 1, {'minOccurs': '0', 'name': 'okei', 'type': 'okeiProductType'}, None),
        'qty': MemberSpec_('qty', ['lotItemQtyType', 'xs:decimal'], 0, 1, {'minOccurs': '0', 'name': 'qty', 'type': 'xs:decimal'}, None),
        'additionalInfo': MemberSpec_('additionalInfo', ['additionalInfoType84', 'nonEmptyString', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'additionalInfo', 'type': 'xs:string'}, None),
        'deliveryPlace': MemberSpec_('deliveryPlace', 'deliveryPlaceType', 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'deliveryPlace', 'type': 'deliveryPlaceType'}, None),
        'commodityItemPrice': MemberSpec_('commodityItemPrice', ['money2', 'xs:decimal'], 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'commodityItemPrice', 'type': 'xs:decimal'}, None),
        'commodityItemPriceRub': MemberSpec_('commodityItemPriceRub', ['money2', 'xs:decimal'], 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'commodityItemPriceRub', 'type': 'xs:decimal'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, guid=None, ordinalNumber=None, okdp=None, okpd2=None, okved=None, okved2=None, okei=None, qty=None, additionalInfo=None, deliveryPlace=None, commodityItemPrice=None, commodityItemPriceRub=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.guid = guid
        self.validate_guidType(self.guid)
        self.guid_nsprefix_ = None
        self.ordinalNumber = ordinalNumber
        self.ordinalNumber_nsprefix_ = None
        self.okdp = okdp
        self.okdp_nsprefix_ = None
        self.okpd2 = okpd2
        self.okpd2_nsprefix_ = None
        self.okved = okved
        self.okved_nsprefix_ = None
        self.okved2 = okved2
        self.okved2_nsprefix_ = None
        self.okei = okei
        self.okei_nsprefix_ = None
        self.qty = qty
        self.validate_lotItemQtyType(self.qty)
        self.qty_nsprefix_ = None
        self.additionalInfo = additionalInfo
        self.validate_additionalInfoType84(self.additionalInfo)
        self.additionalInfo_nsprefix_ = None
        self.deliveryPlace = deliveryPlace
        self.deliveryPlace_nsprefix_ = None
        self.commodityItemPrice = commodityItemPrice
        self.validate_money2(self.commodityItemPrice)
        self.commodityItemPrice_nsprefix_ = None
        self.commodityItemPriceRub = commodityItemPriceRub
        self.validate_money2(self.commodityItemPriceRub)
        self.commodityItemPriceRub_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, lotItemType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if lotItemType.subclass:
            return lotItemType.subclass(*args_, **kwargs_)
        else:
            return lotItemType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_guidType(self, value):
        result = True
        # Validate type guidType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) != 36:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd length restriction on guidType' % {"value": encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_guidType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_guidType_patterns_, ))
                result = False
        return result
    validate_guidType_patterns_ = [['^([a-fA-F0-9]{8}\\-[a-fA-F0-9]{4}\\-[a-fA-F0-9]{4}\\-[a-fA-F0-9]{4}\\-[a-fA-F0-9]{12})$']]
    def validate_lotItemQtyType(self, value):
        result = True
        # Validate type lotItemQtyType, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, decimal_.Decimal):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (decimal_.Decimal)' % {"value": value, "lineno": lineno, })
                return False
            if len(str(value)) >= 25:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd totalDigits restriction on lotItemQtyType' % {"value": value, "lineno": lineno} )
                result = False
        return result
    def validate_additionalInfoType84(self, value):
        result = True
        # Validate type additionalInfoType84, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on additionalInfoType84' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on additionalInfoType84' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_money2(self, value):
        result = True
        # Validate type money2, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, decimal_.Decimal):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (decimal_.Decimal)' % {"value": value, "lineno": lineno, })
                return False
            if len(str(value)) >= 20:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd totalDigits restriction on money2' % {"value": value, "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.guid is not None or
            self.ordinalNumber is not None or
            self.okdp is not None or
            self.okpd2 is not None or
            self.okved is not None or
            self.okved2 is not None or
            self.okei is not None or
            self.qty is not None or
            self.additionalInfo is not None or
            self.deliveryPlace is not None or
            self.commodityItemPrice is not None or
            self.commodityItemPriceRub is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'guid':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'guid')
            value_ = self.gds_validate_string(value_, node, 'guid')
            self.guid = value_
            self.guid_nsprefix_ = child_.prefix
            # validate type guidType
            self.validate_guidType(self.guid)
        elif nodeName_ == 'ordinalNumber' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'ordinalNumber')
            ival_ = self.gds_validate_integer(ival_, node, 'ordinalNumber')
            self.ordinalNumber = ival_
            self.ordinalNumber_nsprefix_ = child_.prefix
        elif nodeName_ == 'okdp':
            obj_ = okdpProductType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.okdp = obj_
            obj_.original_tagname_ = 'okdp'
        elif nodeName_ == 'okpd2':
            obj_ = okpd2ProductType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.okpd2 = obj_
            obj_.original_tagname_ = 'okpd2'
        elif nodeName_ == 'okved':
            obj_ = okvedProductType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.okved = obj_
            obj_.original_tagname_ = 'okved'
        elif nodeName_ == 'okved2':
            obj_ = okved2ProductType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.okved2 = obj_
            obj_.original_tagname_ = 'okved2'
        elif nodeName_ == 'okei':
            obj_ = okeiProductType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.okei = obj_
            obj_.original_tagname_ = 'okei'
        elif nodeName_ == 'qty' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'qty')
            fval_ = self.gds_validate_decimal(fval_, node, 'qty')
            self.qty = fval_
            self.qty_nsprefix_ = child_.prefix
            # validate type lotItemQtyType
            self.validate_lotItemQtyType(self.qty)
        elif nodeName_ == 'additionalInfo':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'additionalInfo')
            value_ = self.gds_validate_string(value_, node, 'additionalInfo')
            self.additionalInfo = value_
            self.additionalInfo_nsprefix_ = child_.prefix
            # validate type additionalInfoType84
            self.validate_additionalInfoType84(self.additionalInfo)
        elif nodeName_ == 'deliveryPlace':
            obj_ = deliveryPlaceType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.deliveryPlace = obj_
            obj_.original_tagname_ = 'deliveryPlace'
        elif nodeName_ == 'commodityItemPrice' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'commodityItemPrice')
            fval_ = self.gds_validate_decimal(fval_, node, 'commodityItemPrice')
            self.commodityItemPrice = fval_
            self.commodityItemPrice_nsprefix_ = child_.prefix
            # validate type money2
            self.validate_money2(self.commodityItemPrice)
        elif nodeName_ == 'commodityItemPriceRub' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'commodityItemPriceRub')
            fval_ = self.gds_validate_decimal(fval_, node, 'commodityItemPriceRub')
            self.commodityItemPriceRub = fval_
            self.commodityItemPriceRub_nsprefix_ = child_.prefix
            # validate type money2
            self.validate_money2(self.commodityItemPriceRub)
# end class lotItemType


class lotListType(GeneratedsSuper):
    """Лоты"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'lot': MemberSpec_('lot', 'lotType', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'lot', 'type': 'lotType'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, lot=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if lot is None:
            self.lot = []
        else:
            self.lot = lot
        self.lot_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, lotListType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if lotListType.subclass:
            return lotListType.subclass(*args_, **kwargs_)
        else:
            return lotListType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.lot
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'lot':
            class_obj_ = self.get_class_obj_(child_, lotType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.lot.append(obj_)
            obj_.original_tagname_ = 'lot'
# end class lotListType


class lotISListType(GeneratedsSuper):
    """Лоты ИС"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'lot': MemberSpec_('lot', 'lotTypeIS', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'lot', 'type': 'lotTypeIS'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, lot=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if lot is None:
            self.lot = []
        else:
            self.lot = lot
        self.lot_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, lotISListType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if lotISListType.subclass:
            return lotISListType.subclass(*args_, **kwargs_)
        else:
            return lotISListType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.lot
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'lot':
            obj_ = lotTypeIS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.lot.append(obj_)
            obj_.original_tagname_ = 'lot'
# end class lotISListType


class lotType(GeneratedsSuper):
    """Лот"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'guid': MemberSpec_('guid', ['guidType', 'xs:string'], 0, 0, {'name': 'guid', 'type': 'xs:string'}, None),
        'ordinalNumber': MemberSpec_('ordinalNumber', 'xs:int', 0, 0, {'name': 'ordinalNumber', 'type': 'xs:int'}, None),
        'lotEditEnabled': MemberSpec_('lotEditEnabled', 'xs:boolean', 0, 0, {'name': 'lotEditEnabled', 'type': 'xs:boolean'}, None),
        'lotData': MemberSpec_('lotData', 'lotDataType', 0, 1, {'minOccurs': '0', 'name': 'lotData', 'type': 'lotDataType'}, None),
        'deliveryPlaceIndication': MemberSpec_('deliveryPlaceIndication', ['deliveryPlaceIndicationType', 'xs:string'], 0, 0, {'name': 'deliveryPlaceIndication', 'type': 'xs:string'}, None),
        'jointLotData': MemberSpec_('jointLotData', 'jointLotDataType', 0, 1, {'minOccurs': '0', 'name': 'jointLotData', 'type': 'jointLotDataType'}, None),
        'lotPlanInfo': MemberSpec_('lotPlanInfo', 'planInfoType', 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'lotPlanInfo', 'type': 'planInfoType'}, None),
        'cancelled': MemberSpec_('cancelled', 'xs:boolean', 0, 0, {'name': 'cancelled', 'type': 'xs:boolean'}, None),
        'cancellation': MemberSpec_('cancellation', 'lotCancellationInfoType', 0, 1, {'minOccurs': '0', 'name': 'cancellation', 'type': 'lotCancellationInfoType'}, None),
        'criteria': MemberSpec_('criteria', 'lotCriteriaListType', 0, 1, {'minOccurs': '0', 'name': 'criteria', 'type': 'lotCriteriaListType'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_) + ['extensiontype_']
    subclass = None
    superclass = None
    def __init__(self, guid=None, ordinalNumber=None, lotEditEnabled=None, lotData=None, deliveryPlaceIndication=None, jointLotData=None, lotPlanInfo=None, cancelled=None, cancellation=None, criteria=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.guid = guid
        self.validate_guidType(self.guid)
        self.guid_nsprefix_ = None
        self.ordinalNumber = ordinalNumber
        self.ordinalNumber_nsprefix_ = None
        self.lotEditEnabled = lotEditEnabled
        self.lotEditEnabled_nsprefix_ = None
        self.lotData = lotData
        self.lotData_nsprefix_ = None
        self.deliveryPlaceIndication = deliveryPlaceIndication
        self.validate_deliveryPlaceIndicationType(self.deliveryPlaceIndication)
        self.deliveryPlaceIndication_nsprefix_ = None
        self.jointLotData = jointLotData
        self.jointLotData_nsprefix_ = None
        self.lotPlanInfo = lotPlanInfo
        self.lotPlanInfo_nsprefix_ = None
        self.cancelled = cancelled
        self.cancelled_nsprefix_ = None
        self.cancellation = cancellation
        self.cancellation_nsprefix_ = None
        self.criteria = criteria
        self.criteria_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, lotType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if lotType.subclass:
            return lotType.subclass(*args_, **kwargs_)
        else:
            return lotType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_guidType(self, value):
        result = True
        # Validate type guidType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) != 36:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd length restriction on guidType' % {"value": encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_guidType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_guidType_patterns_, ))
                result = False
        return result
    validate_guidType_patterns_ = [['^([a-fA-F0-9]{8}\\-[a-fA-F0-9]{4}\\-[a-fA-F0-9]{4}\\-[a-fA-F0-9]{4}\\-[a-fA-F0-9]{12})$']]
    def validate_deliveryPlaceIndicationType(self, value):
        result = True
        # Validate type deliveryPlaceIndicationType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['GL', 'ELP', 'LC', 'GA', 'EP']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on deliveryPlaceIndicationType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.guid is not None or
            self.ordinalNumber is not None or
            self.lotEditEnabled is not None or
            self.lotData is not None or
            self.deliveryPlaceIndication is not None or
            self.jointLotData is not None or
            self.lotPlanInfo is not None or
            self.cancelled is not None or
            self.cancellation is not None or
            self.criteria is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'guid':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'guid')
            value_ = self.gds_validate_string(value_, node, 'guid')
            self.guid = value_
            self.guid_nsprefix_ = child_.prefix
            # validate type guidType
            self.validate_guidType(self.guid)
        elif nodeName_ == 'ordinalNumber' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'ordinalNumber')
            ival_ = self.gds_validate_integer(ival_, node, 'ordinalNumber')
            self.ordinalNumber = ival_
            self.ordinalNumber_nsprefix_ = child_.prefix
        elif nodeName_ == 'lotEditEnabled':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'lotEditEnabled')
            ival_ = self.gds_validate_boolean(ival_, node, 'lotEditEnabled')
            self.lotEditEnabled = ival_
            self.lotEditEnabled_nsprefix_ = child_.prefix
        elif nodeName_ == 'lotData':
            obj_ = lotDataType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.lotData = obj_
            obj_.original_tagname_ = 'lotData'
        elif nodeName_ == 'deliveryPlaceIndication':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'deliveryPlaceIndication')
            value_ = self.gds_validate_string(value_, node, 'deliveryPlaceIndication')
            self.deliveryPlaceIndication = value_
            self.deliveryPlaceIndication_nsprefix_ = child_.prefix
            # validate type deliveryPlaceIndicationType
            self.validate_deliveryPlaceIndicationType(self.deliveryPlaceIndication)
        elif nodeName_ == 'jointLotData':
            obj_ = jointLotDataType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.jointLotData = obj_
            obj_.original_tagname_ = 'jointLotData'
        elif nodeName_ == 'lotPlanInfo':
            obj_ = planInfoType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.lotPlanInfo = obj_
            obj_.original_tagname_ = 'lotPlanInfo'
        elif nodeName_ == 'cancelled':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'cancelled')
            ival_ = self.gds_validate_boolean(ival_, node, 'cancelled')
            self.cancelled = ival_
            self.cancelled_nsprefix_ = child_.prefix
        elif nodeName_ == 'cancellation':
            obj_ = lotCancellationInfoType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.cancellation = obj_
            obj_.original_tagname_ = 'cancellation'
        elif nodeName_ == 'criteria':
            obj_ = lotCriteriaListType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.criteria = obj_
            obj_.original_tagname_ = 'criteria'
# end class lotType


class lotCriteriaListType(GeneratedsSuper):
    """Список критериев по лоту"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'lotCriteria': MemberSpec_('lotCriteria', 'lotCriteriaType', 1, 0, {'maxOccurs': 'unbounded', 'name': 'lotCriteria', 'type': 'lotCriteriaType'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, lotCriteria=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if lotCriteria is None:
            self.lotCriteria = []
        else:
            self.lotCriteria = lotCriteria
        self.lotCriteria_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, lotCriteriaListType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if lotCriteriaListType.subclass:
            return lotCriteriaListType.subclass(*args_, **kwargs_)
        else:
            return lotCriteriaListType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.lotCriteria
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'lotCriteria':
            obj_ = lotCriteriaType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.lotCriteria.append(obj_)
            obj_.original_tagname_ = 'lotCriteria'
# end class lotCriteriaListType


class lotApplicationsCriteriaListType(GeneratedsSuper):
    """Список критериев по лоту протокола"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'lotApplicationsCriteria': MemberSpec_('lotApplicationsCriteria', 'lotApplicationsCriteriaType', 1, 0, {'maxOccurs': 'unbounded', 'name': 'lotApplicationsCriteria', 'type': 'lotApplicationsCriteriaType'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, lotApplicationsCriteria=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if lotApplicationsCriteria is None:
            self.lotApplicationsCriteria = []
        else:
            self.lotApplicationsCriteria = lotApplicationsCriteria
        self.lotApplicationsCriteria_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, lotApplicationsCriteriaListType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if lotApplicationsCriteriaListType.subclass:
            return lotApplicationsCriteriaListType.subclass(*args_, **kwargs_)
        else:
            return lotApplicationsCriteriaListType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.lotApplicationsCriteria
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'lotApplicationsCriteria':
            obj_ = lotApplicationsCriteriaType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.lotApplicationsCriteria.append(obj_)
            obj_.original_tagname_ = 'lotApplicationsCriteria'
# end class lotApplicationsCriteriaListType


class baseCriteriaType(GeneratedsSuper):
    """Базовый критерий по лоту"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'guid': MemberSpec_('guid', ['guidType', 'xs:string'], 0, 0, {'name': 'guid', 'type': 'xs:string'}, None),
        'name': MemberSpec_('name', ['nameType85', 'nonEmptyString', 'xs:string'], 0, 0, {'name': 'name', 'type': 'xs:string'}, None),
        'description': MemberSpec_('description', ['descriptionType86', 'nonEmptyString', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'description', 'type': 'xs:string'}, None),
        'maxValue': MemberSpec_('maxValue', ['decimal20_2', 'xs:decimal'], 0, 0, {'name': 'maxValue', 'type': 'xs:decimal'}, None),
        'weight': MemberSpec_('weight', ['decimal20_2', 'xs:decimal'], 0, 0, {'name': 'weight', 'type': 'xs:decimal'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_) + ['extensiontype_']
    subclass = None
    superclass = None
    def __init__(self, guid=None, name=None, description=None, maxValue=None, weight=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.guid = guid
        self.validate_guidType(self.guid)
        self.guid_nsprefix_ = None
        self.name = name
        self.validate_nameType85(self.name)
        self.name_nsprefix_ = None
        self.description = description
        self.validate_descriptionType86(self.description)
        self.description_nsprefix_ = None
        self.maxValue = maxValue
        self.validate_decimal20_2(self.maxValue)
        self.maxValue_nsprefix_ = None
        self.weight = weight
        self.validate_decimal20_2(self.weight)
        self.weight_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, baseCriteriaType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if baseCriteriaType.subclass:
            return baseCriteriaType.subclass(*args_, **kwargs_)
        else:
            return baseCriteriaType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_guidType(self, value):
        result = True
        # Validate type guidType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) != 36:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd length restriction on guidType' % {"value": encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_guidType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_guidType_patterns_, ))
                result = False
        return result
    validate_guidType_patterns_ = [['^([a-fA-F0-9]{8}\\-[a-fA-F0-9]{4}\\-[a-fA-F0-9]{4}\\-[a-fA-F0-9]{4}\\-[a-fA-F0-9]{12})$']]
    def validate_nameType85(self, value):
        result = True
        # Validate type nameType85, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 500:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on nameType85' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on nameType85' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_descriptionType86(self, value):
        result = True
        # Validate type descriptionType86, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on descriptionType86' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on descriptionType86' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_decimal20_2(self, value):
        result = True
        # Validate type decimal20_2, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, decimal_.Decimal):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (decimal_.Decimal)' % {"value": value, "lineno": lineno, })
                return False
            if len(str(value)) >= 20:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd totalDigits restriction on decimal20_2' % {"value": value, "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.guid is not None or
            self.name is not None or
            self.description is not None or
            self.maxValue is not None or
            self.weight is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'guid':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'guid')
            value_ = self.gds_validate_string(value_, node, 'guid')
            self.guid = value_
            self.guid_nsprefix_ = child_.prefix
            # validate type guidType
            self.validate_guidType(self.guid)
        elif nodeName_ == 'name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'name')
            value_ = self.gds_validate_string(value_, node, 'name')
            self.name = value_
            self.name_nsprefix_ = child_.prefix
            # validate type nameType85
            self.validate_nameType85(self.name)
        elif nodeName_ == 'description':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'description')
            value_ = self.gds_validate_string(value_, node, 'description')
            self.description = value_
            self.description_nsprefix_ = child_.prefix
            # validate type descriptionType86
            self.validate_descriptionType86(self.description)
        elif nodeName_ == 'maxValue' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'maxValue')
            fval_ = self.gds_validate_decimal(fval_, node, 'maxValue')
            self.maxValue = fval_
            self.maxValue_nsprefix_ = child_.prefix
            # validate type decimal20_2
            self.validate_decimal20_2(self.maxValue)
        elif nodeName_ == 'weight' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'weight')
            fval_ = self.gds_validate_decimal(fval_, node, 'weight')
            self.weight = fval_
            self.weight_nsprefix_ = child_.prefix
            # validate type decimal20_2
            self.validate_decimal20_2(self.weight)
# end class baseCriteriaType


class applicationLotCriteriaListType(GeneratedsSuper):
    """Список значений критериев заявок"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'applicationLotCriteria': MemberSpec_('applicationLotCriteria', 'applicationLotCriteriaType', 1, 0, {'maxOccurs': 'unbounded', 'name': 'applicationLotCriteria', 'type': 'applicationLotCriteriaType'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, applicationLotCriteria=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if applicationLotCriteria is None:
            self.applicationLotCriteria = []
        else:
            self.applicationLotCriteria = applicationLotCriteria
        self.applicationLotCriteria_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, applicationLotCriteriaListType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if applicationLotCriteriaListType.subclass:
            return applicationLotCriteriaListType.subclass(*args_, **kwargs_)
        else:
            return applicationLotCriteriaListType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.applicationLotCriteria
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'applicationLotCriteria':
            obj_ = applicationLotCriteriaType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.applicationLotCriteria.append(obj_)
            obj_.original_tagname_ = 'applicationLotCriteria'
# end class applicationLotCriteriaListType


class applicationLotCriteriaType(GeneratedsSuper):
    """Значения критериев заявок"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'lotApplcationsCriteria': MemberSpec_('lotApplcationsCriteria', 'lotApplcationsCriteriaType', 0, 0, {'name': 'lotApplcationsCriteria', 'type': 'lotApplcationsCriteriaType'}, None),
        'value': MemberSpec_('value', ['decimal20_2', 'xs:decimal'], 0, 0, {'name': 'value', 'type': 'xs:decimal'}, None),
        'description': MemberSpec_('description', ['descriptionType88', 'nonEmptyString', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'description', 'type': 'xs:string'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, lotApplcationsCriteria=None, value=None, description=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.lotApplcationsCriteria = lotApplcationsCriteria
        self.lotApplcationsCriteria_nsprefix_ = None
        self.value = value
        self.validate_decimal20_2(self.value)
        self.value_nsprefix_ = None
        self.description = description
        self.validate_descriptionType88(self.description)
        self.description_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, applicationLotCriteriaType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if applicationLotCriteriaType.subclass:
            return applicationLotCriteriaType.subclass(*args_, **kwargs_)
        else:
            return applicationLotCriteriaType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_decimal20_2(self, value):
        result = True
        # Validate type decimal20_2, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, decimal_.Decimal):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (decimal_.Decimal)' % {"value": value, "lineno": lineno, })
                return False
            if len(str(value)) >= 20:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd totalDigits restriction on decimal20_2' % {"value": value, "lineno": lineno} )
                result = False
        return result
    def validate_descriptionType88(self, value):
        result = True
        # Validate type descriptionType88, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on descriptionType88' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on descriptionType88' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.lotApplcationsCriteria is not None or
            self.value is not None or
            self.description is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'lotApplcationsCriteria':
            obj_ = lotApplcationsCriteriaType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.lotApplcationsCriteria = obj_
            obj_.original_tagname_ = 'lotApplcationsCriteria'
        elif nodeName_ == 'value' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'value')
            fval_ = self.gds_validate_decimal(fval_, node, 'value')
            self.value = fval_
            self.value_nsprefix_ = child_.prefix
            # validate type decimal20_2
            self.validate_decimal20_2(self.value)
        elif nodeName_ == 'description':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'description')
            value_ = self.gds_validate_string(value_, node, 'description')
            self.description = value_
            self.description_nsprefix_ = child_.prefix
            # validate type descriptionType88
            self.validate_descriptionType88(self.description)
# end class applicationLotCriteriaType


class lotCancellationInfoType(GeneratedsSuper):
    """Данные об отмене лота"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'cancelDate': MemberSpec_('cancelDate', 'xs:date', 0, 0, {'name': 'cancelDate', 'type': 'xs:date'}, None),
        'cancelInfo': MemberSpec_('cancelInfo', ['cancelInfoType', 'nonEmptyString', 'xs:string'], 0, 0, {'name': 'cancelInfo', 'type': 'xs:string'}, None),
        'emergency': MemberSpec_('emergency', 'xs:boolean', 0, 1, {'minOccurs': '0', 'name': 'emergency', 'type': 'xs:boolean'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, cancelDate=None, cancelInfo=None, emergency=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if isinstance(cancelDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(cancelDate, '%Y-%m-%d').date()
        else:
            initvalue_ = cancelDate
        self.cancelDate = initvalue_
        self.cancelDate_nsprefix_ = None
        self.cancelInfo = cancelInfo
        self.validate_cancelInfoType(self.cancelInfo)
        self.cancelInfo_nsprefix_ = None
        self.emergency = emergency
        self.emergency_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, lotCancellationInfoType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if lotCancellationInfoType.subclass:
            return lotCancellationInfoType.subclass(*args_, **kwargs_)
        else:
            return lotCancellationInfoType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_cancelInfoType(self, value):
        result = True
        # Validate type cancelInfoType, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 2000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on cancelInfoType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on cancelInfoType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.cancelDate is not None or
            self.cancelInfo is not None or
            self.emergency is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'cancelDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.cancelDate = dval_
            self.cancelDate_nsprefix_ = child_.prefix
        elif nodeName_ == 'cancelInfo':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'cancelInfo')
            value_ = self.gds_validate_string(value_, node, 'cancelInfo')
            self.cancelInfo = value_
            self.cancelInfo_nsprefix_ = child_.prefix
            # validate type cancelInfoType
            self.validate_cancelInfoType(self.cancelInfo)
        elif nodeName_ == 'emergency':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'emergency')
            ival_ = self.gds_validate_boolean(ival_, node, 'emergency')
            self.emergency = ival_
            self.emergency_nsprefix_ = child_.prefix
# end class lotCancellationInfoType


class lotAllocationReferenceType(GeneratedsSuper):
    """Сведения о формировании протокола в результате выделения лотов"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'protocolRequisites': MemberSpec_('protocolRequisites', 'protocolRequisitesType', 0, 0, {'name': 'protocolRequisites', 'type': 'protocolRequisitesType'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, protocolRequisites=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.protocolRequisites = protocolRequisites
        self.protocolRequisites_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, lotAllocationReferenceType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if lotAllocationReferenceType.subclass:
            return lotAllocationReferenceType.subclass(*args_, **kwargs_)
        else:
            return lotAllocationReferenceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.protocolRequisites is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'protocolRequisites':
            class_obj_ = self.get_class_obj_(child_, protocolRequisitesType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.protocolRequisites = obj_
            obj_.original_tagname_ = 'protocolRequisites'
# end class lotAllocationReferenceType


class lotAllocationInfoType(GeneratedsSuper):
    """Данные о выделении лота в отдельный протокол"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'allocationDate': MemberSpec_('allocationDate', 'xs:date', 0, 0, {'name': 'allocationDate', 'type': 'xs:date'}, None),
        'allocationInfo': MemberSpec_('allocationInfo', ['allocationInfoType', 'nonEmptyString', 'xs:string'], 0, 0, {'name': 'allocationInfo', 'type': 'xs:string'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, allocationDate=None, allocationInfo=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if isinstance(allocationDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(allocationDate, '%Y-%m-%d').date()
        else:
            initvalue_ = allocationDate
        self.allocationDate = initvalue_
        self.allocationDate_nsprefix_ = None
        self.allocationInfo = allocationInfo
        self.validate_allocationInfoType(self.allocationInfo)
        self.allocationInfo_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, lotAllocationInfoType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if lotAllocationInfoType.subclass:
            return lotAllocationInfoType.subclass(*args_, **kwargs_)
        else:
            return lotAllocationInfoType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_allocationInfoType(self, value):
        result = True
        # Validate type allocationInfoType, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 2000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on allocationInfoType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on allocationInfoType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.allocationDate is not None or
            self.allocationInfo is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'allocationDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.allocationDate = dval_
            self.allocationDate_nsprefix_ = child_.prefix
        elif nodeName_ == 'allocationInfo':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'allocationInfo')
            value_ = self.gds_validate_string(value_, node, 'allocationInfo')
            self.allocationInfo = value_
            self.allocationInfo_nsprefix_ = child_.prefix
            # validate type allocationInfoType
            self.validate_allocationInfoType(self.allocationInfo)
# end class lotAllocationInfoType


class deliveryPlaceType(GeneratedsSuper):
    """Место поставки"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'state': MemberSpec_('state', ['stateType', 'nonEmptyString', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'state', 'type': 'xs:string'}, None),
        'region': MemberSpec_('region', ['regionType89', 'nonEmptyString', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'region', 'type': 'xs:string'}, None),
        'regionOkato': MemberSpec_('regionOkato', ['codeOkatoType', 'nonEmptyString', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'regionOkato', 'type': 'xs:string'}, None),
        'address': MemberSpec_('address', ['addressType90', 'nonEmptyString', 'xs:string'], 0, 0, {'name': 'address', 'type': 'xs:string'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, state=None, region=None, regionOkato=None, address=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.state = state
        self.validate_stateType(self.state)
        self.state_nsprefix_ = None
        self.region = region
        self.validate_regionType89(self.region)
        self.region_nsprefix_ = None
        self.regionOkato = regionOkato
        self.validate_codeOkatoType(self.regionOkato)
        self.regionOkato_nsprefix_ = None
        self.address = address
        self.validate_addressType90(self.address)
        self.address_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, deliveryPlaceType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if deliveryPlaceType.subclass:
            return deliveryPlaceType.subclass(*args_, **kwargs_)
        else:
            return deliveryPlaceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_stateType(self, value):
        result = True
        # Validate type stateType, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 2000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on stateType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on stateType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_regionType89(self, value):
        result = True
        # Validate type regionType89, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 2000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on regionType89' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on regionType89' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_codeOkatoType(self, value):
        result = True
        # Validate type codeOkatoType, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on codeOkatoType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_codeOkatoType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_codeOkatoType_patterns_, ))
                result = False
        return result
    validate_codeOkatoType_patterns_ = [['^(\\d{11})$']]
    def validate_addressType90(self, value):
        result = True
        # Validate type addressType90, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 2000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on addressType90' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on addressType90' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.state is not None or
            self.region is not None or
            self.regionOkato is not None or
            self.address is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'state':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'state')
            value_ = self.gds_validate_string(value_, node, 'state')
            self.state = value_
            self.state_nsprefix_ = child_.prefix
            # validate type stateType
            self.validate_stateType(self.state)
        elif nodeName_ == 'region':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'region')
            value_ = self.gds_validate_string(value_, node, 'region')
            self.region = value_
            self.region_nsprefix_ = child_.prefix
            # validate type regionType89
            self.validate_regionType89(self.region)
        elif nodeName_ == 'regionOkato':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'regionOkato')
            value_ = self.gds_validate_string(value_, node, 'regionOkato')
            self.regionOkato = value_
            self.regionOkato_nsprefix_ = child_.prefix
            # validate type codeOkatoType
            self.validate_codeOkatoType(self.regionOkato)
        elif nodeName_ == 'address':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'address')
            value_ = self.gds_validate_string(value_, node, 'address')
            self.address = value_
            self.address_nsprefix_ = child_.prefix
            # validate type addressType90
            self.validate_addressType90(self.address)
# end class deliveryPlaceType


class planInfoType(GeneratedsSuper):
    """Информация о плане и позиции"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'planRegistrationNumber': MemberSpec_('planRegistrationNumber', ['registrationNumberType', 'nonEmptyString', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'planRegistrationNumber', 'type': 'xs:string'}, None),
        'planGuid': MemberSpec_('planGuid', ['guidType', 'xs:string'], 0, 0, {'name': 'planGuid', 'type': 'xs:string'}, None),
        'positionNumber': MemberSpec_('positionNumber', 'xs:long', 0, 0, {'name': 'positionNumber', 'type': 'xs:long'}, None),
        'lotPlanPosition': MemberSpec_('lotPlanPosition', ['lotPlanPositionType', 'xs:string'], 0, 0, {'name': 'lotPlanPosition', 'type': 'xs:string'}, None),
        'positionGuid': MemberSpec_('positionGuid', ['guidType', 'xs:string'], 0, 0, {'name': 'positionGuid', 'type': 'xs:string'}, None),
        'contractSubject': MemberSpec_('contractSubject', ['contractSubjectType', 'nonEmptyString', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'contractSubject', 'type': 'xs:string'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, planRegistrationNumber=None, planGuid=None, positionNumber=None, lotPlanPosition=None, positionGuid=None, contractSubject=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.planRegistrationNumber = planRegistrationNumber
        self.validate_registrationNumberType(self.planRegistrationNumber)
        self.planRegistrationNumber_nsprefix_ = None
        self.planGuid = planGuid
        self.validate_guidType(self.planGuid)
        self.planGuid_nsprefix_ = None
        self.positionNumber = positionNumber
        self.positionNumber_nsprefix_ = None
        self.lotPlanPosition = lotPlanPosition
        self.validate_lotPlanPositionType(self.lotPlanPosition)
        self.lotPlanPosition_nsprefix_ = None
        self.positionGuid = positionGuid
        self.validate_guidType(self.positionGuid)
        self.positionGuid_nsprefix_ = None
        self.contractSubject = contractSubject
        self.validate_contractSubjectType(self.contractSubject)
        self.contractSubject_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, planInfoType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if planInfoType.subclass:
            return planInfoType.subclass(*args_, **kwargs_)
        else:
            return planInfoType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_registrationNumberType(self, value):
        result = True
        # Validate type registrationNumberType, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on registrationNumberType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_registrationNumberType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_registrationNumberType_patterns_, ))
                result = False
        return result
    validate_registrationNumberType_patterns_ = [['^(\\d{10})$']]
    def validate_guidType(self, value):
        result = True
        # Validate type guidType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) != 36:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd length restriction on guidType' % {"value": encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_guidType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_guidType_patterns_, ))
                result = False
        return result
    validate_guidType_patterns_ = [['^([a-fA-F0-9]{8}\\-[a-fA-F0-9]{4}\\-[a-fA-F0-9]{4}\\-[a-fA-F0-9]{4}\\-[a-fA-F0-9]{12})$']]
    def validate_lotPlanPositionType(self, value):
        result = True
        # Validate type lotPlanPositionType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['COMMODITY', 'INNOVATION']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on lotPlanPositionType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_contractSubjectType(self, value):
        result = True
        # Validate type contractSubjectType, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 4000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on contractSubjectType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on contractSubjectType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.planRegistrationNumber is not None or
            self.planGuid is not None or
            self.positionNumber is not None or
            self.lotPlanPosition is not None or
            self.positionGuid is not None or
            self.contractSubject is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'planRegistrationNumber':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'planRegistrationNumber')
            value_ = self.gds_validate_string(value_, node, 'planRegistrationNumber')
            self.planRegistrationNumber = value_
            self.planRegistrationNumber_nsprefix_ = child_.prefix
            # validate type registrationNumberType
            self.validate_registrationNumberType(self.planRegistrationNumber)
        elif nodeName_ == 'planGuid':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'planGuid')
            value_ = self.gds_validate_string(value_, node, 'planGuid')
            self.planGuid = value_
            self.planGuid_nsprefix_ = child_.prefix
            # validate type guidType
            self.validate_guidType(self.planGuid)
        elif nodeName_ == 'positionNumber' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'positionNumber')
            ival_ = self.gds_validate_integer(ival_, node, 'positionNumber')
            self.positionNumber = ival_
            self.positionNumber_nsprefix_ = child_.prefix
        elif nodeName_ == 'lotPlanPosition':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'lotPlanPosition')
            value_ = self.gds_validate_string(value_, node, 'lotPlanPosition')
            self.lotPlanPosition = value_
            self.lotPlanPosition_nsprefix_ = child_.prefix
            # validate type lotPlanPositionType
            self.validate_lotPlanPositionType(self.lotPlanPosition)
        elif nodeName_ == 'positionGuid':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'positionGuid')
            value_ = self.gds_validate_string(value_, node, 'positionGuid')
            self.positionGuid = value_
            self.positionGuid_nsprefix_ = child_.prefix
            # validate type guidType
            self.validate_guidType(self.positionGuid)
        elif nodeName_ == 'contractSubject':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'contractSubject')
            value_ = self.gds_validate_string(value_, node, 'contractSubject')
            self.contractSubject = value_
            self.contractSubject_nsprefix_ = child_.prefix
            # validate type contractSubjectType
            self.validate_contractSubjectType(self.contractSubject)
# end class planInfoType


class lotCustomerListType(GeneratedsSuper):
    """Участники совместной закупки"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'lotCustomer': MemberSpec_('lotCustomer', 'lotCustomerType', 1, 0, {'maxOccurs': 'unbounded', 'minOccurs': '1', 'name': 'lotCustomer', 'type': 'lotCustomerType'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, lotCustomer=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if lotCustomer is None:
            self.lotCustomer = []
        else:
            self.lotCustomer = lotCustomer
        self.lotCustomer_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, lotCustomerListType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if lotCustomerListType.subclass:
            return lotCustomerListType.subclass(*args_, **kwargs_)
        else:
            return lotCustomerListType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.lotCustomer
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'lotCustomer':
            obj_ = lotCustomerType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.lotCustomer.append(obj_)
            obj_.original_tagname_ = 'lotCustomer'
# end class lotCustomerListType


class lotCustomerListShortType(GeneratedsSuper):
    """Участники совместной закупки"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'lotCustomer': MemberSpec_('lotCustomer', 'lotCustomerShortType', 1, 0, {'maxOccurs': 'unbounded', 'minOccurs': '1', 'name': 'lotCustomer', 'type': 'lotCustomerShortType'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, lotCustomer=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if lotCustomer is None:
            self.lotCustomer = []
        else:
            self.lotCustomer = lotCustomer
        self.lotCustomer_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, lotCustomerListShortType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if lotCustomerListShortType.subclass:
            return lotCustomerListShortType.subclass(*args_, **kwargs_)
        else:
            return lotCustomerListShortType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.lotCustomer
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'lotCustomer':
            obj_ = lotCustomerShortType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.lotCustomer.append(obj_)
            obj_.original_tagname_ = 'lotCustomer'
# end class lotCustomerListShortType


class lotCustomerBaseType(GeneratedsSuper):
    """Участник совместной закупки"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'additionalInfo': MemberSpec_('additionalInfo', ['additionalInfoType91', 'nonEmptyString', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'additionalInfo', 'type': 'xs:string'}, None),
        'deliveryPlaceIndication': MemberSpec_('deliveryPlaceIndication', ['deliveryPlaceIndicationType', 'xs:string'], 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'deliveryPlaceIndication', 'type': 'xs:string'}, None),
        'lotCustomerEditEnabled': MemberSpec_('lotCustomerEditEnabled', 'xs:boolean', 0, 0, {'name': 'lotCustomerEditEnabled', 'type': 'xs:boolean'}, None),
        'lotCustomerData': MemberSpec_('lotCustomerData', 'lotCustomerDataType', 0, 0, {'name': 'lotCustomerData', 'type': 'lotCustomerDataType'}, None),
        'lotPlanInfo': MemberSpec_('lotPlanInfo', 'planInfoType', 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'lotPlanInfo', 'type': 'planInfoType'}, None),
        'extendFields': MemberSpec_('extendFields', 'noticeExtendFieldValueListType', 0, 1, {'minOccurs': '0', 'name': 'extendFields', 'type': 'noticeExtendFieldValueListType'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_) + ['extensiontype_']
    subclass = None
    superclass = None
    def __init__(self, additionalInfo=None, deliveryPlaceIndication=None, lotCustomerEditEnabled=None, lotCustomerData=None, lotPlanInfo=None, extendFields=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.additionalInfo = additionalInfo
        self.validate_additionalInfoType91(self.additionalInfo)
        self.additionalInfo_nsprefix_ = None
        self.deliveryPlaceIndication = deliveryPlaceIndication
        self.validate_deliveryPlaceIndicationType(self.deliveryPlaceIndication)
        self.deliveryPlaceIndication_nsprefix_ = None
        self.lotCustomerEditEnabled = lotCustomerEditEnabled
        self.lotCustomerEditEnabled_nsprefix_ = None
        self.lotCustomerData = lotCustomerData
        self.lotCustomerData_nsprefix_ = None
        self.lotPlanInfo = lotPlanInfo
        self.lotPlanInfo_nsprefix_ = None
        self.extendFields = extendFields
        self.extendFields_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, lotCustomerBaseType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if lotCustomerBaseType.subclass:
            return lotCustomerBaseType.subclass(*args_, **kwargs_)
        else:
            return lotCustomerBaseType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_additionalInfoType91(self, value):
        result = True
        # Validate type additionalInfoType91, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 2000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on additionalInfoType91' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on additionalInfoType91' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_deliveryPlaceIndicationType(self, value):
        result = True
        # Validate type deliveryPlaceIndicationType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['GL', 'ELP', 'LC', 'GA', 'EP']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on deliveryPlaceIndicationType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.additionalInfo is not None or
            self.deliveryPlaceIndication is not None or
            self.lotCustomerEditEnabled is not None or
            self.lotCustomerData is not None or
            self.lotPlanInfo is not None or
            self.extendFields is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'additionalInfo':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'additionalInfo')
            value_ = self.gds_validate_string(value_, node, 'additionalInfo')
            self.additionalInfo = value_
            self.additionalInfo_nsprefix_ = child_.prefix
            # validate type additionalInfoType91
            self.validate_additionalInfoType91(self.additionalInfo)
        elif nodeName_ == 'deliveryPlaceIndication':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'deliveryPlaceIndication')
            value_ = self.gds_validate_string(value_, node, 'deliveryPlaceIndication')
            self.deliveryPlaceIndication = value_
            self.deliveryPlaceIndication_nsprefix_ = child_.prefix
            # validate type deliveryPlaceIndicationType
            self.validate_deliveryPlaceIndicationType(self.deliveryPlaceIndication)
        elif nodeName_ == 'lotCustomerEditEnabled':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'lotCustomerEditEnabled')
            ival_ = self.gds_validate_boolean(ival_, node, 'lotCustomerEditEnabled')
            self.lotCustomerEditEnabled = ival_
            self.lotCustomerEditEnabled_nsprefix_ = child_.prefix
        elif nodeName_ == 'lotCustomerData':
            obj_ = lotCustomerDataType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.lotCustomerData = obj_
            obj_.original_tagname_ = 'lotCustomerData'
        elif nodeName_ == 'lotPlanInfo':
            obj_ = planInfoType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.lotPlanInfo = obj_
            obj_.original_tagname_ = 'lotPlanInfo'
        elif nodeName_ == 'extendFields':
            obj_ = noticeExtendFieldValueListType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.extendFields = obj_
            obj_.original_tagname_ = 'extendFields'
# end class lotCustomerBaseType


class lotCustomerType(lotCustomerBaseType):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'nonResident': MemberSpec_('nonResident', 'xs:boolean', 0, 1, {'minOccurs': '0', 'name': 'nonResident', 'type': 'xs:boolean'}, None),
        'tax': MemberSpec_('tax', 'xs:boolean', 0, 1, {'minOccurs': '0', 'name': 'tax', 'type': 'xs:boolean'}, None),
        'customerInfo': MemberSpec_('customerInfo', 'customerMainInfoType', 0, 1, {'minOccurs': '0', 'name': 'customerInfo', 'type': 'customerMainInfoType'}, None),
        'nonResidentInfo': MemberSpec_('nonResidentInfo', 'nonResidentLotCustomerInfoType', 0, 1, {'minOccurs': '0', 'name': 'nonResidentInfo', 'type': 'nonResidentLotCustomerInfoType'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = lotCustomerBaseType
    def __init__(self, additionalInfo=None, deliveryPlaceIndication=None, lotCustomerEditEnabled=None, lotCustomerData=None, lotPlanInfo=None, extendFields=None, nonResident=None, tax=None, customerInfo=None, nonResidentInfo=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(lotCustomerType, self).__init__(additionalInfo, deliveryPlaceIndication, lotCustomerEditEnabled, lotCustomerData, lotPlanInfo, extendFields,  **kwargs_)
        self.nonResident = nonResident
        self.nonResident_nsprefix_ = None
        self.tax = tax
        self.tax_nsprefix_ = None
        self.customerInfo = customerInfo
        self.customerInfo_nsprefix_ = None
        self.nonResidentInfo = nonResidentInfo
        self.nonResidentInfo_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, lotCustomerType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if lotCustomerType.subclass:
            return lotCustomerType.subclass(*args_, **kwargs_)
        else:
            return lotCustomerType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.nonResident is not None or
            self.tax is not None or
            self.customerInfo is not None or
            self.nonResidentInfo is not None or
            super(lotCustomerType, self).hasContent_()
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(lotCustomerType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'nonResident':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'nonResident')
            ival_ = self.gds_validate_boolean(ival_, node, 'nonResident')
            self.nonResident = ival_
            self.nonResident_nsprefix_ = child_.prefix
        elif nodeName_ == 'tax':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'tax')
            ival_ = self.gds_validate_boolean(ival_, node, 'tax')
            self.tax = ival_
            self.tax_nsprefix_ = child_.prefix
        elif nodeName_ == 'customerInfo':
            obj_ = customerMainInfoType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.customerInfo = obj_
            obj_.original_tagname_ = 'customerInfo'
        elif nodeName_ == 'nonResidentInfo':
            obj_ = nonResidentLotCustomerInfoType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.nonResidentInfo = obj_
            obj_.original_tagname_ = 'nonResidentInfo'
        super(lotCustomerType, self).buildChildren(child_, node, nodeName_, True)
# end class lotCustomerType


class lotCustomerShortType(lotCustomerBaseType):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'customerInfo': MemberSpec_('customerInfo', 'customerMainInfo2Type', 0, 0, {'name': 'customerInfo', 'type': 'customerMainInfo2Type'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = lotCustomerBaseType
    def __init__(self, additionalInfo=None, deliveryPlaceIndication=None, lotCustomerEditEnabled=None, lotCustomerData=None, lotPlanInfo=None, extendFields=None, customerInfo=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(lotCustomerShortType, self).__init__(additionalInfo, deliveryPlaceIndication, lotCustomerEditEnabled, lotCustomerData, lotPlanInfo, extendFields,  **kwargs_)
        self.customerInfo = customerInfo
        self.customerInfo_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, lotCustomerShortType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if lotCustomerShortType.subclass:
            return lotCustomerShortType.subclass(*args_, **kwargs_)
        else:
            return lotCustomerShortType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.customerInfo is not None or
            super(lotCustomerShortType, self).hasContent_()
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(lotCustomerShortType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'customerInfo':
            obj_ = customerMainInfo2Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.customerInfo = obj_
            obj_.original_tagname_ = 'customerInfo'
        super(lotCustomerShortType, self).buildChildren(child_, node, nodeName_, True)
# end class lotCustomerShortType


class lotTypeIS(lotType):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'extendFields': MemberSpec_('extendFields', 'noticeExtendFieldValueListType', 0, 1, {'minOccurs': '0', 'name': 'extendFields', 'type': 'noticeExtendFieldValueListType'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = lotType
    def __init__(self, guid=None, ordinalNumber=None, lotEditEnabled=None, lotData=None, deliveryPlaceIndication=None, jointLotData=None, lotPlanInfo=None, cancelled=None, cancellation=None, criteria=None, extendFields=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(lotTypeIS, self).__init__(guid, ordinalNumber, lotEditEnabled, lotData, deliveryPlaceIndication, jointLotData, lotPlanInfo, cancelled, cancellation, criteria,  **kwargs_)
        self.extendFields = extendFields
        self.extendFields_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, lotTypeIS)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if lotTypeIS.subclass:
            return lotTypeIS.subclass(*args_, **kwargs_)
        else:
            return lotTypeIS(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.extendFields is not None or
            super(lotTypeIS, self).hasContent_()
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(lotTypeIS, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'extendFields':
            obj_ = noticeExtendFieldValueListType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.extendFields = obj_
            obj_.original_tagname_ = 'extendFields'
        super(lotTypeIS, self).buildChildren(child_, node, nodeName_, True)
# end class lotTypeIS


class lotLinkType(GeneratedsSuper):
    """Ccылка на лот"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'guid': MemberSpec_('guid', ['guidType', 'xs:string'], 0, 0, {'name': 'guid', 'type': 'xs:string'}, None),
        'subject': MemberSpec_('subject', ['subjectType95', 'nonEmptyString', 'xs:string'], 0, 0, {'name': 'subject', 'type': 'xs:string'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, guid=None, subject=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.guid = guid
        self.validate_guidType(self.guid)
        self.guid_nsprefix_ = None
        self.subject = subject
        self.validate_subjectType95(self.subject)
        self.subject_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, lotLinkType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if lotLinkType.subclass:
            return lotLinkType.subclass(*args_, **kwargs_)
        else:
            return lotLinkType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_guidType(self, value):
        result = True
        # Validate type guidType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) != 36:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd length restriction on guidType' % {"value": encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_guidType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_guidType_patterns_, ))
                result = False
        return result
    validate_guidType_patterns_ = [['^([a-fA-F0-9]{8}\\-[a-fA-F0-9]{4}\\-[a-fA-F0-9]{4}\\-[a-fA-F0-9]{4}\\-[a-fA-F0-9]{12})$']]
    def validate_subjectType95(self, value):
        result = True
        # Validate type subjectType95, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 2000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on subjectType95' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on subjectType95' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.guid is not None or
            self.subject is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'guid':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'guid')
            value_ = self.gds_validate_string(value_, node, 'guid')
            self.guid = value_
            self.guid_nsprefix_ = child_.prefix
            # validate type guidType
            self.validate_guidType(self.guid)
        elif nodeName_ == 'subject':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'subject')
            value_ = self.gds_validate_string(value_, node, 'subject')
            self.subject = value_
            self.subject_nsprefix_ = child_.prefix
            # validate type subjectType95
            self.validate_subjectType95(self.subject)
# end class lotLinkType


class okeiProductType(GeneratedsSuper):
    """Код единицы измерения по ОКЕИ"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'code': MemberSpec_('code', ['codeType96', 'nonEmptyString', 'xs:string'], 0, 0, {'name': 'code', 'type': 'xs:string'}, None),
        'name': MemberSpec_('name', ['nameType97', 'nonEmptyString', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'name', 'type': 'xs:string'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, code=None, name=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.code = code
        self.validate_codeType96(self.code)
        self.code_nsprefix_ = None
        self.name = name
        self.validate_nameType97(self.name)
        self.name_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, okeiProductType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if okeiProductType.subclass:
            return okeiProductType.subclass(*args_, **kwargs_)
        else:
            return okeiProductType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_codeType96(self, value):
        result = True
        # Validate type codeType96, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 20:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on codeType96' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on codeType96' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_nameType97(self, value):
        result = True
        # Validate type nameType97, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 2000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on nameType97' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on nameType97' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.code is not None or
            self.name is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'code':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'code')
            value_ = self.gds_validate_string(value_, node, 'code')
            self.code = value_
            self.code_nsprefix_ = child_.prefix
            # validate type codeType96
            self.validate_codeType96(self.code)
        elif nodeName_ == 'name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'name')
            value_ = self.gds_validate_string(value_, node, 'name')
            self.name = value_
            self.name_nsprefix_ = child_.prefix
            # validate type nameType97
            self.validate_nameType97(self.name)
# end class okeiProductType


class okvedProductType(GeneratedsSuper):
    """Код товара, работы или услуги по ОКВЭД"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'code': MemberSpec_('code', ['codeOkvedType', 'nonEmptyString', 'xs:string'], 0, 0, {'name': 'code', 'type': 'xs:string'}, None),
        'name': MemberSpec_('name', ['nameType98', 'nonEmptyString', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'name', 'type': 'xs:string'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, code=None, name=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.code = code
        self.validate_codeOkvedType(self.code)
        self.code_nsprefix_ = None
        self.name = name
        self.validate_nameType98(self.name)
        self.name_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, okvedProductType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if okvedProductType.subclass:
            return okvedProductType.subclass(*args_, **kwargs_)
        else:
            return okvedProductType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_codeOkvedType(self, value):
        result = True
        # Validate type codeOkvedType, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on codeOkvedType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_codeOkvedType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_codeOkvedType_patterns_, ))
                result = False
        return result
    validate_codeOkvedType_patterns_ = [['^([A-Q]{1,2}|(\\d{2}((\\.\\d{1,2})|(\\.\\d{2}\\.\\d{1,2}))?))$']]
    def validate_nameType98(self, value):
        result = True
        # Validate type nameType98, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 500:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on nameType98' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on nameType98' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.code is not None or
            self.name is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'code':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'code')
            value_ = self.gds_validate_string(value_, node, 'code')
            self.code = value_
            self.code_nsprefix_ = child_.prefix
            # validate type codeOkvedType
            self.validate_codeOkvedType(self.code)
        elif nodeName_ == 'name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'name')
            value_ = self.gds_validate_string(value_, node, 'name')
            self.name = value_
            self.name_nsprefix_ = child_.prefix
            # validate type nameType98
            self.validate_nameType98(self.name)
# end class okvedProductType


class okved2ProductType(GeneratedsSuper):
    """Код товара, работы или услуги по ОКВЭД2"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'code': MemberSpec_('code', ['codeOkvedType', 'nonEmptyString', 'xs:string'], 0, 0, {'name': 'code', 'type': 'xs:string'}, None),
        'name': MemberSpec_('name', ['nameType99', 'nonEmptyString', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'name', 'type': 'xs:string'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, code=None, name=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.code = code
        self.validate_codeOkvedType(self.code)
        self.code_nsprefix_ = None
        self.name = name
        self.validate_nameType99(self.name)
        self.name_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, okved2ProductType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if okved2ProductType.subclass:
            return okved2ProductType.subclass(*args_, **kwargs_)
        else:
            return okved2ProductType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_codeOkvedType(self, value):
        result = True
        # Validate type codeOkvedType, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on codeOkvedType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_codeOkvedType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_codeOkvedType_patterns_, ))
                result = False
        return result
    validate_codeOkvedType_patterns_ = [['^([A-Q]{1,2}|(\\d{2}((\\.\\d{1,2})|(\\.\\d{2}\\.\\d{1,2}))?))$']]
    def validate_nameType99(self, value):
        result = True
        # Validate type nameType99, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 500:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on nameType99' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on nameType99' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.code is not None or
            self.name is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'code':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'code')
            value_ = self.gds_validate_string(value_, node, 'code')
            self.code = value_
            self.code_nsprefix_ = child_.prefix
            # validate type codeOkvedType
            self.validate_codeOkvedType(self.code)
        elif nodeName_ == 'name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'name')
            value_ = self.gds_validate_string(value_, node, 'name')
            self.name = value_
            self.name_nsprefix_ = child_.prefix
            # validate type nameType99
            self.validate_nameType99(self.name)
# end class okved2ProductType


class okpdProductType(GeneratedsSuper):
    """Код товара, работы или услуги по ОКПД"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'code': MemberSpec_('code', ['codeType100', 'nonEmptyString', 'xs:string'], 0, 0, {'name': 'code', 'type': 'xs:string'}, None),
        'name': MemberSpec_('name', ['nameType101', 'nonEmptyString', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'name', 'type': 'xs:string'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, code=None, name=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.code = code
        self.validate_codeType100(self.code)
        self.code_nsprefix_ = None
        self.name = name
        self.validate_nameType101(self.name)
        self.name_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, okpdProductType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if okpdProductType.subclass:
            return okpdProductType.subclass(*args_, **kwargs_)
        else:
            return okpdProductType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_codeType100(self, value):
        result = True
        # Validate type codeType100, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 20:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on codeType100' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on codeType100' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_nameType101(self, value):
        result = True
        # Validate type nameType101, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 500:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on nameType101' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on nameType101' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.code is not None or
            self.name is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'code':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'code')
            value_ = self.gds_validate_string(value_, node, 'code')
            self.code = value_
            self.code_nsprefix_ = child_.prefix
            # validate type codeType100
            self.validate_codeType100(self.code)
        elif nodeName_ == 'name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'name')
            value_ = self.gds_validate_string(value_, node, 'name')
            self.name = value_
            self.name_nsprefix_ = child_.prefix
            # validate type nameType101
            self.validate_nameType101(self.name)
# end class okpdProductType


class okpd2ProductType(GeneratedsSuper):
    """Код товара, работы или услуги по ОКПД2"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'code': MemberSpec_('code', ['codeType102', 'nonEmptyString', 'xs:string'], 0, 0, {'name': 'code', 'type': 'xs:string'}, None),
        'name': MemberSpec_('name', ['nameType103', 'nonEmptyString', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'name', 'type': 'xs:string'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, code=None, name=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.code = code
        self.validate_codeType102(self.code)
        self.code_nsprefix_ = None
        self.name = name
        self.validate_nameType103(self.name)
        self.name_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, okpd2ProductType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if okpd2ProductType.subclass:
            return okpd2ProductType.subclass(*args_, **kwargs_)
        else:
            return okpd2ProductType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_codeType102(self, value):
        result = True
        # Validate type codeType102, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 20:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on codeType102' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on codeType102' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_nameType103(self, value):
        result = True
        # Validate type nameType103, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 500:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on nameType103' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on nameType103' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.code is not None or
            self.name is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'code':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'code')
            value_ = self.gds_validate_string(value_, node, 'code')
            self.code = value_
            self.code_nsprefix_ = child_.prefix
            # validate type codeType102
            self.validate_codeType102(self.code)
        elif nodeName_ == 'name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'name')
            value_ = self.gds_validate_string(value_, node, 'name')
            self.name = value_
            self.name_nsprefix_ = child_.prefix
            # validate type nameType103
            self.validate_nameType103(self.name)
# end class okpd2ProductType


class okdpProductType(GeneratedsSuper):
    """Код товара, работы или услуги по ОКДП"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'code': MemberSpec_('code', ['codeType104', 'nonEmptyString', 'xs:string'], 0, 0, {'name': 'code', 'type': 'xs:string'}, None),
        'name': MemberSpec_('name', ['nameType105', 'nonEmptyString', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'name', 'type': 'xs:string'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, code=None, name=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.code = code
        self.validate_codeType104(self.code)
        self.code_nsprefix_ = None
        self.name = name
        self.validate_nameType105(self.name)
        self.name_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, okdpProductType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if okdpProductType.subclass:
            return okdpProductType.subclass(*args_, **kwargs_)
        else:
            return okdpProductType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_codeType104(self, value):
        result = True
        # Validate type codeType104, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 20:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on codeType104' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on codeType104' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_nameType105(self, value):
        result = True
        # Validate type nameType105, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 500:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on nameType105' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on nameType105' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.code is not None or
            self.name is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'code':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'code')
            value_ = self.gds_validate_string(value_, node, 'code')
            self.code = value_
            self.code_nsprefix_ = child_.prefix
            # validate type codeType104
            self.validate_codeType104(self.code)
        elif nodeName_ == 'name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'name')
            value_ = self.gds_validate_string(value_, node, 'name')
            self.name = value_
            self.name_nsprefix_ = child_.prefix
            # validate type nameType105
            self.validate_nameType105(self.name)
# end class okdpProductType


class eisXmlDoc(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_) + ['extensiontype_']
    subclass = None
    superclass = None
    def __init__(self, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, eisXmlDoc)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if eisXmlDoc.subclass:
            return eisXmlDoc.subclass(*args_, **kwargs_)
        else:
            return eisXmlDoc(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class eisXmlDoc


class packetType(eisXmlDoc):
    """Пакет данных"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'header': MemberSpec_('header', 'headerType', 0, 0, {'name': 'header', 'type': 'headerType'}, None),
        'signature': MemberSpec_('signature', 'xs:base64Binary', 0, 1, {'minOccurs': '0', 'name': 'signature', 'type': 'xs:base64Binary'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_) + ['extensiontype_']
    subclass = None
    superclass = eisXmlDoc
    def __init__(self, header=None, signature=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(packetType, self).__init__(extensiontype_,  **kwargs_)
        self.header = header
        self.header_nsprefix_ = None
        self.signature = signature
        self.signature_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, packetType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if packetType.subclass:
            return packetType.subclass(*args_, **kwargs_)
        else:
            return packetType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.header is not None or
            self.signature is not None or
            super(packetType, self).hasContent_()
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(packetType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'header':
            obj_ = headerType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.header = obj_
            obj_.original_tagname_ = 'header'
        elif nodeName_ == 'signature':
            sval_ = child_.text
            if sval_ is not None:
                try:
                    bval_ = base64.b64decode(sval_)
                except (TypeError, ValueError) as exp:
                    raise_parse_error(child_, 'requires base64 encoded string: %s' % exp)
                bval_ = self.gds_validate_base64(bval_, node, 'signature')
            else:
                bval_ = None
            self.signature = bval_
            self.signature_nsprefix_ = child_.prefix
        super(packetType, self).buildChildren(child_, node, nodeName_, True)
    def get_xml_tag(self):
        return self.gds_elementtree_node_.tag
# end class packetType


class purchaseInfoType(GeneratedsSuper):
    """Информация о закупке"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'guid': MemberSpec_('guid', ['guidType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'guid', 'type': 'xs:string'}, None),
        'purchaseNoticeNumber': MemberSpec_('purchaseNoticeNumber', ['registrationNumber11Type', 'nonEmptyString', 'xs:string'], 0, 0, {'name': 'purchaseNoticeNumber', 'type': 'xs:string'}, None),
        'publicationDateTime': MemberSpec_('publicationDateTime', 'xs:dateTime', 0, 1, {'minOccurs': '0', 'name': 'publicationDateTime', 'type': 'xs:dateTime'}, None),
        'name': MemberSpec_('name', ['nameType106', 'nonEmptyString', 'xs:string'], 0, 0, {'name': 'name', 'type': 'xs:string'}, None),
        'purchaseMethod': MemberSpec_('purchaseMethod', ['purchaseMethodClassType', 'xs:string'], 0, 0, {'name': 'purchaseMethod', 'type': 'xs:string'}, 8),
        'purchaseMethodCode': MemberSpec_('purchaseMethodCode', 'xs:long', 0, 1, {'minOccurs': '0', 'name': 'purchaseMethodCode', 'type': 'xs:long'}, 8),
        'purchaseCodeName': MemberSpec_('purchaseCodeName', ['purchaseCodeNameType', 'nonEmptyString', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'purchaseCodeName', 'type': 'xs:string'}, 8),
        'emergency': MemberSpec_('emergency', 'xs:boolean', 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'emergency', 'type': 'xs:boolean'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_) + ['extensiontype_']
    subclass = None
    superclass = None
    def __init__(self, guid=None, purchaseNoticeNumber=None, publicationDateTime=None, name=None, purchaseMethod=None, purchaseMethodCode=None, purchaseCodeName=None, emergency=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.guid = guid
        self.validate_guidType(self.guid)
        self.guid_nsprefix_ = None
        self.purchaseNoticeNumber = purchaseNoticeNumber
        self.validate_registrationNumber11Type(self.purchaseNoticeNumber)
        self.purchaseNoticeNumber_nsprefix_ = None
        if isinstance(publicationDateTime, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(publicationDateTime, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = publicationDateTime
        self.publicationDateTime = initvalue_
        self.publicationDateTime_nsprefix_ = None
        self.name = name
        self.validate_nameType106(self.name)
        self.name_nsprefix_ = None
        self.purchaseMethod = purchaseMethod
        self.validate_purchaseMethodClassType(self.purchaseMethod)
        self.purchaseMethod_nsprefix_ = None
        self.purchaseMethodCode = purchaseMethodCode
        self.purchaseMethodCode_nsprefix_ = None
        self.purchaseCodeName = purchaseCodeName
        self.validate_purchaseCodeNameType(self.purchaseCodeName)
        self.purchaseCodeName_nsprefix_ = None
        self.emergency = emergency
        self.emergency_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, purchaseInfoType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if purchaseInfoType.subclass:
            return purchaseInfoType.subclass(*args_, **kwargs_)
        else:
            return purchaseInfoType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_guidType(self, value):
        result = True
        # Validate type guidType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) != 36:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd length restriction on guidType' % {"value": encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_guidType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_guidType_patterns_, ))
                result = False
        return result
    validate_guidType_patterns_ = [['^([a-fA-F0-9]{8}\\-[a-fA-F0-9]{4}\\-[a-fA-F0-9]{4}\\-[a-fA-F0-9]{4}\\-[a-fA-F0-9]{12})$']]
    def validate_registrationNumber11Type(self, value):
        result = True
        # Validate type registrationNumber11Type, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on registrationNumber11Type' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_registrationNumber11Type_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_registrationNumber11Type_patterns_, ))
                result = False
        return result
    validate_registrationNumber11Type_patterns_ = [['^(\\d{11})$']]
    def validate_nameType106(self, value):
        result = True
        # Validate type nameType106, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 2000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on nameType106' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on nameType106' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_purchaseMethodClassType(self, value):
        result = True
        # Validate type purchaseMethodClassType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['OK', 'OA', 'AE', 'AE94', 'ZK', 'EP', 'KESMBO', 'AESMBO', 'ZKESMBO', 'ZPESMBO', 'IS', 'TSK', 'TSA', 'TSZK', 'TSZP', 'TSEP']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on purchaseMethodClassType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_purchaseCodeNameType(self, value):
        result = True
        # Validate type purchaseCodeNameType, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 2000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on purchaseCodeNameType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on purchaseCodeNameType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.guid is not None or
            self.purchaseNoticeNumber is not None or
            self.publicationDateTime is not None or
            self.name is not None or
            self.purchaseMethod is not None or
            self.purchaseMethodCode is not None or
            self.purchaseCodeName is not None or
            self.emergency is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'guid':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'guid')
            value_ = self.gds_validate_string(value_, node, 'guid')
            self.guid = value_
            self.guid_nsprefix_ = child_.prefix
            # validate type guidType
            self.validate_guidType(self.guid)
        elif nodeName_ == 'purchaseNoticeNumber':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'purchaseNoticeNumber')
            value_ = self.gds_validate_string(value_, node, 'purchaseNoticeNumber')
            self.purchaseNoticeNumber = value_
            self.purchaseNoticeNumber_nsprefix_ = child_.prefix
            # validate type registrationNumber11Type
            self.validate_registrationNumber11Type(self.purchaseNoticeNumber)
        elif nodeName_ == 'publicationDateTime':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.publicationDateTime = dval_
            self.publicationDateTime_nsprefix_ = child_.prefix
        elif nodeName_ == 'name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'name')
            value_ = self.gds_validate_string(value_, node, 'name')
            self.name = value_
            self.name_nsprefix_ = child_.prefix
            # validate type nameType106
            self.validate_nameType106(self.name)
        elif nodeName_ == 'purchaseMethod':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'purchaseMethod')
            value_ = self.gds_validate_string(value_, node, 'purchaseMethod')
            self.purchaseMethod = value_
            self.purchaseMethod_nsprefix_ = child_.prefix
            # validate type purchaseMethodClassType
            self.validate_purchaseMethodClassType(self.purchaseMethod)
        elif nodeName_ == 'purchaseMethodCode' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'purchaseMethodCode')
            ival_ = self.gds_validate_integer(ival_, node, 'purchaseMethodCode')
            self.purchaseMethodCode = ival_
            self.purchaseMethodCode_nsprefix_ = child_.prefix
        elif nodeName_ == 'purchaseCodeName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'purchaseCodeName')
            value_ = self.gds_validate_string(value_, node, 'purchaseCodeName')
            self.purchaseCodeName = value_
            self.purchaseCodeName_nsprefix_ = child_.prefix
            # validate type purchaseCodeNameType
            self.validate_purchaseCodeNameType(self.purchaseCodeName)
        elif nodeName_ == 'emergency':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'emergency')
            ival_ = self.gds_validate_boolean(ival_, node, 'emergency')
            self.emergency = ival_
            self.emergency_nsprefix_ = child_.prefix
# end class purchaseInfoType


class contractInfoType(GeneratedsSuper):
    """Информация о договоре"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'contractNumber': MemberSpec_('contractNumber', ['registrationNumber11-2Type', 'nonEmptyString', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'contractNumber', 'type': 'xs:string'}, None),
        'contractDate': MemberSpec_('contractDate', 'xs:date', 0, 0, {'name': 'contractDate', 'type': 'xs:date'}, None),
        'name': MemberSpec_('name', ['nameType107', 'nonEmptyString', 'xs:string'], 0, 0, {'name': 'name', 'type': 'xs:string'}, None),
        'currency': MemberSpec_('currency', 'currencyType', 0, 0, {'name': 'currency', 'type': 'currencyType'}, 9),
        'sum': MemberSpec_('sum', ['money2', 'xs:decimal'], 0, 0, {'name': 'sum', 'type': 'xs:decimal'}, 9),
        'sumInfo': MemberSpec_('sumInfo', ['sumInfoType', 'nonEmptyString', 'xs:string'], 0, 0, {'name': 'sumInfo', 'type': 'xs:string'}, 9),
        'fulfillmentDate': MemberSpec_('fulfillmentDate', ['fulfillmentDateType', 'nonEmptyString', 'xs:string'], 0, 0, {'name': 'fulfillmentDate', 'type': 'xs:string'}, None),
        'cancellationReason': MemberSpec_('cancellationReason', ['cancellationReasonType', 'nonEmptyString', 'xs:string'], 0, 0, {'name': 'cancellationReason', 'type': 'xs:string'}, None),
        'cancellationJudgmentDate': MemberSpec_('cancellationJudgmentDate', 'xs:date', 0, 1, {'minOccurs': '0', 'name': 'cancellationJudgmentDate', 'type': 'xs:date'}, None),
        'cancellationDate': MemberSpec_('cancellationDate', 'xs:date', 0, 1, {'minOccurs': '0', 'name': 'cancellationDate', 'type': 'xs:date'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, contractNumber=None, contractDate=None, name=None, currency=None, sum=None, sumInfo=None, fulfillmentDate=None, cancellationReason=None, cancellationJudgmentDate=None, cancellationDate=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.contractNumber = contractNumber
        self.validate_registrationNumber11_2Type(self.contractNumber)
        self.contractNumber_nsprefix_ = None
        if isinstance(contractDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(contractDate, '%Y-%m-%d').date()
        else:
            initvalue_ = contractDate
        self.contractDate = initvalue_
        self.contractDate_nsprefix_ = None
        self.name = name
        self.validate_nameType107(self.name)
        self.name_nsprefix_ = None
        self.currency = currency
        self.currency_nsprefix_ = None
        self.sum = sum
        self.validate_money2(self.sum)
        self.sum_nsprefix_ = None
        self.sumInfo = sumInfo
        self.validate_sumInfoType(self.sumInfo)
        self.sumInfo_nsprefix_ = None
        self.fulfillmentDate = fulfillmentDate
        self.validate_fulfillmentDateType(self.fulfillmentDate)
        self.fulfillmentDate_nsprefix_ = None
        self.cancellationReason = cancellationReason
        self.validate_cancellationReasonType(self.cancellationReason)
        self.cancellationReason_nsprefix_ = None
        if isinstance(cancellationJudgmentDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(cancellationJudgmentDate, '%Y-%m-%d').date()
        else:
            initvalue_ = cancellationJudgmentDate
        self.cancellationJudgmentDate = initvalue_
        self.cancellationJudgmentDate_nsprefix_ = None
        if isinstance(cancellationDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(cancellationDate, '%Y-%m-%d').date()
        else:
            initvalue_ = cancellationDate
        self.cancellationDate = initvalue_
        self.cancellationDate_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, contractInfoType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if contractInfoType.subclass:
            return contractInfoType.subclass(*args_, **kwargs_)
        else:
            return contractInfoType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_registrationNumber11_2Type(self, value):
        result = True
        # Validate type registrationNumber11-2Type, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on registrationNumber11-2Type' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_registrationNumber11_2Type_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_registrationNumber11_2Type_patterns_, ))
                result = False
        return result
    validate_registrationNumber11_2Type_patterns_ = [['^(\\d{11}-\\d{2})$']]
    def validate_nameType107(self, value):
        result = True
        # Validate type nameType107, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 2000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on nameType107' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on nameType107' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_money2(self, value):
        result = True
        # Validate type money2, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, decimal_.Decimal):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (decimal_.Decimal)' % {"value": value, "lineno": lineno, })
                return False
            if len(str(value)) >= 20:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd totalDigits restriction on money2' % {"value": value, "lineno": lineno} )
                result = False
        return result
    def validate_sumInfoType(self, value):
        result = True
        # Validate type sumInfoType, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 2000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on sumInfoType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on sumInfoType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_fulfillmentDateType(self, value):
        result = True
        # Validate type fulfillmentDateType, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 2000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on fulfillmentDateType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on fulfillmentDateType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_cancellationReasonType(self, value):
        result = True
        # Validate type cancellationReasonType, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 2000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on cancellationReasonType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on cancellationReasonType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.contractNumber is not None or
            self.contractDate is not None or
            self.name is not None or
            self.currency is not None or
            self.sum is not None or
            self.sumInfo is not None or
            self.fulfillmentDate is not None or
            self.cancellationReason is not None or
            self.cancellationJudgmentDate is not None or
            self.cancellationDate is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'contractNumber':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'contractNumber')
            value_ = self.gds_validate_string(value_, node, 'contractNumber')
            self.contractNumber = value_
            self.contractNumber_nsprefix_ = child_.prefix
            # validate type registrationNumber11-2Type
            self.validate_registrationNumber11_2Type(self.contractNumber)
        elif nodeName_ == 'contractDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.contractDate = dval_
            self.contractDate_nsprefix_ = child_.prefix
        elif nodeName_ == 'name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'name')
            value_ = self.gds_validate_string(value_, node, 'name')
            self.name = value_
            self.name_nsprefix_ = child_.prefix
            # validate type nameType107
            self.validate_nameType107(self.name)
        elif nodeName_ == 'currency':
            obj_ = currencyType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.currency = obj_
            obj_.original_tagname_ = 'currency'
        elif nodeName_ == 'sum' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'sum')
            fval_ = self.gds_validate_decimal(fval_, node, 'sum')
            self.sum = fval_
            self.sum_nsprefix_ = child_.prefix
            # validate type money2
            self.validate_money2(self.sum)
        elif nodeName_ == 'sumInfo':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'sumInfo')
            value_ = self.gds_validate_string(value_, node, 'sumInfo')
            self.sumInfo = value_
            self.sumInfo_nsprefix_ = child_.prefix
            # validate type sumInfoType
            self.validate_sumInfoType(self.sumInfo)
        elif nodeName_ == 'fulfillmentDate':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'fulfillmentDate')
            value_ = self.gds_validate_string(value_, node, 'fulfillmentDate')
            self.fulfillmentDate = value_
            self.fulfillmentDate_nsprefix_ = child_.prefix
            # validate type fulfillmentDateType
            self.validate_fulfillmentDateType(self.fulfillmentDate)
        elif nodeName_ == 'cancellationReason':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'cancellationReason')
            value_ = self.gds_validate_string(value_, node, 'cancellationReason')
            self.cancellationReason = value_
            self.cancellationReason_nsprefix_ = child_.prefix
            # validate type cancellationReasonType
            self.validate_cancellationReasonType(self.cancellationReason)
        elif nodeName_ == 'cancellationJudgmentDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.cancellationJudgmentDate = dval_
            self.cancellationJudgmentDate_nsprefix_ = child_.prefix
        elif nodeName_ == 'cancellationDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.cancellationDate = dval_
            self.cancellationDate_nsprefix_ = child_.prefix
# end class contractInfoType


class purchaseInfo2Type(purchaseInfoType):
    """Информация о закупке и лоте"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'lotData': MemberSpec_('lotData', 'lotDataType108', 0, 1, {'minOccurs': '0', 'name': 'lotData', 'type': 'lotDataType108'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = purchaseInfoType
    def __init__(self, guid=None, purchaseNoticeNumber=None, publicationDateTime=None, name=None, purchaseMethod=None, purchaseMethodCode=None, purchaseCodeName=None, emergency=None, lotData=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(purchaseInfo2Type, self).__init__(guid, purchaseNoticeNumber, publicationDateTime, name, purchaseMethod, purchaseMethodCode, purchaseCodeName, emergency,  **kwargs_)
        self.lotData = lotData
        self.lotData_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, purchaseInfo2Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if purchaseInfo2Type.subclass:
            return purchaseInfo2Type.subclass(*args_, **kwargs_)
        else:
            return purchaseInfo2Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.lotData is not None or
            super(purchaseInfo2Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(purchaseInfo2Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'lotData':
            obj_ = lotDataType108.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.lotData = obj_
            obj_.original_tagname_ = 'lotData'
        super(purchaseInfo2Type, self).buildChildren(child_, node, nodeName_, True)
# end class purchaseInfo2Type


class violationListType(GeneratedsSuper):
    """Выявленные в процессе обработки нарушения и ошибки"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'violation': MemberSpec_('violation', 'violationType', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'violation', 'type': 'violationType'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, violation=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if violation is None:
            self.violation = []
        else:
            self.violation = violation
        self.violation_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, violationListType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if violationListType.subclass:
            return violationListType.subclass(*args_, **kwargs_)
        else:
            return violationListType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.violation
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'violation':
            obj_ = violationType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.violation.append(obj_)
            obj_.original_tagname_ = 'violation'
# end class violationListType


class violationType(GeneratedsSuper):
    """Выявленные в процессе обработки нарушения и ошибки"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'code': MemberSpec_('code', 'xs:string', 0, 0, {'name': 'code', 'type': 'xs:string'}, None),
        'level': MemberSpec_('level', ['violation.levelType', 'xs:string'], 0, 0, {'name': 'level', 'type': 'xs:string'}, None),
        'name': MemberSpec_('name', 'xs:string', 0, 0, {'name': 'name', 'type': 'xs:string'}, None),
        'description': MemberSpec_('description', 'xs:string', 0, 1, {'minOccurs': '0', 'name': 'description', 'type': 'xs:string'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, code=None, level=None, name=None, description=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.code = code
        self.code_nsprefix_ = None
        self.level = level
        self.validate_violation_levelType(self.level)
        self.level_nsprefix_ = None
        self.name = name
        self.name_nsprefix_ = None
        self.description = description
        self.description_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, violationType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if violationType.subclass:
            return violationType.subclass(*args_, **kwargs_)
        else:
            return violationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_violation_levelType(self, value):
        result = True
        # Validate type violation.levelType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['error', 'warning']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on violation.levelType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.code is not None or
            self.level is not None or
            self.name is not None or
            self.description is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'code':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'code')
            value_ = self.gds_validate_string(value_, node, 'code')
            self.code = value_
            self.code_nsprefix_ = child_.prefix
        elif nodeName_ == 'level':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'level')
            value_ = self.gds_validate_string(value_, node, 'level')
            self.level = value_
            self.level_nsprefix_ = child_.prefix
            # validate type violation.levelType
            self.validate_violation_levelType(self.level)
        elif nodeName_ == 'name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'name')
            value_ = self.gds_validate_string(value_, node, 'name')
            self.name = value_
            self.name_nsprefix_ = child_.prefix
        elif nodeName_ == 'description':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'description')
            value_ = self.gds_validate_string(value_, node, 'description')
            self.description = value_
            self.description_nsprefix_ = child_.prefix
# end class violationType


class userType(GeneratedsSuper):
    """Информация о пользователе"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'snils': MemberSpec_('snils', ['snilsType', 'nonEmptyString', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'snils', 'type': 'xs:string'}, None),
        'login': MemberSpec_('login', ['loginType', 'nonEmptyString', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'login', 'type': 'xs:string'}, None),
        'firstName': MemberSpec_('firstName', ['firstNameType109', 'nonEmptyString', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'firstName', 'type': 'xs:string'}, None),
        'middleName': MemberSpec_('middleName', ['middleNameType110', 'nonEmptyString', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'middleName', 'type': 'xs:string'}, None),
        'lastName': MemberSpec_('lastName', ['lastNameType111', 'nonEmptyString', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'lastName', 'type': 'xs:string'}, None),
        'phone': MemberSpec_('phone', ['phoneType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'phone', 'type': 'xs:string'}, None),
        'email': MemberSpec_('email', ['emailType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'email', 'type': 'xs:string'}, None),
        'organization': MemberSpec_('organization', 'customerInfoType', 0, 1, {'minOccurs': '0', 'name': 'organization', 'type': 'customerInfoType'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, snils=None, login=None, firstName=None, middleName=None, lastName=None, phone=None, email=None, organization=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.snils = snils
        self.validate_snilsType(self.snils)
        self.snils_nsprefix_ = None
        self.login = login
        self.validate_loginType(self.login)
        self.login_nsprefix_ = None
        self.firstName = firstName
        self.validate_firstNameType109(self.firstName)
        self.firstName_nsprefix_ = None
        self.middleName = middleName
        self.validate_middleNameType110(self.middleName)
        self.middleName_nsprefix_ = None
        self.lastName = lastName
        self.validate_lastNameType111(self.lastName)
        self.lastName_nsprefix_ = None
        self.phone = phone
        self.validate_phoneType(self.phone)
        self.phone_nsprefix_ = None
        self.email = email
        self.validate_emailType(self.email)
        self.email_nsprefix_ = None
        self.organization = organization
        self.organization_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, userType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if userType.subclass:
            return userType.subclass(*args_, **kwargs_)
        else:
            return userType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_snilsType(self, value):
        result = True
        # Validate type snilsType, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 11:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on snilsType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on snilsType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_loginType(self, value):
        result = True
        # Validate type loginType, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 255:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on loginType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on loginType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_firstNameType109(self, value):
        result = True
        # Validate type firstNameType109, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 255:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on firstNameType109' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on firstNameType109' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_middleNameType110(self, value):
        result = True
        # Validate type middleNameType110, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 255:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on middleNameType110' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on middleNameType110' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_lastNameType111(self, value):
        result = True
        # Validate type lastNameType111, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 255:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on lastNameType111' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on lastNameType111' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_phoneType(self, value):
        result = True
        # Validate type phoneType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 300:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on phoneType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on phoneType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_emailType(self, value):
        result = True
        # Validate type emailType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 300:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on emailType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on emailType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_emailType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_emailType_patterns_, ))
                result = False
        return result
    validate_emailType_patterns_ = [["^(([\\-a-zA-Zа-яА-Я0-9!#%&'\\*\\+/=\\?\\^_`\\{\\|\\}~]+(\\.[\\-a-zA-Zа-яА-Я0-9!#%&'\\*\\+/=\\?\\^_`\\{\\|\\}~]+)*@([a-zA-Zа-яА-Я0-9]([\\-_a-zA-Zа-яА-Я0-9]{0,61}[a-zA-Zа-яА-Я0-9])?\\.)*[\\-a-zA-Zа-яА-Я0-9]+(\\.[\\-a-zA-Zа-яА-Я0-9]+)*)+(,\\s?[\\-a-zA-Zа-яА-Я0-9!#%&'\\*\\+/=\\?\\^_`\\{\\|\\}~]+(\\.[\\-a-zA-Zа-яА-Я0-9!#%&'\\*\\+/=\\?\\^_`\\{\\|\\}~]+)*@([a-zA-Zа-яА-Я0-9]([\\-_a-zA-Zа-яА-Я0-9]{0,61}[a-zA-Zа-яА-Я0-9])?\\.)*[\\-a-zA-Zа-яА-Я0-9]+(\\.[\\-a-zA-Zа-яА-Я0-9]+)*)*)$"]]
    def hasContent_(self):
        if (
            self.snils is not None or
            self.login is not None or
            self.firstName is not None or
            self.middleName is not None or
            self.lastName is not None or
            self.phone is not None or
            self.email is not None or
            self.organization is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'snils':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'snils')
            value_ = self.gds_validate_string(value_, node, 'snils')
            self.snils = value_
            self.snils_nsprefix_ = child_.prefix
            # validate type snilsType
            self.validate_snilsType(self.snils)
        elif nodeName_ == 'login':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'login')
            value_ = self.gds_validate_string(value_, node, 'login')
            self.login = value_
            self.login_nsprefix_ = child_.prefix
            # validate type loginType
            self.validate_loginType(self.login)
        elif nodeName_ == 'firstName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'firstName')
            value_ = self.gds_validate_string(value_, node, 'firstName')
            self.firstName = value_
            self.firstName_nsprefix_ = child_.prefix
            # validate type firstNameType109
            self.validate_firstNameType109(self.firstName)
        elif nodeName_ == 'middleName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'middleName')
            value_ = self.gds_validate_string(value_, node, 'middleName')
            self.middleName = value_
            self.middleName_nsprefix_ = child_.prefix
            # validate type middleNameType110
            self.validate_middleNameType110(self.middleName)
        elif nodeName_ == 'lastName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'lastName')
            value_ = self.gds_validate_string(value_, node, 'lastName')
            self.lastName = value_
            self.lastName_nsprefix_ = child_.prefix
            # validate type lastNameType111
            self.validate_lastNameType111(self.lastName)
        elif nodeName_ == 'phone':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'phone')
            value_ = self.gds_validate_string(value_, node, 'phone')
            self.phone = value_
            self.phone_nsprefix_ = child_.prefix
            # validate type phoneType
            self.validate_phoneType(self.phone)
        elif nodeName_ == 'email':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'email')
            value_ = self.gds_validate_string(value_, node, 'email')
            self.email = value_
            self.email_nsprefix_ = child_.prefix
            # validate type emailType
            self.validate_emailType(self.email)
        elif nodeName_ == 'organization':
            obj_ = customerInfoType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.organization = obj_
            obj_.original_tagname_ = 'organization'
# end class userType


class countryType(GeneratedsSuper):
    """Страна"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'name': MemberSpec_('name', ['nameType112', 'nonEmptyString', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'name', 'type': 'xs:string'}, None),
        'digitalCode': MemberSpec_('digitalCode', ['digitalCodeType113', 'nonEmptyString', 'xs:string'], 0, 0, {'name': 'digitalCode', 'type': 'xs:string'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, name=None, digitalCode=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.name = name
        self.validate_nameType112(self.name)
        self.name_nsprefix_ = None
        self.digitalCode = digitalCode
        self.validate_digitalCodeType113(self.digitalCode)
        self.digitalCode_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, countryType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if countryType.subclass:
            return countryType.subclass(*args_, **kwargs_)
        else:
            return countryType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_nameType112(self, value):
        result = True
        # Validate type nameType112, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 500:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on nameType112' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on nameType112' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_digitalCodeType113(self, value):
        result = True
        # Validate type digitalCodeType113, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on digitalCodeType113' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_digitalCodeType113_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_digitalCodeType113_patterns_, ))
                result = False
        return result
    validate_digitalCodeType113_patterns_ = [['^(\\d{3})$']]
    def hasContent_(self):
        if (
            self.name is not None or
            self.digitalCode is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'name')
            value_ = self.gds_validate_string(value_, node, 'name')
            self.name = value_
            self.name_nsprefix_ = child_.prefix
            # validate type nameType112
            self.validate_nameType112(self.name)
        elif nodeName_ == 'digitalCode':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'digitalCode')
            value_ = self.gds_validate_string(value_, node, 'digitalCode')
            self.digitalCode = value_
            self.digitalCode_nsprefix_ = child_.prefix
            # validate type digitalCodeType113
            self.validate_digitalCodeType113(self.digitalCode)
# end class countryType


class baseTemplateType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'id': MemberSpec_('id', 'xs:long', 0, 0, {'name': 'id', 'type': 'xs:long'}, None),
        'parent': MemberSpec_('parent', 'xs:long', 0, 0, {'name': 'parent', 'type': 'xs:long'}, None),
        'status': MemberSpec_('status', ['templateStatusType', 'xs:string'], 0, 0, {'name': 'status', 'type': 'xs:string'}, None),
        'version': MemberSpec_('version', ['templateVersionType', 'xs:long'], 0, 0, {'name': 'version', 'type': 'xs:long'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_) + ['extensiontype_']
    subclass = None
    superclass = None
    def __init__(self, id=None, parent=None, status=None, version=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.id = id
        self.id_nsprefix_ = None
        self.parent = parent
        self.parent_nsprefix_ = None
        self.status = status
        self.validate_templateStatusType(self.status)
        self.status_nsprefix_ = None
        self.version = version
        self.validate_templateVersionType(self.version)
        self.version_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, baseTemplateType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if baseTemplateType.subclass:
            return baseTemplateType.subclass(*args_, **kwargs_)
        else:
            return baseTemplateType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_templateStatusType(self, value):
        result = True
        # Validate type templateStatusType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['I', 'P']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on templateStatusType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_templateVersionType(self, value):
        result = True
        # Validate type templateVersionType, a restriction on xs:long.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            if value < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on templateVersionType' % {"value": value, "lineno": lineno} )
                result = False
            if len(str(value)) >= 5:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd totalDigits restriction on templateVersionType' % {"value": value, "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.id is not None or
            self.parent is not None or
            self.status is not None or
            self.version is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'id' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'id')
            ival_ = self.gds_validate_integer(ival_, node, 'id')
            self.id = ival_
            self.id_nsprefix_ = child_.prefix
        elif nodeName_ == 'parent' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'parent')
            ival_ = self.gds_validate_integer(ival_, node, 'parent')
            self.parent = ival_
            self.parent_nsprefix_ = child_.prefix
        elif nodeName_ == 'status':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'status')
            value_ = self.gds_validate_string(value_, node, 'status')
            self.status = value_
            self.status_nsprefix_ = child_.prefix
            # validate type templateStatusType
            self.validate_templateStatusType(self.status)
        elif nodeName_ == 'version' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'version')
            ival_ = self.gds_validate_integer(ival_, node, 'version')
            self.version = ival_
            self.version_nsprefix_ = child_.prefix
            # validate type templateVersionType
            self.validate_templateVersionType(self.version)
# end class baseTemplateType


class protocolTemplateHideBlocks(GeneratedsSuper):
    """Скрываемые группы полей протокола"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'hideCommDecision': MemberSpec_('hideCommDecision', 'xs:boolean', 0, 0, {'name': 'hideCommDecision', 'type': 'xs:boolean'}, None),
        'hideCommDecisionAccess': MemberSpec_('hideCommDecisionAccess', 'xs:boolean', 0, 0, {'name': 'hideCommDecisionAccess', 'type': 'xs:boolean'}, None),
        'hideCommDecisionResult': MemberSpec_('hideCommDecisionResult', 'xs:boolean', 0, 0, {'name': 'hideCommDecisionResult', 'type': 'xs:boolean'}, None),
        'hideProcedure': MemberSpec_('hideProcedure', 'xs:boolean', 0, 0, {'name': 'hideProcedure', 'type': 'xs:boolean'}, None),
        'hideCancellation': MemberSpec_('hideCancellation', 'xs:boolean', 0, 0, {'name': 'hideCancellation', 'type': 'xs:boolean'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, hideCommDecision=None, hideCommDecisionAccess=None, hideCommDecisionResult=None, hideProcedure=None, hideCancellation=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.hideCommDecision = hideCommDecision
        self.hideCommDecision_nsprefix_ = None
        self.hideCommDecisionAccess = hideCommDecisionAccess
        self.hideCommDecisionAccess_nsprefix_ = None
        self.hideCommDecisionResult = hideCommDecisionResult
        self.hideCommDecisionResult_nsprefix_ = None
        self.hideProcedure = hideProcedure
        self.hideProcedure_nsprefix_ = None
        self.hideCancellation = hideCancellation
        self.hideCancellation_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, protocolTemplateHideBlocks)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if protocolTemplateHideBlocks.subclass:
            return protocolTemplateHideBlocks.subclass(*args_, **kwargs_)
        else:
            return protocolTemplateHideBlocks(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.hideCommDecision is not None or
            self.hideCommDecisionAccess is not None or
            self.hideCommDecisionResult is not None or
            self.hideProcedure is not None or
            self.hideCancellation is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'hideCommDecision':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'hideCommDecision')
            ival_ = self.gds_validate_boolean(ival_, node, 'hideCommDecision')
            self.hideCommDecision = ival_
            self.hideCommDecision_nsprefix_ = child_.prefix
        elif nodeName_ == 'hideCommDecisionAccess':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'hideCommDecisionAccess')
            ival_ = self.gds_validate_boolean(ival_, node, 'hideCommDecisionAccess')
            self.hideCommDecisionAccess = ival_
            self.hideCommDecisionAccess_nsprefix_ = child_.prefix
        elif nodeName_ == 'hideCommDecisionResult':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'hideCommDecisionResult')
            ival_ = self.gds_validate_boolean(ival_, node, 'hideCommDecisionResult')
            self.hideCommDecisionResult = ival_
            self.hideCommDecisionResult_nsprefix_ = child_.prefix
        elif nodeName_ == 'hideProcedure':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'hideProcedure')
            ival_ = self.gds_validate_boolean(ival_, node, 'hideProcedure')
            self.hideProcedure = ival_
            self.hideProcedure_nsprefix_ = child_.prefix
        elif nodeName_ == 'hideCancellation':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'hideCancellation')
            ival_ = self.gds_validate_boolean(ival_, node, 'hideCancellation')
            self.hideCancellation = ival_
            self.hideCancellation_nsprefix_ = child_.prefix
# end class protocolTemplateHideBlocks


class protocolTemplateType(baseTemplateType):
    """Шаблон протокола"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'blocks': MemberSpec_('blocks', 'protocolTemplateHideBlocks', 0, 1, {'minOccurs': '0', 'name': 'blocks', 'type': 'protocolTemplateHideBlocks'}, None),
        'fields': MemberSpec_('fields', 'protocolTemplateFieldList', 0, 1, {'minOccurs': '0', 'name': 'fields', 'type': 'protocolTemplateFieldList'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = baseTemplateType
    def __init__(self, id=None, parent=None, status=None, version=None, blocks=None, fields=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(protocolTemplateType, self).__init__(id, parent, status, version,  **kwargs_)
        self.blocks = blocks
        self.blocks_nsprefix_ = None
        self.fields = fields
        self.fields_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, protocolTemplateType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if protocolTemplateType.subclass:
            return protocolTemplateType.subclass(*args_, **kwargs_)
        else:
            return protocolTemplateType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.blocks is not None or
            self.fields is not None or
            super(protocolTemplateType, self).hasContent_()
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(protocolTemplateType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'blocks':
            obj_ = protocolTemplateHideBlocks.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.blocks = obj_
            obj_.original_tagname_ = 'blocks'
        elif nodeName_ == 'fields':
            obj_ = protocolTemplateFieldList.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.fields = obj_
            obj_.original_tagname_ = 'fields'
        super(protocolTemplateType, self).buildChildren(child_, node, nodeName_, True)
# end class protocolTemplateType


class orderClauseTemplateType(baseTemplateType):
    """Шаблон положения о закупках"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'fields': MemberSpec_('fields', 'orderClauseTemplateFieldList', 0, 1, {'minOccurs': '0', 'name': 'fields', 'type': 'orderClauseTemplateFieldList'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = baseTemplateType
    def __init__(self, id=None, parent=None, status=None, version=None, fields=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(orderClauseTemplateType, self).__init__(id, parent, status, version,  **kwargs_)
        self.fields = fields
        self.fields_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, orderClauseTemplateType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if orderClauseTemplateType.subclass:
            return orderClauseTemplateType.subclass(*args_, **kwargs_)
        else:
            return orderClauseTemplateType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.fields is not None or
            super(orderClauseTemplateType, self).hasContent_()
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(orderClauseTemplateType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'fields':
            obj_ = orderClauseTemplateFieldList.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.fields = obj_
            obj_.original_tagname_ = 'fields'
        super(orderClauseTemplateType, self).buildChildren(child_, node, nodeName_, True)
# end class orderClauseTemplateType


class noticeTemplateType(baseTemplateType):
    """Шаблон извещения"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'copyOfType': MemberSpec_('copyOfType', ['templateExtendPurchaseTypes', 'xs:string'], 0, 0, {'name': 'copyOfType', 'type': 'xs:string'}, None),
        'hiddenFields': MemberSpec_('hiddenFields', ['hiddenFieldsType', 'nonEmptyString', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'hiddenFields', 'type': 'xs:string'}, None),
        'fields': MemberSpec_('fields', 'noticeTemplateFieldList', 0, 1, {'minOccurs': '0', 'name': 'fields', 'type': 'noticeTemplateFieldList'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = baseTemplateType
    def __init__(self, id=None, parent=None, status=None, version=None, copyOfType=None, hiddenFields=None, fields=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(noticeTemplateType, self).__init__(id, parent, status, version,  **kwargs_)
        self.copyOfType = copyOfType
        self.validate_templateExtendPurchaseTypes(self.copyOfType)
        self.copyOfType_nsprefix_ = None
        self.hiddenFields = hiddenFields
        self.validate_hiddenFieldsType(self.hiddenFields)
        self.hiddenFields_nsprefix_ = None
        self.fields = fields
        self.fields_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, noticeTemplateType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if noticeTemplateType.subclass:
            return noticeTemplateType.subclass(*args_, **kwargs_)
        else:
            return noticeTemplateType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_templateExtendPurchaseTypes(self, value):
        result = True
        # Validate type templateExtendPurchaseTypes, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['OK', 'OA', 'OE', 'ZK', 'ZE', 'IS', 'ES']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on templateExtendPurchaseTypes' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_hiddenFieldsType(self, value):
        result = True
        # Validate type hiddenFieldsType, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 20:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on hiddenFieldsType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on hiddenFieldsType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.copyOfType is not None or
            self.hiddenFields is not None or
            self.fields is not None or
            super(noticeTemplateType, self).hasContent_()
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(noticeTemplateType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'copyOfType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'copyOfType')
            value_ = self.gds_validate_string(value_, node, 'copyOfType')
            self.copyOfType = value_
            self.copyOfType_nsprefix_ = child_.prefix
            # validate type templateExtendPurchaseTypes
            self.validate_templateExtendPurchaseTypes(self.copyOfType)
        elif nodeName_ == 'hiddenFields':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'hiddenFields')
            value_ = self.gds_validate_string(value_, node, 'hiddenFields')
            self.hiddenFields = value_
            self.hiddenFields_nsprefix_ = child_.prefix
            # validate type hiddenFieldsType
            self.validate_hiddenFieldsType(self.hiddenFields)
        elif nodeName_ == 'fields':
            obj_ = noticeTemplateFieldList.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.fields = obj_
            obj_.original_tagname_ = 'fields'
        super(noticeTemplateType, self).buildChildren(child_, node, nodeName_, True)
# end class noticeTemplateType


class templateTableType(GeneratedsSuper):
    """Табличное представление данных"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'id': MemberSpec_('id', 'xs:long', 0, 0, {'name': 'id', 'type': 'xs:long'}, None),
        'name': MemberSpec_('name', ['nameType114', 'nonEmptyString', 'xs:string'], 0, 0, {'name': 'name', 'type': 'xs:string'}, None),
        'fixedColumnsData': MemberSpec_('fixedColumnsData', 'fixedColumnsDataType', 0, 1, {'minOccurs': '0', 'name': 'fixedColumnsData', 'type': 'fixedColumnsDataType'}, None),
        'columns': MemberSpec_('columns', 'columnsType', 0, 1, {'minOccurs': '0', 'name': 'columns', 'type': 'columnsType'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, id=None, name=None, fixedColumnsData=None, columns=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.id = id
        self.id_nsprefix_ = None
        self.name = name
        self.validate_nameType114(self.name)
        self.name_nsprefix_ = None
        self.fixedColumnsData = fixedColumnsData
        self.fixedColumnsData_nsprefix_ = None
        self.columns = columns
        self.columns_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, templateTableType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if templateTableType.subclass:
            return templateTableType.subclass(*args_, **kwargs_)
        else:
            return templateTableType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_nameType114(self, value):
        result = True
        # Validate type nameType114, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 100:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on nameType114' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on nameType114' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.id is not None or
            self.name is not None or
            self.fixedColumnsData is not None or
            self.columns is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'id' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'id')
            ival_ = self.gds_validate_integer(ival_, node, 'id')
            self.id = ival_
            self.id_nsprefix_ = child_.prefix
        elif nodeName_ == 'name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'name')
            value_ = self.gds_validate_string(value_, node, 'name')
            self.name = value_
            self.name_nsprefix_ = child_.prefix
            # validate type nameType114
            self.validate_nameType114(self.name)
        elif nodeName_ == 'fixedColumnsData':
            obj_ = fixedColumnsDataType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.fixedColumnsData = obj_
            obj_.original_tagname_ = 'fixedColumnsData'
        elif nodeName_ == 'columns':
            obj_ = columnsType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.columns = obj_
            obj_.original_tagname_ = 'columns'
# end class templateTableType


class templateTableColumnType(GeneratedsSuper):
    """Колонка табличного представления данных"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'colIndex': MemberSpec_('colIndex', ['colIndexType', 'xs:int'], 0, 0, {'name': 'colIndex', 'type': 'xs:int'}, None),
        'colName': MemberSpec_('colName', ['colNameType', 'nonEmptyString', 'xs:string'], 0, 0, {'name': 'colName', 'type': 'xs:string'}, None),
        'colType': MemberSpec_('colType', ['extendFieldType', 'xs:string'], 0, 0, {'name': 'colType', 'type': 'xs:string'}, None),
        'colLength': MemberSpec_('colLength', ['colLengthType', 'xs:decimal'], 0, 1, {'minOccurs': '0', 'name': 'colLength', 'type': 'xs:decimal'}, None),
        'colMandatory': MemberSpec_('colMandatory', 'xs:boolean', 0, 0, {'name': 'colMandatory', 'type': 'xs:boolean'}, None),
        'integrCode': MemberSpec_('integrCode', ['integrCodeType', 'xs:string'], 0, 0, {'name': 'integrCode', 'type': 'xs:string'}, None),
        'typeInfo': MemberSpec_('typeInfo', ['typeInfoType', 'nonEmptyString', 'xs:string'], 0, 0, {'name': 'typeInfo', 'type': 'xs:string'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, colIndex=None, colName=None, colType=None, colLength=None, colMandatory=None, integrCode=None, typeInfo=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.colIndex = colIndex
        self.validate_colIndexType(self.colIndex)
        self.colIndex_nsprefix_ = None
        self.colName = colName
        self.validate_colNameType(self.colName)
        self.colName_nsprefix_ = None
        self.colType = colType
        self.validate_extendFieldType(self.colType)
        self.colType_nsprefix_ = None
        self.colLength = colLength
        self.validate_colLengthType(self.colLength)
        self.colLength_nsprefix_ = None
        self.colMandatory = colMandatory
        self.colMandatory_nsprefix_ = None
        self.integrCode = integrCode
        self.validate_integrCodeType(self.integrCode)
        self.integrCode_nsprefix_ = None
        self.typeInfo = typeInfo
        self.validate_typeInfoType(self.typeInfo)
        self.typeInfo_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, templateTableColumnType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if templateTableColumnType.subclass:
            return templateTableColumnType.subclass(*args_, **kwargs_)
        else:
            return templateTableColumnType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_colIndexType(self, value):
        result = True
        # Validate type colIndexType, a restriction on xs:int.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            if value < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on colIndexType' % {"value": value, "lineno": lineno} )
                result = False
            if value > 10:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxInclusive restriction on colIndexType' % {"value": value, "lineno": lineno} )
                result = False
        return result
    def validate_colNameType(self, value):
        result = True
        # Validate type colNameType, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 40:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on colNameType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on colNameType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_extendFieldType(self, value):
        result = True
        # Validate type extendFieldType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['STRING', 'TEXT', 'INTEGER', 'NUMBER', 'BOOLEAN', 'TIME', 'DATETIME', 'DATE', 'LINK', 'FILE', 'REGEXP', 'CURRENCY', 'UNITS', 'OKDP', 'OKPD2', 'OKVED', 'OKVED2', 'TABLE']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on extendFieldType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_colLengthType(self, value):
        result = True
        # Validate type colLengthType, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, decimal_.Decimal):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (decimal_.Decimal)' % {"value": value, "lineno": lineno, })
                return False
            if len(str(value)) >= 20:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd totalDigits restriction on colLengthType' % {"value": value, "lineno": lineno} )
                result = False
        return result
    def validate_integrCodeType(self, value):
        result = True
        # Validate type integrCodeType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 50:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on integrCodeType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on integrCodeType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_integrCodeType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_integrCodeType_patterns_, ))
                result = False
        return result
    validate_integrCodeType_patterns_ = [['^([_a-zA-Z]+)$']]
    def validate_typeInfoType(self, value):
        result = True
        # Validate type typeInfoType, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 400:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on typeInfoType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on typeInfoType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.colIndex is not None or
            self.colName is not None or
            self.colType is not None or
            self.colLength is not None or
            self.colMandatory is not None or
            self.integrCode is not None or
            self.typeInfo is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'colIndex' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'colIndex')
            ival_ = self.gds_validate_integer(ival_, node, 'colIndex')
            self.colIndex = ival_
            self.colIndex_nsprefix_ = child_.prefix
            # validate type colIndexType
            self.validate_colIndexType(self.colIndex)
        elif nodeName_ == 'colName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'colName')
            value_ = self.gds_validate_string(value_, node, 'colName')
            self.colName = value_
            self.colName_nsprefix_ = child_.prefix
            # validate type colNameType
            self.validate_colNameType(self.colName)
        elif nodeName_ == 'colType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'colType')
            value_ = self.gds_validate_string(value_, node, 'colType')
            self.colType = value_
            self.colType_nsprefix_ = child_.prefix
            # validate type extendFieldType
            self.validate_extendFieldType(self.colType)
        elif nodeName_ == 'colLength' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'colLength')
            fval_ = self.gds_validate_decimal(fval_, node, 'colLength')
            self.colLength = fval_
            self.colLength_nsprefix_ = child_.prefix
            # validate type colLengthType
            self.validate_colLengthType(self.colLength)
        elif nodeName_ == 'colMandatory':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'colMandatory')
            ival_ = self.gds_validate_boolean(ival_, node, 'colMandatory')
            self.colMandatory = ival_
            self.colMandatory_nsprefix_ = child_.prefix
        elif nodeName_ == 'integrCode':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'integrCode')
            value_ = self.gds_validate_string(value_, node, 'integrCode')
            self.integrCode = value_
            self.integrCode_nsprefix_ = child_.prefix
            # validate type integrCodeType
            self.validate_integrCodeType(self.integrCode)
        elif nodeName_ == 'typeInfo':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'typeInfo')
            value_ = self.gds_validate_string(value_, node, 'typeInfo')
            self.typeInfo = value_
            self.typeInfo_nsprefix_ = child_.prefix
            # validate type typeInfoType
            self.validate_typeInfoType(self.typeInfo)
# end class templateTableColumnType


class baseTemplateFieldType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'id': MemberSpec_('id', 'xs:long', 0, 0, {'name': 'id', 'type': 'xs:long'}, None),
        'name': MemberSpec_('name', ['nameType115', 'nonEmptyString', 'xs:string'], 0, 0, {'name': 'name', 'type': 'xs:string'}, None),
        'type_': MemberSpec_('type_', ['extendFieldType', 'xs:string'], 0, 0, {'name': 'type', 'type': 'xs:string'}, None),
        'length': MemberSpec_('length', ['lengthType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'length', 'type': 'xs:string'}, None),
        'mandatory': MemberSpec_('mandatory', 'xs:boolean', 0, 0, {'name': 'mandatory', 'type': 'xs:boolean'}, None),
        'position': MemberSpec_('position', 'templateFieldPositionType', 0, 0, {'name': 'position', 'type': 'templateFieldPositionType'}, None),
        'typeInfo': MemberSpec_('typeInfo', ['typeInfoType116', 'nonEmptyString', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'typeInfo', 'type': 'xs:string'}, None),
        'integrCode': MemberSpec_('integrCode', ['integrCodeType', 'xs:string'], 0, 0, {'name': 'integrCode', 'type': 'xs:string'}, None),
        'indexNumber': MemberSpec_('indexNumber', ['indexNumberType', 'xs:int'], 0, 0, {'name': 'indexNumber', 'type': 'xs:int'}, None),
        'code': MemberSpec_('code', ['codeType117', 'nonEmptyString', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'code', 'type': 'xs:string'}, None),
        'tableType': MemberSpec_('tableType', 'tableType', 0, 1, {'minOccurs': '0', 'name': 'tableType', 'type': 'templateTableType'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_) + ['extensiontype_']
    subclass = None
    superclass = None
    def __init__(self, id=None, name=None, type_=None, length=None, mandatory=None, position=None, typeInfo=None, integrCode=None, indexNumber=None, code=None, tableType=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.id = id
        self.id_nsprefix_ = None
        self.name = name
        self.validate_nameType115(self.name)
        self.name_nsprefix_ = None
        self.type_ = type_
        self.validate_extendFieldType(self.type_)
        self.type__nsprefix_ = None
        self.length = length
        self.validate_lengthType(self.length)
        self.length_nsprefix_ = None
        self.mandatory = mandatory
        self.mandatory_nsprefix_ = None
        self.position = position
        self.position_nsprefix_ = None
        self.typeInfo = typeInfo
        self.validate_typeInfoType116(self.typeInfo)
        self.typeInfo_nsprefix_ = None
        self.integrCode = integrCode
        self.validate_integrCodeType(self.integrCode)
        self.integrCode_nsprefix_ = None
        self.indexNumber = indexNumber
        self.validate_indexNumberType(self.indexNumber)
        self.indexNumber_nsprefix_ = None
        self.code = code
        self.validate_codeType117(self.code)
        self.code_nsprefix_ = None
        self.tableType = tableType
        self.tableType_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, baseTemplateFieldType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if baseTemplateFieldType.subclass:
            return baseTemplateFieldType.subclass(*args_, **kwargs_)
        else:
            return baseTemplateFieldType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_nameType115(self, value):
        result = True
        # Validate type nameType115, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 100:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on nameType115' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on nameType115' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_extendFieldType(self, value):
        result = True
        # Validate type extendFieldType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['STRING', 'TEXT', 'INTEGER', 'NUMBER', 'BOOLEAN', 'TIME', 'DATETIME', 'DATE', 'LINK', 'FILE', 'REGEXP', 'CURRENCY', 'UNITS', 'OKDP', 'OKPD2', 'OKVED', 'OKVED2', 'TABLE']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on extendFieldType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_lengthType(self, value):
        result = True
        # Validate type lengthType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 21:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on lengthType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on lengthType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_lengthType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_lengthType_patterns_, ))
                result = False
        return result
    validate_lengthType_patterns_ = [['^(\\d{1,14}[\\.,]{0,1}\\d{0,6})$']]
    def validate_typeInfoType116(self, value):
        result = True
        # Validate type typeInfoType116, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 100:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on typeInfoType116' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on typeInfoType116' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_integrCodeType(self, value):
        result = True
        # Validate type integrCodeType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 50:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on integrCodeType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on integrCodeType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_integrCodeType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_integrCodeType_patterns_, ))
                result = False
        return result
    validate_integrCodeType_patterns_ = [['^([_a-zA-Z]+)$']]
    def validate_indexNumberType(self, value):
        result = True
        # Validate type indexNumberType, a restriction on xs:int.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            if value < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on indexNumberType' % {"value": value, "lineno": lineno} )
                result = False
            if len(str(value)) >= 3:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd totalDigits restriction on indexNumberType' % {"value": value, "lineno": lineno} )
                result = False
        return result
    def validate_codeType117(self, value):
        result = True
        # Validate type codeType117, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 30:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on codeType117' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on codeType117' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.id is not None or
            self.name is not None or
            self.type_ is not None or
            self.length is not None or
            self.mandatory is not None or
            self.position is not None or
            self.typeInfo is not None or
            self.integrCode is not None or
            self.indexNumber is not None or
            self.code is not None or
            self.tableType is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'id' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'id')
            ival_ = self.gds_validate_integer(ival_, node, 'id')
            self.id = ival_
            self.id_nsprefix_ = child_.prefix
        elif nodeName_ == 'name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'name')
            value_ = self.gds_validate_string(value_, node, 'name')
            self.name = value_
            self.name_nsprefix_ = child_.prefix
            # validate type nameType115
            self.validate_nameType115(self.name)
        elif nodeName_ == 'type':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'type')
            value_ = self.gds_validate_string(value_, node, 'type')
            self.type_ = value_
            self.type_nsprefix_ = child_.prefix
            # validate type extendFieldType
            self.validate_extendFieldType(self.type_)
        elif nodeName_ == 'length':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'length')
            value_ = self.gds_validate_string(value_, node, 'length')
            self.length = value_
            self.length_nsprefix_ = child_.prefix
            # validate type lengthType
            self.validate_lengthType(self.length)
        elif nodeName_ == 'mandatory':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'mandatory')
            ival_ = self.gds_validate_boolean(ival_, node, 'mandatory')
            self.mandatory = ival_
            self.mandatory_nsprefix_ = child_.prefix
        elif nodeName_ == 'position':
            obj_ = templateFieldPositionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.position = obj_
            obj_.original_tagname_ = 'position'
        elif nodeName_ == 'typeInfo':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'typeInfo')
            value_ = self.gds_validate_string(value_, node, 'typeInfo')
            self.typeInfo = value_
            self.typeInfo_nsprefix_ = child_.prefix
            # validate type typeInfoType116
            self.validate_typeInfoType116(self.typeInfo)
        elif nodeName_ == 'integrCode':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'integrCode')
            value_ = self.gds_validate_string(value_, node, 'integrCode')
            self.integrCode = value_
            self.integrCode_nsprefix_ = child_.prefix
            # validate type integrCodeType
            self.validate_integrCodeType(self.integrCode)
        elif nodeName_ == 'indexNumber' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'indexNumber')
            ival_ = self.gds_validate_integer(ival_, node, 'indexNumber')
            self.indexNumber = ival_
            self.indexNumber_nsprefix_ = child_.prefix
            # validate type indexNumberType
            self.validate_indexNumberType(self.indexNumber)
        elif nodeName_ == 'code':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'code')
            value_ = self.gds_validate_string(value_, node, 'code')
            self.code = value_
            self.code_nsprefix_ = child_.prefix
            # validate type codeType117
            self.validate_codeType117(self.code)
        elif nodeName_ == 'tableType':
            obj_ = templateTableType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.tableType = obj_
            obj_.original_tagname_ = 'tableType'
# end class baseTemplateFieldType


class templateFieldPositionType(GeneratedsSuper):
    """Расположение поля"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'tabOrdinal': MemberSpec_('tabOrdinal', 'xs:long', 0, 0, {'name': 'tabOrdinal', 'type': 'xs:long'}, None),
        'tabName': MemberSpec_('tabName', ['tabNameType', 'nonEmptyString', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'tabName', 'type': 'xs:string'}, None),
        'sectionOrdinal': MemberSpec_('sectionOrdinal', 'xs:long', 0, 0, {'name': 'sectionOrdinal', 'type': 'xs:long'}, None),
        'sectionName': MemberSpec_('sectionName', ['sectionNameType', 'nonEmptyString', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'sectionName', 'type': 'xs:string'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, tabOrdinal=None, tabName=None, sectionOrdinal=None, sectionName=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.tabOrdinal = tabOrdinal
        self.tabOrdinal_nsprefix_ = None
        self.tabName = tabName
        self.validate_tabNameType(self.tabName)
        self.tabName_nsprefix_ = None
        self.sectionOrdinal = sectionOrdinal
        self.sectionOrdinal_nsprefix_ = None
        self.sectionName = sectionName
        self.validate_sectionNameType(self.sectionName)
        self.sectionName_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, templateFieldPositionType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if templateFieldPositionType.subclass:
            return templateFieldPositionType.subclass(*args_, **kwargs_)
        else:
            return templateFieldPositionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_tabNameType(self, value):
        result = True
        # Validate type tabNameType, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 130:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on tabNameType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on tabNameType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_sectionNameType(self, value):
        result = True
        # Validate type sectionNameType, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 130:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on sectionNameType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on sectionNameType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.tabOrdinal is not None or
            self.tabName is not None or
            self.sectionOrdinal is not None or
            self.sectionName is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'tabOrdinal' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'tabOrdinal')
            ival_ = self.gds_validate_integer(ival_, node, 'tabOrdinal')
            self.tabOrdinal = ival_
            self.tabOrdinal_nsprefix_ = child_.prefix
        elif nodeName_ == 'tabName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'tabName')
            value_ = self.gds_validate_string(value_, node, 'tabName')
            self.tabName = value_
            self.tabName_nsprefix_ = child_.prefix
            # validate type tabNameType
            self.validate_tabNameType(self.tabName)
        elif nodeName_ == 'sectionOrdinal' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'sectionOrdinal')
            ival_ = self.gds_validate_integer(ival_, node, 'sectionOrdinal')
            self.sectionOrdinal = ival_
            self.sectionOrdinal_nsprefix_ = child_.prefix
        elif nodeName_ == 'sectionName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'sectionName')
            value_ = self.gds_validate_string(value_, node, 'sectionName')
            self.sectionName = value_
            self.sectionName_nsprefix_ = child_.prefix
            # validate type sectionNameType
            self.validate_sectionNameType(self.sectionName)
# end class templateFieldPositionType


class orderClauseTemplateFieldType(baseTemplateFieldType):
    """Поле шаблона положения о закупках"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = baseTemplateFieldType
    def __init__(self, id=None, name=None, type_=None, length=None, mandatory=None, position=None, typeInfo=None, integrCode=None, indexNumber=None, code=None, tableType=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(orderClauseTemplateFieldType, self).__init__(id, name, type_, length, mandatory, position, typeInfo, integrCode, indexNumber, code, tableType,  **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, orderClauseTemplateFieldType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if orderClauseTemplateFieldType.subclass:
            return orderClauseTemplateFieldType.subclass(*args_, **kwargs_)
        else:
            return orderClauseTemplateFieldType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(orderClauseTemplateFieldType, self).hasContent_()
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(orderClauseTemplateFieldType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(orderClauseTemplateFieldType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class orderClauseTemplateFieldType


class noticeTemplateFieldType(baseTemplateFieldType):
    """Поле шаблона извещения"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'tabLevel': MemberSpec_('tabLevel', ['noticeTemplateFieldLevelType', 'xs:string'], 0, 0, {'name': 'tabLevel', 'type': 'xs:string'}, None),
        'isBaseField': MemberSpec_('isBaseField', 'xs:boolean', 0, 0, {'name': 'isBaseField', 'type': 'xs:boolean'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = baseTemplateFieldType
    def __init__(self, id=None, name=None, type_=None, length=None, mandatory=None, position=None, typeInfo=None, integrCode=None, indexNumber=None, code=None, tableType=None, tabLevel=None, isBaseField=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(noticeTemplateFieldType, self).__init__(id, name, type_, length, mandatory, position, typeInfo, integrCode, indexNumber, code, tableType,  **kwargs_)
        self.tabLevel = tabLevel
        self.validate_noticeTemplateFieldLevelType(self.tabLevel)
        self.tabLevel_nsprefix_ = None
        self.isBaseField = isBaseField
        self.isBaseField_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, noticeTemplateFieldType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if noticeTemplateFieldType.subclass:
            return noticeTemplateFieldType.subclass(*args_, **kwargs_)
        else:
            return noticeTemplateFieldType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_noticeTemplateFieldLevelType(self, value):
        result = True
        # Validate type noticeTemplateFieldLevelType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['NOTICE', 'LOT', 'LOT_CUSTOMER']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on noticeTemplateFieldLevelType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.tabLevel is not None or
            self.isBaseField is not None or
            super(noticeTemplateFieldType, self).hasContent_()
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(noticeTemplateFieldType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'tabLevel':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'tabLevel')
            value_ = self.gds_validate_string(value_, node, 'tabLevel')
            self.tabLevel = value_
            self.tabLevel_nsprefix_ = child_.prefix
            # validate type noticeTemplateFieldLevelType
            self.validate_noticeTemplateFieldLevelType(self.tabLevel)
        elif nodeName_ == 'isBaseField':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'isBaseField')
            ival_ = self.gds_validate_boolean(ival_, node, 'isBaseField')
            self.isBaseField = ival_
            self.isBaseField_nsprefix_ = child_.prefix
        super(noticeTemplateFieldType, self).buildChildren(child_, node, nodeName_, True)
# end class noticeTemplateFieldType


class protocolTemplateFieldType(baseTemplateFieldType):
    """Поле шаблона протокола"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'tabLevel': MemberSpec_('tabLevel', ['protocolTemplateFieldLevelType', 'xs:string'], 0, 0, {'name': 'tabLevel', 'type': 'xs:string'}, None),
        'isBaseField': MemberSpec_('isBaseField', 'xs:boolean', 0, 0, {'name': 'isBaseField', 'type': 'xs:boolean'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = baseTemplateFieldType
    def __init__(self, id=None, name=None, type_=None, length=None, mandatory=None, position=None, typeInfo=None, integrCode=None, indexNumber=None, code=None, tableType=None, tabLevel=None, isBaseField=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(protocolTemplateFieldType, self).__init__(id, name, type_, length, mandatory, position, typeInfo, integrCode, indexNumber, code, tableType,  **kwargs_)
        self.tabLevel = tabLevel
        self.validate_protocolTemplateFieldLevelType(self.tabLevel)
        self.tabLevel_nsprefix_ = None
        self.isBaseField = isBaseField
        self.isBaseField_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, protocolTemplateFieldType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if protocolTemplateFieldType.subclass:
            return protocolTemplateFieldType.subclass(*args_, **kwargs_)
        else:
            return protocolTemplateFieldType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_protocolTemplateFieldLevelType(self, value):
        result = True
        # Validate type protocolTemplateFieldLevelType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['PROTOCOL', 'APPLICATION']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on protocolTemplateFieldLevelType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.tabLevel is not None or
            self.isBaseField is not None or
            super(protocolTemplateFieldType, self).hasContent_()
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(protocolTemplateFieldType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'tabLevel':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'tabLevel')
            value_ = self.gds_validate_string(value_, node, 'tabLevel')
            self.tabLevel = value_
            self.tabLevel_nsprefix_ = child_.prefix
            # validate type protocolTemplateFieldLevelType
            self.validate_protocolTemplateFieldLevelType(self.tabLevel)
        elif nodeName_ == 'isBaseField':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'isBaseField')
            ival_ = self.gds_validate_boolean(ival_, node, 'isBaseField')
            self.isBaseField = ival_
            self.isBaseField_nsprefix_ = child_.prefix
        super(protocolTemplateFieldType, self).buildChildren(child_, node, nodeName_, True)
# end class protocolTemplateFieldType


class orderClauseTemplateFieldList(GeneratedsSuper):
    """Поля шаблона положения о закупках"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'field': MemberSpec_('field', 'orderClauseTemplateFieldType', 1, 0, {'maxOccurs': 'unbounded', 'minOccurs': '1', 'name': 'field', 'type': 'orderClauseTemplateFieldType'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, field=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if field is None:
            self.field = []
        else:
            self.field = field
        self.field_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, orderClauseTemplateFieldList)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if orderClauseTemplateFieldList.subclass:
            return orderClauseTemplateFieldList.subclass(*args_, **kwargs_)
        else:
            return orderClauseTemplateFieldList(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.field
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'field':
            obj_ = orderClauseTemplateFieldType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.field.append(obj_)
            obj_.original_tagname_ = 'field'
# end class orderClauseTemplateFieldList


class noticeTemplateFieldList(GeneratedsSuper):
    """Поля шаблона извещения"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'field': MemberSpec_('field', 'noticeTemplateFieldType', 1, 0, {'maxOccurs': 'unbounded', 'minOccurs': '1', 'name': 'field', 'type': 'noticeTemplateFieldType'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, field=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if field is None:
            self.field = []
        else:
            self.field = field
        self.field_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, noticeTemplateFieldList)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if noticeTemplateFieldList.subclass:
            return noticeTemplateFieldList.subclass(*args_, **kwargs_)
        else:
            return noticeTemplateFieldList(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.field
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'field':
            obj_ = noticeTemplateFieldType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.field.append(obj_)
            obj_.original_tagname_ = 'field'
# end class noticeTemplateFieldList


class protocolTemplateFieldList(GeneratedsSuper):
    """Поля шаблона протокола"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'field': MemberSpec_('field', 'protocolTemplateFieldType', 1, 0, {'maxOccurs': 'unbounded', 'minOccurs': '1', 'name': 'field', 'type': 'protocolTemplateFieldType'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, field=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if field is None:
            self.field = []
        else:
            self.field = field
        self.field_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, protocolTemplateFieldList)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if protocolTemplateFieldList.subclass:
            return protocolTemplateFieldList.subclass(*args_, **kwargs_)
        else:
            return protocolTemplateFieldList(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.field
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'field':
            obj_ = protocolTemplateFieldType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.field.append(obj_)
            obj_.original_tagname_ = 'field'
# end class protocolTemplateFieldList


class noticeExtendFieldValueListType(GeneratedsSuper):
    """Значения дополнительных полей шаблона извещения"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'noticeExtendField': MemberSpec_('noticeExtendField', 'noticeExtendBlockFieldType', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'noticeExtendField', 'type': 'noticeExtendBlockFieldType'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, noticeExtendField=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if noticeExtendField is None:
            self.noticeExtendField = []
        else:
            self.noticeExtendField = noticeExtendField
        self.noticeExtendField_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, noticeExtendFieldValueListType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if noticeExtendFieldValueListType.subclass:
            return noticeExtendFieldValueListType.subclass(*args_, **kwargs_)
        else:
            return noticeExtendFieldValueListType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.noticeExtendField
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'noticeExtendField':
            obj_ = noticeExtendBlockFieldType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.noticeExtendField.append(obj_)
            obj_.original_tagname_ = 'noticeExtendField'
# end class noticeExtendFieldValueListType


class protocolExtendFieldValueListType(GeneratedsSuper):
    """Значения дополнительных полей шаблона протокола"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'protocolExtendField': MemberSpec_('protocolExtendField', 'protocolExtendBlockFieldType', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'protocolExtendField', 'type': 'protocolExtendBlockFieldType'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, protocolExtendField=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if protocolExtendField is None:
            self.protocolExtendField = []
        else:
            self.protocolExtendField = protocolExtendField
        self.protocolExtendField_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, protocolExtendFieldValueListType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if protocolExtendFieldValueListType.subclass:
            return protocolExtendFieldValueListType.subclass(*args_, **kwargs_)
        else:
            return protocolExtendFieldValueListType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.protocolExtendField
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'protocolExtendField':
            obj_ = protocolExtendBlockFieldType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.protocolExtendField.append(obj_)
            obj_.original_tagname_ = 'protocolExtendField'
# end class protocolExtendFieldValueListType


class orderClauseExtendFieldValueListType(GeneratedsSuper):
    """Значения дополнительных полей положения о закупках"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'orderClauseExtendField': MemberSpec_('orderClauseExtendField', 'orderClauseExtendBlockFieldType', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'orderClauseExtendField', 'type': 'orderClauseExtendBlockFieldType'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, orderClauseExtendField=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if orderClauseExtendField is None:
            self.orderClauseExtendField = []
        else:
            self.orderClauseExtendField = orderClauseExtendField
        self.orderClauseExtendField_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, orderClauseExtendFieldValueListType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if orderClauseExtendFieldValueListType.subclass:
            return orderClauseExtendFieldValueListType.subclass(*args_, **kwargs_)
        else:
            return orderClauseExtendFieldValueListType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.orderClauseExtendField
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'orderClauseExtendField':
            obj_ = orderClauseExtendBlockFieldType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.orderClauseExtendField.append(obj_)
            obj_.original_tagname_ = 'orderClauseExtendField'
# end class orderClauseExtendFieldValueListType


class baseExtendFieldType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'integrCode': MemberSpec_('integrCode', ['integrCodeType', 'xs:string'], 0, 0, {'name': 'integrCode', 'type': 'xs:string'}, None),
        'description': MemberSpec_('description', ['descriptionType118', 'nonEmptyString', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'description', 'type': 'xs:string'}, None),
        'type_': MemberSpec_('type_', ['extendFieldType', 'xs:string'], 0, 0, {'name': 'type', 'type': 'xs:string'}, None),
        'value': MemberSpec_('value', 'fieldValueType', 0, 0, {'name': 'value', 'type': 'fieldValueType'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, integrCode=None, description=None, type_=None, value=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.integrCode = integrCode
        self.validate_integrCodeType(self.integrCode)
        self.integrCode_nsprefix_ = None
        self.description = description
        self.validate_descriptionType118(self.description)
        self.description_nsprefix_ = None
        self.type_ = type_
        self.validate_extendFieldType(self.type_)
        self.type__nsprefix_ = None
        self.value = value
        self.value_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, baseExtendFieldType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if baseExtendFieldType.subclass:
            return baseExtendFieldType.subclass(*args_, **kwargs_)
        else:
            return baseExtendFieldType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_integrCodeType(self, value):
        result = True
        # Validate type integrCodeType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 50:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on integrCodeType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on integrCodeType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_integrCodeType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_integrCodeType_patterns_, ))
                result = False
        return result
    validate_integrCodeType_patterns_ = [['^([_a-zA-Z]+)$']]
    def validate_descriptionType118(self, value):
        result = True
        # Validate type descriptionType118, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 200:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on descriptionType118' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on descriptionType118' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_extendFieldType(self, value):
        result = True
        # Validate type extendFieldType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['STRING', 'TEXT', 'INTEGER', 'NUMBER', 'BOOLEAN', 'TIME', 'DATETIME', 'DATE', 'LINK', 'FILE', 'REGEXP', 'CURRENCY', 'UNITS', 'OKDP', 'OKPD2', 'OKVED', 'OKVED2', 'TABLE']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on extendFieldType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.integrCode is not None or
            self.description is not None or
            self.type_ is not None or
            self.value is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'integrCode':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'integrCode')
            value_ = self.gds_validate_string(value_, node, 'integrCode')
            self.integrCode = value_
            self.integrCode_nsprefix_ = child_.prefix
            # validate type integrCodeType
            self.validate_integrCodeType(self.integrCode)
        elif nodeName_ == 'description':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'description')
            value_ = self.gds_validate_string(value_, node, 'description')
            self.description = value_
            self.description_nsprefix_ = child_.prefix
            # validate type descriptionType118
            self.validate_descriptionType118(self.description)
        elif nodeName_ == 'type':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'type')
            value_ = self.gds_validate_string(value_, node, 'type')
            self.type_ = value_
            self.type_nsprefix_ = child_.prefix
            # validate type extendFieldType
            self.validate_extendFieldType(self.type_)
        elif nodeName_ == 'value':
            obj_ = fieldValueType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.value = obj_
            obj_.original_tagname_ = 'value'
# end class baseExtendFieldType


class baseExtendBlockFieldType(GeneratedsSuper):
    """Значения дополнительных полей извещения/протокола"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'extendField': MemberSpec_('extendField', 'baseExtendFieldType', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'extendField', 'type': 'baseExtendFieldType'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_) + ['extensiontype_']
    subclass = None
    superclass = None
    def __init__(self, extendField=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if extendField is None:
            self.extendField = []
        else:
            self.extendField = extendField
        self.extendField_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, baseExtendBlockFieldType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if baseExtendBlockFieldType.subclass:
            return baseExtendBlockFieldType.subclass(*args_, **kwargs_)
        else:
            return baseExtendBlockFieldType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.extendField
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'extendField':
            obj_ = baseExtendFieldType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.extendField.append(obj_)
            obj_.original_tagname_ = 'extendField'
# end class baseExtendBlockFieldType


class noticeExtendBlockFieldType(baseExtendBlockFieldType):
    """Дополнительные поля шаблона извещения"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'position': MemberSpec_('position', 'templateFieldPositionType', 0, 0, {'name': 'position', 'type': 'templateFieldPositionType'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = baseExtendBlockFieldType
    def __init__(self, extendField=None, position=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(noticeExtendBlockFieldType, self).__init__(extendField,  **kwargs_)
        self.position = position
        self.position_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, noticeExtendBlockFieldType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if noticeExtendBlockFieldType.subclass:
            return noticeExtendBlockFieldType.subclass(*args_, **kwargs_)
        else:
            return noticeExtendBlockFieldType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.position is not None or
            super(noticeExtendBlockFieldType, self).hasContent_()
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(noticeExtendBlockFieldType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'position':
            obj_ = templateFieldPositionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.position = obj_
            obj_.original_tagname_ = 'position'
        super(noticeExtendBlockFieldType, self).buildChildren(child_, node, nodeName_, True)
# end class noticeExtendBlockFieldType


class protocolExtendBlockFieldType(baseExtendBlockFieldType):
    """Дополнительные поля шаблона протокола"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'position': MemberSpec_('position', 'templateFieldPositionType', 0, 0, {'name': 'position', 'type': 'templateFieldPositionType'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = baseExtendBlockFieldType
    def __init__(self, extendField=None, position=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(protocolExtendBlockFieldType, self).__init__(extendField,  **kwargs_)
        self.position = position
        self.position_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, protocolExtendBlockFieldType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if protocolExtendBlockFieldType.subclass:
            return protocolExtendBlockFieldType.subclass(*args_, **kwargs_)
        else:
            return protocolExtendBlockFieldType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.position is not None or
            super(protocolExtendBlockFieldType, self).hasContent_()
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(protocolExtendBlockFieldType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'position':
            obj_ = templateFieldPositionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.position = obj_
            obj_.original_tagname_ = 'position'
        super(protocolExtendBlockFieldType, self).buildChildren(child_, node, nodeName_, True)
# end class protocolExtendBlockFieldType


class orderClauseExtendBlockFieldType(baseExtendBlockFieldType):
    """Дополнительные поля шаблона положения о закупках"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'position': MemberSpec_('position', 'templateFieldPositionType', 0, 0, {'name': 'position', 'type': 'templateFieldPositionType'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = baseExtendBlockFieldType
    def __init__(self, extendField=None, position=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(orderClauseExtendBlockFieldType, self).__init__(extendField,  **kwargs_)
        self.position = position
        self.position_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, orderClauseExtendBlockFieldType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if orderClauseExtendBlockFieldType.subclass:
            return orderClauseExtendBlockFieldType.subclass(*args_, **kwargs_)
        else:
            return orderClauseExtendBlockFieldType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.position is not None or
            super(orderClauseExtendBlockFieldType, self).hasContent_()
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(orderClauseExtendBlockFieldType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'position':
            obj_ = templateFieldPositionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.position = obj_
            obj_.original_tagname_ = 'position'
        super(orderClauseExtendBlockFieldType, self).buildChildren(child_, node, nodeName_, True)
# end class orderClauseExtendBlockFieldType


class fieldValueType(GeneratedsSuper):
    """Значение поля данных"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'string': MemberSpec_('string', ['stringType', 'nonEmptyString', 'xs:string'], 0, 0, {'name': 'string', 'type': 'xs:string'}, 10),
        'text': MemberSpec_('text', ['textType', 'nonEmptyString', 'xs:string'], 0, 0, {'name': 'text', 'type': 'xs:string'}, 10),
        'integer': MemberSpec_('integer', 'xs:int', 0, 0, {'name': 'integer', 'type': 'xs:int'}, 10),
        'number': MemberSpec_('number', 'xs:decimal', 0, 0, {'name': 'number', 'type': 'xs:decimal'}, 10),
        'boolean': MemberSpec_('boolean', 'xs:boolean', 0, 0, {'name': 'boolean', 'type': 'xs:boolean'}, 10),
        'time': MemberSpec_('time', 'xs:time', 0, 0, {'name': 'time', 'type': 'xs:time'}, 10),
        'dateTime': MemberSpec_('dateTime', 'xs:dateTime', 0, 0, {'name': 'dateTime', 'type': 'xs:dateTime'}, 10),
        'date': MemberSpec_('date', 'xs:date', 0, 0, {'name': 'date', 'type': 'xs:date'}, 10),
        'url': MemberSpec_('url', ['urlType119', 'nonEmptyString', 'xs:string'], 0, 0, {'name': 'url', 'type': 'xs:string'}, 10),
        'attachments': MemberSpec_('attachments', 'documentListType', 0, 0, {'name': 'attachments', 'type': 'documentListType'}, 10),
        'nsi': MemberSpec_('nsi', 'nsiType', 0, 0, {'name': 'nsi', 'type': 'nsiType'}, 10),
        'table': MemberSpec_('table', 'tableType', 0, 0, {'name': 'table', 'type': 'tableType'}, 10),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, string=None, text=None, integer=None, number=None, boolean=None, time=None, dateTime=None, date=None, url=None, attachments=None, nsi=None, table=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.string = string
        self.validate_stringType(self.string)
        self.string_nsprefix_ = None
        self.text = text
        self.validate_textType(self.text)
        self.text_nsprefix_ = None
        self.integer = integer
        self.integer_nsprefix_ = None
        self.number = number
        self.number_nsprefix_ = None
        self.boolean = boolean
        self.boolean_nsprefix_ = None
        if isinstance(time, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(time, '%H:%M:%S').time()
        else:
            initvalue_ = time
        self.time = initvalue_
        self.time_nsprefix_ = None
        if isinstance(dateTime, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(dateTime, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = dateTime
        self.dateTime = initvalue_
        self.dateTime_nsprefix_ = None
        if isinstance(date, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(date, '%Y-%m-%d').date()
        else:
            initvalue_ = date
        self.date = initvalue_
        self.date_nsprefix_ = None
        self.url = url
        self.validate_urlType119(self.url)
        self.url_nsprefix_ = None
        self.attachments = attachments
        self.attachments_nsprefix_ = None
        self.nsi = nsi
        self.nsi_nsprefix_ = None
        self.table = table
        self.table_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, fieldValueType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if fieldValueType.subclass:
            return fieldValueType.subclass(*args_, **kwargs_)
        else:
            return fieldValueType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_stringType(self, value):
        result = True
        # Validate type stringType, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on stringType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on stringType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_textType(self, value):
        result = True
        # Validate type textType, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 2000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on textType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on textType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_urlType119(self, value):
        result = True
        # Validate type urlType119, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on urlType119' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on urlType119' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.string is not None or
            self.text is not None or
            self.integer is not None or
            self.number is not None or
            self.boolean is not None or
            self.time is not None or
            self.dateTime is not None or
            self.date is not None or
            self.url is not None or
            self.attachments is not None or
            self.nsi is not None or
            self.table is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'string':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'string')
            value_ = self.gds_validate_string(value_, node, 'string')
            self.string = value_
            self.string_nsprefix_ = child_.prefix
            # validate type stringType
            self.validate_stringType(self.string)
        elif nodeName_ == 'text':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'text')
            value_ = self.gds_validate_string(value_, node, 'text')
            self.text = value_
            self.text_nsprefix_ = child_.prefix
            # validate type textType
            self.validate_textType(self.text)
        elif nodeName_ == 'integer' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'integer')
            ival_ = self.gds_validate_integer(ival_, node, 'integer')
            self.integer = ival_
            self.integer_nsprefix_ = child_.prefix
        elif nodeName_ == 'number' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'number')
            fval_ = self.gds_validate_decimal(fval_, node, 'number')
            self.number = fval_
            self.number_nsprefix_ = child_.prefix
        elif nodeName_ == 'boolean':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'boolean')
            self.boolean = ival_
            self.boolean_nsprefix_ = child_.prefix
        elif nodeName_ == 'time':
            sval_ = child_.text
            dval_ = self.gds_parse_time(sval_)
            self.time = dval_
            self.time_nsprefix_ = child_.prefix
        elif nodeName_ == 'dateTime':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.dateTime = dval_
            self.dateTime_nsprefix_ = child_.prefix
        elif nodeName_ == 'date':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.date = dval_
            self.date_nsprefix_ = child_.prefix
        elif nodeName_ == 'url':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'url')
            value_ = self.gds_validate_string(value_, node, 'url')
            self.url = value_
            self.url_nsprefix_ = child_.prefix
            # validate type urlType119
            self.validate_urlType119(self.url)
        elif nodeName_ == 'attachments':
            obj_ = documentListType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.attachments = obj_
            obj_.original_tagname_ = 'attachments'
        elif nodeName_ == 'nsi':
            obj_ = nsiType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.nsi = obj_
            obj_.original_tagname_ = 'nsi'
        elif nodeName_ == 'table':
            obj_ = tableType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.table = obj_
            obj_.original_tagname_ = 'table'
# end class fieldValueType


class extendTableRowType(GeneratedsSuper):
    """Строка табличного представления"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'column': MemberSpec_('column', 'extendTableColumnType', 1, 0, {'maxOccurs': '10', 'minOccurs': '1', 'name': 'column', 'type': 'extendTableColumnType'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, column=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if column is None:
            self.column = []
        else:
            self.column = column
        self.column_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, extendTableRowType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if extendTableRowType.subclass:
            return extendTableRowType.subclass(*args_, **kwargs_)
        else:
            return extendTableRowType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.column
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'column':
            obj_ = extendTableColumnType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.column.append(obj_)
            obj_.original_tagname_ = 'column'
# end class extendTableRowType


class extendTableColumnType(GeneratedsSuper):
    """Столбец табличного представления"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'colIndex': MemberSpec_('colIndex', ['colIndexType120', 'xs:int'], 0, 0, {'name': 'colIndex', 'type': 'xs:int'}, None),
        'colType': MemberSpec_('colType', ['extendFieldType', 'xs:string'], 0, 0, {'name': 'colType', 'type': 'xs:string'}, None),
        'integrCode': MemberSpec_('integrCode', ['integrCodeType', 'xs:string'], 0, 0, {'name': 'integrCode', 'type': 'xs:string'}, None),
        'value': MemberSpec_('value', 'tableColumnValueType', 0, 0, {'name': 'value', 'type': 'tableColumnValueType'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, colIndex=None, colType=None, integrCode=None, value=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.colIndex = colIndex
        self.validate_colIndexType120(self.colIndex)
        self.colIndex_nsprefix_ = None
        self.colType = colType
        self.validate_extendFieldType(self.colType)
        self.colType_nsprefix_ = None
        self.integrCode = integrCode
        self.validate_integrCodeType(self.integrCode)
        self.integrCode_nsprefix_ = None
        self.value = value
        self.value_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, extendTableColumnType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if extendTableColumnType.subclass:
            return extendTableColumnType.subclass(*args_, **kwargs_)
        else:
            return extendTableColumnType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_colIndexType120(self, value):
        result = True
        # Validate type colIndexType120, a restriction on xs:int.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            if value < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on colIndexType120' % {"value": value, "lineno": lineno} )
                result = False
            if value > 10:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxInclusive restriction on colIndexType120' % {"value": value, "lineno": lineno} )
                result = False
        return result
    def validate_extendFieldType(self, value):
        result = True
        # Validate type extendFieldType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['STRING', 'TEXT', 'INTEGER', 'NUMBER', 'BOOLEAN', 'TIME', 'DATETIME', 'DATE', 'LINK', 'FILE', 'REGEXP', 'CURRENCY', 'UNITS', 'OKDP', 'OKPD2', 'OKVED', 'OKVED2', 'TABLE']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on extendFieldType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_integrCodeType(self, value):
        result = True
        # Validate type integrCodeType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 50:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on integrCodeType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on integrCodeType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_integrCodeType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_integrCodeType_patterns_, ))
                result = False
        return result
    validate_integrCodeType_patterns_ = [['^([_a-zA-Z]+)$']]
    def hasContent_(self):
        if (
            self.colIndex is not None or
            self.colType is not None or
            self.integrCode is not None or
            self.value is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'colIndex' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'colIndex')
            ival_ = self.gds_validate_integer(ival_, node, 'colIndex')
            self.colIndex = ival_
            self.colIndex_nsprefix_ = child_.prefix
            # validate type colIndexType120
            self.validate_colIndexType120(self.colIndex)
        elif nodeName_ == 'colType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'colType')
            value_ = self.gds_validate_string(value_, node, 'colType')
            self.colType = value_
            self.colType_nsprefix_ = child_.prefix
            # validate type extendFieldType
            self.validate_extendFieldType(self.colType)
        elif nodeName_ == 'integrCode':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'integrCode')
            value_ = self.gds_validate_string(value_, node, 'integrCode')
            self.integrCode = value_
            self.integrCode_nsprefix_ = child_.prefix
            # validate type integrCodeType
            self.validate_integrCodeType(self.integrCode)
        elif nodeName_ == 'value':
            obj_ = tableColumnValueType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.value = obj_
            obj_.original_tagname_ = 'value'
# end class extendTableColumnType


class tableColumnValueType(GeneratedsSuper):
    """Значение поля данных"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'string': MemberSpec_('string', ['stringType121', 'nonEmptyString', 'xs:string'], 0, 0, {'name': 'string', 'type': 'xs:string'}, 11),
        'text': MemberSpec_('text', ['textType122', 'nonEmptyString', 'xs:string'], 0, 0, {'name': 'text', 'type': 'xs:string'}, 11),
        'integer': MemberSpec_('integer', 'xs:int', 0, 0, {'name': 'integer', 'type': 'xs:int'}, 11),
        'number': MemberSpec_('number', 'xs:decimal', 0, 0, {'name': 'number', 'type': 'xs:decimal'}, 11),
        'boolean': MemberSpec_('boolean', 'xs:boolean', 0, 0, {'name': 'boolean', 'type': 'xs:boolean'}, 11),
        'time': MemberSpec_('time', 'xs:time', 0, 0, {'name': 'time', 'type': 'xs:time'}, 11),
        'dateTime': MemberSpec_('dateTime', 'xs:dateTime', 0, 0, {'name': 'dateTime', 'type': 'xs:dateTime'}, 11),
        'date': MemberSpec_('date', 'xs:date', 0, 0, {'name': 'date', 'type': 'xs:date'}, 11),
        'url': MemberSpec_('url', ['urlType123', 'nonEmptyString', 'xs:string'], 0, 0, {'name': 'url', 'type': 'xs:string'}, 11),
        'attachments': MemberSpec_('attachments', 'documentListType', 0, 0, {'name': 'attachments', 'type': 'documentListType'}, 11),
        'nsi': MemberSpec_('nsi', 'nsiType124', 0, 0, {'name': 'nsi', 'type': 'nsiType124'}, 11),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, string=None, text=None, integer=None, number=None, boolean=None, time=None, dateTime=None, date=None, url=None, attachments=None, nsi=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.string = string
        self.validate_stringType121(self.string)
        self.string_nsprefix_ = None
        self.text = text
        self.validate_textType122(self.text)
        self.text_nsprefix_ = None
        self.integer = integer
        self.integer_nsprefix_ = None
        self.number = number
        self.number_nsprefix_ = None
        self.boolean = boolean
        self.boolean_nsprefix_ = None
        if isinstance(time, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(time, '%H:%M:%S').time()
        else:
            initvalue_ = time
        self.time = initvalue_
        self.time_nsprefix_ = None
        if isinstance(dateTime, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(dateTime, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = dateTime
        self.dateTime = initvalue_
        self.dateTime_nsprefix_ = None
        if isinstance(date, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(date, '%Y-%m-%d').date()
        else:
            initvalue_ = date
        self.date = initvalue_
        self.date_nsprefix_ = None
        self.url = url
        self.validate_urlType123(self.url)
        self.url_nsprefix_ = None
        self.attachments = attachments
        self.attachments_nsprefix_ = None
        self.nsi = nsi
        self.nsi_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tableColumnValueType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tableColumnValueType.subclass:
            return tableColumnValueType.subclass(*args_, **kwargs_)
        else:
            return tableColumnValueType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_stringType121(self, value):
        result = True
        # Validate type stringType121, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on stringType121' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on stringType121' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_textType122(self, value):
        result = True
        # Validate type textType122, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 2000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on textType122' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on textType122' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_urlType123(self, value):
        result = True
        # Validate type urlType123, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on urlType123' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on urlType123' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.string is not None or
            self.text is not None or
            self.integer is not None or
            self.number is not None or
            self.boolean is not None or
            self.time is not None or
            self.dateTime is not None or
            self.date is not None or
            self.url is not None or
            self.attachments is not None or
            self.nsi is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'string':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'string')
            value_ = self.gds_validate_string(value_, node, 'string')
            self.string = value_
            self.string_nsprefix_ = child_.prefix
            # validate type stringType121
            self.validate_stringType121(self.string)
        elif nodeName_ == 'text':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'text')
            value_ = self.gds_validate_string(value_, node, 'text')
            self.text = value_
            self.text_nsprefix_ = child_.prefix
            # validate type textType122
            self.validate_textType122(self.text)
        elif nodeName_ == 'integer' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'integer')
            ival_ = self.gds_validate_integer(ival_, node, 'integer')
            self.integer = ival_
            self.integer_nsprefix_ = child_.prefix
        elif nodeName_ == 'number' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'number')
            fval_ = self.gds_validate_decimal(fval_, node, 'number')
            self.number = fval_
            self.number_nsprefix_ = child_.prefix
        elif nodeName_ == 'boolean':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'boolean')
            self.boolean = ival_
            self.boolean_nsprefix_ = child_.prefix
        elif nodeName_ == 'time':
            sval_ = child_.text
            dval_ = self.gds_parse_time(sval_)
            self.time = dval_
            self.time_nsprefix_ = child_.prefix
        elif nodeName_ == 'dateTime':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.dateTime = dval_
            self.dateTime_nsprefix_ = child_.prefix
        elif nodeName_ == 'date':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.date = dval_
            self.date_nsprefix_ = child_.prefix
        elif nodeName_ == 'url':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'url')
            value_ = self.gds_validate_string(value_, node, 'url')
            self.url = value_
            self.url_nsprefix_ = child_.prefix
            # validate type urlType123
            self.validate_urlType123(self.url)
        elif nodeName_ == 'attachments':
            obj_ = documentListType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.attachments = obj_
            obj_.original_tagname_ = 'attachments'
        elif nodeName_ == 'nsi':
            obj_ = nsiType124.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.nsi = obj_
            obj_.original_tagname_ = 'nsi'
# end class tableColumnValueType


class protocolRequisitesType(GeneratedsSuper):
    """Реквизиты протокола"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'guid': MemberSpec_('guid', ['guidType', 'xs:string'], 0, 0, {'name': 'guid', 'type': 'xs:string'}, None),
        'registrationNumber': MemberSpec_('registrationNumber', ['registrationNumber11-2Type', 'nonEmptyString', 'xs:string'], 0, 0, {'name': 'registrationNumber', 'type': 'xs:string'}, None),
        'version': MemberSpec_('version', ['versionType', 'xs:long'], 0, 0, {'name': 'version', 'type': 'xs:long'}, None),
        'publicationDateTime': MemberSpec_('publicationDateTime', 'xs:dateTime', 0, 1, {'minOccurs': '0', 'name': 'publicationDateTime', 'type': 'xs:dateTime'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_) + ['extensiontype_']
    subclass = None
    superclass = None
    def __init__(self, guid=None, registrationNumber=None, version=None, publicationDateTime=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.guid = guid
        self.validate_guidType(self.guid)
        self.guid_nsprefix_ = None
        self.registrationNumber = registrationNumber
        self.validate_registrationNumber11_2Type(self.registrationNumber)
        self.registrationNumber_nsprefix_ = None
        self.version = version
        self.validate_versionType(self.version)
        self.version_nsprefix_ = None
        if isinstance(publicationDateTime, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(publicationDateTime, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = publicationDateTime
        self.publicationDateTime = initvalue_
        self.publicationDateTime_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, protocolRequisitesType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if protocolRequisitesType.subclass:
            return protocolRequisitesType.subclass(*args_, **kwargs_)
        else:
            return protocolRequisitesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_guidType(self, value):
        result = True
        # Validate type guidType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) != 36:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd length restriction on guidType' % {"value": encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_guidType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_guidType_patterns_, ))
                result = False
        return result
    validate_guidType_patterns_ = [['^([a-fA-F0-9]{8}\\-[a-fA-F0-9]{4}\\-[a-fA-F0-9]{4}\\-[a-fA-F0-9]{4}\\-[a-fA-F0-9]{12})$']]
    def validate_registrationNumber11_2Type(self, value):
        result = True
        # Validate type registrationNumber11-2Type, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on registrationNumber11-2Type' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_registrationNumber11_2Type_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_registrationNumber11_2Type_patterns_, ))
                result = False
        return result
    validate_registrationNumber11_2Type_patterns_ = [['^(\\d{11}-\\d{2})$']]
    def validate_versionType(self, value):
        result = True
        # Validate type versionType, a restriction on xs:long.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            if value < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on versionType' % {"value": value, "lineno": lineno} )
                result = False
            if len(str(value)) >= 9:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd totalDigits restriction on versionType' % {"value": value, "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.guid is not None or
            self.registrationNumber is not None or
            self.version is not None or
            self.publicationDateTime is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'guid':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'guid')
            value_ = self.gds_validate_string(value_, node, 'guid')
            self.guid = value_
            self.guid_nsprefix_ = child_.prefix
            # validate type guidType
            self.validate_guidType(self.guid)
        elif nodeName_ == 'registrationNumber':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'registrationNumber')
            value_ = self.gds_validate_string(value_, node, 'registrationNumber')
            self.registrationNumber = value_
            self.registrationNumber_nsprefix_ = child_.prefix
            # validate type registrationNumber11-2Type
            self.validate_registrationNumber11_2Type(self.registrationNumber)
        elif nodeName_ == 'version' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'version')
            ival_ = self.gds_validate_integer(ival_, node, 'version')
            self.version = ival_
            self.version_nsprefix_ = child_.prefix
            # validate type versionType
            self.validate_versionType(self.version)
        elif nodeName_ == 'publicationDateTime':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.publicationDateTime = dval_
            self.publicationDateTime_nsprefix_ = child_.prefix
# end class protocolRequisitesType


class protocolRequisitesType2(protocolRequisitesType):
    """Реквизиты протокола"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'typeName': MemberSpec_('typeName', ['typeNameType', 'nonEmptyString', 'xs:string'], 0, 0, {'name': 'typeName', 'type': 'xs:string'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = protocolRequisitesType
    def __init__(self, guid=None, registrationNumber=None, version=None, publicationDateTime=None, typeName=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(protocolRequisitesType2, self).__init__(guid, registrationNumber, version, publicationDateTime,  **kwargs_)
        self.typeName = typeName
        self.validate_typeNameType(self.typeName)
        self.typeName_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, protocolRequisitesType2)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if protocolRequisitesType2.subclass:
            return protocolRequisitesType2.subclass(*args_, **kwargs_)
        else:
            return protocolRequisitesType2(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_typeNameType(self, value):
        result = True
        # Validate type typeNameType, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 2000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on typeNameType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on typeNameType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.typeName is not None or
            super(protocolRequisitesType2, self).hasContent_()
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(protocolRequisitesType2, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'typeName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'typeName')
            value_ = self.gds_validate_string(value_, node, 'typeName')
            self.typeName = value_
            self.typeName_nsprefix_ = child_.prefix
            # validate type typeNameType
            self.validate_typeNameType(self.typeName)
        super(protocolRequisitesType2, self).buildChildren(child_, node, nodeName_, True)
# end class protocolRequisitesType2


class extendedAddressType(GeneratedsSuper):
    """Полный адрес организации"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'country': MemberSpec_('country', 'countryType', 0, 1, {'minOccurs': '0', 'name': 'country', 'type': 'countryType'}, None),
        'area': MemberSpec_('area', ['areaType', 'nonEmptyString', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'area', 'type': 'xs:string'}, None),
        'corpus': MemberSpec_('corpus', ['corpusType', 'nonEmptyString', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'corpus', 'type': 'xs:string'}, None),
        'house': MemberSpec_('house', ['houseType', 'nonEmptyString', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'house', 'type': 'xs:string'}, None),
        'zip': MemberSpec_('zip', ['zipType', 'nonEmptyString', 'xs:string'], 0, 0, {'name': 'zip', 'type': 'xs:string'}, None),
        'region': MemberSpec_('region', ['regionType125', 'nonEmptyString', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'region', 'type': 'xs:string'}, None),
        'structure': MemberSpec_('structure', ['structureType', 'nonEmptyString', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'structure', 'type': 'xs:string'}, None),
        'city': MemberSpec_('city', ['cityType', 'nonEmptyString', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'city', 'type': 'xs:string'}, None),
        'settlement': MemberSpec_('settlement', ['settlementType', 'nonEmptyString', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'settlement', 'type': 'xs:string'}, None),
        'street': MemberSpec_('street', ['streetType', 'nonEmptyString', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'street', 'type': 'xs:string'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, country=None, area=None, corpus=None, house=None, zip=None, region=None, structure=None, city=None, settlement=None, street=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.country = country
        self.country_nsprefix_ = None
        self.area = area
        self.validate_areaType(self.area)
        self.area_nsprefix_ = None
        self.corpus = corpus
        self.validate_corpusType(self.corpus)
        self.corpus_nsprefix_ = None
        self.house = house
        self.validate_houseType(self.house)
        self.house_nsprefix_ = None
        self.zip = zip
        self.validate_zipType(self.zip)
        self.zip_nsprefix_ = None
        self.region = region
        self.validate_regionType125(self.region)
        self.region_nsprefix_ = None
        self.structure = structure
        self.validate_structureType(self.structure)
        self.structure_nsprefix_ = None
        self.city = city
        self.validate_cityType(self.city)
        self.city_nsprefix_ = None
        self.settlement = settlement
        self.validate_settlementType(self.settlement)
        self.settlement_nsprefix_ = None
        self.street = street
        self.validate_streetType(self.street)
        self.street_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, extendedAddressType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if extendedAddressType.subclass:
            return extendedAddressType.subclass(*args_, **kwargs_)
        else:
            return extendedAddressType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_areaType(self, value):
        result = True
        # Validate type areaType, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 2000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on areaType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on areaType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_corpusType(self, value):
        result = True
        # Validate type corpusType, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 20:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on corpusType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on corpusType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_houseType(self, value):
        result = True
        # Validate type houseType, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 20:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on houseType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on houseType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_zipType(self, value):
        result = True
        # Validate type zipType, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on zipType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_zipType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_zipType_patterns_, ))
                result = False
        return result
    validate_zipType_patterns_ = [['^(\\d{6})$']]
    def validate_regionType125(self, value):
        result = True
        # Validate type regionType125, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 2000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on regionType125' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on regionType125' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_structureType(self, value):
        result = True
        # Validate type structureType, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 20:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on structureType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on structureType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_cityType(self, value):
        result = True
        # Validate type cityType, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 2000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on cityType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on cityType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_settlementType(self, value):
        result = True
        # Validate type settlementType, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 2000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on settlementType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on settlementType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_streetType(self, value):
        result = True
        # Validate type streetType, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 2000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on streetType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on streetType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.country is not None or
            self.area is not None or
            self.corpus is not None or
            self.house is not None or
            self.zip is not None or
            self.region is not None or
            self.structure is not None or
            self.city is not None or
            self.settlement is not None or
            self.street is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'country':
            obj_ = countryType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.country = obj_
            obj_.original_tagname_ = 'country'
        elif nodeName_ == 'area':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'area')
            value_ = self.gds_validate_string(value_, node, 'area')
            self.area = value_
            self.area_nsprefix_ = child_.prefix
            # validate type areaType
            self.validate_areaType(self.area)
        elif nodeName_ == 'corpus':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'corpus')
            value_ = self.gds_validate_string(value_, node, 'corpus')
            self.corpus = value_
            self.corpus_nsprefix_ = child_.prefix
            # validate type corpusType
            self.validate_corpusType(self.corpus)
        elif nodeName_ == 'house':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'house')
            value_ = self.gds_validate_string(value_, node, 'house')
            self.house = value_
            self.house_nsprefix_ = child_.prefix
            # validate type houseType
            self.validate_houseType(self.house)
        elif nodeName_ == 'zip':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'zip')
            value_ = self.gds_validate_string(value_, node, 'zip')
            self.zip = value_
            self.zip_nsprefix_ = child_.prefix
            # validate type zipType
            self.validate_zipType(self.zip)
        elif nodeName_ == 'region':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'region')
            value_ = self.gds_validate_string(value_, node, 'region')
            self.region = value_
            self.region_nsprefix_ = child_.prefix
            # validate type regionType125
            self.validate_regionType125(self.region)
        elif nodeName_ == 'structure':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'structure')
            value_ = self.gds_validate_string(value_, node, 'structure')
            self.structure = value_
            self.structure_nsprefix_ = child_.prefix
            # validate type structureType
            self.validate_structureType(self.structure)
        elif nodeName_ == 'city':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'city')
            value_ = self.gds_validate_string(value_, node, 'city')
            self.city = value_
            self.city_nsprefix_ = child_.prefix
            # validate type cityType
            self.validate_cityType(self.city)
        elif nodeName_ == 'settlement':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'settlement')
            value_ = self.gds_validate_string(value_, node, 'settlement')
            self.settlement = value_
            self.settlement_nsprefix_ = child_.prefix
            # validate type settlementType
            self.validate_settlementType(self.settlement)
        elif nodeName_ == 'street':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'street')
            value_ = self.gds_validate_string(value_, node, 'street')
            self.street = value_
            self.street_nsprefix_ = child_.prefix
            # validate type streetType
            self.validate_streetType(self.street)
# end class extendedAddressType


class templateStructureTabType(GeneratedsSuper):
    """Описание вкладки шаблона"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'tabOrdinal': MemberSpec_('tabOrdinal', 'xs:long', 0, 0, {'name': 'tabOrdinal', 'type': 'xs:long'}, None),
        'tabName': MemberSpec_('tabName', ['tabNameType126', 'nonEmptyString', 'xs:string'], 0, 0, {'name': 'tabName', 'type': 'xs:string'}, None),
        'fixedName': MemberSpec_('fixedName', ['fixedNameType', 'nonEmptyString', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'fixedName', 'type': 'xs:string'}, None),
        'section': MemberSpec_('section', 'sectionType127', 1, 0, {'maxOccurs': 'unbounded', 'minOccurs': '1', 'name': 'section', 'type': 'sectionType127'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, tabOrdinal=None, tabName=None, fixedName=None, section=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.tabOrdinal = tabOrdinal
        self.tabOrdinal_nsprefix_ = None
        self.tabName = tabName
        self.validate_tabNameType126(self.tabName)
        self.tabName_nsprefix_ = None
        self.fixedName = fixedName
        self.validate_fixedNameType(self.fixedName)
        self.fixedName_nsprefix_ = None
        if section is None:
            self.section = []
        else:
            self.section = section
        self.section_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, templateStructureTabType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if templateStructureTabType.subclass:
            return templateStructureTabType.subclass(*args_, **kwargs_)
        else:
            return templateStructureTabType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_tabNameType126(self, value):
        result = True
        # Validate type tabNameType126, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 130:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on tabNameType126' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on tabNameType126' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_fixedNameType(self, value):
        result = True
        # Validate type fixedNameType, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 130:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on fixedNameType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on fixedNameType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.tabOrdinal is not None or
            self.tabName is not None or
            self.fixedName is not None or
            self.section
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'tabOrdinal' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'tabOrdinal')
            ival_ = self.gds_validate_integer(ival_, node, 'tabOrdinal')
            self.tabOrdinal = ival_
            self.tabOrdinal_nsprefix_ = child_.prefix
        elif nodeName_ == 'tabName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'tabName')
            value_ = self.gds_validate_string(value_, node, 'tabName')
            self.tabName = value_
            self.tabName_nsprefix_ = child_.prefix
            # validate type tabNameType126
            self.validate_tabNameType126(self.tabName)
        elif nodeName_ == 'fixedName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'fixedName')
            value_ = self.gds_validate_string(value_, node, 'fixedName')
            self.fixedName = value_
            self.fixedName_nsprefix_ = child_.prefix
            # validate type fixedNameType
            self.validate_fixedNameType(self.fixedName)
        elif nodeName_ == 'section':
            obj_ = sectionType127.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.section.append(obj_)
            obj_.original_tagname_ = 'section'
# end class templateStructureTabType


class purchaseCategory(GeneratedsSuper):
    """Категория закупки"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'code': MemberSpec_('code', 'xs:long', 0, 0, {'maxOccurs': '1', 'minOccurs': '1', 'name': 'code', 'type': 'xs:long'}, None),
        'name': MemberSpec_('name', 'xs:string', 0, 0, {'maxOccurs': '1', 'minOccurs': '1', 'name': 'name', 'type': 'xs:string'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, code=None, name=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.code = code
        self.code_nsprefix_ = None
        self.name = name
        self.name_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, purchaseCategory)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if purchaseCategory.subclass:
            return purchaseCategory.subclass(*args_, **kwargs_)
        else:
            return purchaseCategory(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.code is not None or
            self.name is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'code' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'code')
            ival_ = self.gds_validate_integer(ival_, node, 'code')
            self.code = ival_
            self.code_nsprefix_ = child_.prefix
        elif nodeName_ == 'name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'name')
            value_ = self.gds_validate_string(value_, node, 'name')
            self.name = value_
            self.name_nsprefix_ = child_.prefix
# end class purchaseCategory


class hiddenFzFields(GeneratedsSuper):
    """Скрытые поля 223 ФЗ"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'code': MemberSpec_('code', 'xs:string', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'code', 'type': 'xs:string'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, code=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if code is None:
            self.code = []
        else:
            self.code = code
        self.code_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, hiddenFzFields)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if hiddenFzFields.subclass:
            return hiddenFzFields.subclass(*args_, **kwargs_)
        else:
            return hiddenFzFields(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.code
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'code':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'code')
            value_ = self.gds_validate_string(value_, node, 'code')
            self.code.append(value_)
            self.code_nsprefix_ = child_.prefix
# end class hiddenFzFields


class sectionType4(GeneratedsSuper):
    """Раздел"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'code': MemberSpec_('code', ['codeType', 't:nonEmptyString'], 0, 0, {'name': 'code', 'type': 'xs:string'}, None),
        'name': MemberSpec_('name', ['nameType5', 't:nonEmptyString'], 0, 0, {'name': 'name', 'type': 'xs:string'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, code=None, name=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.code = code
        self.validate_codeType(self.code)
        self.code_nsprefix_ = None
        self.name = name
        self.validate_nameType5(self.name)
        self.name_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, sectionType4)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if sectionType4.subclass:
            return sectionType4.subclass(*args_, **kwargs_)
        else:
            return sectionType4(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_codeType(self, value):
        result = True
        # Validate type codeType, a restriction on t:nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on codeType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on codeType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_nameType5(self, value):
        result = True
        # Validate type nameType5, a restriction on t:nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on nameType5' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on nameType5' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.code is not None or
            self.name is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'code':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'code')
            value_ = self.gds_validate_string(value_, node, 'code')
            self.code = value_
            self.code_nsprefix_ = child_.prefix
            # validate type codeType
            self.validate_codeType(self.code)
        elif nodeName_ == 'name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'name')
            value_ = self.gds_validate_string(value_, node, 'name')
            self.name = value_
            self.name_nsprefix_ = child_.prefix
            # validate type nameType5
            self.validate_nameType5(self.name)
# end class sectionType4


class groupType(GeneratedsSuper):
    """Группа"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'code': MemberSpec_('code', 'xs:int', 0, 0, {'name': 'code', 'type': 'xs:int'}, None),
        'name': MemberSpec_('name', ['nameType6', 't:nonEmptyString'], 0, 0, {'name': 'name', 'type': 'xs:string'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, code=None, name=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.code = code
        self.code_nsprefix_ = None
        self.name = name
        self.validate_nameType6(self.name)
        self.name_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, groupType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if groupType.subclass:
            return groupType.subclass(*args_, **kwargs_)
        else:
            return groupType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_nameType6(self, value):
        result = True
        # Validate type nameType6, a restriction on t:nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on nameType6' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on nameType6' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.code is not None or
            self.name is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'code' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'code')
            ival_ = self.gds_validate_integer(ival_, node, 'code')
            self.code = ival_
            self.code_nsprefix_ = child_.prefix
        elif nodeName_ == 'name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'name')
            value_ = self.gds_validate_string(value_, node, 'name')
            self.name = value_
            self.name_nsprefix_ = child_.prefix
            # validate type nameType6
            self.validate_nameType6(self.name)
# end class groupType


class classificationType(GeneratedsSuper):
    """Дополнительная информация"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'okfs': MemberSpec_('okfs', ['codeOkfsType', 'nonEmptyString', 'xs:string'], 0, 0, {'name': 'okfs', 'type': 'xs:string'}, None),
        'okopf': MemberSpec_('okopf', ['codeOkopfType', 'nonEmptyString', 'xs:string'], 0, 0, {'name': 'okopf', 'type': 'xs:string'}, None),
        'okato': MemberSpec_('okato', ['codeOkatoType', 'nonEmptyString', 'xs:string'], 0, 0, {'name': 'okato', 'type': 'xs:string'}, None),
        'oktmo': MemberSpec_('oktmo', ['codeOktmoType', 'nonEmptyString', 'xs:string'], 0, 0, {'name': 'oktmo', 'type': 'xs:string'}, None),
        'okpo': MemberSpec_('okpo', ['codeOkpoType', 'nonEmptyString', 'xs:string'], 0, 0, {'name': 'okpo', 'type': 'xs:string'}, None),
        'spzCode': MemberSpec_('spzCode', ['spzCodeType', 't:nonEmptyString'], 0, 1, {'minOccurs': '0', 'name': 'spzCode', 'type': 'xs:string'}, None),
        'pgmuCode': MemberSpec_('pgmuCode', ['pgmuCodeType', 't:nonEmptyString'], 0, 1, {'minOccurs': '0', 'name': 'pgmuCode', 'type': 'xs:string'}, None),
        'rfSubjectCode': MemberSpec_('rfSubjectCode', ['rfSubjectCodeType', 't:nonEmptyString'], 0, 1, {'minOccurs': '0', 'name': 'rfSubjectCode', 'type': 'xs:string'}, None),
        'ppo': MemberSpec_('ppo', 'ppoType', 0, 1, {'minOccurs': '0', 'name': 'ppo', 'type': 'ppoType'}, None),
        'activities': MemberSpec_('activities', 'activitiesType', 0, 1, {'minOccurs': '0', 'name': 'activities', 'type': 'activitiesType'}, None),
        'fz223types': MemberSpec_('fz223types', 'fz223typesType', 0, 1, {'minOccurs': '0', 'name': 'fz223types', 'type': 'fz223typesType'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, okfs=None, okopf=None, okato=None, oktmo=None, okpo=None, spzCode=None, pgmuCode=None, rfSubjectCode=None, ppo=None, activities=None, fz223types=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.okfs = okfs
        self.validate_codeOkfsType(self.okfs)
        self.okfs_nsprefix_ = None
        self.okopf = okopf
        self.validate_codeOkopfType(self.okopf)
        self.okopf_nsprefix_ = None
        self.okato = okato
        self.validate_codeOkatoType(self.okato)
        self.okato_nsprefix_ = None
        self.oktmo = oktmo
        self.validate_codeOktmoType(self.oktmo)
        self.oktmo_nsprefix_ = None
        self.okpo = okpo
        self.validate_codeOkpoType(self.okpo)
        self.okpo_nsprefix_ = None
        self.spzCode = spzCode
        self.validate_spzCodeType(self.spzCode)
        self.spzCode_nsprefix_ = None
        self.pgmuCode = pgmuCode
        self.validate_pgmuCodeType(self.pgmuCode)
        self.pgmuCode_nsprefix_ = None
        self.rfSubjectCode = rfSubjectCode
        self.validate_rfSubjectCodeType(self.rfSubjectCode)
        self.rfSubjectCode_nsprefix_ = None
        self.ppo = ppo
        self.ppo_nsprefix_ = None
        self.activities = activities
        self.activities_nsprefix_ = None
        self.fz223types = fz223types
        self.fz223types_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, classificationType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if classificationType.subclass:
            return classificationType.subclass(*args_, **kwargs_)
        else:
            return classificationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_codeOkfsType(self, value):
        result = True
        # Validate type codeOkfsType, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on codeOkfsType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_codeOkfsType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_codeOkfsType_patterns_, ))
                result = False
        return result
    validate_codeOkfsType_patterns_ = [['^(\\d{2})$']]
    def validate_codeOkopfType(self, value):
        result = True
        # Validate type codeOkopfType, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on codeOkopfType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_codeOkopfType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_codeOkopfType_patterns_, ))
                result = False
        return result
    validate_codeOkopfType_patterns_ = [['^(\\d{2}|\\d{5})$']]
    def validate_codeOkatoType(self, value):
        result = True
        # Validate type codeOkatoType, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on codeOkatoType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_codeOkatoType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_codeOkatoType_patterns_, ))
                result = False
        return result
    validate_codeOkatoType_patterns_ = [['^(\\d{11})$']]
    def validate_codeOktmoType(self, value):
        result = True
        # Validate type codeOktmoType, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on codeOktmoType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_codeOktmoType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_codeOktmoType_patterns_, ))
                result = False
        return result
    validate_codeOktmoType_patterns_ = [['^(\\d{2,11})$']]
    def validate_codeOkpoType(self, value):
        result = True
        # Validate type codeOkpoType, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on codeOkpoType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_codeOkpoType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_codeOkpoType_patterns_, ))
                result = False
        return result
    validate_codeOkpoType_patterns_ = [['^(\\d{10}|\\d{8})$']]
    def validate_spzCodeType(self, value):
        result = True
        # Validate type spzCodeType, a restriction on t:nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 255:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on spzCodeType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on spzCodeType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_pgmuCodeType(self, value):
        result = True
        # Validate type pgmuCodeType, a restriction on t:nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 255:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on pgmuCodeType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on pgmuCodeType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_rfSubjectCodeType(self, value):
        result = True
        # Validate type rfSubjectCodeType, a restriction on t:nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 255:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on rfSubjectCodeType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on rfSubjectCodeType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.okfs is not None or
            self.okopf is not None or
            self.okato is not None or
            self.oktmo is not None or
            self.okpo is not None or
            self.spzCode is not None or
            self.pgmuCode is not None or
            self.rfSubjectCode is not None or
            self.ppo is not None or
            self.activities is not None or
            self.fz223types is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'okfs':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'okfs')
            value_ = self.gds_validate_string(value_, node, 'okfs')
            self.okfs = value_
            self.okfs_nsprefix_ = child_.prefix
            # validate type codeOkfsType
            self.validate_codeOkfsType(self.okfs)
        elif nodeName_ == 'okopf':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'okopf')
            value_ = self.gds_validate_string(value_, node, 'okopf')
            self.okopf = value_
            self.okopf_nsprefix_ = child_.prefix
            # validate type codeOkopfType
            self.validate_codeOkopfType(self.okopf)
        elif nodeName_ == 'okato':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'okato')
            value_ = self.gds_validate_string(value_, node, 'okato')
            self.okato = value_
            self.okato_nsprefix_ = child_.prefix
            # validate type codeOkatoType
            self.validate_codeOkatoType(self.okato)
        elif nodeName_ == 'oktmo':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'oktmo')
            value_ = self.gds_validate_string(value_, node, 'oktmo')
            self.oktmo = value_
            self.oktmo_nsprefix_ = child_.prefix
            # validate type codeOktmoType
            self.validate_codeOktmoType(self.oktmo)
        elif nodeName_ == 'okpo':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'okpo')
            value_ = self.gds_validate_string(value_, node, 'okpo')
            self.okpo = value_
            self.okpo_nsprefix_ = child_.prefix
            # validate type codeOkpoType
            self.validate_codeOkpoType(self.okpo)
        elif nodeName_ == 'spzCode':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'spzCode')
            value_ = self.gds_validate_string(value_, node, 'spzCode')
            self.spzCode = value_
            self.spzCode_nsprefix_ = child_.prefix
            # validate type spzCodeType
            self.validate_spzCodeType(self.spzCode)
        elif nodeName_ == 'pgmuCode':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'pgmuCode')
            value_ = self.gds_validate_string(value_, node, 'pgmuCode')
            self.pgmuCode = value_
            self.pgmuCode_nsprefix_ = child_.prefix
            # validate type pgmuCodeType
            self.validate_pgmuCodeType(self.pgmuCode)
        elif nodeName_ == 'rfSubjectCode':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'rfSubjectCode')
            value_ = self.gds_validate_string(value_, node, 'rfSubjectCode')
            self.rfSubjectCode = value_
            self.rfSubjectCode_nsprefix_ = child_.prefix
            # validate type rfSubjectCodeType
            self.validate_rfSubjectCodeType(self.rfSubjectCode)
        elif nodeName_ == 'ppo':
            obj_ = ppoType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ppo = obj_
            obj_.original_tagname_ = 'ppo'
        elif nodeName_ == 'activities':
            obj_ = activitiesType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.activities = obj_
            obj_.original_tagname_ = 'activities'
        elif nodeName_ == 'fz223types':
            obj_ = fz223typesType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.fz223types = obj_
            obj_.original_tagname_ = 'fz223types'
# end class classificationType


class ppoType(GeneratedsSuper):
    """Принадлежность организации к публично-правовому образованию"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'isPpo': MemberSpec_('isPpo', 'xs:boolean', 0, 0, {'default': 'false', 'name': 'isPpo', 'type': 'xs:boolean'}, None),
        'code': MemberSpec_('code', ['codeType17', 't:nonEmptyString'], 0, 1, {'minOccurs': '0', 'name': 'code', 'type': 'xs:string'}, None),
        'name': MemberSpec_('name', ['nameType18', 't:nonEmptyString'], 0, 1, {'minOccurs': '0', 'name': 'name', 'type': 'xs:string'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, isPpo=False, code=None, name=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.isPpo = isPpo
        self.isPpo_nsprefix_ = None
        self.code = code
        self.validate_codeType17(self.code)
        self.code_nsprefix_ = None
        self.name = name
        self.validate_nameType18(self.name)
        self.name_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ppoType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ppoType.subclass:
            return ppoType.subclass(*args_, **kwargs_)
        else:
            return ppoType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_codeType17(self, value):
        result = True
        # Validate type codeType17, a restriction on t:nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 11:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on codeType17' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on codeType17' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_nameType18(self, value):
        result = True
        # Validate type nameType18, a restriction on t:nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 2000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on nameType18' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on nameType18' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.isPpo or
            self.code is not None or
            self.name is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'isPpo':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'isPpo')
            ival_ = self.gds_validate_boolean(ival_, node, 'isPpo')
            self.isPpo = ival_
            self.isPpo_nsprefix_ = child_.prefix
        elif nodeName_ == 'code':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'code')
            value_ = self.gds_validate_string(value_, node, 'code')
            self.code = value_
            self.code_nsprefix_ = child_.prefix
            # validate type codeType17
            self.validate_codeType17(self.code)
        elif nodeName_ == 'name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'name')
            value_ = self.gds_validate_string(value_, node, 'name')
            self.name = value_
            self.name_nsprefix_ = child_.prefix
            # validate type nameType18
            self.validate_nameType18(self.name)
# end class ppoType


class activitiesType(GeneratedsSuper):
    """Список видов деятельности по ОКВЭД/ОКВЭД2"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'okved': MemberSpec_('okved', 'okvedType', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'okved', 'type': 'okvedType'}, None),
        'okved2': MemberSpec_('okved2', 'okved2Type', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'okved2', 'type': 'okved2Type'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, okved=None, okved2=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if okved is None:
            self.okved = []
        else:
            self.okved = okved
        self.okved_nsprefix_ = None
        if okved2 is None:
            self.okved2 = []
        else:
            self.okved2 = okved2
        self.okved2_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, activitiesType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if activitiesType.subclass:
            return activitiesType.subclass(*args_, **kwargs_)
        else:
            return activitiesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.okved or
            self.okved2
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'okved':
            obj_ = okvedType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.okved.append(obj_)
            obj_.original_tagname_ = 'okved'
        elif nodeName_ == 'okved2':
            obj_ = okved2Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.okved2.append(obj_)
            obj_.original_tagname_ = 'okved2'
# end class activitiesType


class okvedType(GeneratedsSuper):
    """Вид деятельности по ОКВЭД"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'code': MemberSpec_('code', ['codeOkvedType', 'nonEmptyString', 'xs:string'], 0, 0, {'name': 'code', 'type': 'xs:string'}, None),
        'isMain': MemberSpec_('isMain', 'xs:boolean', 0, 0, {'default': 'false', 'name': 'isMain', 'type': 'xs:boolean'}, None),
        'name': MemberSpec_('name', ['nameType19', 't:nonEmptyString'], 0, 0, {'name': 'name', 'type': 'xs:string'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, code=None, isMain=False, name=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.code = code
        self.validate_codeOkvedType(self.code)
        self.code_nsprefix_ = None
        self.isMain = isMain
        self.isMain_nsprefix_ = None
        self.name = name
        self.validate_nameType19(self.name)
        self.name_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, okvedType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if okvedType.subclass:
            return okvedType.subclass(*args_, **kwargs_)
        else:
            return okvedType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_codeOkvedType(self, value):
        result = True
        # Validate type codeOkvedType, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on codeOkvedType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_codeOkvedType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_codeOkvedType_patterns_, ))
                result = False
        return result
    validate_codeOkvedType_patterns_ = [['^([A-Q]{1,2}|(\\d{2}((\\.\\d{1,2})|(\\.\\d{2}\\.\\d{1,2}))?))$']]
    def validate_nameType19(self, value):
        result = True
        # Validate type nameType19, a restriction on t:nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 500:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on nameType19' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on nameType19' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.code is not None or
            self.isMain or
            self.name is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'code':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'code')
            value_ = self.gds_validate_string(value_, node, 'code')
            self.code = value_
            self.code_nsprefix_ = child_.prefix
            # validate type codeOkvedType
            self.validate_codeOkvedType(self.code)
        elif nodeName_ == 'isMain':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'isMain')
            ival_ = self.gds_validate_boolean(ival_, node, 'isMain')
            self.isMain = ival_
            self.isMain_nsprefix_ = child_.prefix
        elif nodeName_ == 'name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'name')
            value_ = self.gds_validate_string(value_, node, 'name')
            self.name = value_
            self.name_nsprefix_ = child_.prefix
            # validate type nameType19
            self.validate_nameType19(self.name)
# end class okvedType


class okved2Type(GeneratedsSuper):
    """Вид деятельности по ОКВЭД2"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'code': MemberSpec_('code', ['codeOkved2Type', 'nonEmptyString', 'xs:string'], 0, 0, {'name': 'code', 'type': 'xs:string'}, None),
        'isMain': MemberSpec_('isMain', 'xs:boolean', 0, 0, {'default': 'false', 'name': 'isMain', 'type': 'xs:boolean'}, None),
        'name': MemberSpec_('name', ['nameType20', 't:nonEmptyString'], 0, 0, {'name': 'name', 'type': 'xs:string'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, code=None, isMain=False, name=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.code = code
        self.validate_codeOkved2Type(self.code)
        self.code_nsprefix_ = None
        self.isMain = isMain
        self.isMain_nsprefix_ = None
        self.name = name
        self.validate_nameType20(self.name)
        self.name_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, okved2Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if okved2Type.subclass:
            return okved2Type.subclass(*args_, **kwargs_)
        else:
            return okved2Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_codeOkved2Type(self, value):
        result = True
        # Validate type codeOkved2Type, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on codeOkved2Type' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_codeOkved2Type_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_codeOkved2Type_patterns_, ))
                result = False
        return result
    validate_codeOkved2Type_patterns_ = [['^([A-Q]{1,2}|(\\d{2}((\\.\\d{1,2})|(\\.\\d{2}\\.\\d{1,2}))?))$']]
    def validate_nameType20(self, value):
        result = True
        # Validate type nameType20, a restriction on t:nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 500:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on nameType20' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on nameType20' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.code is not None or
            self.isMain or
            self.name is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'code':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'code')
            value_ = self.gds_validate_string(value_, node, 'code')
            self.code = value_
            self.code_nsprefix_ = child_.prefix
            # validate type codeOkved2Type
            self.validate_codeOkved2Type(self.code)
        elif nodeName_ == 'isMain':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'isMain')
            ival_ = self.gds_validate_boolean(ival_, node, 'isMain')
            self.isMain = ival_
            self.isMain_nsprefix_ = child_.prefix
        elif nodeName_ == 'name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'name')
            value_ = self.gds_validate_string(value_, node, 'name')
            self.name = value_
            self.name_nsprefix_ = child_.prefix
            # validate type nameType20
            self.validate_nameType20(self.name)
# end class okved2Type


class fz223typesType(GeneratedsSuper):
    """Виды организации по 223-ФЗ"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'fz223type': MemberSpec_('fz223type', 'fz223type', 1, 0, {'maxOccurs': 'unbounded', 'name': 'fz223type', 'type': 'fz223typeType'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, fz223type=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if fz223type is None:
            self.fz223type = []
        else:
            self.fz223type = fz223type
        self.fz223type_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, fz223typesType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if fz223typesType.subclass:
            return fz223typesType.subclass(*args_, **kwargs_)
        else:
            return fz223typesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.fz223type
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'fz223type':
            obj_ = fz223typeType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.fz223type.append(obj_)
            obj_.original_tagname_ = 'fz223type'
# end class fz223typesType


class fz223typeType(GeneratedsSuper):
    """Тип организации"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'name': MemberSpec_('name', ['nameType21', 't:nonEmptyString'], 0, 0, {'name': 'name', 'type': 'xs:string'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, name=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.name = name
        self.validate_nameType21(self.name)
        self.name_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, fz223typeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if fz223typeType.subclass:
            return fz223typeType.subclass(*args_, **kwargs_)
        else:
            return fz223typeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_nameType21(self, value):
        result = True
        # Validate type nameType21, a restriction on t:nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 2000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on nameType21' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on nameType21' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.name is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'name')
            value_ = self.gds_validate_string(value_, node, 'name')
            self.name = value_
            self.name_nsprefix_ = child_.prefix
            # validate type nameType21
            self.validate_nameType21(self.name)
# end class fz223typeType


class additionalInfoType(GeneratedsSuper):
    """Дополнительная информация"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'timeZone': MemberSpec_('timeZone', 'timeZoneType22', 0, 0, {'name': 'timeZone', 'type': 'timeZoneType22'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, timeZone=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.timeZone = timeZone
        self.timeZone_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, additionalInfoType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if additionalInfoType.subclass:
            return additionalInfoType.subclass(*args_, **kwargs_)
        else:
            return additionalInfoType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.timeZone is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'timeZone':
            obj_ = timeZoneType22.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.timeZone = obj_
            obj_.original_tagname_ = 'timeZone'
# end class additionalInfoType


class timeZoneType22(GeneratedsSuper):
    """Временная зона"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'offset': MemberSpec_('offset', 'xs:int', 0, 0, {'name': 'offset', 'type': 'xs:int'}, None),
        'name': MemberSpec_('name', ['nameType23', 't:nonEmptyString'], 0, 0, {'name': 'name', 'type': 'xs:string'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, offset=None, name=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.offset = offset
        self.offset_nsprefix_ = None
        self.name = name
        self.validate_nameType23(self.name)
        self.name_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, timeZoneType22)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if timeZoneType22.subclass:
            return timeZoneType22.subclass(*args_, **kwargs_)
        else:
            return timeZoneType22(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_nameType23(self, value):
        result = True
        # Validate type nameType23, a restriction on t:nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 100:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on nameType23' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on nameType23' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.offset is not None or
            self.name is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'offset' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'offset')
            ival_ = self.gds_validate_integer(ival_, node, 'offset')
            self.offset = ival_
            self.offset_nsprefix_ = child_.prefix
        elif nodeName_ == 'name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'name')
            value_ = self.gds_validate_string(value_, node, 'name')
            self.name = value_
            self.name_nsprefix_ = child_.prefix
            # validate type nameType23
            self.validate_nameType23(self.name)
# end class timeZoneType22


class authorityType(GeneratedsSuper):
    """Полномочия организации"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'isCustomer': MemberSpec_('isCustomer', 'xs:boolean', 0, 1, {'default': 'false', 'minOccurs': '0', 'name': 'isCustomer', 'type': 'xs:boolean'}, None),
        'isCustomerAgent': MemberSpec_('isCustomerAgent', 'xs:boolean', 0, 1, {'default': 'false', 'minOccurs': '0', 'name': 'isCustomerAgent', 'type': 'xs:boolean'}, None),
        'isSupervisor': MemberSpec_('isSupervisor', 'xs:boolean', 0, 1, {'default': 'false', 'minOccurs': '0', 'name': 'isSupervisor', 'type': 'xs:boolean'}, None),
        'isOperator': MemberSpec_('isOperator', 'xs:boolean', 0, 1, {'default': 'false', 'minOccurs': '0', 'name': 'isOperator', 'type': 'xs:boolean'}, None),
        'isOVK': MemberSpec_('isOVK', 'xs:boolean', 0, 1, {'default': 'false', 'minOccurs': '0', 'name': 'isOVK', 'type': 'xs:boolean'}, None),
        'isPurchaseAudit': MemberSpec_('isPurchaseAudit', 'xs:boolean', 0, 1, {'default': 'false', 'minOccurs': '0', 'name': 'isPurchaseAudit', 'type': 'xs:boolean'}, None),
        'isMonitoring': MemberSpec_('isMonitoring', 'xs:boolean', 0, 1, {'default': 'false', 'minOccurs': '0', 'name': 'isMonitoring', 'type': 'xs:boolean'}, None),
        'isAssessment': MemberSpec_('isAssessment', 'xs:boolean', 0, 1, {'default': 'false', 'minOccurs': '0', 'name': 'isAssessment', 'type': 'xs:boolean'}, None),
        'isTypalOrderClause': MemberSpec_('isTypalOrderClause', 'xs:boolean', 0, 1, {'default': 'false', 'minOccurs': '0', 'name': 'isTypalOrderClause', 'type': 'xs:boolean'}, None),
        'isOperatorEM': MemberSpec_('isOperatorEM', 'xs:boolean', 0, 1, {'default': 'false', 'minOccurs': '0', 'name': 'isOperatorEM', 'type': 'xs:boolean'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, isCustomer=False, isCustomerAgent=False, isSupervisor=False, isOperator=False, isOVK=False, isPurchaseAudit=False, isMonitoring=False, isAssessment=False, isTypalOrderClause=False, isOperatorEM=False, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.isCustomer = isCustomer
        self.isCustomer_nsprefix_ = None
        self.isCustomerAgent = isCustomerAgent
        self.isCustomerAgent_nsprefix_ = None
        self.isSupervisor = isSupervisor
        self.isSupervisor_nsprefix_ = None
        self.isOperator = isOperator
        self.isOperator_nsprefix_ = None
        self.isOVK = isOVK
        self.isOVK_nsprefix_ = None
        self.isPurchaseAudit = isPurchaseAudit
        self.isPurchaseAudit_nsprefix_ = None
        self.isMonitoring = isMonitoring
        self.isMonitoring_nsprefix_ = None
        self.isAssessment = isAssessment
        self.isAssessment_nsprefix_ = None
        self.isTypalOrderClause = isTypalOrderClause
        self.isTypalOrderClause_nsprefix_ = None
        self.isOperatorEM = isOperatorEM
        self.isOperatorEM_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, authorityType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if authorityType.subclass:
            return authorityType.subclass(*args_, **kwargs_)
        else:
            return authorityType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.isCustomer or
            self.isCustomerAgent or
            self.isSupervisor or
            self.isOperator or
            self.isOVK or
            self.isPurchaseAudit or
            self.isMonitoring or
            self.isAssessment or
            self.isTypalOrderClause or
            self.isOperatorEM
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'isCustomer':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'isCustomer')
            ival_ = self.gds_validate_boolean(ival_, node, 'isCustomer')
            self.isCustomer = ival_
            self.isCustomer_nsprefix_ = child_.prefix
        elif nodeName_ == 'isCustomerAgent':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'isCustomerAgent')
            ival_ = self.gds_validate_boolean(ival_, node, 'isCustomerAgent')
            self.isCustomerAgent = ival_
            self.isCustomerAgent_nsprefix_ = child_.prefix
        elif nodeName_ == 'isSupervisor':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'isSupervisor')
            ival_ = self.gds_validate_boolean(ival_, node, 'isSupervisor')
            self.isSupervisor = ival_
            self.isSupervisor_nsprefix_ = child_.prefix
        elif nodeName_ == 'isOperator':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'isOperator')
            ival_ = self.gds_validate_boolean(ival_, node, 'isOperator')
            self.isOperator = ival_
            self.isOperator_nsprefix_ = child_.prefix
        elif nodeName_ == 'isOVK':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'isOVK')
            ival_ = self.gds_validate_boolean(ival_, node, 'isOVK')
            self.isOVK = ival_
            self.isOVK_nsprefix_ = child_.prefix
        elif nodeName_ == 'isPurchaseAudit':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'isPurchaseAudit')
            ival_ = self.gds_validate_boolean(ival_, node, 'isPurchaseAudit')
            self.isPurchaseAudit = ival_
            self.isPurchaseAudit_nsprefix_ = child_.prefix
        elif nodeName_ == 'isMonitoring':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'isMonitoring')
            ival_ = self.gds_validate_boolean(ival_, node, 'isMonitoring')
            self.isMonitoring = ival_
            self.isMonitoring_nsprefix_ = child_.prefix
        elif nodeName_ == 'isAssessment':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'isAssessment')
            ival_ = self.gds_validate_boolean(ival_, node, 'isAssessment')
            self.isAssessment = ival_
            self.isAssessment_nsprefix_ = child_.prefix
        elif nodeName_ == 'isTypalOrderClause':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'isTypalOrderClause')
            ival_ = self.gds_validate_boolean(ival_, node, 'isTypalOrderClause')
            self.isTypalOrderClause = ival_
            self.isTypalOrderClause_nsprefix_ = child_.prefix
        elif nodeName_ == 'isOperatorEM':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'isOperatorEM')
            ival_ = self.gds_validate_boolean(ival_, node, 'isOperatorEM')
            self.isOperatorEM = ival_
            self.isOperatorEM_nsprefix_ = child_.prefix
# end class authorityType


class contactInfoType24(GeneratedsSuper):
    """Контактная информация"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'contactFirstName': MemberSpec_('contactFirstName', ['contactFirstNameType', 't:nonEmptyString'], 0, 1, {'minOccurs': '0', 'name': 'contactFirstName', 'type': 'xs:string'}, None),
        'contactMiddleName': MemberSpec_('contactMiddleName', ['contactMiddleNameType', 't:nonEmptyString'], 0, 1, {'minOccurs': '0', 'name': 'contactMiddleName', 'type': 'xs:string'}, None),
        'contactLastName': MemberSpec_('contactLastName', ['contactLastNameType', 't:nonEmptyString'], 0, 1, {'minOccurs': '0', 'name': 'contactLastName', 'type': 'xs:string'}, None),
        'contactEmail': MemberSpec_('contactEmail', ['emailType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'contactEmail', 'type': 'xs:string'}, None),
        'phone': MemberSpec_('phone', ['phoneType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'phone', 'type': 'xs:string'}, None),
        'fax': MemberSpec_('fax', ['phoneType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'fax', 'type': 'xs:string'}, None),
        'email': MemberSpec_('email', ['emailType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'email', 'type': 'xs:string'}, None),
        'website': MemberSpec_('website', ['websiteType', 't:nonEmptyString'], 0, 1, {'minOccurs': '0', 'name': 'website', 'type': 'xs:string'}, None),
        'additional': MemberSpec_('additional', ['additionalType', 't:nonEmptyString'], 0, 1, {'minOccurs': '0', 'name': 'additional', 'type': 'xs:string'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, contactFirstName=None, contactMiddleName=None, contactLastName=None, contactEmail=None, phone=None, fax=None, email=None, website=None, additional=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.contactFirstName = contactFirstName
        self.validate_contactFirstNameType(self.contactFirstName)
        self.contactFirstName_nsprefix_ = None
        self.contactMiddleName = contactMiddleName
        self.validate_contactMiddleNameType(self.contactMiddleName)
        self.contactMiddleName_nsprefix_ = None
        self.contactLastName = contactLastName
        self.validate_contactLastNameType(self.contactLastName)
        self.contactLastName_nsprefix_ = None
        self.contactEmail = contactEmail
        self.validate_emailType(self.contactEmail)
        self.contactEmail_nsprefix_ = None
        self.phone = phone
        self.validate_phoneType(self.phone)
        self.phone_nsprefix_ = None
        self.fax = fax
        self.validate_phoneType(self.fax)
        self.fax_nsprefix_ = None
        self.email = email
        self.validate_emailType(self.email)
        self.email_nsprefix_ = None
        self.website = website
        self.validate_websiteType(self.website)
        self.website_nsprefix_ = None
        self.additional = additional
        self.validate_additionalType(self.additional)
        self.additional_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, contactInfoType24)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if contactInfoType24.subclass:
            return contactInfoType24.subclass(*args_, **kwargs_)
        else:
            return contactInfoType24(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_contactFirstNameType(self, value):
        result = True
        # Validate type contactFirstNameType, a restriction on t:nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 300:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on contactFirstNameType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on contactFirstNameType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_contactMiddleNameType(self, value):
        result = True
        # Validate type contactMiddleNameType, a restriction on t:nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 300:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on contactMiddleNameType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on contactMiddleNameType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_contactLastNameType(self, value):
        result = True
        # Validate type contactLastNameType, a restriction on t:nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 300:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on contactLastNameType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on contactLastNameType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_emailType(self, value):
        result = True
        # Validate type emailType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 300:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on emailType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on emailType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_emailType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_emailType_patterns_, ))
                result = False
        return result
    validate_emailType_patterns_ = [["^(([\\-a-zA-Zа-яА-Я0-9!#%&'\\*\\+/=\\?\\^_`\\{\\|\\}~]+(\\.[\\-a-zA-Zа-яА-Я0-9!#%&'\\*\\+/=\\?\\^_`\\{\\|\\}~]+)*@([a-zA-Zа-яА-Я0-9]([\\-_a-zA-Zа-яА-Я0-9]{0,61}[a-zA-Zа-яА-Я0-9])?\\.)*[\\-a-zA-Zа-яА-Я0-9]+(\\.[\\-a-zA-Zа-яА-Я0-9]+)*)+(,\\s?[\\-a-zA-Zа-яА-Я0-9!#%&'\\*\\+/=\\?\\^_`\\{\\|\\}~]+(\\.[\\-a-zA-Zа-яА-Я0-9!#%&'\\*\\+/=\\?\\^_`\\{\\|\\}~]+)*@([a-zA-Zа-яА-Я0-9]([\\-_a-zA-Zа-яА-Я0-9]{0,61}[a-zA-Zа-яА-Я0-9])?\\.)*[\\-a-zA-Zа-яА-Я0-9]+(\\.[\\-a-zA-Zа-яА-Я0-9]+)*)*)$"]]
    def validate_phoneType(self, value):
        result = True
        # Validate type phoneType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 300:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on phoneType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on phoneType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_websiteType(self, value):
        result = True
        # Validate type websiteType, a restriction on t:nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 300:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on websiteType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on websiteType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_additionalType(self, value):
        result = True
        # Validate type additionalType, a restriction on t:nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 500:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on additionalType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on additionalType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.contactFirstName is not None or
            self.contactMiddleName is not None or
            self.contactLastName is not None or
            self.contactEmail is not None or
            self.phone is not None or
            self.fax is not None or
            self.email is not None or
            self.website is not None or
            self.additional is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'contactFirstName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'contactFirstName')
            value_ = self.gds_validate_string(value_, node, 'contactFirstName')
            self.contactFirstName = value_
            self.contactFirstName_nsprefix_ = child_.prefix
            # validate type contactFirstNameType
            self.validate_contactFirstNameType(self.contactFirstName)
        elif nodeName_ == 'contactMiddleName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'contactMiddleName')
            value_ = self.gds_validate_string(value_, node, 'contactMiddleName')
            self.contactMiddleName = value_
            self.contactMiddleName_nsprefix_ = child_.prefix
            # validate type contactMiddleNameType
            self.validate_contactMiddleNameType(self.contactMiddleName)
        elif nodeName_ == 'contactLastName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'contactLastName')
            value_ = self.gds_validate_string(value_, node, 'contactLastName')
            self.contactLastName = value_
            self.contactLastName_nsprefix_ = child_.prefix
            # validate type contactLastNameType
            self.validate_contactLastNameType(self.contactLastName)
        elif nodeName_ == 'contactEmail':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'contactEmail')
            value_ = self.gds_validate_string(value_, node, 'contactEmail')
            self.contactEmail = value_
            self.contactEmail_nsprefix_ = child_.prefix
            # validate type emailType
            self.validate_emailType(self.contactEmail)
        elif nodeName_ == 'phone':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'phone')
            value_ = self.gds_validate_string(value_, node, 'phone')
            self.phone = value_
            self.phone_nsprefix_ = child_.prefix
            # validate type phoneType
            self.validate_phoneType(self.phone)
        elif nodeName_ == 'fax':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'fax')
            value_ = self.gds_validate_string(value_, node, 'fax')
            self.fax = value_
            self.fax_nsprefix_ = child_.prefix
            # validate type phoneType
            self.validate_phoneType(self.fax)
        elif nodeName_ == 'email':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'email')
            value_ = self.gds_validate_string(value_, node, 'email')
            self.email = value_
            self.email_nsprefix_ = child_.prefix
            # validate type emailType
            self.validate_emailType(self.email)
        elif nodeName_ == 'website':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'website')
            value_ = self.gds_validate_string(value_, node, 'website')
            self.website = value_
            self.website_nsprefix_ = child_.prefix
            # validate type websiteType
            self.validate_websiteType(self.website)
        elif nodeName_ == 'additional':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'additional')
            value_ = self.gds_validate_string(value_, node, 'additional')
            self.additional = value_
            self.additional_nsprefix_ = child_.prefix
            # validate type additionalType
            self.validate_additionalType(self.additional)
# end class contactInfoType24


class templatesType(GeneratedsSuper):
    """Шаблоны извещений"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'template': MemberSpec_('template', 'orderClauseTemplateType', 1, 0, {'maxOccurs': 'unbounded', 'name': 'template', 'type': 'orderClauseTemplateType'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, template=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if template is None:
            self.template = []
        else:
            self.template = template
        self.template_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, templatesType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if templatesType.subclass:
            return templatesType.subclass(*args_, **kwargs_)
        else:
            return templatesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.template
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'template':
            obj_ = orderClauseTemplateType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.template.append(obj_)
            obj_.original_tagname_ = 'template'
# end class templatesType


class templatesType27(GeneratedsSuper):
    """Шаблоны протоколов"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'template': MemberSpec_('template', 'protocolTemplateType', 1, 0, {'maxOccurs': 'unbounded', 'name': 'template', 'type': 'protocolTemplateType'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, template=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if template is None:
            self.template = []
        else:
            self.template = template
        self.template_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, templatesType27)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if templatesType27.subclass:
            return templatesType27.subclass(*args_, **kwargs_)
        else:
            return templatesType27(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.template
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'template':
            obj_ = protocolTemplateType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.template.append(obj_)
            obj_.original_tagname_ = 'template'
# end class templatesType27


class templatesType29(GeneratedsSuper):
    """Шаблоны извещений"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'template': MemberSpec_('template', 'noticeTemplateType', 1, 0, {'maxOccurs': 'unbounded', 'name': 'template', 'type': 'noticeTemplateType'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, template=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if template is None:
            self.template = []
        else:
            self.template = template
        self.template_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, templatesType29)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if templatesType29.subclass:
            return templatesType29.subclass(*args_, **kwargs_)
        else:
            return templatesType29(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.template
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'template':
            obj_ = noticeTemplateType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.template.append(obj_)
            obj_.original_tagname_ = 'template'
# end class templatesType29


class bodyType(GeneratedsSuper):
    """Данные информационного пакета"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'item': MemberSpec_('item', 'nsiOkatoItemType', 1, 0, {'maxOccurs': 'unbounded', 'name': 'item', 'type': 'nsiOkatoItemType'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, item=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if item is None:
            self.item = []
        else:
            self.item = item
        self.item_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, bodyType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if bodyType.subclass:
            return bodyType.subclass(*args_, **kwargs_)
        else:
            return bodyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.item
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'item':
            obj_ = nsiOkatoItemType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.item.append(obj_)
            obj_.original_tagname_ = 'item'
# end class bodyType


class bodyType32(GeneratedsSuper):
    """Данные информационного пакета"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'item': MemberSpec_('item', 'nsiOkdpItemType', 1, 0, {'maxOccurs': 'unbounded', 'name': 'item', 'type': 'nsiOkdpItemType'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, item=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if item is None:
            self.item = []
        else:
            self.item = item
        self.item_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, bodyType32)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if bodyType32.subclass:
            return bodyType32.subclass(*args_, **kwargs_)
        else:
            return bodyType32(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.item
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'item':
            obj_ = nsiOkdpItemType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.item.append(obj_)
            obj_.original_tagname_ = 'item'
# end class bodyType32


class bodyType33(GeneratedsSuper):
    """Данные информационного пакета"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'item': MemberSpec_('item', 'nsiOkpd2ItemType', 1, 0, {'maxOccurs': 'unbounded', 'name': 'item', 'type': 'nsiOkpd2ItemType'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, item=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if item is None:
            self.item = []
        else:
            self.item = item
        self.item_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, bodyType33)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if bodyType33.subclass:
            return bodyType33.subclass(*args_, **kwargs_)
        else:
            return bodyType33(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.item
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'item':
            obj_ = nsiOkpd2ItemType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.item.append(obj_)
            obj_.original_tagname_ = 'item'
# end class bodyType33


class bodyType34(GeneratedsSuper):
    """Данные информационного пакета"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'item': MemberSpec_('item', 'nsiOkeiItemType', 1, 0, {'maxOccurs': 'unbounded', 'name': 'item', 'type': 'nsiOkeiItemType'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, item=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if item is None:
            self.item = []
        else:
            self.item = item
        self.item_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, bodyType34)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if bodyType34.subclass:
            return bodyType34.subclass(*args_, **kwargs_)
        else:
            return bodyType34(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.item
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'item':
            obj_ = nsiOkeiItemType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.item.append(obj_)
            obj_.original_tagname_ = 'item'
# end class bodyType34


class bodyType35(GeneratedsSuper):
    """Данные информационного пакета"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'item': MemberSpec_('item', 'nsiOkfsItemType', 1, 0, {'maxOccurs': 'unbounded', 'name': 'item', 'type': 'nsiOkfsItemType'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, item=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if item is None:
            self.item = []
        else:
            self.item = item
        self.item_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, bodyType35)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if bodyType35.subclass:
            return bodyType35.subclass(*args_, **kwargs_)
        else:
            return bodyType35(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.item
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'item':
            obj_ = nsiOkfsItemType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.item.append(obj_)
            obj_.original_tagname_ = 'item'
# end class bodyType35


class bodyType36(GeneratedsSuper):
    """Данные информационного пакета"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'item': MemberSpec_('item', 'nsiOkoguItemType', 1, 0, {'maxOccurs': 'unbounded', 'name': 'item', 'type': 'nsiOkoguItemType'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, item=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if item is None:
            self.item = []
        else:
            self.item = item
        self.item_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, bodyType36)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if bodyType36.subclass:
            return bodyType36.subclass(*args_, **kwargs_)
        else:
            return bodyType36(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.item
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'item':
            obj_ = nsiOkoguItemType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.item.append(obj_)
            obj_.original_tagname_ = 'item'
# end class bodyType36


class bodyType37(GeneratedsSuper):
    """Данные информационного пакета"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'item': MemberSpec_('item', 'nsiOkopfItemType', 1, 0, {'maxOccurs': 'unbounded', 'name': 'item', 'type': 'nsiOkopfItemType'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, item=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if item is None:
            self.item = []
        else:
            self.item = item
        self.item_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, bodyType37)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if bodyType37.subclass:
            return bodyType37.subclass(*args_, **kwargs_)
        else:
            return bodyType37(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.item
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'item':
            obj_ = nsiOkopfItemType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.item.append(obj_)
            obj_.original_tagname_ = 'item'
# end class bodyType37


class bodyType38(GeneratedsSuper):
    """Данные информационного пакета"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'item': MemberSpec_('item', 'nsiOktmoItemType', 1, 0, {'maxOccurs': 'unbounded', 'name': 'item', 'type': 'nsiOktmoItemType'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, item=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if item is None:
            self.item = []
        else:
            self.item = item
        self.item_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, bodyType38)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if bodyType38.subclass:
            return bodyType38.subclass(*args_, **kwargs_)
        else:
            return bodyType38(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.item
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'item':
            obj_ = nsiOktmoItemType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.item.append(obj_)
            obj_.original_tagname_ = 'item'
# end class bodyType38


class bodyType39(GeneratedsSuper):
    """Данные информационного пакета"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'item': MemberSpec_('item', 'nsiOkvItemType', 1, 0, {'maxOccurs': 'unbounded', 'name': 'item', 'type': 'nsiOkvItemType'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, item=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if item is None:
            self.item = []
        else:
            self.item = item
        self.item_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, bodyType39)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if bodyType39.subclass:
            return bodyType39.subclass(*args_, **kwargs_)
        else:
            return bodyType39(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.item
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'item':
            obj_ = nsiOkvItemType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.item.append(obj_)
            obj_.original_tagname_ = 'item'
# end class bodyType39


class bodyType40(GeneratedsSuper):
    """Данные информационного пакета"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'item': MemberSpec_('item', 'nsiOkvedItemType', 1, 0, {'maxOccurs': 'unbounded', 'name': 'item', 'type': 'nsiOkvedItemType'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, item=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if item is None:
            self.item = []
        else:
            self.item = item
        self.item_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, bodyType40)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if bodyType40.subclass:
            return bodyType40.subclass(*args_, **kwargs_)
        else:
            return bodyType40(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.item
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'item':
            obj_ = nsiOkvedItemType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.item.append(obj_)
            obj_.original_tagname_ = 'item'
# end class bodyType40


class bodyType41(GeneratedsSuper):
    """Данные информационного пакета"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'item': MemberSpec_('item', 'nsiOkved2ItemType', 1, 0, {'maxOccurs': 'unbounded', 'name': 'item', 'type': 'nsiOkved2ItemType'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, item=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if item is None:
            self.item = []
        else:
            self.item = item
        self.item_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, bodyType41)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if bodyType41.subclass:
            return bodyType41.subclass(*args_, **kwargs_)
        else:
            return bodyType41(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.item
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'item':
            obj_ = nsiOkved2ItemType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.item.append(obj_)
            obj_.original_tagname_ = 'item'
# end class bodyType41


class bodyType42(GeneratedsSuper):
    """Данные информационного пакета"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'item': MemberSpec_('item', 'nsiOrganizationItemType', 1, 0, {'maxOccurs': 'unbounded', 'name': 'item', 'type': 'nsiOrganizationItemType'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, item=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if item is None:
            self.item = []
        else:
            self.item = item
        self.item_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, bodyType42)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if bodyType42.subclass:
            return bodyType42.subclass(*args_, **kwargs_)
        else:
            return bodyType42(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.item
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'item':
            obj_ = nsiOrganizationItemType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.item.append(obj_)
            obj_.original_tagname_ = 'item'
# end class bodyType42


class bodyType43(GeneratedsSuper):
    """Данные информационного пакета"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'item': MemberSpec_('item', 'nsiProtocolTypeItemType', 1, 0, {'maxOccurs': 'unbounded', 'name': 'item', 'type': 'nsiProtocolTypeItemType'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, item=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if item is None:
            self.item = []
        else:
            self.item = item
        self.item_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, bodyType43)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if bodyType43.subclass:
            return bodyType43.subclass(*args_, **kwargs_)
        else:
            return bodyType43(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.item
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'item':
            obj_ = nsiProtocolTypeItemType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.item.append(obj_)
            obj_.original_tagname_ = 'item'
# end class bodyType43


class bodyType44(GeneratedsSuper):
    """Данные информационного пакета"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'item': MemberSpec_('item', 'nsiOrderClauseTypeItemType', 1, 0, {'maxOccurs': 'unbounded', 'name': 'item', 'type': 'nsiOrderClauseTypeItemType'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, item=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if item is None:
            self.item = []
        else:
            self.item = item
        self.item_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, bodyType44)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if bodyType44.subclass:
            return bodyType44.subclass(*args_, **kwargs_)
        else:
            return bodyType44(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.item
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'item':
            obj_ = nsiOrderClauseTypeItemType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.item.append(obj_)
            obj_.original_tagname_ = 'item'
# end class bodyType44


class bodyType45(GeneratedsSuper):
    """Данные информационного пакета"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'item': MemberSpec_('item', 'nsiPurchaseMethodItemType', 1, 0, {'maxOccurs': 'unbounded', 'name': 'item', 'type': 'nsiPurchaseMethodItemType'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, item=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if item is None:
            self.item = []
        else:
            self.item = item
        self.item_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, bodyType45)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if bodyType45.subclass:
            return bodyType45.subclass(*args_, **kwargs_)
        else:
            return bodyType45(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.item
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'item':
            obj_ = nsiPurchaseMethodItemType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.item.append(obj_)
            obj_.original_tagname_ = 'item'
# end class bodyType45


class bodyType46(GeneratedsSuper):
    """Данные информационного пакета"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'orderClauseDocumentUpload': MemberSpec_('orderClauseDocumentUpload', 'orderClauseDocumentUploadType', 0, 0, {'name': 'orderClauseDocumentUpload', 'type': 'orderClauseDocumentUploadType'}, 12),
        'noticeDocumentUpload': MemberSpec_('noticeDocumentUpload', 'noticeDocumentUploadType', 0, 0, {'name': 'noticeDocumentUpload', 'type': 'noticeDocumentUploadType'}, 12),
        'protocolDocumentUpload': MemberSpec_('protocolDocumentUpload', 'protocolDocumentUploadType', 0, 0, {'name': 'protocolDocumentUpload', 'type': 'protocolDocumentUploadType'}, 12),
        'purchaseContractDocumentUpload': MemberSpec_('purchaseContractDocumentUpload', 'purchaseContractDocumentUploadType', 0, 0, {'name': 'purchaseContractDocumentUpload', 'type': 'purchaseContractDocumentUploadType'}, 12),
        'purchasePlanDocumentUpload': MemberSpec_('purchasePlanDocumentUpload', 'purchasePlanDocumentUploadType', 0, 0, {'name': 'purchasePlanDocumentUpload', 'type': 'purchasePlanDocumentUploadType'}, 12),
        'purchasePlanProjectDocumentUpload': MemberSpec_('purchasePlanProjectDocumentUpload', 'purchasePlanProjectDocumentUploadType', 0, 0, {'name': 'purchasePlanProjectDocumentUpload', 'type': 'purchasePlanProjectDocumentUploadType'}, 12),
        'purchaseContractAccountDocumentUpload': MemberSpec_('purchaseContractAccountDocumentUpload', 'purchaseContractAccountDocumentUploadType', 0, 0, {'name': 'purchaseContractAccountDocumentUpload', 'type': 'purchaseContractAccountDocumentUploadType'}, 12),
        'purchaseRejectionDocumentUpload': MemberSpec_('purchaseRejectionDocumentUpload', 'purchaseRejectionDocumentUploadType', 0, 0, {'name': 'purchaseRejectionDocumentUpload', 'type': 'purchaseRejectionDocumentUploadType'}, 12),
        'explanationDocumentUpload': MemberSpec_('explanationDocumentUpload', 'explanationDocumentUploadType', 0, 0, {'name': 'explanationDocumentUpload', 'type': 'explanationDocumentUploadType'}, 12),
        'explanationRequestDocumentUpload': MemberSpec_('explanationRequestDocumentUpload', 'explanationRequestDocumentUploadType', 0, 0, {'name': 'explanationRequestDocumentUpload', 'type': 'explanationRequestDocumentUploadType'}, 12),
        'changeRequirementsDocumentUpload': MemberSpec_('changeRequirementsDocumentUpload', 'changeRequirementsDocumentUploadType', 0, 0, {'name': 'changeRequirementsDocumentUpload', 'type': 'changeRequirementsDocumentUploadType'}, 12),
        'contractDocumentUpload': MemberSpec_('contractDocumentUpload', 'contractDocumentUploadType', 0, 0, {'name': 'contractDocumentUpload', 'type': 'contractDocumentUploadType'}, 12),
        'contractCompletionDocumentUpload': MemberSpec_('contractCompletionDocumentUpload', 'contractCompletionDocumentUploadType', 0, 0, {'name': 'contractCompletionDocumentUpload', 'type': 'contractCompletionDocumentUploadType'}, 12),
        'contractCancellationDocumentUpload': MemberSpec_('contractCancellationDocumentUpload', 'contractCancellationDocumentUploadType', 0, 0, {'name': 'contractCancellationDocumentUpload', 'type': 'contractCancellationDocumentUploadType'}, 12),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, orderClauseDocumentUpload=None, noticeDocumentUpload=None, protocolDocumentUpload=None, purchaseContractDocumentUpload=None, purchasePlanDocumentUpload=None, purchasePlanProjectDocumentUpload=None, purchaseContractAccountDocumentUpload=None, purchaseRejectionDocumentUpload=None, explanationDocumentUpload=None, explanationRequestDocumentUpload=None, changeRequirementsDocumentUpload=None, contractDocumentUpload=None, contractCompletionDocumentUpload=None, contractCancellationDocumentUpload=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.orderClauseDocumentUpload = orderClauseDocumentUpload
        self.orderClauseDocumentUpload_nsprefix_ = None
        self.noticeDocumentUpload = noticeDocumentUpload
        self.noticeDocumentUpload_nsprefix_ = None
        self.protocolDocumentUpload = protocolDocumentUpload
        self.protocolDocumentUpload_nsprefix_ = None
        self.purchaseContractDocumentUpload = purchaseContractDocumentUpload
        self.purchaseContractDocumentUpload_nsprefix_ = None
        self.purchasePlanDocumentUpload = purchasePlanDocumentUpload
        self.purchasePlanDocumentUpload_nsprefix_ = None
        self.purchasePlanProjectDocumentUpload = purchasePlanProjectDocumentUpload
        self.purchasePlanProjectDocumentUpload_nsprefix_ = None
        self.purchaseContractAccountDocumentUpload = purchaseContractAccountDocumentUpload
        self.purchaseContractAccountDocumentUpload_nsprefix_ = None
        self.purchaseRejectionDocumentUpload = purchaseRejectionDocumentUpload
        self.purchaseRejectionDocumentUpload_nsprefix_ = None
        self.explanationDocumentUpload = explanationDocumentUpload
        self.explanationDocumentUpload_nsprefix_ = None
        self.explanationRequestDocumentUpload = explanationRequestDocumentUpload
        self.explanationRequestDocumentUpload_nsprefix_ = None
        self.changeRequirementsDocumentUpload = changeRequirementsDocumentUpload
        self.changeRequirementsDocumentUpload_nsprefix_ = None
        self.contractDocumentUpload = contractDocumentUpload
        self.contractDocumentUpload_nsprefix_ = None
        self.contractCompletionDocumentUpload = contractCompletionDocumentUpload
        self.contractCompletionDocumentUpload_nsprefix_ = None
        self.contractCancellationDocumentUpload = contractCancellationDocumentUpload
        self.contractCancellationDocumentUpload_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, bodyType46)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if bodyType46.subclass:
            return bodyType46.subclass(*args_, **kwargs_)
        else:
            return bodyType46(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.orderClauseDocumentUpload is not None or
            self.noticeDocumentUpload is not None or
            self.protocolDocumentUpload is not None or
            self.purchaseContractDocumentUpload is not None or
            self.purchasePlanDocumentUpload is not None or
            self.purchasePlanProjectDocumentUpload is not None or
            self.purchaseContractAccountDocumentUpload is not None or
            self.purchaseRejectionDocumentUpload is not None or
            self.explanationDocumentUpload is not None or
            self.explanationRequestDocumentUpload is not None or
            self.changeRequirementsDocumentUpload is not None or
            self.contractDocumentUpload is not None or
            self.contractCompletionDocumentUpload is not None or
            self.contractCancellationDocumentUpload is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'orderClauseDocumentUpload':
            obj_ = orderClauseDocumentUploadType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.orderClauseDocumentUpload = obj_
            obj_.original_tagname_ = 'orderClauseDocumentUpload'
        elif nodeName_ == 'noticeDocumentUpload':
            obj_ = noticeDocumentUploadType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.noticeDocumentUpload = obj_
            obj_.original_tagname_ = 'noticeDocumentUpload'
        elif nodeName_ == 'protocolDocumentUpload':
            obj_ = protocolDocumentUploadType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.protocolDocumentUpload = obj_
            obj_.original_tagname_ = 'protocolDocumentUpload'
        elif nodeName_ == 'purchaseContractDocumentUpload':
            obj_ = purchaseContractDocumentUploadType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.purchaseContractDocumentUpload = obj_
            obj_.original_tagname_ = 'purchaseContractDocumentUpload'
        elif nodeName_ == 'purchasePlanDocumentUpload':
            obj_ = purchasePlanDocumentUploadType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.purchasePlanDocumentUpload = obj_
            obj_.original_tagname_ = 'purchasePlanDocumentUpload'
        elif nodeName_ == 'purchasePlanProjectDocumentUpload':
            obj_ = purchasePlanProjectDocumentUploadType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.purchasePlanProjectDocumentUpload = obj_
            obj_.original_tagname_ = 'purchasePlanProjectDocumentUpload'
        elif nodeName_ == 'purchaseContractAccountDocumentUpload':
            obj_ = purchaseContractAccountDocumentUploadType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.purchaseContractAccountDocumentUpload = obj_
            obj_.original_tagname_ = 'purchaseContractAccountDocumentUpload'
        elif nodeName_ == 'purchaseRejectionDocumentUpload':
            obj_ = purchaseRejectionDocumentUploadType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.purchaseRejectionDocumentUpload = obj_
            obj_.original_tagname_ = 'purchaseRejectionDocumentUpload'
        elif nodeName_ == 'explanationDocumentUpload':
            obj_ = explanationDocumentUploadType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.explanationDocumentUpload = obj_
            obj_.original_tagname_ = 'explanationDocumentUpload'
        elif nodeName_ == 'explanationRequestDocumentUpload':
            obj_ = explanationRequestDocumentUploadType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.explanationRequestDocumentUpload = obj_
            obj_.original_tagname_ = 'explanationRequestDocumentUpload'
        elif nodeName_ == 'changeRequirementsDocumentUpload':
            obj_ = changeRequirementsDocumentUploadType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.changeRequirementsDocumentUpload = obj_
            obj_.original_tagname_ = 'changeRequirementsDocumentUpload'
        elif nodeName_ == 'contractDocumentUpload':
            obj_ = contractDocumentUploadType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.contractDocumentUpload = obj_
            obj_.original_tagname_ = 'contractDocumentUpload'
        elif nodeName_ == 'contractCompletionDocumentUpload':
            obj_ = contractCompletionDocumentUploadType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.contractCompletionDocumentUpload = obj_
            obj_.original_tagname_ = 'contractCompletionDocumentUpload'
        elif nodeName_ == 'contractCancellationDocumentUpload':
            obj_ = contractCancellationDocumentUploadType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.contractCancellationDocumentUpload = obj_
            obj_.original_tagname_ = 'contractCancellationDocumentUpload'
# end class bodyType46


class orderClauseDocumentUploadType(documentUploadBaseData):
    """Документы положения о закупке"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = documentUploadBaseData
    def __init__(self, guid=None, entityGuid=None, placer=None, additionalDocumentsCount=None, documentNumber=None, document=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(orderClauseDocumentUploadType, self).__init__(guid, entityGuid, placer, additionalDocumentsCount, documentNumber, document,  **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, orderClauseDocumentUploadType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if orderClauseDocumentUploadType.subclass:
            return orderClauseDocumentUploadType.subclass(*args_, **kwargs_)
        else:
            return orderClauseDocumentUploadType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(orderClauseDocumentUploadType, self).hasContent_()
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(orderClauseDocumentUploadType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(orderClauseDocumentUploadType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class orderClauseDocumentUploadType


class noticeDocumentUploadType(documentUploadBaseData):
    """Документы извещения о закупке"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'isUploadComplete': MemberSpec_('isUploadComplete', 'xs:boolean', 0, 1, {'default': 'false', 'minOccurs': '0', 'name': 'isUploadComplete', 'type': 'xs:boolean'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = documentUploadBaseData
    def __init__(self, guid=None, entityGuid=None, placer=None, additionalDocumentsCount=None, documentNumber=None, document=None, isUploadComplete=False, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(noticeDocumentUploadType, self).__init__(guid, entityGuid, placer, additionalDocumentsCount, documentNumber, document,  **kwargs_)
        self.isUploadComplete = isUploadComplete
        self.isUploadComplete_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, noticeDocumentUploadType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if noticeDocumentUploadType.subclass:
            return noticeDocumentUploadType.subclass(*args_, **kwargs_)
        else:
            return noticeDocumentUploadType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.isUploadComplete or
            super(noticeDocumentUploadType, self).hasContent_()
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(noticeDocumentUploadType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'isUploadComplete':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'isUploadComplete')
            ival_ = self.gds_validate_boolean(ival_, node, 'isUploadComplete')
            self.isUploadComplete = ival_
            self.isUploadComplete_nsprefix_ = child_.prefix
        super(noticeDocumentUploadType, self).buildChildren(child_, node, nodeName_, True)
# end class noticeDocumentUploadType


class protocolDocumentUploadType(documentUploadBaseData):
    """Документы протокола"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = documentUploadBaseData
    def __init__(self, guid=None, entityGuid=None, placer=None, additionalDocumentsCount=None, documentNumber=None, document=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(protocolDocumentUploadType, self).__init__(guid, entityGuid, placer, additionalDocumentsCount, documentNumber, document,  **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, protocolDocumentUploadType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if protocolDocumentUploadType.subclass:
            return protocolDocumentUploadType.subclass(*args_, **kwargs_)
        else:
            return protocolDocumentUploadType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(protocolDocumentUploadType, self).hasContent_()
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(protocolDocumentUploadType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(protocolDocumentUploadType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class protocolDocumentUploadType


class purchaseContractDocumentUploadType(documentUploadBaseData):
    """Документы договора закупки"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = documentUploadBaseData
    def __init__(self, guid=None, entityGuid=None, placer=None, additionalDocumentsCount=None, documentNumber=None, document=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(purchaseContractDocumentUploadType, self).__init__(guid, entityGuid, placer, additionalDocumentsCount, documentNumber, document,  **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, purchaseContractDocumentUploadType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if purchaseContractDocumentUploadType.subclass:
            return purchaseContractDocumentUploadType.subclass(*args_, **kwargs_)
        else:
            return purchaseContractDocumentUploadType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(purchaseContractDocumentUploadType, self).hasContent_()
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(purchaseContractDocumentUploadType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(purchaseContractDocumentUploadType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class purchaseContractDocumentUploadType


class purchasePlanDocumentUploadType(documentUploadBaseData):
    """Документы плана закупок"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = documentUploadBaseData
    def __init__(self, guid=None, entityGuid=None, placer=None, additionalDocumentsCount=None, documentNumber=None, document=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(purchasePlanDocumentUploadType, self).__init__(guid, entityGuid, placer, additionalDocumentsCount, documentNumber, document,  **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, purchasePlanDocumentUploadType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if purchasePlanDocumentUploadType.subclass:
            return purchasePlanDocumentUploadType.subclass(*args_, **kwargs_)
        else:
            return purchasePlanDocumentUploadType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(purchasePlanDocumentUploadType, self).hasContent_()
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(purchasePlanDocumentUploadType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(purchasePlanDocumentUploadType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class purchasePlanDocumentUploadType


class purchasePlanProjectDocumentUploadType(documentUploadBaseData):
    """Документы проекта плана закупок"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = documentUploadBaseData
    def __init__(self, guid=None, entityGuid=None, placer=None, additionalDocumentsCount=None, documentNumber=None, document=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(purchasePlanProjectDocumentUploadType, self).__init__(guid, entityGuid, placer, additionalDocumentsCount, documentNumber, document,  **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, purchasePlanProjectDocumentUploadType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if purchasePlanProjectDocumentUploadType.subclass:
            return purchasePlanProjectDocumentUploadType.subclass(*args_, **kwargs_)
        else:
            return purchasePlanProjectDocumentUploadType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(purchasePlanProjectDocumentUploadType, self).hasContent_()
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(purchasePlanProjectDocumentUploadType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(purchasePlanProjectDocumentUploadType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class purchasePlanProjectDocumentUploadType


class purchaseContractAccountDocumentUploadType(documentUploadBaseData):
    """Документы отчетности о договорах"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = documentUploadBaseData
    def __init__(self, guid=None, entityGuid=None, placer=None, additionalDocumentsCount=None, documentNumber=None, document=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(purchaseContractAccountDocumentUploadType, self).__init__(guid, entityGuid, placer, additionalDocumentsCount, documentNumber, document,  **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, purchaseContractAccountDocumentUploadType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if purchaseContractAccountDocumentUploadType.subclass:
            return purchaseContractAccountDocumentUploadType.subclass(*args_, **kwargs_)
        else:
            return purchaseContractAccountDocumentUploadType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(purchaseContractAccountDocumentUploadType, self).hasContent_()
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(purchaseContractAccountDocumentUploadType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(purchaseContractAccountDocumentUploadType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class purchaseContractAccountDocumentUploadType


class purchaseRejectionDocumentUploadType(documentUploadBaseData):
    """Документы извещения об отказе"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = documentUploadBaseData
    def __init__(self, guid=None, entityGuid=None, placer=None, additionalDocumentsCount=None, documentNumber=None, document=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(purchaseRejectionDocumentUploadType, self).__init__(guid, entityGuid, placer, additionalDocumentsCount, documentNumber, document,  **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, purchaseRejectionDocumentUploadType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if purchaseRejectionDocumentUploadType.subclass:
            return purchaseRejectionDocumentUploadType.subclass(*args_, **kwargs_)
        else:
            return purchaseRejectionDocumentUploadType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(purchaseRejectionDocumentUploadType, self).hasContent_()
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(purchaseRejectionDocumentUploadType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(purchaseRejectionDocumentUploadType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class purchaseRejectionDocumentUploadType


class explanationDocumentUploadType(documentUploadBaseData):
    """Документы разъяснения"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = documentUploadBaseData
    def __init__(self, guid=None, entityGuid=None, placer=None, additionalDocumentsCount=None, documentNumber=None, document=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(explanationDocumentUploadType, self).__init__(guid, entityGuid, placer, additionalDocumentsCount, documentNumber, document,  **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, explanationDocumentUploadType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if explanationDocumentUploadType.subclass:
            return explanationDocumentUploadType.subclass(*args_, **kwargs_)
        else:
            return explanationDocumentUploadType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(explanationDocumentUploadType, self).hasContent_()
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(explanationDocumentUploadType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(explanationDocumentUploadType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class explanationDocumentUploadType


class explanationRequestDocumentUploadType(documentUploadBaseData):
    """Документы запросов заказчика о разъяснении положений заявки"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = documentUploadBaseData
    def __init__(self, guid=None, entityGuid=None, placer=None, additionalDocumentsCount=None, documentNumber=None, document=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(explanationRequestDocumentUploadType, self).__init__(guid, entityGuid, placer, additionalDocumentsCount, documentNumber, document,  **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, explanationRequestDocumentUploadType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if explanationRequestDocumentUploadType.subclass:
            return explanationRequestDocumentUploadType.subclass(*args_, **kwargs_)
        else:
            return explanationRequestDocumentUploadType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(explanationRequestDocumentUploadType, self).hasContent_()
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(explanationRequestDocumentUploadType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(explanationRequestDocumentUploadType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class explanationRequestDocumentUploadType


class changeRequirementsDocumentUploadType(documentUploadBaseData):
    """Документы уточненных требований"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = documentUploadBaseData
    def __init__(self, guid=None, entityGuid=None, placer=None, additionalDocumentsCount=None, documentNumber=None, document=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(changeRequirementsDocumentUploadType, self).__init__(guid, entityGuid, placer, additionalDocumentsCount, documentNumber, document,  **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, changeRequirementsDocumentUploadType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if changeRequirementsDocumentUploadType.subclass:
            return changeRequirementsDocumentUploadType.subclass(*args_, **kwargs_)
        else:
            return changeRequirementsDocumentUploadType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(changeRequirementsDocumentUploadType, self).hasContent_()
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(changeRequirementsDocumentUploadType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(changeRequirementsDocumentUploadType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class changeRequirementsDocumentUploadType


class contractDocumentUploadType(documentUploadBaseData):
    """Документы договора"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = documentUploadBaseData
    def __init__(self, guid=None, entityGuid=None, placer=None, additionalDocumentsCount=None, documentNumber=None, document=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(contractDocumentUploadType, self).__init__(guid, entityGuid, placer, additionalDocumentsCount, documentNumber, document,  **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, contractDocumentUploadType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if contractDocumentUploadType.subclass:
            return contractDocumentUploadType.subclass(*args_, **kwargs_)
        else:
            return contractDocumentUploadType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(contractDocumentUploadType, self).hasContent_()
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(contractDocumentUploadType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(contractDocumentUploadType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class contractDocumentUploadType


class contractCompletionDocumentUploadType(documentUploadBaseData):
    """Документы сведений об исполнении договора"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = documentUploadBaseData
    def __init__(self, guid=None, entityGuid=None, placer=None, additionalDocumentsCount=None, documentNumber=None, document=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(contractCompletionDocumentUploadType, self).__init__(guid, entityGuid, placer, additionalDocumentsCount, documentNumber, document,  **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, contractCompletionDocumentUploadType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if contractCompletionDocumentUploadType.subclass:
            return contractCompletionDocumentUploadType.subclass(*args_, **kwargs_)
        else:
            return contractCompletionDocumentUploadType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(contractCompletionDocumentUploadType, self).hasContent_()
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(contractCompletionDocumentUploadType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(contractCompletionDocumentUploadType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class contractCompletionDocumentUploadType


class contractCancellationDocumentUploadType(documentUploadBaseData):
    """Документы сведений о расторжении договора"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = documentUploadBaseData
    def __init__(self, guid=None, entityGuid=None, placer=None, additionalDocumentsCount=None, documentNumber=None, document=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(contractCancellationDocumentUploadType, self).__init__(guid, entityGuid, placer, additionalDocumentsCount, documentNumber, document,  **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, contractCancellationDocumentUploadType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if contractCancellationDocumentUploadType.subclass:
            return contractCancellationDocumentUploadType.subclass(*args_, **kwargs_)
        else:
            return contractCancellationDocumentUploadType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(contractCancellationDocumentUploadType, self).hasContent_()
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(contractCancellationDocumentUploadType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(contractCancellationDocumentUploadType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class contractCancellationDocumentUploadType


class bodyType47(GeneratedsSuper):
    """Данные информационного пакета"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'refguid': MemberSpec_('refguid', ['guidType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'refguid', 'type': 'xs:string'}, None),
        'result': MemberSpec_('result', ['resultType', 'xs:string'], 0, 0, {'name': 'result', 'type': 'xs:string'}, None),
        'itemResults': MemberSpec_('itemResults', 'itemResultListType', 0, 1, {'minOccurs': '0', 'name': 'itemResults', 'type': 'itemResultListType'}, None),
        'violations': MemberSpec_('violations', 'violationListType', 0, 1, {'minOccurs': '0', 'name': 'violations', 'type': 'violationListType'}, None),
        'refFileName': MemberSpec_('refFileName', ['nonEmptyString', 'xs:string'], 0, 0, {'name': 'refFileName', 'type': 'xs:string'}, None),
        'messageId': MemberSpec_('messageId', 'xs:string', 0, 1, {'minOccurs': '0', 'name': 'messageId', 'type': 'xs:string'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, refguid=None, result=None, itemResults=None, violations=None, refFileName=None, messageId=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.refguid = refguid
        self.validate_guidType(self.refguid)
        self.refguid_nsprefix_ = None
        self.result = result
        self.validate_resultType(self.result)
        self.result_nsprefix_ = None
        self.itemResults = itemResults
        self.itemResults_nsprefix_ = None
        self.violations = violations
        self.violations_nsprefix_ = None
        self.refFileName = refFileName
        self.validate_nonEmptyString(self.refFileName)
        self.refFileName_nsprefix_ = None
        self.messageId = messageId
        self.messageId_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, bodyType47)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if bodyType47.subclass:
            return bodyType47.subclass(*args_, **kwargs_)
        else:
            return bodyType47(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_guidType(self, value):
        result = True
        # Validate type guidType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) != 36:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd length restriction on guidType' % {"value": encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_guidType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_guidType_patterns_, ))
                result = False
        return result
    validate_guidType_patterns_ = [['^([a-fA-F0-9]{8}\\-[a-fA-F0-9]{4}\\-[a-fA-F0-9]{4}\\-[a-fA-F0-9]{4}\\-[a-fA-F0-9]{12})$']]
    def validate_resultType(self, value):
        result = True
        # Validate type resultType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['success', 'failure']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on resultType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_nonEmptyString(self, value):
        result = True
        # Validate type nonEmptyString, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on nonEmptyString' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.refguid is not None or
            self.result is not None or
            self.itemResults is not None or
            self.violations is not None or
            self.refFileName is not None or
            self.messageId is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'refguid':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'refguid')
            value_ = self.gds_validate_string(value_, node, 'refguid')
            self.refguid = value_
            self.refguid_nsprefix_ = child_.prefix
            # validate type guidType
            self.validate_guidType(self.refguid)
        elif nodeName_ == 'result':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'result')
            value_ = self.gds_validate_string(value_, node, 'result')
            self.result = value_
            self.result_nsprefix_ = child_.prefix
            # validate type resultType
            self.validate_resultType(self.result)
        elif nodeName_ == 'itemResults':
            obj_ = itemResultListType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.itemResults = obj_
            obj_.original_tagname_ = 'itemResults'
        elif nodeName_ == 'violations':
            obj_ = violationListType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.violations = obj_
            obj_.original_tagname_ = 'violations'
        elif nodeName_ == 'refFileName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'refFileName')
            value_ = self.gds_validate_string(value_, node, 'refFileName')
            self.refFileName = value_
            self.refFileName_nsprefix_ = child_.prefix
            # validate type nonEmptyString
            self.validate_nonEmptyString(self.refFileName)
        elif nodeName_ == 'messageId':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'messageId')
            value_ = self.gds_validate_string(value_, node, 'messageId')
            self.messageId = value_
            self.messageId_nsprefix_ = child_.prefix
# end class bodyType47


class bodyType48(GeneratedsSuper):
    """Данные информационного пакета"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'messages': MemberSpec_('messages', 'messagesType', 0, 0, {'name': 'messages', 'type': 'messagesType'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, messages=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.messages = messages
        self.messages_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, bodyType48)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if bodyType48.subclass:
            return bodyType48.subclass(*args_, **kwargs_)
        else:
            return bodyType48(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.messages is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'messages':
            obj_ = messagesType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.messages = obj_
            obj_.original_tagname_ = 'messages'
# end class bodyType48


class messagesType(GeneratedsSuper):
    """Сообщения для асинхронного взаимодействия"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'message': MemberSpec_('message', 'messageType', 1, 0, {'maxOccurs': '1000', 'name': 'message', 'type': 'messageType'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, message=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if message is None:
            self.message = []
        else:
            self.message = message
        self.message_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, messagesType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if messagesType.subclass:
            return messagesType.subclass(*args_, **kwargs_)
        else:
            return messagesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.message
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'message':
            obj_ = messageType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.message.append(obj_)
            obj_.original_tagname_ = 'message'
# end class messagesType


class messageType(GeneratedsSuper):
    """Сообщение для асинхронного взаимодействия"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'messageId': MemberSpec_('messageId', 'xs:string', 0, 0, {'name': 'messageId', 'type': 'xs:string'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, messageId=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.messageId = messageId
        self.messageId_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, messageType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if messageType.subclass:
            return messageType.subclass(*args_, **kwargs_)
        else:
            return messageType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.messageId is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'messageId':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'messageId')
            value_ = self.gds_validate_string(value_, node, 'messageId')
            self.messageId = value_
            self.messageId_nsprefix_ = child_.prefix
# end class messageType


class bodyType49(GeneratedsSuper):
    """Данные информационного пакета"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'refguid': MemberSpec_('refguid', ['guidType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'refguid', 'type': 'xs:string'}, None),
        'result': MemberSpec_('result', ['resultType', 'xs:string'], 0, 0, {'name': 'result', 'type': 'xs:string'}, None),
        'violations': MemberSpec_('violations', 'violationListType', 0, 1, {'minOccurs': '0', 'name': 'violations', 'type': 'violationListType'}, None),
        'infos': MemberSpec_('infos', 'infosType', 0, 1, {'minOccurs': '0', 'name': 'infos', 'type': 'infosType'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, refguid=None, result=None, violations=None, infos=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.refguid = refguid
        self.validate_guidType(self.refguid)
        self.refguid_nsprefix_ = None
        self.result = result
        self.validate_resultType(self.result)
        self.result_nsprefix_ = None
        self.violations = violations
        self.violations_nsprefix_ = None
        self.infos = infos
        self.infos_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, bodyType49)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if bodyType49.subclass:
            return bodyType49.subclass(*args_, **kwargs_)
        else:
            return bodyType49(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_guidType(self, value):
        result = True
        # Validate type guidType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) != 36:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd length restriction on guidType' % {"value": encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_guidType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_guidType_patterns_, ))
                result = False
        return result
    validate_guidType_patterns_ = [['^([a-fA-F0-9]{8}\\-[a-fA-F0-9]{4}\\-[a-fA-F0-9]{4}\\-[a-fA-F0-9]{4}\\-[a-fA-F0-9]{12})$']]
    def validate_resultType(self, value):
        result = True
        # Validate type resultType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['success', 'failure']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on resultType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.refguid is not None or
            self.result is not None or
            self.violations is not None or
            self.infos is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'refguid':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'refguid')
            value_ = self.gds_validate_string(value_, node, 'refguid')
            self.refguid = value_
            self.refguid_nsprefix_ = child_.prefix
            # validate type guidType
            self.validate_guidType(self.refguid)
        elif nodeName_ == 'result':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'result')
            value_ = self.gds_validate_string(value_, node, 'result')
            self.result = value_
            self.result_nsprefix_ = child_.prefix
            # validate type resultType
            self.validate_resultType(self.result)
        elif nodeName_ == 'violations':
            obj_ = violationListType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.violations = obj_
            obj_.original_tagname_ = 'violations'
        elif nodeName_ == 'infos':
            obj_ = infosType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.infos = obj_
            obj_.original_tagname_ = 'infos'
# end class bodyType49


class infosType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'info': MemberSpec_('info', 'infoType', 1, 0, {'maxOccurs': '1000', 'minOccurs': '1', 'name': 'info', 'type': 'infoType'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, info=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if info is None:
            self.info = []
        else:
            self.info = info
        self.info_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, infosType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if infosType.subclass:
            return infosType.subclass(*args_, **kwargs_)
        else:
            return infosType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.info
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'info':
            obj_ = infoType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.info.append(obj_)
            obj_.original_tagname_ = 'info'
# end class infosType


class infoType(GeneratedsSuper):
    """Информаиця о загружаемых сведениях"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'guid': MemberSpec_('guid', ['guidType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'guid', 'type': 'xs:string'}, None),
        'regNum': MemberSpec_('regNum', 'xs:string', 0, 1, {'minOccurs': '0', 'name': 'regNum', 'type': 'xs:string'}, None),
        'placeDate': MemberSpec_('placeDate', 'xs:dateTime', 0, 1, {'minOccurs': '0', 'name': 'placeDate', 'type': 'xs:dateTime'}, None),
        'version': MemberSpec_('version', 'xs:int', 0, 1, {'minOccurs': '0', 'name': 'version', 'type': 'xs:int'}, None),
        'placer': MemberSpec_('placer', 'placerType', 0, 1, {'minOccurs': '0', 'name': 'placer', 'type': 'placerType'}, None),
        'status': MemberSpec_('status', ['statusType', 'xs:string'], 0, 0, {'name': 'status', 'type': 'xs:string'}, None),
        'violations': MemberSpec_('violations', 'violationListType', 0, 1, {'minOccurs': '0', 'name': 'violations', 'type': 'violationListType'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, guid=None, regNum=None, placeDate=None, version=None, placer=None, status=None, violations=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.guid = guid
        self.validate_guidType(self.guid)
        self.guid_nsprefix_ = None
        self.regNum = regNum
        self.regNum_nsprefix_ = None
        if isinstance(placeDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(placeDate, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = placeDate
        self.placeDate = initvalue_
        self.placeDate_nsprefix_ = None
        self.version = version
        self.version_nsprefix_ = None
        self.placer = placer
        self.placer_nsprefix_ = None
        self.status = status
        self.validate_statusType(self.status)
        self.status_nsprefix_ = None
        self.violations = violations
        self.violations_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, infoType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if infoType.subclass:
            return infoType.subclass(*args_, **kwargs_)
        else:
            return infoType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_guidType(self, value):
        result = True
        # Validate type guidType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) != 36:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd length restriction on guidType' % {"value": encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_guidType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_guidType_patterns_, ))
                result = False
        return result
    validate_guidType_patterns_ = [['^([a-fA-F0-9]{8}\\-[a-fA-F0-9]{4}\\-[a-fA-F0-9]{4}\\-[a-fA-F0-9]{4}\\-[a-fA-F0-9]{12})$']]
    def validate_statusType(self, value):
        result = True
        # Validate type statusType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['success', 'failure', 'queued', 'processing']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on statusType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.guid is not None or
            self.regNum is not None or
            self.placeDate is not None or
            self.version is not None or
            self.placer is not None or
            self.status is not None or
            self.violations is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'guid':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'guid')
            value_ = self.gds_validate_string(value_, node, 'guid')
            self.guid = value_
            self.guid_nsprefix_ = child_.prefix
            # validate type guidType
            self.validate_guidType(self.guid)
        elif nodeName_ == 'regNum':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'regNum')
            value_ = self.gds_validate_string(value_, node, 'regNum')
            self.regNum = value_
            self.regNum_nsprefix_ = child_.prefix
        elif nodeName_ == 'placeDate':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.placeDate = dval_
            self.placeDate_nsprefix_ = child_.prefix
        elif nodeName_ == 'version' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'version')
            ival_ = self.gds_validate_integer(ival_, node, 'version')
            self.version = ival_
            self.version_nsprefix_ = child_.prefix
        elif nodeName_ == 'placer':
            obj_ = placerType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.placer = obj_
            obj_.original_tagname_ = 'placer'
        elif nodeName_ == 'status':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'status')
            value_ = self.gds_validate_string(value_, node, 'status')
            self.status = value_
            self.status_nsprefix_ = child_.prefix
            # validate type statusType
            self.validate_statusType(self.status)
        elif nodeName_ == 'violations':
            obj_ = violationListType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.violations = obj_
            obj_.original_tagname_ = 'violations'
# end class infoType


class placerType(GeneratedsSuper):
    """Информация об организации, разместившей сведения"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'name': MemberSpec_('name', 'xs:string', 0, 1, {'minOccurs': '0', 'name': 'name', 'type': 'xs:string'}, None),
        'inn': MemberSpec_('inn', ['innType', 'nonEmptyString', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'inn', 'type': 'xs:string'}, None),
        'kpp': MemberSpec_('kpp', ['kppType', 'nonEmptyString', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'kpp', 'type': 'xs:string'}, None),
        'ogrn': MemberSpec_('ogrn', ['ogrnType', 'nonEmptyString', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'ogrn', 'type': 'xs:string'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, name=None, inn=None, kpp=None, ogrn=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.name = name
        self.name_nsprefix_ = None
        self.inn = inn
        self.validate_innType(self.inn)
        self.inn_nsprefix_ = None
        self.kpp = kpp
        self.validate_kppType(self.kpp)
        self.kpp_nsprefix_ = None
        self.ogrn = ogrn
        self.validate_ogrnType(self.ogrn)
        self.ogrn_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, placerType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if placerType.subclass:
            return placerType.subclass(*args_, **kwargs_)
        else:
            return placerType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_innType(self, value):
        result = True
        # Validate type innType, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on innType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_innType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_innType_patterns_, ))
                result = False
        return result
    validate_innType_patterns_ = [['^(\\d{10}|\\d{12})$']]
    def validate_kppType(self, value):
        result = True
        # Validate type kppType, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on kppType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_kppType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_kppType_patterns_, ))
                result = False
        return result
    validate_kppType_patterns_ = [['^(\\d{9})$']]
    def validate_ogrnType(self, value):
        result = True
        # Validate type ogrnType, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ogrnType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_ogrnType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_ogrnType_patterns_, ))
                result = False
        return result
    validate_ogrnType_patterns_ = [['^(\\d{13})$']]
    def hasContent_(self):
        if (
            self.name is not None or
            self.inn is not None or
            self.kpp is not None or
            self.ogrn is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'name')
            value_ = self.gds_validate_string(value_, node, 'name')
            self.name = value_
            self.name_nsprefix_ = child_.prefix
        elif nodeName_ == 'inn':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'inn')
            value_ = self.gds_validate_string(value_, node, 'inn')
            self.inn = value_
            self.inn_nsprefix_ = child_.prefix
            # validate type innType
            self.validate_innType(self.inn)
        elif nodeName_ == 'kpp':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'kpp')
            value_ = self.gds_validate_string(value_, node, 'kpp')
            self.kpp = value_
            self.kpp_nsprefix_ = child_.prefix
            # validate type kppType
            self.validate_kppType(self.kpp)
        elif nodeName_ == 'ogrn':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'ogrn')
            value_ = self.gds_validate_string(value_, node, 'ogrn')
            self.ogrn = value_
            self.ogrn_nsprefix_ = child_.prefix
            # validate type ogrnType
            self.validate_ogrnType(self.ogrn)
# end class placerType


class signatureType50(GeneratedsSuper):
    """ЭЦПТип ЭЦП:
    CAdES-BES;
    CAdES-A"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'type_': MemberSpec_('type_', 'signatureType', 0, 1, {'use': 'optional'}),
        'valueOf_': MemberSpec_('valueOf_', 'xs:base64Binary', 0),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_) + ['valueOf_']
    subclass = None
    superclass = None
    def __init__(self, type_=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, signatureType50)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if signatureType50.subclass:
            return signatureType50.subclass(*args_, **kwargs_)
        else:
            return signatureType50(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_signatureType(self, value):
        # Validate type signatureType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['CAdES-BES', 'CAdES-A']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on signatureType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
            self.validate_signatureType(self.type_)    # validate type signatureType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class signatureType50


class prevDocumentType(GeneratedsSuper):
    """Документы, загруженные в предыдущих размещенных версиях сведений"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'guid': MemberSpec_('guid', ['guidType', 'xs:string'], 0, 0, {'name': 'guid', 'type': 'xs:string'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, guid=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.guid = guid
        self.validate_guidType(self.guid)
        self.guid_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, prevDocumentType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if prevDocumentType.subclass:
            return prevDocumentType.subclass(*args_, **kwargs_)
        else:
            return prevDocumentType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_guidType(self, value):
        result = True
        # Validate type guidType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) != 36:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd length restriction on guidType' % {"value": encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_guidType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_guidType_patterns_, ))
                result = False
        return result
    validate_guidType_patterns_ = [['^([a-fA-F0-9]{8}\\-[a-fA-F0-9]{4}\\-[a-fA-F0-9]{4}\\-[a-fA-F0-9]{4}\\-[a-fA-F0-9]{12})$']]
    def hasContent_(self):
        if (
            self.guid is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'guid':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'guid')
            value_ = self.gds_validate_string(value_, node, 'guid')
            self.guid = value_
            self.guid_nsprefix_ = child_.prefix
            # validate type guidType
            self.validate_guidType(self.guid)
# end class prevDocumentType


class lotDataType(GeneratedsSuper):
    """Данные лота"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'subject': MemberSpec_('subject', ['subjectType', 'nonEmptyString', 'xs:string'], 0, 0, {'name': 'subject', 'type': 'xs:string'}, None),
        'currency': MemberSpec_('currency', 'currencyType', 0, 0, {'name': 'currency', 'type': 'currencyType'}, 13),
        'exchangeInfo': MemberSpec_('exchangeInfo', 'exchangeInfoType', 0, 1, {'minOccurs': '0', 'name': 'exchangeInfo', 'type': 'exchangeInfoType'}, 13),
        'initialSum': MemberSpec_('initialSum', ['money2', 'xs:decimal'], 0, 0, {'name': 'initialSum', 'type': 'xs:decimal'}, 14),
        'startingContractPriceRub': MemberSpec_('startingContractPriceRub', ['money2', 'xs:decimal'], 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'startingContractPriceRub', 'type': 'xs:decimal'}, 14),
        'priceFormula': MemberSpec_('priceFormula', ['priceFormulaType', 'nonEmptyString', 'xs:string'], 0, 1, {'name': 'priceFormula', 'type': 'xs:string'}, 15),
        'commodityPrice': MemberSpec_('commodityPrice', ['money2', 'xs:decimal'], 0, 1, {'name': 'commodityPrice', 'type': 'xs:decimal'}, 15),
        'commodityPriceRub': MemberSpec_('commodityPriceRub', ['money2', 'xs:decimal'], 0, 1, {'minOccurs': '0', 'name': 'commodityPriceRub', 'type': 'xs:decimal'}, 15),
        'maxContractPrice': MemberSpec_('maxContractPrice', ['money2', 'xs:decimal'], 0, 0, {'maxOccurs': '1', 'minOccurs': '1', 'name': 'maxContractPrice', 'type': 'xs:decimal'}, None),
        'maxContractPriceRub': MemberSpec_('maxContractPriceRub', ['money2', 'xs:decimal'], 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'maxContractPriceRub', 'type': 'xs:decimal'}, None),
        'initialSumInfo': MemberSpec_('initialSumInfo', ['initialSumInfoType', 'nonEmptyString', 'xs:string'], 0, 0, {'name': 'initialSumInfo', 'type': 'xs:string'}, None),
        'orderPricing': MemberSpec_('orderPricing', ['orderPricingType', 'nonEmptyString', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'orderPricing', 'type': 'xs:string'}, None),
        'deliveryPlace': MemberSpec_('deliveryPlace', 'deliveryPlaceType', 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'deliveryPlace', 'type': 'deliveryPlaceType'}, None),
        'lotItems': MemberSpec_('lotItems', 'lotItemListType', 0, 1, {'minOccurs': '0', 'name': 'lotItems', 'type': 'lotItemListType'}, None),
        'forSmallOrMiddle': MemberSpec_('forSmallOrMiddle', 'xs:boolean', 0, 1, {'minOccurs': '0', 'name': 'forSmallOrMiddle', 'type': 'xs:boolean'}, None),
        'excludePurchaseFromPlan': MemberSpec_('excludePurchaseFromPlan', 'xs:boolean', 0, 1, {'minOccurs': '0', 'name': 'excludePurchaseFromPlan', 'type': 'xs:boolean'}, None),
        'subcontractorsRequirement': MemberSpec_('subcontractorsRequirement', 'xs:boolean', 0, 1, {'minOccurs': '0', 'name': 'subcontractorsRequirement', 'type': 'xs:boolean'}, None),
        'ignoredPurchase': MemberSpec_('ignoredPurchase', 'xs:boolean', 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'ignoredPurchase', 'type': 'xs:boolean'}, None),
        'purchaseCategory': MemberSpec_('purchaseCategory', 'purchaseCategory', 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'purchaseCategory', 'type': 'purchaseCategory'}, None),
        'centralized': MemberSpec_('centralized', 'xs:boolean', 0, 1, {'minOccurs': '0', 'name': 'centralized', 'type': 'xs:boolean'}, None),
        'purchaseDescription': MemberSpec_('purchaseDescription', ['purchaseDescriptionType', 'nonEmptyString', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'purchaseDescription', 'type': 'xs:string'}, None),
        'applicationSupplyNeeded': MemberSpec_('applicationSupplyNeeded', 'xs:boolean', 0, 1, {'minOccurs': '0', 'name': 'applicationSupplyNeeded', 'type': 'xs:boolean'}, None),
        'applicationSupplySumm': MemberSpec_('applicationSupplySumm', ['money2', 'xs:decimal'], 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'applicationSupplySumm', 'type': 'xs:decimal'}, None),
        'applicationSupplyCurrency': MemberSpec_('applicationSupplyCurrency', 'currencyType', 0, 1, {'minOccurs': '0', 'name': 'applicationSupplyCurrency', 'type': 'currencyType'}, None),
        'applicationSupplyExtra': MemberSpec_('applicationSupplyExtra', ['applicationSupplyExtraType', 'nonEmptyString', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'applicationSupplyExtra', 'type': 'xs:string'}, None),
        'majorContractConditions': MemberSpec_('majorContractConditions', ['majorContractConditionsType', 'nonEmptyString', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'majorContractConditions', 'type': 'xs:string'}, None),
        'antimonopolyDecisionTaken': MemberSpec_('antimonopolyDecisionTaken', 'xs:boolean', 0, 1, {'minOccurs': '0', 'name': 'antimonopolyDecisionTaken', 'type': 'xs:boolean'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, subject=None, currency=None, exchangeInfo=None, initialSum=None, startingContractPriceRub=None, priceFormula=None, commodityPrice=None, commodityPriceRub=None, maxContractPrice=None, maxContractPriceRub=None, initialSumInfo=None, orderPricing=None, deliveryPlace=None, lotItems=None, forSmallOrMiddle=None, excludePurchaseFromPlan=None, subcontractorsRequirement=None, ignoredPurchase=None, purchaseCategory=None, centralized=None, purchaseDescription=None, applicationSupplyNeeded=None, applicationSupplySumm=None, applicationSupplyCurrency=None, applicationSupplyExtra=None, majorContractConditions=None, antimonopolyDecisionTaken=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.subject = subject
        self.validate_subjectType(self.subject)
        self.subject_nsprefix_ = None
        self.currency = currency
        self.currency_nsprefix_ = None
        self.exchangeInfo = exchangeInfo
        self.exchangeInfo_nsprefix_ = None
        self.initialSum = initialSum
        self.validate_money2(self.initialSum)
        self.initialSum_nsprefix_ = None
        self.startingContractPriceRub = startingContractPriceRub
        self.validate_money2(self.startingContractPriceRub)
        self.startingContractPriceRub_nsprefix_ = None
        self.priceFormula = priceFormula
        self.validate_priceFormulaType(self.priceFormula)
        self.priceFormula_nsprefix_ = None
        self.commodityPrice = commodityPrice
        self.validate_money2(self.commodityPrice)
        self.commodityPrice_nsprefix_ = None
        self.commodityPriceRub = commodityPriceRub
        self.validate_money2(self.commodityPriceRub)
        self.commodityPriceRub_nsprefix_ = None
        self.maxContractPrice = maxContractPrice
        self.validate_money2(self.maxContractPrice)
        self.maxContractPrice_nsprefix_ = None
        self.maxContractPriceRub = maxContractPriceRub
        self.validate_money2(self.maxContractPriceRub)
        self.maxContractPriceRub_nsprefix_ = None
        self.initialSumInfo = initialSumInfo
        self.validate_initialSumInfoType(self.initialSumInfo)
        self.initialSumInfo_nsprefix_ = None
        self.orderPricing = orderPricing
        self.validate_orderPricingType(self.orderPricing)
        self.orderPricing_nsprefix_ = None
        self.deliveryPlace = deliveryPlace
        self.deliveryPlace_nsprefix_ = None
        self.lotItems = lotItems
        self.lotItems_nsprefix_ = None
        self.forSmallOrMiddle = forSmallOrMiddle
        self.forSmallOrMiddle_nsprefix_ = None
        self.excludePurchaseFromPlan = excludePurchaseFromPlan
        self.excludePurchaseFromPlan_nsprefix_ = None
        self.subcontractorsRequirement = subcontractorsRequirement
        self.subcontractorsRequirement_nsprefix_ = None
        self.ignoredPurchase = ignoredPurchase
        self.ignoredPurchase_nsprefix_ = None
        self.purchaseCategory = purchaseCategory
        self.purchaseCategory_nsprefix_ = None
        self.centralized = centralized
        self.centralized_nsprefix_ = None
        self.purchaseDescription = purchaseDescription
        self.validate_purchaseDescriptionType(self.purchaseDescription)
        self.purchaseDescription_nsprefix_ = None
        self.applicationSupplyNeeded = applicationSupplyNeeded
        self.applicationSupplyNeeded_nsprefix_ = None
        self.applicationSupplySumm = applicationSupplySumm
        self.validate_money2(self.applicationSupplySumm)
        self.applicationSupplySumm_nsprefix_ = None
        self.applicationSupplyCurrency = applicationSupplyCurrency
        self.applicationSupplyCurrency_nsprefix_ = None
        self.applicationSupplyExtra = applicationSupplyExtra
        self.validate_applicationSupplyExtraType(self.applicationSupplyExtra)
        self.applicationSupplyExtra_nsprefix_ = None
        self.majorContractConditions = majorContractConditions
        self.validate_majorContractConditionsType(self.majorContractConditions)
        self.majorContractConditions_nsprefix_ = None
        self.antimonopolyDecisionTaken = antimonopolyDecisionTaken
        self.antimonopolyDecisionTaken_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, lotDataType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if lotDataType.subclass:
            return lotDataType.subclass(*args_, **kwargs_)
        else:
            return lotDataType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_subjectType(self, value):
        result = True
        # Validate type subjectType, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 2000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on subjectType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on subjectType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_money2(self, value):
        result = True
        # Validate type money2, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, decimal_.Decimal):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (decimal_.Decimal)' % {"value": value, "lineno": lineno, })
                return False
            if len(str(value)) >= 20:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd totalDigits restriction on money2' % {"value": value, "lineno": lineno} )
                result = False
        return result
    def validate_priceFormulaType(self, value):
        result = True
        # Validate type priceFormulaType, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 2000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on priceFormulaType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on priceFormulaType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_initialSumInfoType(self, value):
        result = True
        # Validate type initialSumInfoType, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 2000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on initialSumInfoType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on initialSumInfoType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_orderPricingType(self, value):
        result = True
        # Validate type orderPricingType, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 2000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on orderPricingType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on orderPricingType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_purchaseDescriptionType(self, value):
        result = True
        # Validate type purchaseDescriptionType, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 2000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on purchaseDescriptionType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on purchaseDescriptionType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_applicationSupplyExtraType(self, value):
        result = True
        # Validate type applicationSupplyExtraType, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 2000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on applicationSupplyExtraType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on applicationSupplyExtraType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_majorContractConditionsType(self, value):
        result = True
        # Validate type majorContractConditionsType, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 2000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on majorContractConditionsType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on majorContractConditionsType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.subject is not None or
            self.currency is not None or
            self.exchangeInfo is not None or
            self.initialSum is not None or
            self.startingContractPriceRub is not None or
            self.priceFormula is not None or
            self.commodityPrice is not None or
            self.commodityPriceRub is not None or
            self.maxContractPrice is not None or
            self.maxContractPriceRub is not None or
            self.initialSumInfo is not None or
            self.orderPricing is not None or
            self.deliveryPlace is not None or
            self.lotItems is not None or
            self.forSmallOrMiddle is not None or
            self.excludePurchaseFromPlan is not None or
            self.subcontractorsRequirement is not None or
            self.ignoredPurchase is not None or
            self.purchaseCategory is not None or
            self.centralized is not None or
            self.purchaseDescription is not None or
            self.applicationSupplyNeeded is not None or
            self.applicationSupplySumm is not None or
            self.applicationSupplyCurrency is not None or
            self.applicationSupplyExtra is not None or
            self.majorContractConditions is not None or
            self.antimonopolyDecisionTaken is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'subject':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'subject')
            value_ = self.gds_validate_string(value_, node, 'subject')
            self.subject = value_
            self.subject_nsprefix_ = child_.prefix
            # validate type subjectType
            self.validate_subjectType(self.subject)
        elif nodeName_ == 'currency':
            obj_ = currencyType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.currency = obj_
            obj_.original_tagname_ = 'currency'
        elif nodeName_ == 'exchangeInfo':
            obj_ = exchangeInfoType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.exchangeInfo = obj_
            obj_.original_tagname_ = 'exchangeInfo'
        elif nodeName_ == 'initialSum' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'initialSum')
            fval_ = self.gds_validate_decimal(fval_, node, 'initialSum')
            self.initialSum = fval_
            self.initialSum_nsprefix_ = child_.prefix
            # validate type money2
            self.validate_money2(self.initialSum)
        elif nodeName_ == 'startingContractPriceRub' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'startingContractPriceRub')
            fval_ = self.gds_validate_decimal(fval_, node, 'startingContractPriceRub')
            self.startingContractPriceRub = fval_
            self.startingContractPriceRub_nsprefix_ = child_.prefix
            # validate type money2
            self.validate_money2(self.startingContractPriceRub)
        elif nodeName_ == 'priceFormula':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'priceFormula')
            value_ = self.gds_validate_string(value_, node, 'priceFormula')
            self.priceFormula = value_
            self.priceFormula_nsprefix_ = child_.prefix
            # validate type priceFormulaType
            self.validate_priceFormulaType(self.priceFormula)
        elif nodeName_ == 'commodityPrice' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'commodityPrice')
            fval_ = self.gds_validate_decimal(fval_, node, 'commodityPrice')
            self.commodityPrice = fval_
            self.commodityPrice_nsprefix_ = child_.prefix
            # validate type money2
            self.validate_money2(self.commodityPrice)
        elif nodeName_ == 'commodityPriceRub' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'commodityPriceRub')
            fval_ = self.gds_validate_decimal(fval_, node, 'commodityPriceRub')
            self.commodityPriceRub = fval_
            self.commodityPriceRub_nsprefix_ = child_.prefix
            # validate type money2
            self.validate_money2(self.commodityPriceRub)
        elif nodeName_ == 'maxContractPrice' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'maxContractPrice')
            fval_ = self.gds_validate_decimal(fval_, node, 'maxContractPrice')
            self.maxContractPrice = fval_
            self.maxContractPrice_nsprefix_ = child_.prefix
            # validate type money2
            self.validate_money2(self.maxContractPrice)
        elif nodeName_ == 'maxContractPriceRub' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'maxContractPriceRub')
            fval_ = self.gds_validate_decimal(fval_, node, 'maxContractPriceRub')
            self.maxContractPriceRub = fval_
            self.maxContractPriceRub_nsprefix_ = child_.prefix
            # validate type money2
            self.validate_money2(self.maxContractPriceRub)
        elif nodeName_ == 'initialSumInfo':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'initialSumInfo')
            value_ = self.gds_validate_string(value_, node, 'initialSumInfo')
            self.initialSumInfo = value_
            self.initialSumInfo_nsprefix_ = child_.prefix
            # validate type initialSumInfoType
            self.validate_initialSumInfoType(self.initialSumInfo)
        elif nodeName_ == 'orderPricing':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'orderPricing')
            value_ = self.gds_validate_string(value_, node, 'orderPricing')
            self.orderPricing = value_
            self.orderPricing_nsprefix_ = child_.prefix
            # validate type orderPricingType
            self.validate_orderPricingType(self.orderPricing)
        elif nodeName_ == 'deliveryPlace':
            obj_ = deliveryPlaceType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.deliveryPlace = obj_
            obj_.original_tagname_ = 'deliveryPlace'
        elif nodeName_ == 'lotItems':
            obj_ = lotItemListType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.lotItems = obj_
            obj_.original_tagname_ = 'lotItems'
        elif nodeName_ == 'forSmallOrMiddle':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'forSmallOrMiddle')
            ival_ = self.gds_validate_boolean(ival_, node, 'forSmallOrMiddle')
            self.forSmallOrMiddle = ival_
            self.forSmallOrMiddle_nsprefix_ = child_.prefix
        elif nodeName_ == 'excludePurchaseFromPlan':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'excludePurchaseFromPlan')
            ival_ = self.gds_validate_boolean(ival_, node, 'excludePurchaseFromPlan')
            self.excludePurchaseFromPlan = ival_
            self.excludePurchaseFromPlan_nsprefix_ = child_.prefix
        elif nodeName_ == 'subcontractorsRequirement':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'subcontractorsRequirement')
            ival_ = self.gds_validate_boolean(ival_, node, 'subcontractorsRequirement')
            self.subcontractorsRequirement = ival_
            self.subcontractorsRequirement_nsprefix_ = child_.prefix
        elif nodeName_ == 'ignoredPurchase':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'ignoredPurchase')
            ival_ = self.gds_validate_boolean(ival_, node, 'ignoredPurchase')
            self.ignoredPurchase = ival_
            self.ignoredPurchase_nsprefix_ = child_.prefix
        elif nodeName_ == 'purchaseCategory':
            obj_ = purchaseCategory.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.purchaseCategory = obj_
            obj_.original_tagname_ = 'purchaseCategory'
        elif nodeName_ == 'centralized':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'centralized')
            ival_ = self.gds_validate_boolean(ival_, node, 'centralized')
            self.centralized = ival_
            self.centralized_nsprefix_ = child_.prefix
        elif nodeName_ == 'purchaseDescription':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'purchaseDescription')
            value_ = self.gds_validate_string(value_, node, 'purchaseDescription')
            self.purchaseDescription = value_
            self.purchaseDescription_nsprefix_ = child_.prefix
            # validate type purchaseDescriptionType
            self.validate_purchaseDescriptionType(self.purchaseDescription)
        elif nodeName_ == 'applicationSupplyNeeded':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'applicationSupplyNeeded')
            ival_ = self.gds_validate_boolean(ival_, node, 'applicationSupplyNeeded')
            self.applicationSupplyNeeded = ival_
            self.applicationSupplyNeeded_nsprefix_ = child_.prefix
        elif nodeName_ == 'applicationSupplySumm' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'applicationSupplySumm')
            fval_ = self.gds_validate_decimal(fval_, node, 'applicationSupplySumm')
            self.applicationSupplySumm = fval_
            self.applicationSupplySumm_nsprefix_ = child_.prefix
            # validate type money2
            self.validate_money2(self.applicationSupplySumm)
        elif nodeName_ == 'applicationSupplyCurrency':
            obj_ = currencyType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.applicationSupplyCurrency = obj_
            obj_.original_tagname_ = 'applicationSupplyCurrency'
        elif nodeName_ == 'applicationSupplyExtra':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'applicationSupplyExtra')
            value_ = self.gds_validate_string(value_, node, 'applicationSupplyExtra')
            self.applicationSupplyExtra = value_
            self.applicationSupplyExtra_nsprefix_ = child_.prefix
            # validate type applicationSupplyExtraType
            self.validate_applicationSupplyExtraType(self.applicationSupplyExtra)
        elif nodeName_ == 'majorContractConditions':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'majorContractConditions')
            value_ = self.gds_validate_string(value_, node, 'majorContractConditions')
            self.majorContractConditions = value_
            self.majorContractConditions_nsprefix_ = child_.prefix
            # validate type majorContractConditionsType
            self.validate_majorContractConditionsType(self.majorContractConditions)
        elif nodeName_ == 'antimonopolyDecisionTaken':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'antimonopolyDecisionTaken')
            ival_ = self.gds_validate_boolean(ival_, node, 'antimonopolyDecisionTaken')
            self.antimonopolyDecisionTaken = ival_
            self.antimonopolyDecisionTaken_nsprefix_ = child_.prefix
# end class lotDataType


class exchangeInfoType(GeneratedsSuper):
    """Информация о курсе валют"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'exchangeRate': MemberSpec_('exchangeRate', ['money6', 'xs:decimal'], 0, 0, {'maxOccurs': '1', 'minOccurs': '1', 'name': 'exchangeRate', 'type': 'xs:decimal'}, None),
        'exchangeRateDate': MemberSpec_('exchangeRateDate', 'xs:date', 0, 0, {'maxOccurs': '1', 'minOccurs': '1', 'name': 'exchangeRateDate', 'type': 'xs:date'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, exchangeRate=None, exchangeRateDate=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.exchangeRate = exchangeRate
        self.validate_money6(self.exchangeRate)
        self.exchangeRate_nsprefix_ = None
        if isinstance(exchangeRateDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(exchangeRateDate, '%Y-%m-%d').date()
        else:
            initvalue_ = exchangeRateDate
        self.exchangeRateDate = initvalue_
        self.exchangeRateDate_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, exchangeInfoType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if exchangeInfoType.subclass:
            return exchangeInfoType.subclass(*args_, **kwargs_)
        else:
            return exchangeInfoType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_money6(self, value):
        result = True
        # Validate type money6, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, decimal_.Decimal):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (decimal_.Decimal)' % {"value": value, "lineno": lineno, })
                return False
            pass
        return result
    def hasContent_(self):
        if (
            self.exchangeRate is not None or
            self.exchangeRateDate is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'exchangeRate' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'exchangeRate')
            fval_ = self.gds_validate_decimal(fval_, node, 'exchangeRate')
            self.exchangeRate = fval_
            self.exchangeRate_nsprefix_ = child_.prefix
            # validate type money6
            self.validate_money6(self.exchangeRate)
        elif nodeName_ == 'exchangeRateDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.exchangeRateDate = dval_
            self.exchangeRateDate_nsprefix_ = child_.prefix
# end class exchangeInfoType


class jointLotDataType(GeneratedsSuper):
    """Данные по совместной закупке"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'jointLot': MemberSpec_('jointLot', 'xs:boolean', 0, 0, {'name': 'jointLot', 'type': 'xs:boolean'}, None),
        'lotCustomers': MemberSpec_('lotCustomers', 'lotCustomerListType', 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'lotCustomers', 'type': 'lotCustomerListType'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, jointLot=None, lotCustomers=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.jointLot = jointLot
        self.jointLot_nsprefix_ = None
        self.lotCustomers = lotCustomers
        self.lotCustomers_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, jointLotDataType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if jointLotDataType.subclass:
            return jointLotDataType.subclass(*args_, **kwargs_)
        else:
            return jointLotDataType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.jointLot is not None or
            self.lotCustomers is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'jointLot':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'jointLot')
            ival_ = self.gds_validate_boolean(ival_, node, 'jointLot')
            self.jointLot = ival_
            self.jointLot_nsprefix_ = child_.prefix
        elif nodeName_ == 'lotCustomers':
            obj_ = lotCustomerListType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.lotCustomers = obj_
            obj_.original_tagname_ = 'lotCustomers'
# end class jointLotDataType


class lotApplcationsCriteriaType(GeneratedsSuper):
    """Сылка на критерий по лоту протокола"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'lotApplcationsCriteriaGuid': MemberSpec_('lotApplcationsCriteriaGuid', ['guidType', 'xs:string'], 0, 0, {'name': 'lotApplcationsCriteriaGuid', 'type': 'xs:string'}, None),
        'name': MemberSpec_('name', ['nameType87', 'nonEmptyString', 'xs:string'], 0, 0, {'name': 'name', 'type': 'xs:string'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, lotApplcationsCriteriaGuid=None, name=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.lotApplcationsCriteriaGuid = lotApplcationsCriteriaGuid
        self.validate_guidType(self.lotApplcationsCriteriaGuid)
        self.lotApplcationsCriteriaGuid_nsprefix_ = None
        self.name = name
        self.validate_nameType87(self.name)
        self.name_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, lotApplcationsCriteriaType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if lotApplcationsCriteriaType.subclass:
            return lotApplcationsCriteriaType.subclass(*args_, **kwargs_)
        else:
            return lotApplcationsCriteriaType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_guidType(self, value):
        result = True
        # Validate type guidType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) != 36:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd length restriction on guidType' % {"value": encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_guidType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_guidType_patterns_, ))
                result = False
        return result
    validate_guidType_patterns_ = [['^([a-fA-F0-9]{8}\\-[a-fA-F0-9]{4}\\-[a-fA-F0-9]{4}\\-[a-fA-F0-9]{4}\\-[a-fA-F0-9]{12})$']]
    def validate_nameType87(self, value):
        result = True
        # Validate type nameType87, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 500:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on nameType87' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on nameType87' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.lotApplcationsCriteriaGuid is not None or
            self.name is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'lotApplcationsCriteriaGuid':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'lotApplcationsCriteriaGuid')
            value_ = self.gds_validate_string(value_, node, 'lotApplcationsCriteriaGuid')
            self.lotApplcationsCriteriaGuid = value_
            self.lotApplcationsCriteriaGuid_nsprefix_ = child_.prefix
            # validate type guidType
            self.validate_guidType(self.lotApplcationsCriteriaGuid)
        elif nodeName_ == 'name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'name')
            value_ = self.gds_validate_string(value_, node, 'name')
            self.name = value_
            self.name_nsprefix_ = child_.prefix
            # validate type nameType87
            self.validate_nameType87(self.name)
# end class lotApplcationsCriteriaType


class lotCustomerDataType(GeneratedsSuper):
    """Данные лота совместной закупки"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'currency': MemberSpec_('currency', 'currencyType', 0, 0, {'name': 'currency', 'type': 'currencyType'}, None),
        'exchangeInfo': MemberSpec_('exchangeInfo', 'exchangeInfoType92', 0, 1, {'minOccurs': '0', 'name': 'exchangeInfo', 'type': 'exchangeInfoType92'}, None),
        'initialSum': MemberSpec_('initialSum', ['money2', 'xs:decimal'], 0, 0, {'name': 'initialSum', 'type': 'xs:decimal'}, 16),
        'startingContractPriceRub': MemberSpec_('startingContractPriceRub', ['money2', 'xs:decimal'], 0, 1, {'minOccurs': '0', 'name': 'startingContractPriceRub', 'type': 'xs:decimal'}, 16),
        'priceFormula': MemberSpec_('priceFormula', ['priceFormulaType93', 'nonEmptyString', 'xs:string'], 0, 1, {'name': 'priceFormula', 'type': 'xs:string'}, 17),
        'price': MemberSpec_('price', ['money2', 'xs:decimal'], 0, 1, {'name': 'price', 'type': 'xs:decimal'}, 17),
        'priceRub': MemberSpec_('priceRub', ['money2', 'xs:decimal'], 0, 1, {'minOccurs': '0', 'name': 'priceRub', 'type': 'xs:decimal'}, 17),
        'maxContractPrice': MemberSpec_('maxContractPrice', ['money2', 'xs:decimal'], 0, 1, {'minOccurs': '0', 'name': 'maxContractPrice', 'type': 'xs:decimal'}, None),
        'maxContractPriceRub': MemberSpec_('maxContractPriceRub', ['money2', 'xs:decimal'], 0, 1, {'minOccurs': '0', 'name': 'maxContractPriceRub', 'type': 'xs:decimal'}, None),
        'excludePurchaseFromPlan': MemberSpec_('excludePurchaseFromPlan', 'xs:boolean', 0, 1, {'minOccurs': '0', 'name': 'excludePurchaseFromPlan', 'type': 'xs:boolean'}, None),
        'orderPricing': MemberSpec_('orderPricing', ['orderPricingType94', 'nonEmptyString', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'orderPricing', 'type': 'xs:string'}, None),
        'deliveryPlace': MemberSpec_('deliveryPlace', 'deliveryPlaceType', 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'deliveryPlace', 'type': 'deliveryPlaceType'}, None),
        'lotItems': MemberSpec_('lotItems', 'lotItemListType', 0, 1, {'minOccurs': '0', 'name': 'lotItems', 'type': 'lotItemListType'}, None),
        'notInLaw223': MemberSpec_('notInLaw223', 'xs:boolean', 0, 1, {'minOccurs': '0', 'name': 'notInLaw223', 'type': 'xs:boolean'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, currency=None, exchangeInfo=None, initialSum=None, startingContractPriceRub=None, priceFormula=None, price=None, priceRub=None, maxContractPrice=None, maxContractPriceRub=None, excludePurchaseFromPlan=None, orderPricing=None, deliveryPlace=None, lotItems=None, notInLaw223=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.currency = currency
        self.currency_nsprefix_ = None
        self.exchangeInfo = exchangeInfo
        self.exchangeInfo_nsprefix_ = None
        self.initialSum = initialSum
        self.validate_money2(self.initialSum)
        self.initialSum_nsprefix_ = None
        self.startingContractPriceRub = startingContractPriceRub
        self.validate_money2(self.startingContractPriceRub)
        self.startingContractPriceRub_nsprefix_ = None
        self.priceFormula = priceFormula
        self.validate_priceFormulaType93(self.priceFormula)
        self.priceFormula_nsprefix_ = None
        self.price = price
        self.validate_money2(self.price)
        self.price_nsprefix_ = None
        self.priceRub = priceRub
        self.validate_money2(self.priceRub)
        self.priceRub_nsprefix_ = None
        self.maxContractPrice = maxContractPrice
        self.validate_money2(self.maxContractPrice)
        self.maxContractPrice_nsprefix_ = None
        self.maxContractPriceRub = maxContractPriceRub
        self.validate_money2(self.maxContractPriceRub)
        self.maxContractPriceRub_nsprefix_ = None
        self.excludePurchaseFromPlan = excludePurchaseFromPlan
        self.excludePurchaseFromPlan_nsprefix_ = None
        self.orderPricing = orderPricing
        self.validate_orderPricingType94(self.orderPricing)
        self.orderPricing_nsprefix_ = None
        self.deliveryPlace = deliveryPlace
        self.deliveryPlace_nsprefix_ = None
        self.lotItems = lotItems
        self.lotItems_nsprefix_ = None
        self.notInLaw223 = notInLaw223
        self.notInLaw223_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, lotCustomerDataType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if lotCustomerDataType.subclass:
            return lotCustomerDataType.subclass(*args_, **kwargs_)
        else:
            return lotCustomerDataType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_money2(self, value):
        result = True
        # Validate type money2, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, decimal_.Decimal):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (decimal_.Decimal)' % {"value": value, "lineno": lineno, })
                return False
            if len(str(value)) >= 20:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd totalDigits restriction on money2' % {"value": value, "lineno": lineno} )
                result = False
        return result
    def validate_priceFormulaType93(self, value):
        result = True
        # Validate type priceFormulaType93, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 2000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on priceFormulaType93' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on priceFormulaType93' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_orderPricingType94(self, value):
        result = True
        # Validate type orderPricingType94, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 2000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on orderPricingType94' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on orderPricingType94' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.currency is not None or
            self.exchangeInfo is not None or
            self.initialSum is not None or
            self.startingContractPriceRub is not None or
            self.priceFormula is not None or
            self.price is not None or
            self.priceRub is not None or
            self.maxContractPrice is not None or
            self.maxContractPriceRub is not None or
            self.excludePurchaseFromPlan is not None or
            self.orderPricing is not None or
            self.deliveryPlace is not None or
            self.lotItems is not None or
            self.notInLaw223 is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'currency':
            obj_ = currencyType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.currency = obj_
            obj_.original_tagname_ = 'currency'
        elif nodeName_ == 'exchangeInfo':
            obj_ = exchangeInfoType92.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.exchangeInfo = obj_
            obj_.original_tagname_ = 'exchangeInfo'
        elif nodeName_ == 'initialSum' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'initialSum')
            fval_ = self.gds_validate_decimal(fval_, node, 'initialSum')
            self.initialSum = fval_
            self.initialSum_nsprefix_ = child_.prefix
            # validate type money2
            self.validate_money2(self.initialSum)
        elif nodeName_ == 'startingContractPriceRub' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'startingContractPriceRub')
            fval_ = self.gds_validate_decimal(fval_, node, 'startingContractPriceRub')
            self.startingContractPriceRub = fval_
            self.startingContractPriceRub_nsprefix_ = child_.prefix
            # validate type money2
            self.validate_money2(self.startingContractPriceRub)
        elif nodeName_ == 'priceFormula':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'priceFormula')
            value_ = self.gds_validate_string(value_, node, 'priceFormula')
            self.priceFormula = value_
            self.priceFormula_nsprefix_ = child_.prefix
            # validate type priceFormulaType93
            self.validate_priceFormulaType93(self.priceFormula)
        elif nodeName_ == 'price' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'price')
            fval_ = self.gds_validate_decimal(fval_, node, 'price')
            self.price = fval_
            self.price_nsprefix_ = child_.prefix
            # validate type money2
            self.validate_money2(self.price)
        elif nodeName_ == 'priceRub' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'priceRub')
            fval_ = self.gds_validate_decimal(fval_, node, 'priceRub')
            self.priceRub = fval_
            self.priceRub_nsprefix_ = child_.prefix
            # validate type money2
            self.validate_money2(self.priceRub)
        elif nodeName_ == 'maxContractPrice' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'maxContractPrice')
            fval_ = self.gds_validate_decimal(fval_, node, 'maxContractPrice')
            self.maxContractPrice = fval_
            self.maxContractPrice_nsprefix_ = child_.prefix
            # validate type money2
            self.validate_money2(self.maxContractPrice)
        elif nodeName_ == 'maxContractPriceRub' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'maxContractPriceRub')
            fval_ = self.gds_validate_decimal(fval_, node, 'maxContractPriceRub')
            self.maxContractPriceRub = fval_
            self.maxContractPriceRub_nsprefix_ = child_.prefix
            # validate type money2
            self.validate_money2(self.maxContractPriceRub)
        elif nodeName_ == 'excludePurchaseFromPlan':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'excludePurchaseFromPlan')
            ival_ = self.gds_validate_boolean(ival_, node, 'excludePurchaseFromPlan')
            self.excludePurchaseFromPlan = ival_
            self.excludePurchaseFromPlan_nsprefix_ = child_.prefix
        elif nodeName_ == 'orderPricing':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'orderPricing')
            value_ = self.gds_validate_string(value_, node, 'orderPricing')
            self.orderPricing = value_
            self.orderPricing_nsprefix_ = child_.prefix
            # validate type orderPricingType94
            self.validate_orderPricingType94(self.orderPricing)
        elif nodeName_ == 'deliveryPlace':
            obj_ = deliveryPlaceType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.deliveryPlace = obj_
            obj_.original_tagname_ = 'deliveryPlace'
        elif nodeName_ == 'lotItems':
            obj_ = lotItemListType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.lotItems = obj_
            obj_.original_tagname_ = 'lotItems'
        elif nodeName_ == 'notInLaw223':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'notInLaw223')
            ival_ = self.gds_validate_boolean(ival_, node, 'notInLaw223')
            self.notInLaw223 = ival_
            self.notInLaw223_nsprefix_ = child_.prefix
# end class lotCustomerDataType


class exchangeInfoType92(GeneratedsSuper):
    """Информация о курсе валют"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'exchangeRate': MemberSpec_('exchangeRate', ['money6', 'xs:decimal'], 0, 0, {'name': 'exchangeRate', 'type': 'xs:decimal'}, None),
        'exchangeRateDate': MemberSpec_('exchangeRateDate', 'xs:date', 0, 0, {'name': 'exchangeRateDate', 'type': 'xs:date'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, exchangeRate=None, exchangeRateDate=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.exchangeRate = exchangeRate
        self.validate_money6(self.exchangeRate)
        self.exchangeRate_nsprefix_ = None
        if isinstance(exchangeRateDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(exchangeRateDate, '%Y-%m-%d').date()
        else:
            initvalue_ = exchangeRateDate
        self.exchangeRateDate = initvalue_
        self.exchangeRateDate_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, exchangeInfoType92)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if exchangeInfoType92.subclass:
            return exchangeInfoType92.subclass(*args_, **kwargs_)
        else:
            return exchangeInfoType92(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_money6(self, value):
        result = True
        # Validate type money6, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, decimal_.Decimal):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (decimal_.Decimal)' % {"value": value, "lineno": lineno, })
                return False
            pass
        return result
    def hasContent_(self):
        if (
            self.exchangeRate is not None or
            self.exchangeRateDate is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'exchangeRate' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'exchangeRate')
            fval_ = self.gds_validate_decimal(fval_, node, 'exchangeRate')
            self.exchangeRate = fval_
            self.exchangeRate_nsprefix_ = child_.prefix
            # validate type money6
            self.validate_money6(self.exchangeRate)
        elif nodeName_ == 'exchangeRateDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.exchangeRateDate = dval_
            self.exchangeRateDate_nsprefix_ = child_.prefix
# end class exchangeInfoType92


class lotDataType108(GeneratedsSuper):
    """Данные о лоте"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'guid': MemberSpec_('guid', ['guidType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'guid', 'type': 'xs:string'}, None),
        'ordinalNumber': MemberSpec_('ordinalNumber', 'xs:int', 0, 1, {'name': 'ordinalNumber', 'type': 'xs:int'}, 18),
        'ordinalNumberText': MemberSpec_('ordinalNumberText', ['ordinalNumberTextType', 'nonEmptyString', 'xs:string'], 0, 1, {'name': 'ordinalNumberText', 'type': 'xs:string'}, 18),
        'lotName': MemberSpec_('lotName', ['lotNameType', 'nonEmptyString', 'xs:string'], 0, 0, {'name': 'lotName', 'type': 'xs:string'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, guid=None, ordinalNumber=None, ordinalNumberText=None, lotName=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.guid = guid
        self.validate_guidType(self.guid)
        self.guid_nsprefix_ = None
        self.ordinalNumber = ordinalNumber
        self.ordinalNumber_nsprefix_ = None
        self.ordinalNumberText = ordinalNumberText
        self.validate_ordinalNumberTextType(self.ordinalNumberText)
        self.ordinalNumberText_nsprefix_ = None
        self.lotName = lotName
        self.validate_lotNameType(self.lotName)
        self.lotName_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, lotDataType108)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if lotDataType108.subclass:
            return lotDataType108.subclass(*args_, **kwargs_)
        else:
            return lotDataType108(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_guidType(self, value):
        result = True
        # Validate type guidType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) != 36:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd length restriction on guidType' % {"value": encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_guidType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_guidType_patterns_, ))
                result = False
        return result
    validate_guidType_patterns_ = [['^([a-fA-F0-9]{8}\\-[a-fA-F0-9]{4}\\-[a-fA-F0-9]{4}\\-[a-fA-F0-9]{4}\\-[a-fA-F0-9]{12})$']]
    def validate_ordinalNumberTextType(self, value):
        result = True
        # Validate type ordinalNumberTextType, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 100:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ordinalNumberTextType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ordinalNumberTextType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_lotNameType(self, value):
        result = True
        # Validate type lotNameType, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 2000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on lotNameType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on lotNameType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.guid is not None or
            self.ordinalNumber is not None or
            self.ordinalNumberText is not None or
            self.lotName is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'guid':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'guid')
            value_ = self.gds_validate_string(value_, node, 'guid')
            self.guid = value_
            self.guid_nsprefix_ = child_.prefix
            # validate type guidType
            self.validate_guidType(self.guid)
        elif nodeName_ == 'ordinalNumber' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'ordinalNumber')
            ival_ = self.gds_validate_integer(ival_, node, 'ordinalNumber')
            self.ordinalNumber = ival_
            self.ordinalNumber_nsprefix_ = child_.prefix
        elif nodeName_ == 'ordinalNumberText':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'ordinalNumberText')
            value_ = self.gds_validate_string(value_, node, 'ordinalNumberText')
            self.ordinalNumberText = value_
            self.ordinalNumberText_nsprefix_ = child_.prefix
            # validate type ordinalNumberTextType
            self.validate_ordinalNumberTextType(self.ordinalNumberText)
        elif nodeName_ == 'lotName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'lotName')
            value_ = self.gds_validate_string(value_, node, 'lotName')
            self.lotName = value_
            self.lotName_nsprefix_ = child_.prefix
            # validate type lotNameType
            self.validate_lotNameType(self.lotName)
# end class lotDataType108


class fixedColumnsDataType(GeneratedsSuper):
    """Значения для строк, выводимых в первой колонке табличного представления
    с фиксированным количеством строк"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'colValue': MemberSpec_('colValue', ['colValueType', 'nonEmptyString', 'xs:string'], 1, 0, {'maxOccurs': 'unbounded', 'minOccurs': '1', 'name': 'colValue', 'type': 'xs:string'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, colValue=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if colValue is None:
            self.colValue = []
        else:
            self.colValue = colValue
        self.colValue_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, fixedColumnsDataType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if fixedColumnsDataType.subclass:
            return fixedColumnsDataType.subclass(*args_, **kwargs_)
        else:
            return fixedColumnsDataType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_colValueType(self, value):
        result = True
        # Validate type colValueType, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 100:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on colValueType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on colValueType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.colValue
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'colValue':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'colValue')
            value_ = self.gds_validate_string(value_, node, 'colValue')
            self.colValue.append(value_)
            self.colValue_nsprefix_ = child_.prefix
            # validate type colValueType
            self.validate_colValueType(self.colValue[-1])
# end class fixedColumnsDataType


class columnsType(GeneratedsSuper):
    """Столбцы табличного представления"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'column': MemberSpec_('column', 'templateTableColumnType', 1, 0, {'maxOccurs': '10', 'minOccurs': '1', 'name': 'column', 'type': 'templateTableColumnType'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, column=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if column is None:
            self.column = []
        else:
            self.column = column
        self.column_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, columnsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if columnsType.subclass:
            return columnsType.subclass(*args_, **kwargs_)
        else:
            return columnsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.column
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'column':
            obj_ = templateTableColumnType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.column.append(obj_)
            obj_.original_tagname_ = 'column'
# end class columnsType


class nsiType(GeneratedsSuper):
    """Значение из справочника"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'currency': MemberSpec_('currency', 'currencyType', 0, 0, {'name': 'currency', 'type': 'currencyType'}, 19),
        'okei': MemberSpec_('okei', 'okeiProductType', 0, 0, {'name': 'okei', 'type': 'okeiProductType'}, 19),
        'okdp': MemberSpec_('okdp', 'okdpProductType', 0, 0, {'name': 'okdp', 'type': 'okdpProductType'}, 19),
        'okpd2': MemberSpec_('okpd2', 'okpd2ProductType', 0, 0, {'name': 'okpd2', 'type': 'okpd2ProductType'}, 19),
        'okved': MemberSpec_('okved', 'okvedProductType', 0, 0, {'name': 'okved', 'type': 'okvedProductType'}, 19),
        'okved2': MemberSpec_('okved2', 'okved2ProductType', 0, 0, {'name': 'okved2', 'type': 'okved2ProductType'}, 19),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, currency=None, okei=None, okdp=None, okpd2=None, okved=None, okved2=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.currency = currency
        self.currency_nsprefix_ = None
        self.okei = okei
        self.okei_nsprefix_ = None
        self.okdp = okdp
        self.okdp_nsprefix_ = None
        self.okpd2 = okpd2
        self.okpd2_nsprefix_ = None
        self.okved = okved
        self.okved_nsprefix_ = None
        self.okved2 = okved2
        self.okved2_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, nsiType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if nsiType.subclass:
            return nsiType.subclass(*args_, **kwargs_)
        else:
            return nsiType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.currency is not None or
            self.okei is not None or
            self.okdp is not None or
            self.okpd2 is not None or
            self.okved is not None or
            self.okved2 is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'currency':
            obj_ = currencyType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.currency = obj_
            obj_.original_tagname_ = 'currency'
        elif nodeName_ == 'okei':
            obj_ = okeiProductType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.okei = obj_
            obj_.original_tagname_ = 'okei'
        elif nodeName_ == 'okdp':
            obj_ = okdpProductType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.okdp = obj_
            obj_.original_tagname_ = 'okdp'
        elif nodeName_ == 'okpd2':
            obj_ = okpd2ProductType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.okpd2 = obj_
            obj_.original_tagname_ = 'okpd2'
        elif nodeName_ == 'okved':
            obj_ = okvedProductType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.okved = obj_
            obj_.original_tagname_ = 'okved'
        elif nodeName_ == 'okved2':
            obj_ = okved2ProductType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.okved2 = obj_
            obj_.original_tagname_ = 'okved2'
# end class nsiType


class tableType(GeneratedsSuper):
    """Табличное представление"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'rows': MemberSpec_('rows', 'rowsType', 0, 0, {'name': 'rows', 'type': 'rowsType'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, rows=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.rows = rows
        self.rows_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tableType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tableType.subclass:
            return tableType.subclass(*args_, **kwargs_)
        else:
            return tableType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.rows is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'rows':
            obj_ = rowsType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.rows = obj_
            obj_.original_tagname_ = 'rows'
# end class tableType


class rowsType(GeneratedsSuper):
    """Строки табличного представления"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'row': MemberSpec_('row', 'extendTableRowType', 1, 0, {'maxOccurs': 'unbounded', 'minOccurs': '1', 'name': 'row', 'type': 'extendTableRowType'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, row=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if row is None:
            self.row = []
        else:
            self.row = row
        self.row_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, rowsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if rowsType.subclass:
            return rowsType.subclass(*args_, **kwargs_)
        else:
            return rowsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.row
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'row':
            obj_ = extendTableRowType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.row.append(obj_)
            obj_.original_tagname_ = 'row'
# end class rowsType


class nsiType124(GeneratedsSuper):
    """Значение из справочника"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'currency': MemberSpec_('currency', 'currencyType', 0, 0, {'name': 'currency', 'type': 'currencyType'}, 20),
        'okei': MemberSpec_('okei', 'okeiProductType', 0, 0, {'name': 'okei', 'type': 'okeiProductType'}, 20),
        'okdp': MemberSpec_('okdp', 'okdpProductType', 0, 0, {'name': 'okdp', 'type': 'okdpProductType'}, 20),
        'okpd2': MemberSpec_('okpd2', 'okpd2ProductType', 0, 0, {'name': 'okpd2', 'type': 'okpd2ProductType'}, 20),
        'okved': MemberSpec_('okved', 'okvedProductType', 0, 0, {'name': 'okved', 'type': 'okvedProductType'}, 20),
        'okved2': MemberSpec_('okved2', 'okved2ProductType', 0, 0, {'name': 'okved2', 'type': 'okved2ProductType'}, 20),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, currency=None, okei=None, okdp=None, okpd2=None, okved=None, okved2=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.currency = currency
        self.currency_nsprefix_ = None
        self.okei = okei
        self.okei_nsprefix_ = None
        self.okdp = okdp
        self.okdp_nsprefix_ = None
        self.okpd2 = okpd2
        self.okpd2_nsprefix_ = None
        self.okved = okved
        self.okved_nsprefix_ = None
        self.okved2 = okved2
        self.okved2_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, nsiType124)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if nsiType124.subclass:
            return nsiType124.subclass(*args_, **kwargs_)
        else:
            return nsiType124(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.currency is not None or
            self.okei is not None or
            self.okdp is not None or
            self.okpd2 is not None or
            self.okved is not None or
            self.okved2 is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'currency':
            obj_ = currencyType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.currency = obj_
            obj_.original_tagname_ = 'currency'
        elif nodeName_ == 'okei':
            obj_ = okeiProductType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.okei = obj_
            obj_.original_tagname_ = 'okei'
        elif nodeName_ == 'okdp':
            obj_ = okdpProductType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.okdp = obj_
            obj_.original_tagname_ = 'okdp'
        elif nodeName_ == 'okpd2':
            obj_ = okpd2ProductType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.okpd2 = obj_
            obj_.original_tagname_ = 'okpd2'
        elif nodeName_ == 'okved':
            obj_ = okvedProductType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.okved = obj_
            obj_.original_tagname_ = 'okved'
        elif nodeName_ == 'okved2':
            obj_ = okved2ProductType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.okved2 = obj_
            obj_.original_tagname_ = 'okved2'
# end class nsiType124


class sectionType127(GeneratedsSuper):
    """Описание раздела шаблона"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'sectionOrdinal': MemberSpec_('sectionOrdinal', 'xs:long', 0, 0, {'name': 'sectionOrdinal', 'type': 'xs:long'}, None),
        'sectionName': MemberSpec_('sectionName', ['sectionNameType128', 'nonEmptyString', 'xs:string'], 0, 0, {'name': 'sectionName', 'type': 'xs:string'}, None),
        'fixedName': MemberSpec_('fixedName', ['fixedNameType129', 'nonEmptyString', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'fixedName', 'type': 'xs:string'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, sectionOrdinal=None, sectionName=None, fixedName=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.sectionOrdinal = sectionOrdinal
        self.sectionOrdinal_nsprefix_ = None
        self.sectionName = sectionName
        self.validate_sectionNameType128(self.sectionName)
        self.sectionName_nsprefix_ = None
        self.fixedName = fixedName
        self.validate_fixedNameType129(self.fixedName)
        self.fixedName_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, sectionType127)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if sectionType127.subclass:
            return sectionType127.subclass(*args_, **kwargs_)
        else:
            return sectionType127(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_sectionNameType128(self, value):
        result = True
        # Validate type sectionNameType128, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 130:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on sectionNameType128' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on sectionNameType128' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_fixedNameType129(self, value):
        result = True
        # Validate type fixedNameType129, a restriction on nonEmptyString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 130:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on fixedNameType129' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on fixedNameType129' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.sectionOrdinal is not None or
            self.sectionName is not None or
            self.fixedName is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'sectionOrdinal' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'sectionOrdinal')
            ival_ = self.gds_validate_integer(ival_, node, 'sectionOrdinal')
            self.sectionOrdinal = ival_
            self.sectionOrdinal_nsprefix_ = child_.prefix
        elif nodeName_ == 'sectionName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'sectionName')
            value_ = self.gds_validate_string(value_, node, 'sectionName')
            self.sectionName = value_
            self.sectionName_nsprefix_ = child_.prefix
            # validate type sectionNameType128
            self.validate_sectionNameType128(self.sectionName)
        elif nodeName_ == 'fixedName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'fixedName')
            value_ = self.gds_validate_string(value_, node, 'fixedName')
            self.fixedName = value_
            self.fixedName_nsprefix_ = child_.prefix
            # validate type fixedNameType129
            self.validate_fixedNameType129(self.fixedName)
# end class sectionType127


class lotApplicationsCriteriaType(baseCriteriaType):
    """Критерий по лоту протокола"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = baseCriteriaType
    def __init__(self, guid=None, name=None, description=None, maxValue=None, weight=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(lotApplicationsCriteriaType, self).__init__(guid, name, description, maxValue, weight,  **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, lotApplicationsCriteriaType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if lotApplicationsCriteriaType.subclass:
            return lotApplicationsCriteriaType.subclass(*args_, **kwargs_)
        else:
            return lotApplicationsCriteriaType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(lotApplicationsCriteriaType, self).hasContent_()
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(lotApplicationsCriteriaType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(lotApplicationsCriteriaType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class lotApplicationsCriteriaType


class lotCriteriaType(baseCriteriaType):
    """Критерий по лоту"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = baseCriteriaType
    def __init__(self, guid=None, name=None, description=None, maxValue=None, weight=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(lotCriteriaType, self).__init__(guid, name, description, maxValue, weight,  **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, lotCriteriaType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if lotCriteriaType.subclass:
            return lotCriteriaType.subclass(*args_, **kwargs_)
        else:
            return lotCriteriaType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(lotCriteriaType, self).hasContent_()
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(lotCriteriaType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(lotCriteriaType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class lotCriteriaType


class processingInfoResponse(packetType):
    """Ответ на запрос статуса загрузки"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'body': MemberSpec_('body', 'bodyType49', 0, 0, {'name': 'body', 'type': 'bodyType49'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = packetType
    def __init__(self, header=None, signature=None, body=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(processingInfoResponse, self).__init__(header, signature,  **kwargs_)
        self.body = body
        self.body_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, processingInfoResponse)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if processingInfoResponse.subclass:
            return processingInfoResponse.subclass(*args_, **kwargs_)
        else:
            return processingInfoResponse(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.body is not None or
            super(processingInfoResponse, self).hasContent_()
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(processingInfoResponse, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'body':
            obj_ = bodyType49.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.body = obj_
            obj_.original_tagname_ = 'body'
        super(processingInfoResponse, self).buildChildren(child_, node, nodeName_, True)
# end class processingInfoResponse


class processingInfoRequest(packetType):
    """Запрос статуса загрузки"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'body': MemberSpec_('body', 'bodyType48', 0, 0, {'name': 'body', 'type': 'bodyType48'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = packetType
    def __init__(self, header=None, signature=None, body=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(processingInfoRequest, self).__init__(header, signature,  **kwargs_)
        self.body = body
        self.body_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, processingInfoRequest)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if processingInfoRequest.subclass:
            return processingInfoRequest.subclass(*args_, **kwargs_)
        else:
            return processingInfoRequest(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.body is not None or
            super(processingInfoRequest, self).hasContent_()
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(processingInfoRequest, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'body':
            obj_ = bodyType48.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.body = obj_
            obj_.original_tagname_ = 'body'
        super(processingInfoRequest, self).buildChildren(child_, node, nodeName_, True)
# end class processingInfoRequest


class confirmation(packetType):
    """Протокол загрузки информационного пакета"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'body': MemberSpec_('body', 'bodyType47', 0, 0, {'name': 'body', 'type': 'bodyType47'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = packetType
    def __init__(self, header=None, signature=None, body=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(confirmation, self).__init__(header, signature,  **kwargs_)
        self.body = body
        self.body_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, confirmation)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if confirmation.subclass:
            return confirmation.subclass(*args_, **kwargs_)
        else:
            return confirmation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.body is not None or
            super(confirmation, self).hasContent_()
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(confirmation, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'body':
            obj_ = bodyType47.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.body = obj_
            obj_.original_tagname_ = 'body'
        super(confirmation, self).buildChildren(child_, node, nodeName_, True)
# end class confirmation


class documentUpload(packetType):
    """Загрузка дополнительного документа"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'body': MemberSpec_('body', 'bodyType46', 0, 0, {'name': 'body', 'type': 'bodyType46'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = packetType
    def __init__(self, header=None, signature=None, body=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(documentUpload, self).__init__(header, signature,  **kwargs_)
        self.body = body
        self.body_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, documentUpload)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if documentUpload.subclass:
            return documentUpload.subclass(*args_, **kwargs_)
        else:
            return documentUpload(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.body is not None or
            super(documentUpload, self).hasContent_()
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(documentUpload, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'body':
            obj_ = bodyType46.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.body = obj_
            obj_.original_tagname_ = 'body'
        super(documentUpload, self).buildChildren(child_, node, nodeName_, True)
# end class documentUpload


class nsiPurchaseMethod(packetType):
    """Справочник способов закупки"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'body': MemberSpec_('body', 'bodyType45', 0, 0, {'name': 'body', 'type': 'bodyType45'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = packetType
    def __init__(self, header=None, signature=None, body=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(nsiPurchaseMethod, self).__init__(header, signature,  **kwargs_)
        self.body = body
        self.body_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, nsiPurchaseMethod)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if nsiPurchaseMethod.subclass:
            return nsiPurchaseMethod.subclass(*args_, **kwargs_)
        else:
            return nsiPurchaseMethod(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.body is not None or
            super(nsiPurchaseMethod, self).hasContent_()
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(nsiPurchaseMethod, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'body':
            obj_ = bodyType45.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.body = obj_
            obj_.original_tagname_ = 'body'
        super(nsiPurchaseMethod, self).buildChildren(child_, node, nodeName_, True)
# end class nsiPurchaseMethod


class nsiOrderClauseType(packetType):
    """Справочник шаблонов положений о закупках"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'body': MemberSpec_('body', 'bodyType44', 0, 0, {'name': 'body', 'type': 'bodyType44'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = packetType
    def __init__(self, header=None, signature=None, body=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(nsiOrderClauseType, self).__init__(header, signature,  **kwargs_)
        self.body = body
        self.body_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, nsiOrderClauseType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if nsiOrderClauseType.subclass:
            return nsiOrderClauseType.subclass(*args_, **kwargs_)
        else:
            return nsiOrderClauseType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.body is not None or
            super(nsiOrderClauseType, self).hasContent_()
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(nsiOrderClauseType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'body':
            obj_ = bodyType44.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.body = obj_
            obj_.original_tagname_ = 'body'
        super(nsiOrderClauseType, self).buildChildren(child_, node, nodeName_, True)
# end class nsiOrderClauseType


class nsiProtocolType(packetType):
    """Справочник типов протоколов"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'body': MemberSpec_('body', 'bodyType43', 0, 0, {'name': 'body', 'type': 'bodyType43'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = packetType
    def __init__(self, header=None, signature=None, body=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(nsiProtocolType, self).__init__(header, signature,  **kwargs_)
        self.body = body
        self.body_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, nsiProtocolType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if nsiProtocolType.subclass:
            return nsiProtocolType.subclass(*args_, **kwargs_)
        else:
            return nsiProtocolType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.body is not None or
            super(nsiProtocolType, self).hasContent_()
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(nsiProtocolType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'body':
            obj_ = bodyType43.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.body = obj_
            obj_.original_tagname_ = 'body'
        super(nsiProtocolType, self).buildChildren(child_, node, nodeName_, True)
# end class nsiProtocolType


class nsiOrganization(packetType):
    """Справочник организаций"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'body': MemberSpec_('body', 'bodyType42', 0, 0, {'name': 'body', 'type': 'bodyType42'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = packetType
    def __init__(self, header=None, signature=None, body=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(nsiOrganization, self).__init__(header, signature,  **kwargs_)
        self.body = body
        self.body_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, nsiOrganization)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if nsiOrganization.subclass:
            return nsiOrganization.subclass(*args_, **kwargs_)
        else:
            return nsiOrganization(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.body is not None or
            super(nsiOrganization, self).hasContent_()
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(nsiOrganization, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'body':
            obj_ = bodyType42.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.body = obj_
            obj_.original_tagname_ = 'body'
        super(nsiOrganization, self).buildChildren(child_, node, nodeName_, True)
# end class nsiOrganization


class nsiOkved2(packetType):
    """Общероссийский классификатор видов экономической деятельности"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'body': MemberSpec_('body', 'bodyType41', 0, 0, {'name': 'body', 'type': 'bodyType41'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = packetType
    def __init__(self, header=None, signature=None, body=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(nsiOkved2, self).__init__(header, signature,  **kwargs_)
        self.body = body
        self.body_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, nsiOkved2)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if nsiOkved2.subclass:
            return nsiOkved2.subclass(*args_, **kwargs_)
        else:
            return nsiOkved2(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.body is not None or
            super(nsiOkved2, self).hasContent_()
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(nsiOkved2, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'body':
            obj_ = bodyType41.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.body = obj_
            obj_.original_tagname_ = 'body'
        super(nsiOkved2, self).buildChildren(child_, node, nodeName_, True)
# end class nsiOkved2


class nsiOkved(packetType):
    """Общероссийский классификатор видов экономической деятельности"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'body': MemberSpec_('body', 'bodyType40', 0, 0, {'name': 'body', 'type': 'bodyType40'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = packetType
    def __init__(self, header=None, signature=None, body=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(nsiOkved, self).__init__(header, signature,  **kwargs_)
        self.body = body
        self.body_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, nsiOkved)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if nsiOkved.subclass:
            return nsiOkved.subclass(*args_, **kwargs_)
        else:
            return nsiOkved(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.body is not None or
            super(nsiOkved, self).hasContent_()
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(nsiOkved, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'body':
            obj_ = bodyType40.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.body = obj_
            obj_.original_tagname_ = 'body'
        super(nsiOkved, self).buildChildren(child_, node, nodeName_, True)
# end class nsiOkved


class nsiOkv(packetType):
    """Общероссийский классификатор валют"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'body': MemberSpec_('body', 'bodyType39', 0, 0, {'name': 'body', 'type': 'bodyType39'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = packetType
    def __init__(self, header=None, signature=None, body=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(nsiOkv, self).__init__(header, signature,  **kwargs_)
        self.body = body
        self.body_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, nsiOkv)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if nsiOkv.subclass:
            return nsiOkv.subclass(*args_, **kwargs_)
        else:
            return nsiOkv(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.body is not None or
            super(nsiOkv, self).hasContent_()
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(nsiOkv, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'body':
            obj_ = bodyType39.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.body = obj_
            obj_.original_tagname_ = 'body'
        super(nsiOkv, self).buildChildren(child_, node, nodeName_, True)
# end class nsiOkv


class nsiOktmo(packetType):
    """Общероссийский классификатор территорий муниципальных образований"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'body': MemberSpec_('body', 'bodyType38', 0, 0, {'name': 'body', 'type': 'bodyType38'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = packetType
    def __init__(self, header=None, signature=None, body=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(nsiOktmo, self).__init__(header, signature,  **kwargs_)
        self.body = body
        self.body_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, nsiOktmo)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if nsiOktmo.subclass:
            return nsiOktmo.subclass(*args_, **kwargs_)
        else:
            return nsiOktmo(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.body is not None or
            super(nsiOktmo, self).hasContent_()
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(nsiOktmo, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'body':
            obj_ = bodyType38.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.body = obj_
            obj_.original_tagname_ = 'body'
        super(nsiOktmo, self).buildChildren(child_, node, nodeName_, True)
# end class nsiOktmo


class nsiOkopf(packetType):
    """Общероссийский классификатор организационно-правовых форм"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'body': MemberSpec_('body', 'bodyType37', 0, 0, {'name': 'body', 'type': 'bodyType37'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = packetType
    def __init__(self, header=None, signature=None, body=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(nsiOkopf, self).__init__(header, signature,  **kwargs_)
        self.body = body
        self.body_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, nsiOkopf)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if nsiOkopf.subclass:
            return nsiOkopf.subclass(*args_, **kwargs_)
        else:
            return nsiOkopf(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.body is not None or
            super(nsiOkopf, self).hasContent_()
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(nsiOkopf, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'body':
            obj_ = bodyType37.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.body = obj_
            obj_.original_tagname_ = 'body'
        super(nsiOkopf, self).buildChildren(child_, node, nodeName_, True)
# end class nsiOkopf


class nsiOkogu(packetType):
    """Общероссийский классификатор органов государственной власти и
    управления"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'body': MemberSpec_('body', 'bodyType36', 0, 0, {'name': 'body', 'type': 'bodyType36'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = packetType
    def __init__(self, header=None, signature=None, body=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(nsiOkogu, self).__init__(header, signature,  **kwargs_)
        self.body = body
        self.body_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, nsiOkogu)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if nsiOkogu.subclass:
            return nsiOkogu.subclass(*args_, **kwargs_)
        else:
            return nsiOkogu(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.body is not None or
            super(nsiOkogu, self).hasContent_()
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(nsiOkogu, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'body':
            obj_ = bodyType36.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.body = obj_
            obj_.original_tagname_ = 'body'
        super(nsiOkogu, self).buildChildren(child_, node, nodeName_, True)
# end class nsiOkogu


class nsiOkfs(packetType):
    """Общероссийский классификатор форм собственности"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'body': MemberSpec_('body', 'bodyType35', 0, 0, {'name': 'body', 'type': 'bodyType35'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = packetType
    def __init__(self, header=None, signature=None, body=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(nsiOkfs, self).__init__(header, signature,  **kwargs_)
        self.body = body
        self.body_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, nsiOkfs)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if nsiOkfs.subclass:
            return nsiOkfs.subclass(*args_, **kwargs_)
        else:
            return nsiOkfs(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.body is not None or
            super(nsiOkfs, self).hasContent_()
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(nsiOkfs, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'body':
            obj_ = bodyType35.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.body = obj_
            obj_.original_tagname_ = 'body'
        super(nsiOkfs, self).buildChildren(child_, node, nodeName_, True)
# end class nsiOkfs


class nsiOkei(packetType):
    """Общероссийский классификатор единиц измерения"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'body': MemberSpec_('body', 'bodyType34', 0, 0, {'name': 'body', 'type': 'bodyType34'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = packetType
    def __init__(self, header=None, signature=None, body=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(nsiOkei, self).__init__(header, signature,  **kwargs_)
        self.body = body
        self.body_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, nsiOkei)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if nsiOkei.subclass:
            return nsiOkei.subclass(*args_, **kwargs_)
        else:
            return nsiOkei(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.body is not None or
            super(nsiOkei, self).hasContent_()
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(nsiOkei, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'body':
            obj_ = bodyType34.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.body = obj_
            obj_.original_tagname_ = 'body'
        super(nsiOkei, self).buildChildren(child_, node, nodeName_, True)
# end class nsiOkei


class nsiOkpd2(packetType):
    """Общероссийский классификатор видов экономической деятельности, продукции
    и услуг"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'body': MemberSpec_('body', 'bodyType33', 0, 0, {'name': 'body', 'type': 'bodyType33'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = packetType
    def __init__(self, header=None, signature=None, body=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(nsiOkpd2, self).__init__(header, signature,  **kwargs_)
        self.body = body
        self.body_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, nsiOkpd2)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if nsiOkpd2.subclass:
            return nsiOkpd2.subclass(*args_, **kwargs_)
        else:
            return nsiOkpd2(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.body is not None or
            super(nsiOkpd2, self).hasContent_()
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(nsiOkpd2, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'body':
            obj_ = bodyType33.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.body = obj_
            obj_.original_tagname_ = 'body'
        super(nsiOkpd2, self).buildChildren(child_, node, nodeName_, True)
# end class nsiOkpd2


class nsiOkdp(packetType):
    """Общероссийский классификатор видов экономической деятельности, продукции
    и услуг"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'body': MemberSpec_('body', 'bodyType32', 0, 0, {'name': 'body', 'type': 'bodyType32'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = packetType
    def __init__(self, header=None, signature=None, body=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(nsiOkdp, self).__init__(header, signature,  **kwargs_)
        self.body = body
        self.body_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, nsiOkdp)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if nsiOkdp.subclass:
            return nsiOkdp.subclass(*args_, **kwargs_)
        else:
            return nsiOkdp(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.body is not None or
            super(nsiOkdp, self).hasContent_()
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(nsiOkdp, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'body':
            obj_ = bodyType32.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.body = obj_
            obj_.original_tagname_ = 'body'
        super(nsiOkdp, self).buildChildren(child_, node, nodeName_, True)
# end class nsiOkdp


class nsiOkato(packetType):
    """Общероссийский классификатор объектов административно-территориального
    деления"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'body': MemberSpec_('body', 'bodyType', 0, 0, {'name': 'body', 'type': 'bodyType'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = packetType
    def __init__(self, header=None, signature=None, body=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(nsiOkato, self).__init__(header, signature,  **kwargs_)
        self.body = body
        self.body_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, nsiOkato)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if nsiOkato.subclass:
            return nsiOkato.subclass(*args_, **kwargs_)
        else:
            return nsiOkato(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.body is not None or
            super(nsiOkato, self).hasContent_()
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(nsiOkato, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'body':
            obj_ = bodyType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.body = obj_
            obj_.original_tagname_ = 'body'
        super(nsiOkato, self).buildChildren(child_, node, nodeName_, True)
# end class nsiOkato


class nsiPurchaseMethodItemType(itemType):
    """Данные позиции в пакете"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'nsiPurchaseMethodData': MemberSpec_('nsiPurchaseMethodData', 'nsiPurchaseMethodDataType', 0, 0, {'name': 'nsiPurchaseMethodData', 'type': 'nsiPurchaseMethodDataType'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = itemType
    def __init__(self, guid=None, nsiPurchaseMethodData=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(nsiPurchaseMethodItemType, self).__init__(guid,  **kwargs_)
        self.nsiPurchaseMethodData = nsiPurchaseMethodData
        self.nsiPurchaseMethodData_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, nsiPurchaseMethodItemType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if nsiPurchaseMethodItemType.subclass:
            return nsiPurchaseMethodItemType.subclass(*args_, **kwargs_)
        else:
            return nsiPurchaseMethodItemType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.nsiPurchaseMethodData is not None or
            super(nsiPurchaseMethodItemType, self).hasContent_()
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(nsiPurchaseMethodItemType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'nsiPurchaseMethodData':
            obj_ = nsiPurchaseMethodDataType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.nsiPurchaseMethodData = obj_
            obj_.original_tagname_ = 'nsiPurchaseMethodData'
        super(nsiPurchaseMethodItemType, self).buildChildren(child_, node, nodeName_, True)
# end class nsiPurchaseMethodItemType


class nsiProtocolTypeItemType(itemType):
    """Данные позиции в пакете"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'nsiProtocolTypeData': MemberSpec_('nsiProtocolTypeData', 'nsiProtocolTypeDataType', 0, 0, {'name': 'nsiProtocolTypeData', 'type': 'nsiProtocolTypeDataType'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = itemType
    def __init__(self, guid=None, nsiProtocolTypeData=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(nsiProtocolTypeItemType, self).__init__(guid,  **kwargs_)
        self.nsiProtocolTypeData = nsiProtocolTypeData
        self.nsiProtocolTypeData_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, nsiProtocolTypeItemType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if nsiProtocolTypeItemType.subclass:
            return nsiProtocolTypeItemType.subclass(*args_, **kwargs_)
        else:
            return nsiProtocolTypeItemType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.nsiProtocolTypeData is not None or
            super(nsiProtocolTypeItemType, self).hasContent_()
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(nsiProtocolTypeItemType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'nsiProtocolTypeData':
            obj_ = nsiProtocolTypeDataType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.nsiProtocolTypeData = obj_
            obj_.original_tagname_ = 'nsiProtocolTypeData'
        super(nsiProtocolTypeItemType, self).buildChildren(child_, node, nodeName_, True)
# end class nsiProtocolTypeItemType


class nsiOrderClauseTypeItemType(itemType):
    """Данные позиции в пакете"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'nsiOrderClauseTypeData': MemberSpec_('nsiOrderClauseTypeData', 'nsiOrderClauseTypeDataType', 0, 0, {'name': 'nsiOrderClauseTypeData', 'type': 'nsiOrderClauseTypeDataType'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = itemType
    def __init__(self, guid=None, nsiOrderClauseTypeData=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(nsiOrderClauseTypeItemType, self).__init__(guid,  **kwargs_)
        self.nsiOrderClauseTypeData = nsiOrderClauseTypeData
        self.nsiOrderClauseTypeData_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, nsiOrderClauseTypeItemType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if nsiOrderClauseTypeItemType.subclass:
            return nsiOrderClauseTypeItemType.subclass(*args_, **kwargs_)
        else:
            return nsiOrderClauseTypeItemType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.nsiOrderClauseTypeData is not None or
            super(nsiOrderClauseTypeItemType, self).hasContent_()
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(nsiOrderClauseTypeItemType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'nsiOrderClauseTypeData':
            obj_ = nsiOrderClauseTypeDataType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.nsiOrderClauseTypeData = obj_
            obj_.original_tagname_ = 'nsiOrderClauseTypeData'
        super(nsiOrderClauseTypeItemType, self).buildChildren(child_, node, nodeName_, True)
# end class nsiOrderClauseTypeItemType


class nsiOrganizationItemType(itemType):
    """Данные позиции в пакете"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'nsiOrganizationData': MemberSpec_('nsiOrganizationData', 'nsiOrganizationDataType', 0, 0, {'name': 'nsiOrganizationData', 'type': 'nsiOrganizationDataType'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = itemType
    def __init__(self, guid=None, nsiOrganizationData=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(nsiOrganizationItemType, self).__init__(guid,  **kwargs_)
        self.nsiOrganizationData = nsiOrganizationData
        self.nsiOrganizationData_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, nsiOrganizationItemType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if nsiOrganizationItemType.subclass:
            return nsiOrganizationItemType.subclass(*args_, **kwargs_)
        else:
            return nsiOrganizationItemType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.nsiOrganizationData is not None or
            super(nsiOrganizationItemType, self).hasContent_()
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(nsiOrganizationItemType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'nsiOrganizationData':
            obj_ = nsiOrganizationDataType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.nsiOrganizationData = obj_
            obj_.original_tagname_ = 'nsiOrganizationData'
        super(nsiOrganizationItemType, self).buildChildren(child_, node, nodeName_, True)
# end class nsiOrganizationItemType


class nsiOkved2ItemType(itemType):
    """Данные позиции в пакете"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'nsiOkved2Data': MemberSpec_('nsiOkved2Data', 'nsiOkved2DataType', 0, 0, {'name': 'nsiOkved2Data', 'type': 'nsiOkved2DataType'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = itemType
    def __init__(self, guid=None, nsiOkved2Data=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(nsiOkved2ItemType, self).__init__(guid,  **kwargs_)
        self.nsiOkved2Data = nsiOkved2Data
        self.nsiOkved2Data_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, nsiOkved2ItemType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if nsiOkved2ItemType.subclass:
            return nsiOkved2ItemType.subclass(*args_, **kwargs_)
        else:
            return nsiOkved2ItemType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.nsiOkved2Data is not None or
            super(nsiOkved2ItemType, self).hasContent_()
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(nsiOkved2ItemType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'nsiOkved2Data':
            obj_ = nsiOkved2DataType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.nsiOkved2Data = obj_
            obj_.original_tagname_ = 'nsiOkved2Data'
        super(nsiOkved2ItemType, self).buildChildren(child_, node, nodeName_, True)
# end class nsiOkved2ItemType


class nsiOkvedItemType(itemType):
    """Данные позиции в пакете"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'nsiOkvedData': MemberSpec_('nsiOkvedData', 'nsiOkvedDataType', 0, 0, {'name': 'nsiOkvedData', 'type': 'nsiOkvedDataType'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = itemType
    def __init__(self, guid=None, nsiOkvedData=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(nsiOkvedItemType, self).__init__(guid,  **kwargs_)
        self.nsiOkvedData = nsiOkvedData
        self.nsiOkvedData_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, nsiOkvedItemType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if nsiOkvedItemType.subclass:
            return nsiOkvedItemType.subclass(*args_, **kwargs_)
        else:
            return nsiOkvedItemType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.nsiOkvedData is not None or
            super(nsiOkvedItemType, self).hasContent_()
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(nsiOkvedItemType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'nsiOkvedData':
            obj_ = nsiOkvedDataType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.nsiOkvedData = obj_
            obj_.original_tagname_ = 'nsiOkvedData'
        super(nsiOkvedItemType, self).buildChildren(child_, node, nodeName_, True)
# end class nsiOkvedItemType


class nsiOkvItemType(itemType):
    """Данные позиции в пакете"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'nsiOkvData': MemberSpec_('nsiOkvData', 'nsiOkvDataType', 0, 0, {'name': 'nsiOkvData', 'type': 'nsiOkvDataType'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = itemType
    def __init__(self, guid=None, nsiOkvData=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(nsiOkvItemType, self).__init__(guid,  **kwargs_)
        self.nsiOkvData = nsiOkvData
        self.nsiOkvData_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, nsiOkvItemType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if nsiOkvItemType.subclass:
            return nsiOkvItemType.subclass(*args_, **kwargs_)
        else:
            return nsiOkvItemType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.nsiOkvData is not None or
            super(nsiOkvItemType, self).hasContent_()
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(nsiOkvItemType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'nsiOkvData':
            obj_ = nsiOkvDataType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.nsiOkvData = obj_
            obj_.original_tagname_ = 'nsiOkvData'
        super(nsiOkvItemType, self).buildChildren(child_, node, nodeName_, True)
# end class nsiOkvItemType


class nsiOkopfItemType(itemType):
    """Данные позиции в пакете"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'nsiOkopfData': MemberSpec_('nsiOkopfData', 'nsiOkopfDataType', 0, 0, {'name': 'nsiOkopfData', 'type': 'nsiOkopfDataType'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = itemType
    def __init__(self, guid=None, nsiOkopfData=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(nsiOkopfItemType, self).__init__(guid,  **kwargs_)
        self.nsiOkopfData = nsiOkopfData
        self.nsiOkopfData_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, nsiOkopfItemType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if nsiOkopfItemType.subclass:
            return nsiOkopfItemType.subclass(*args_, **kwargs_)
        else:
            return nsiOkopfItemType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.nsiOkopfData is not None or
            super(nsiOkopfItemType, self).hasContent_()
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(nsiOkopfItemType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'nsiOkopfData':
            obj_ = nsiOkopfDataType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.nsiOkopfData = obj_
            obj_.original_tagname_ = 'nsiOkopfData'
        super(nsiOkopfItemType, self).buildChildren(child_, node, nodeName_, True)
# end class nsiOkopfItemType


class nsiOkoguItemType(itemType):
    """Данные позиции в пакете"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'nsiOkoguData': MemberSpec_('nsiOkoguData', 'nsiOkoguDataType', 0, 0, {'name': 'nsiOkoguData', 'type': 'nsiOkoguDataType'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = itemType
    def __init__(self, guid=None, nsiOkoguData=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(nsiOkoguItemType, self).__init__(guid,  **kwargs_)
        self.nsiOkoguData = nsiOkoguData
        self.nsiOkoguData_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, nsiOkoguItemType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if nsiOkoguItemType.subclass:
            return nsiOkoguItemType.subclass(*args_, **kwargs_)
        else:
            return nsiOkoguItemType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.nsiOkoguData is not None or
            super(nsiOkoguItemType, self).hasContent_()
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(nsiOkoguItemType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'nsiOkoguData':
            obj_ = nsiOkoguDataType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.nsiOkoguData = obj_
            obj_.original_tagname_ = 'nsiOkoguData'
        super(nsiOkoguItemType, self).buildChildren(child_, node, nodeName_, True)
# end class nsiOkoguItemType


class nsiOktmoItemType(itemType):
    """Данные позиции в пакете"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'nsiOktmoData': MemberSpec_('nsiOktmoData', 'nsiOktmoDataType', 0, 0, {'name': 'nsiOktmoData', 'type': 'nsiOktmoDataType'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = itemType
    def __init__(self, guid=None, nsiOktmoData=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(nsiOktmoItemType, self).__init__(guid,  **kwargs_)
        self.nsiOktmoData = nsiOktmoData
        self.nsiOktmoData_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, nsiOktmoItemType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if nsiOktmoItemType.subclass:
            return nsiOktmoItemType.subclass(*args_, **kwargs_)
        else:
            return nsiOktmoItemType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.nsiOktmoData is not None or
            super(nsiOktmoItemType, self).hasContent_()
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(nsiOktmoItemType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'nsiOktmoData':
            obj_ = nsiOktmoDataType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.nsiOktmoData = obj_
            obj_.original_tagname_ = 'nsiOktmoData'
        super(nsiOktmoItemType, self).buildChildren(child_, node, nodeName_, True)
# end class nsiOktmoItemType


class nsiOkfsItemType(itemType):
    """Данные позиции в пакете"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'nsiOkfsData': MemberSpec_('nsiOkfsData', 'nsiOkfsDataType', 0, 0, {'name': 'nsiOkfsData', 'type': 'nsiOkfsDataType'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = itemType
    def __init__(self, guid=None, nsiOkfsData=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(nsiOkfsItemType, self).__init__(guid,  **kwargs_)
        self.nsiOkfsData = nsiOkfsData
        self.nsiOkfsData_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, nsiOkfsItemType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if nsiOkfsItemType.subclass:
            return nsiOkfsItemType.subclass(*args_, **kwargs_)
        else:
            return nsiOkfsItemType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.nsiOkfsData is not None or
            super(nsiOkfsItemType, self).hasContent_()
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(nsiOkfsItemType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'nsiOkfsData':
            obj_ = nsiOkfsDataType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.nsiOkfsData = obj_
            obj_.original_tagname_ = 'nsiOkfsData'
        super(nsiOkfsItemType, self).buildChildren(child_, node, nodeName_, True)
# end class nsiOkfsItemType


class nsiOkeiItemType(itemType):
    """Данные позиции в пакете"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'nsiOkeiData': MemberSpec_('nsiOkeiData', 'nsiOkeiDataType', 0, 0, {'name': 'nsiOkeiData', 'type': 'nsiOkeiDataType'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = itemType
    def __init__(self, guid=None, nsiOkeiData=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(nsiOkeiItemType, self).__init__(guid,  **kwargs_)
        self.nsiOkeiData = nsiOkeiData
        self.nsiOkeiData_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, nsiOkeiItemType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if nsiOkeiItemType.subclass:
            return nsiOkeiItemType.subclass(*args_, **kwargs_)
        else:
            return nsiOkeiItemType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.nsiOkeiData is not None or
            super(nsiOkeiItemType, self).hasContent_()
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(nsiOkeiItemType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'nsiOkeiData':
            obj_ = nsiOkeiDataType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.nsiOkeiData = obj_
            obj_.original_tagname_ = 'nsiOkeiData'
        super(nsiOkeiItemType, self).buildChildren(child_, node, nodeName_, True)
# end class nsiOkeiItemType


class nsiOkpd2ItemType(itemType):
    """Данные позиции в пакете"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'nsiOkpd2Data': MemberSpec_('nsiOkpd2Data', 'nsiOkpd2DataType', 0, 0, {'name': 'nsiOkpd2Data', 'type': 'nsiOkpd2DataType'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = itemType
    def __init__(self, guid=None, nsiOkpd2Data=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(nsiOkpd2ItemType, self).__init__(guid,  **kwargs_)
        self.nsiOkpd2Data = nsiOkpd2Data
        self.nsiOkpd2Data_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, nsiOkpd2ItemType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if nsiOkpd2ItemType.subclass:
            return nsiOkpd2ItemType.subclass(*args_, **kwargs_)
        else:
            return nsiOkpd2ItemType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.nsiOkpd2Data is not None or
            super(nsiOkpd2ItemType, self).hasContent_()
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(nsiOkpd2ItemType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'nsiOkpd2Data':
            obj_ = nsiOkpd2DataType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.nsiOkpd2Data = obj_
            obj_.original_tagname_ = 'nsiOkpd2Data'
        super(nsiOkpd2ItemType, self).buildChildren(child_, node, nodeName_, True)
# end class nsiOkpd2ItemType


class nsiOkdpItemType(itemType):
    """Данные позиции в пакете"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'nsiOkdpData': MemberSpec_('nsiOkdpData', 'nsiOkdpDataType', 0, 0, {'name': 'nsiOkdpData', 'type': 'nsiOkdpDataType'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = itemType
    def __init__(self, guid=None, nsiOkdpData=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(nsiOkdpItemType, self).__init__(guid,  **kwargs_)
        self.nsiOkdpData = nsiOkdpData
        self.nsiOkdpData_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, nsiOkdpItemType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if nsiOkdpItemType.subclass:
            return nsiOkdpItemType.subclass(*args_, **kwargs_)
        else:
            return nsiOkdpItemType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.nsiOkdpData is not None or
            super(nsiOkdpItemType, self).hasContent_()
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(nsiOkdpItemType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'nsiOkdpData':
            obj_ = nsiOkdpDataType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.nsiOkdpData = obj_
            obj_.original_tagname_ = 'nsiOkdpData'
        super(nsiOkdpItemType, self).buildChildren(child_, node, nodeName_, True)
# end class nsiOkdpItemType


class nsiOkatoItemType(itemType):
    """Данные позиции в пакете"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'nsiOkatoData': MemberSpec_('nsiOkatoData', 'nsiOkatoDataType', 0, 0, {'name': 'nsiOkatoData', 'type': 'nsiOkatoDataType'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = itemType
    def __init__(self, guid=None, nsiOkatoData=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(nsiOkatoItemType, self).__init__(guid,  **kwargs_)
        self.nsiOkatoData = nsiOkatoData
        self.nsiOkatoData_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, nsiOkatoItemType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if nsiOkatoItemType.subclass:
            return nsiOkatoItemType.subclass(*args_, **kwargs_)
        else:
            return nsiOkatoItemType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.nsiOkatoData is not None or
            super(nsiOkatoItemType, self).hasContent_()
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(nsiOkatoItemType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'nsiOkatoData':
            obj_ = nsiOkatoDataType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.nsiOkatoData = obj_
            obj_.original_tagname_ = 'nsiOkatoData'
        super(nsiOkatoItemType, self).buildChildren(child_, node, nodeName_, True)
# end class nsiOkatoItemType


GDSClassesMapping = {
}


USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""


def usage():
    print(USAGE_TEXT)
    sys.exit(1)


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    rootClass = GDSClassesMapping.get(tag)
    if rootClass is None:
        rootClass = globals().get(tag)
    return tag, rootClass


def get_required_ns_prefix_defs(rootNode):
    '''Get all name space prefix definitions required in this XML doc.
    Return a dictionary of definitions and a char string of definitions.
    '''
    nsmap = {
        prefix: uri
        for node in rootNode.iter()
        for (prefix, uri) in node.nsmap.items()
        if prefix is not None
    }
    namespacedefs = ' '.join([
        'xmlns:{}="{}"'.format(prefix, uri)
        for prefix, uri in nsmap.items()
    ])
    return nsmap, namespacedefs


def parse(inFileName, silence=False, print_warnings=True):
    global CapturedNsmap_
    gds_collector = GdsCollector_()
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'nsiOkatoDataType'
        rootClass = nsiOkatoDataType
    rootObj = rootClass.factory()
    rootObj.build(rootNode, gds_collector_=gds_collector)
    CapturedNsmap_, namespacedefs = get_required_ns_prefix_defs(rootNode)
    if not SaveElementTreeNode:
        doc = None
        rootNode = None
##     if not silence:
##         sys.stdout.write('<?xml version="1.0" ?>\n')
##         rootObj.export(
##             sys.stdout, 0, name_=rootTag,
##             namespacedef_=namespacedefs,
##             pretty_print=True)
    if print_warnings and len(gds_collector.get_messages()) > 0:
        separator = ('-' * 50) + '\n'
        sys.stderr.write(separator)
        sys.stderr.write('----- Warnings -- count: {} -----\n'.format(
            len(gds_collector.get_messages()), ))
        gds_collector.write_messages(sys.stderr)
        sys.stderr.write(separator)
    return rootObj


def parseEtree(inFileName, silence=False, print_warnings=True,
               mapping=None, nsmap=None):
    parser = None
    doc = parsexml_(inFileName, parser)
    gds_collector = GdsCollector_()
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'nsiOkatoDataType'
        rootClass = nsiOkatoDataType
    rootObj = rootClass.factory()
    rootObj.build(rootNode, gds_collector_=gds_collector)
    # Enable Python to collect the space used by the DOM.
    if mapping is None:
        mapping = {}
    rootElement = rootObj.to_etree(
        None, name_=rootTag, mapping_=mapping, nsmap_=nsmap)
    reverse_mapping = rootObj.gds_reverse_node_mapping(mapping)
    if not SaveElementTreeNode:
        doc = None
        rootNode = None
##     if not silence:
##         content = etree_.tostring(
##             rootElement, pretty_print=True,
##             xml_declaration=True, encoding="utf-8")
##         sys.stdout.write(str(content))
##         sys.stdout.write('\n')
    if print_warnings and len(gds_collector.get_messages()) > 0:
        separator = ('-' * 50) + '\n'
        sys.stderr.write(separator)
        sys.stderr.write('----- Warnings -- count: {} -----\n'.format(
            len(gds_collector.get_messages()), ))
        gds_collector.write_messages(sys.stderr)
        sys.stderr.write(separator)
    return rootObj, rootElement, mapping, reverse_mapping


def parseString(inString, silence=False, print_warnings=True):
    '''Parse a string, create the object tree, and export it.

    Arguments:
    - inString -- A string.  This XML fragment should not start
      with an XML declaration containing an encoding.
    - silence -- A boolean.  If False, export the object.
    Returns -- The root object in the tree.
    '''
    parser = None
    rootNode= parsexmlstring_(inString, parser)
    gds_collector = GdsCollector_()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'nsiOkatoDataType'
        rootClass = nsiOkatoDataType
    rootObj = rootClass.factory()
    rootObj.build(rootNode, gds_collector_=gds_collector)
    if not SaveElementTreeNode:
        rootNode = None
##     if not silence:
##         sys.stdout.write('<?xml version="1.0" ?>\n')
##         rootObj.export(
##             sys.stdout, 0, name_=rootTag,
##             namespacedef_='')
    if print_warnings and len(gds_collector.get_messages()) > 0:
        separator = ('-' * 50) + '\n'
        sys.stderr.write(separator)
        sys.stderr.write('----- Warnings -- count: {} -----\n'.format(
            len(gds_collector.get_messages()), ))
        gds_collector.write_messages(sys.stderr)
        sys.stderr.write(separator)
    return rootObj


def parseLiteral(inFileName, silence=False, print_warnings=True):
    parser = None
    doc = parsexml_(inFileName, parser)
    gds_collector = GdsCollector_()
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'nsiOkatoDataType'
        rootClass = nsiOkatoDataType
    rootObj = rootClass.factory()
    rootObj.build(rootNode, gds_collector_=gds_collector)
    # Enable Python to collect the space used by the DOM.
    if not SaveElementTreeNode:
        doc = None
        rootNode = None
##     if not silence:
##         sys.stdout.write('#from reference import *\n\n')
##         sys.stdout.write('import reference as model_\n\n')
##         sys.stdout.write('rootObj = model_.rootClass(\n')
##         rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
##         sys.stdout.write(')\n')
    if print_warnings and len(gds_collector.get_messages()) > 0:
        separator = ('-' * 50) + '\n'
        sys.stderr.write(separator)
        sys.stderr.write('----- Warnings -- count: {} -----\n'.format(
            len(gds_collector.get_messages()), ))
        gds_collector.write_messages(sys.stderr)
        sys.stderr.write(separator)
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()

RenameMappings_ = {
}

#
# Mapping of namespaces to types defined in them
# and the file in which each is defined.
# simpleTypes are marked "ST" and complexTypes "CT".
NamespaceToDefMappings_ = {'http://zakupki.gov.ru/223fz/reference/1': [('businessStatusType',
                                              'reference.xsd',
                                              'ST'),
                                             ('typalKindType',
                                              'reference.xsd',
                                              'ST'),
                                             ('protocolKindType',
                                              'reference.xsd',
                                              'ST'),
                                             ('nsiOkatoDataType',
                                              'reference.xsd',
                                              'CT'),
                                             ('nsiOkatoItemType',
                                              'reference.xsd',
                                              'CT'),
                                             ('nsiOkdpDataType',
                                              'reference.xsd',
                                              'CT'),
                                             ('nsiOkdpItemType',
                                              'reference.xsd',
                                              'CT'),
                                             ('nsiOkpd2DataType',
                                              'reference.xsd',
                                              'CT'),
                                             ('nsiOkpd2ItemType',
                                              'reference.xsd',
                                              'CT'),
                                             ('nsiOkeiDataType',
                                              'reference.xsd',
                                              'CT'),
                                             ('nsiOkeiItemType',
                                              'reference.xsd',
                                              'CT'),
                                             ('nsiOkfsDataType',
                                              'reference.xsd',
                                              'CT'),
                                             ('nsiOkfsItemType',
                                              'reference.xsd',
                                              'CT'),
                                             ('nsiOktmoDataType',
                                              'reference.xsd',
                                              'CT'),
                                             ('nsiOktmoItemType',
                                              'reference.xsd',
                                              'CT'),
                                             ('nsiOkoguDataType',
                                              'reference.xsd',
                                              'CT'),
                                             ('nsiOkoguItemType',
                                              'reference.xsd',
                                              'CT'),
                                             ('nsiOkopfDataType',
                                              'reference.xsd',
                                              'CT'),
                                             ('nsiOkopfItemType',
                                              'reference.xsd',
                                              'CT'),
                                             ('nsiOkvDataType',
                                              'reference.xsd',
                                              'CT'),
                                             ('nsiOkvItemType',
                                              'reference.xsd',
                                              'CT'),
                                             ('nsiOkvedDataType',
                                              'reference.xsd',
                                              'CT'),
                                             ('nsiOkvedItemType',
                                              'reference.xsd',
                                              'CT'),
                                             ('nsiOkved2DataType',
                                              'reference.xsd',
                                              'CT'),
                                             ('nsiOkved2ItemType',
                                              'reference.xsd',
                                              'CT'),
                                             ('nsiOrganizationDataType',
                                              'reference.xsd',
                                              'CT'),
                                             ('SuccessionInfo',
                                              'reference.xsd',
                                              'CT'),
                                             ('SuccessorType',
                                              'reference.xsd',
                                              'CT'),
                                             ('nsiOrganizationItemType',
                                              'reference.xsd',
                                              'CT'),
                                             ('nsiOrderClauseTypeItemType',
                                              'reference.xsd',
                                              'CT'),
                                             ('nsiOrderClauseTypeDataType',
                                              'reference.xsd',
                                              'CT'),
                                             ('nsiProtocolTypeDataType',
                                              'reference.xsd',
                                              'CT'),
                                             ('nsiProtocolTypeItemType',
                                              'reference.xsd',
                                              'CT'),
                                             ('nsiPurchaseMethodDataType',
                                              'reference.xsd',
                                              'CT'),
                                             ('phaseTransitionsListType',
                                              'reference.xsd',
                                              'CT'),
                                             ('phaseTransition',
                                              'reference.xsd',
                                              'CT'),
                                             ('purchasePhaseListType',
                                              'reference.xsd',
                                              'CT'),
                                             ('purchasePhase',
                                              'reference.xsd',
                                              'CT'),
                                             ('protocolListType',
                                              'reference.xsd',
                                              'CT'),
                                             ('purchaseProtocol',
                                              'reference.xsd',
                                              'CT'),
                                             ('nsiPurchaseMethodItemType',
                                              'reference.xsd',
                                              'CT')],
 'http://zakupki.gov.ru/223fz/types/1': [('deliveryPlaceIndicationType',
                                          'Types.xsd',
                                          'ST'),
                                         ('lotPlanPositionType',
                                          'Types.xsd',
                                          'ST'),
                                         ('organizationCodeType',
                                          'Types.xsd',
                                          'ST'),
                                         ('codeEgrulType', 'Types.xsd', 'ST'),
                                         ('codeOkatoType', 'Types.xsd', 'ST'),
                                         ('codeOkdpType', 'Types.xsd', 'ST'),
                                         ('codeOkpd2Type', 'Types.xsd', 'ST'),
                                         ('codeOkeiType', 'Types.xsd', 'ST'),
                                         ('codeOkfsType', 'Types.xsd', 'ST'),
                                         ('codeOkoguType', 'Types.xsd', 'ST'),
                                         ('codeOkopfType', 'Types.xsd', 'ST'),
                                         ('codeOktmoType', 'Types.xsd', 'ST'),
                                         ('codeOkpoType', 'Types.xsd', 'ST'),
                                         ('customerCodeOkpoType',
                                          'Types.xsd',
                                          'ST'),
                                         ('codeOkvedType', 'Types.xsd', 'ST'),
                                         ('codeOkved2Type', 'Types.xsd', 'ST'),
                                         ('emailType', 'Types.xsd', 'ST'),
                                         ('guidType', 'Types.xsd', 'ST'),
                                         ('ikoType', 'Types.xsd', 'ST'),
                                         ('innType', 'Types.xsd', 'ST'),
                                         ('kppType', 'Types.xsd', 'ST'),
                                         ('money2', 'Types.xsd', 'ST'),
                                         ('unsignedMoney2', 'Types.xsd', 'ST'),
                                         ('decimal20_2', 'Types.xsd', 'ST'),
                                         ('money3', 'Types.xsd', 'ST'),
                                         ('money4', 'Types.xsd', 'ST'),
                                         ('money6', 'Types.xsd', 'ST'),
                                         ('lotItemQtyType', 'Types.xsd', 'ST'),
                                         ('ogrnType', 'Types.xsd', 'ST'),
                                         ('innovVolumeChecked',
                                          'Types.xsd',
                                          'ST'),
                                         ('orderClauseStatusType',
                                          'Types.xsd',
                                          'ST'),
                                         ('phoneType', 'Types.xsd', 'ST'),
                                         ('purchaseContractStatusType',
                                          'Types.xsd',
                                          'ST'),
                                         ('purchaseContractTypeInfoType',
                                          'Types.xsd',
                                          'ST'),
                                         ('listGWSStatusType',
                                          'Types.xsd',
                                          'ST'),
                                         ('listInnovStatusType',
                                          'Types.xsd',
                                          'ST'),
                                         ('volumePurchaseStatusType',
                                          'Types.xsd',
                                          'ST'),
                                         ('stopCommodityStatus',
                                          'Types.xsd',
                                          'ST'),
                                         ('disagreementsProtocolStatus',
                                          'Types.xsd',
                                          'ST'),
                                         ('purchaseNoticeStatusType',
                                          'Types.xsd',
                                          'ST'),
                                         ('purchaseContractTypeCodeType',
                                          'Types.xsd',
                                          'ST'),
                                         ('purchaseContractAccountStatusType',
                                          'Types.xsd',
                                          'ST'),
                                         ('purchasePlanItemStatusType',
                                          'Types.xsd',
                                          'ST'),
                                         ('purchasePlanStatusType',
                                          'Types.xsd',
                                          'ST'),
                                         ('explanationStatusType',
                                          'Types.xsd',
                                          'ST'),
                                         ('explanationRequestStatusType',
                                          'Types.xsd',
                                          'ST'),
                                         ('purchaseProtocolStatusType',
                                          'Types.xsd',
                                          'ST'),
                                         ('purchaseStageType',
                                          'Types.xsd',
                                          'ST'),
                                         ('registrationNumberType',
                                          'Types.xsd',
                                          'ST'),
                                         ('registrationNumber11Type',
                                          'Types.xsd',
                                          'ST'),
                                         ('registrationNumber14Type',
                                          'Types.xsd',
                                          'ST'),
                                         ('registrationNumber17Type',
                                          'Types.xsd',
                                          'ST'),
                                         ('registrationNumber11-2Type',
                                          'Types.xsd',
                                          'ST'),
                                         ('registrationNumber28Type',
                                          'Types.xsd',
                                          'ST'),
                                         ('resultType', 'Types.xsd', 'ST'),
                                         ('signatureType', 'Types.xsd', 'ST'),
                                         ('violation.levelType',
                                          'Types.xsd',
                                          'ST'),
                                         ('supplierType', 'Types.xsd', 'ST'),
                                         ('winnerIndication',
                                          'Types.xsd',
                                          'ST'),
                                         ('winnerIndication3',
                                          'Types.xsd',
                                          'ST'),
                                         ('acceptedType2', 'Types.xsd', 'ST'),
                                         ('acceptedType', 'Types.xsd', 'ST'),
                                         ('templateExtendPurchaseTypes',
                                          'Types.xsd',
                                          'ST'),
                                         ('extendFieldType', 'Types.xsd', 'ST'),
                                         ('versionType', 'Types.xsd', 'ST'),
                                         ('templateVersionType',
                                          'Types.xsd',
                                          'ST'),
                                         ('templateStatusType',
                                          'Types.xsd',
                                          'ST'),
                                         ('noticeTemplateFieldLevelType',
                                          'Types.xsd',
                                          'ST'),
                                         ('protocolTemplateFieldLevelType',
                                          'Types.xsd',
                                          'ST'),
                                         ('integrCodeType', 'Types.xsd', 'ST'),
                                         ('agencyStatusType',
                                          'Types.xsd',
                                          'ST'),
                                         ('purchaseMethodClassType',
                                          'Types.xsd',
                                          'ST'),
                                         ('lotCancellationType',
                                          'Types.xsd',
                                          'ST'),
                                         ('nonEmptyString', 'Types.xsd', 'ST'),
                                         ('registrationNumber23Type',
                                          'Types.xsd',
                                          'ST'),
                                         ('noticeDeliveryPlaceIndicationType',
                                          'Types.xsd',
                                          'ST'),
                                         ('planInformationType',
                                          'Types.xsd',
                                          'ST'),
                                         ('commissionIsFunctionalCharacteristicsRefineNeededType',
                                          'Types.xsd',
                                          'ST'),
                                         ('statusType', 'Types.xsd', 'ST'),
                                         ('positiveIntegerWithoutSigns',
                                          'Types.xsd',
                                          'ST'),
                                         ('documentUploadBaseData',
                                          'Types.xsd',
                                          'CT'),
                                         ('contactInfoType', 'Types.xsd', 'CT'),
                                         ('cryptoSignsType', 'Types.xsd', 'CT'),
                                         ('currencyType', 'Types.xsd', 'CT'),
                                         ('customerInfoType',
                                          'Types.xsd',
                                          'CT'),
                                         ('supplierInfoType',
                                          'Types.xsd',
                                          'CT'),
                                         ('supplierMainInfoType',
                                          'Types.xsd',
                                          'CT'),
                                         ('nonResidentInfoType',
                                          'Types.xsd',
                                          'CT'),
                                         ('nonResidentLotCustomerInfoType',
                                          'Types.xsd',
                                          'CT'),
                                         ('contractItemType',
                                          'Types.xsd',
                                          'CT'),
                                         ('customerInfo2Type',
                                          'Types.xsd',
                                          'CT'),
                                         ('customerInfo3Type',
                                          'Types.xsd',
                                          'CT'),
                                         ('customerMainInfoType',
                                          'Types.xsd',
                                          'CT'),
                                         ('customerRegistryInfoType',
                                          'Types.xsd',
                                          'CT'),
                                         ('ikulType', 'Types.xsd', 'CT'),
                                         ('grantedUserWoAttorneyType',
                                          'Types.xsd',
                                          'CT'),
                                         ('capitalStockAgencyType',
                                          'Types.xsd',
                                          'CT'),
                                         ('fz223type', 'Types.xsd', 'CT'),
                                         ('timeZoneType', 'Types.xsd', 'CT'),
                                         ('customerMainInfo2Type',
                                          'Types.xsd',
                                          'CT'),
                                         ('customerMainInfo3Type',
                                          'Types.xsd',
                                          'CT'),
                                         ('docDeliveryInfoType',
                                          'Types.xsd',
                                          'CT'),
                                         ('docDeliveryPaymentType',
                                          'Types.xsd',
                                          'CT'),
                                         ('documentListType',
                                          'Types.xsd',
                                          'CT'),
                                         ('documentType', 'Types.xsd', 'CT'),
                                         ('electronicPlaceInfoType',
                                          'Types.xsd',
                                          'CT'),
                                         ('headerType', 'Types.xsd', 'CT'),
                                         ('itemResultListType',
                                          'Types.xsd',
                                          'CT'),
                                         ('itemResultType', 'Types.xsd', 'CT'),
                                         ('itemType', 'Types.xsd', 'CT'),
                                         ('lotItemListType', 'Types.xsd', 'CT'),
                                         ('lotItemType', 'Types.xsd', 'CT'),
                                         ('lotListType', 'Types.xsd', 'CT'),
                                         ('lotISListType', 'Types.xsd', 'CT'),
                                         ('lotType', 'Types.xsd', 'CT'),
                                         ('lotCriteriaListType',
                                          'Types.xsd',
                                          'CT'),
                                         ('lotApplicationsCriteriaListType',
                                          'Types.xsd',
                                          'CT'),
                                         ('lotCriteriaType', 'Types.xsd', 'CT'),
                                         ('lotApplicationsCriteriaType',
                                          'Types.xsd',
                                          'CT'),
                                         ('baseCriteriaType',
                                          'Types.xsd',
                                          'CT'),
                                         ('applicationLotCriteriaListType',
                                          'Types.xsd',
                                          'CT'),
                                         ('applicationLotCriteriaType',
                                          'Types.xsd',
                                          'CT'),
                                         ('lotCancellationInfoType',
                                          'Types.xsd',
                                          'CT'),
                                         ('lotAllocationReferenceType',
                                          'Types.xsd',
                                          'CT'),
                                         ('lotAllocationInfoType',
                                          'Types.xsd',
                                          'CT'),
                                         ('deliveryPlaceType',
                                          'Types.xsd',
                                          'CT'),
                                         ('planInfoType', 'Types.xsd', 'CT'),
                                         ('lotCustomerListType',
                                          'Types.xsd',
                                          'CT'),
                                         ('lotCustomerListShortType',
                                          'Types.xsd',
                                          'CT'),
                                         ('lotCustomerBaseType',
                                          'Types.xsd',
                                          'CT'),
                                         ('lotCustomerType', 'Types.xsd', 'CT'),
                                         ('lotCustomerShortType',
                                          'Types.xsd',
                                          'CT'),
                                         ('lotTypeIS', 'Types.xsd', 'CT'),
                                         ('lotLinkType', 'Types.xsd', 'CT'),
                                         ('okeiProductType', 'Types.xsd', 'CT'),
                                         ('okvedProductType',
                                          'Types.xsd',
                                          'CT'),
                                         ('okved2ProductType',
                                          'Types.xsd',
                                          'CT'),
                                         ('okpdProductType', 'Types.xsd', 'CT'),
                                         ('okpd2ProductType',
                                          'Types.xsd',
                                          'CT'),
                                         ('okdpProductType', 'Types.xsd', 'CT'),
                                         ('eisXmlDoc', 'Types.xsd', 'CT'),
                                         ('packetType', 'Types.xsd', 'CT'),
                                         ('purchaseInfoType',
                                          'Types.xsd',
                                          'CT'),
                                         ('contractInfoType',
                                          'Types.xsd',
                                          'CT'),
                                         ('purchaseInfo2Type',
                                          'Types.xsd',
                                          'CT'),
                                         ('violationListType',
                                          'Types.xsd',
                                          'CT'),
                                         ('violationType', 'Types.xsd', 'CT'),
                                         ('userType', 'Types.xsd', 'CT'),
                                         ('countryType', 'Types.xsd', 'CT'),
                                         ('baseTemplateType',
                                          'Types.xsd',
                                          'CT'),
                                         ('protocolTemplateHideBlocks',
                                          'Types.xsd',
                                          'CT'),
                                         ('protocolTemplateType',
                                          'Types.xsd',
                                          'CT'),
                                         ('orderClauseTemplateType',
                                          'Types.xsd',
                                          'CT'),
                                         ('noticeTemplateType',
                                          'Types.xsd',
                                          'CT'),
                                         ('templateTableType',
                                          'Types.xsd',
                                          'CT'),
                                         ('templateTableColumnType',
                                          'Types.xsd',
                                          'CT'),
                                         ('baseTemplateFieldType',
                                          'Types.xsd',
                                          'CT'),
                                         ('templateFieldPositionType',
                                          'Types.xsd',
                                          'CT'),
                                         ('orderClauseTemplateFieldType',
                                          'Types.xsd',
                                          'CT'),
                                         ('noticeTemplateFieldType',
                                          'Types.xsd',
                                          'CT'),
                                         ('protocolTemplateFieldType',
                                          'Types.xsd',
                                          'CT'),
                                         ('orderClauseTemplateFieldList',
                                          'Types.xsd',
                                          'CT'),
                                         ('noticeTemplateFieldList',
                                          'Types.xsd',
                                          'CT'),
                                         ('protocolTemplateFieldList',
                                          'Types.xsd',
                                          'CT'),
                                         ('noticeExtendFieldValueListType',
                                          'Types.xsd',
                                          'CT'),
                                         ('protocolExtendFieldValueListType',
                                          'Types.xsd',
                                          'CT'),
                                         ('orderClauseExtendFieldValueListType',
                                          'Types.xsd',
                                          'CT'),
                                         ('baseExtendFieldType',
                                          'Types.xsd',
                                          'CT'),
                                         ('baseExtendBlockFieldType',
                                          'Types.xsd',
                                          'CT'),
                                         ('noticeExtendBlockFieldType',
                                          'Types.xsd',
                                          'CT'),
                                         ('protocolExtendBlockFieldType',
                                          'Types.xsd',
                                          'CT'),
                                         ('orderClauseExtendBlockFieldType',
                                          'Types.xsd',
                                          'CT'),
                                         ('fieldValueType', 'Types.xsd', 'CT'),
                                         ('extendTableRowType',
                                          'Types.xsd',
                                          'CT'),
                                         ('extendTableColumnType',
                                          'Types.xsd',
                                          'CT'),
                                         ('tableColumnValueType',
                                          'Types.xsd',
                                          'CT'),
                                         ('protocolRequisitesType',
                                          'Types.xsd',
                                          'CT'),
                                         ('protocolRequisitesType2',
                                          'Types.xsd',
                                          'CT'),
                                         ('extendedAddressType',
                                          'Types.xsd',
                                          'CT'),
                                         ('templateStructureTabType',
                                          'Types.xsd',
                                          'CT'),
                                         ('purchaseCategory',
                                          'Types.xsd',
                                          'CT'),
                                         ('hiddenFzFields', 'Types.xsd', 'CT')]}

__all__ = [
    "SuccessionInfo",
    "SuccessorType",
    "activitiesType",
    "additionalInfoType",
    "applicationLotCriteriaListType",
    "applicationLotCriteriaType",
    "authorityType",
    "baseCriteriaType",
    "baseExtendBlockFieldType",
    "baseExtendFieldType",
    "baseTemplateFieldType",
    "baseTemplateType",
    "bodyType",
    "bodyType32",
    "bodyType33",
    "bodyType34",
    "bodyType35",
    "bodyType36",
    "bodyType37",
    "bodyType38",
    "bodyType39",
    "bodyType40",
    "bodyType41",
    "bodyType42",
    "bodyType43",
    "bodyType44",
    "bodyType45",
    "bodyType46",
    "bodyType47",
    "bodyType48",
    "bodyType49",
    "capitalStockAgencyType",
    "changeRequirementsDocumentUploadType",
    "classificationType",
    "columnsType",
    "confirmation",
    "contactInfoType",
    "contactInfoType24",
    "contractCancellationDocumentUploadType",
    "contractCompletionDocumentUploadType",
    "contractDocumentUploadType",
    "contractInfoType",
    "contractItemType",
    "countryType",
    "cryptoSignsType",
    "currencyType",
    "customerInfo2Type",
    "customerInfo3Type",
    "customerInfoType",
    "customerMainInfo2Type",
    "customerMainInfo3Type",
    "customerMainInfoType",
    "customerRegistryInfoType",
    "deliveryPlaceType",
    "docDeliveryInfoType",
    "docDeliveryPaymentType",
    "documentListType",
    "documentType",
    "documentUpload",
    "documentUploadBaseData",
    "eisXmlDoc",
    "electronicPlaceInfoType",
    "exchangeInfoType",
    "exchangeInfoType92",
    "explanationDocumentUploadType",
    "explanationRequestDocumentUploadType",
    "extendTableColumnType",
    "extendTableRowType",
    "extendedAddressType",
    "fieldValueType",
    "fixedColumnsDataType",
    "fz223type",
    "fz223typeType",
    "fz223typesType",
    "grantedUserWoAttorneyType",
    "groupType",
    "headerType",
    "hiddenFzFields",
    "ikulType",
    "infoType",
    "infosType",
    "itemResultListType",
    "itemResultType",
    "itemType",
    "jointLotDataType",
    "lotAllocationInfoType",
    "lotAllocationReferenceType",
    "lotApplcationsCriteriaType",
    "lotApplicationsCriteriaListType",
    "lotApplicationsCriteriaType",
    "lotCancellationInfoType",
    "lotCriteriaListType",
    "lotCriteriaType",
    "lotCustomerBaseType",
    "lotCustomerDataType",
    "lotCustomerListShortType",
    "lotCustomerListType",
    "lotCustomerShortType",
    "lotCustomerType",
    "lotDataType",
    "lotDataType108",
    "lotISListType",
    "lotItemListType",
    "lotItemType",
    "lotLinkType",
    "lotListType",
    "lotType",
    "lotTypeIS",
    "messageType",
    "messagesType",
    "nonResidentInfoType",
    "nonResidentLotCustomerInfoType",
    "noticeDocumentUploadType",
    "noticeExtendBlockFieldType",
    "noticeExtendFieldValueListType",
    "noticeTemplateFieldList",
    "noticeTemplateFieldType",
    "noticeTemplateType",
    "nsiOkato",
    "nsiOkatoDataType",
    "nsiOkatoItemType",
    "nsiOkdp",
    "nsiOkdpDataType",
    "nsiOkdpItemType",
    "nsiOkei",
    "nsiOkeiDataType",
    "nsiOkeiItemType",
    "nsiOkfs",
    "nsiOkfsDataType",
    "nsiOkfsItemType",
    "nsiOkogu",
    "nsiOkoguDataType",
    "nsiOkoguItemType",
    "nsiOkopf",
    "nsiOkopfDataType",
    "nsiOkopfItemType",
    "nsiOkpd2",
    "nsiOkpd2DataType",
    "nsiOkpd2ItemType",
    "nsiOktmo",
    "nsiOktmoDataType",
    "nsiOktmoItemType",
    "nsiOkv",
    "nsiOkvDataType",
    "nsiOkvItemType",
    "nsiOkved",
    "nsiOkved2",
    "nsiOkved2DataType",
    "nsiOkved2ItemType",
    "nsiOkvedDataType",
    "nsiOkvedItemType",
    "nsiOrderClauseType",
    "nsiOrderClauseTypeDataType",
    "nsiOrderClauseTypeItemType",
    "nsiOrganization",
    "nsiOrganizationDataType",
    "nsiOrganizationItemType",
    "nsiProtocolType",
    "nsiProtocolTypeDataType",
    "nsiProtocolTypeItemType",
    "nsiPurchaseMethod",
    "nsiPurchaseMethodDataType",
    "nsiPurchaseMethodItemType",
    "nsiType",
    "nsiType124",
    "okdpProductType",
    "okeiProductType",
    "okpd2ProductType",
    "okpdProductType",
    "okved2ProductType",
    "okved2Type",
    "okvedProductType",
    "okvedType",
    "orderClauseDocumentUploadType",
    "orderClauseExtendBlockFieldType",
    "orderClauseExtendFieldValueListType",
    "orderClauseTemplateFieldList",
    "orderClauseTemplateFieldType",
    "orderClauseTemplateType",
    "packetType",
    "phaseTransition",
    "phaseTransitionsListType",
    "placerType",
    "planInfoType",
    "ppoType",
    "prevDocumentType",
    "processingInfoRequest",
    "processingInfoResponse",
    "protocolDocumentUploadType",
    "protocolExtendBlockFieldType",
    "protocolExtendFieldValueListType",
    "protocolListType",
    "protocolRequisitesType",
    "protocolRequisitesType2",
    "protocolTemplateFieldList",
    "protocolTemplateFieldType",
    "protocolTemplateHideBlocks",
    "protocolTemplateType",
    "purchaseCategory",
    "purchaseContractAccountDocumentUploadType",
    "purchaseContractDocumentUploadType",
    "purchaseInfo2Type",
    "purchaseInfoType",
    "purchasePhase",
    "purchasePhaseListType",
    "purchasePlanDocumentUploadType",
    "purchasePlanProjectDocumentUploadType",
    "purchaseProtocol",
    "purchaseRejectionDocumentUploadType",
    "rowsType",
    "sectionType127",
    "sectionType4",
    "signatureType50",
    "supplierInfoType",
    "supplierMainInfoType",
    "tableColumnValueType",
    "tableType",
    "templateFieldPositionType",
    "templateStructureTabType",
    "templateTableColumnType",
    "templateTableType",
    "templatesType",
    "templatesType27",
    "templatesType29",
    "timeZoneType",
    "timeZoneType22",
    "userType",
    "violationListType",
    "violationType"
]

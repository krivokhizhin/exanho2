#!/usr/bin/env python
# -*- coding: utf-8 -*-

#
# Generated Mon Jan 11 11:56:25 2021 by generateDS.py version 2.37.11.
# Python 3.8.2 (default, Apr 12 2020, 19:32:31)  [GCC 8.3.0]
#
# Command line options:
#   ('-f', '')
#   ('--one-file-per-xsd', '')
#   ('--output-directory', '/home/kks/git/exanho/exanho/eis44/ds/contracts')
#   ('--use-source-file-as-module-name', '')
#   ('--use-getter-setter', 'none')
#   ('--enable-slots', '')
#   ('--member-specs', 'dict')
#   ('--export', '')
#   ('--silence', '')
#
# Command line arguments:
#   /home/kks/git/exanho/exanho/eis44/ds/contracts/xsd/fcsExport.xsd
#
# Command line:
#   /home/kks/git/exanho/venv/bin/generateDS.py -f --one-file-per-xsd --output-directory="/home/kks/git/exanho/exanho/eis44/ds/contracts" --use-source-file-as-module-name --use-getter-setter="none" --enable-slots --member-specs="dict" --export --silence /home/kks/git/exanho/exanho/eis44/ds/contracts/xsd/fcsExport.xsd
#
# Current working directory (os.getcwd()):
#   exanho
#

import sys
try:
    ModulenotfoundExp_ = ModuleNotFoundError
except NameError:
    ModulenotfoundExp_ = ImportError
from itertools import islice
import os
import re as re_
import base64
import datetime as datetime_
import decimal as decimal_
try:
    from lxml import etree as etree_
except ModulenotfoundExp_ :
    from xml.etree import ElementTree as etree_


Validate_simpletypes_ = True
SaveElementTreeNode = True
if sys.version_info.major == 2:
    BaseStrType_ = basestring
else:
    BaseStrType_ = str


def parsexml_(infile, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        try:
            parser = etree_.ETCompatXMLParser()
        except AttributeError:
            # fallback to xml.etree
            parser = etree_.XMLParser()
    try:
        if isinstance(infile, os.PathLike):
            infile = os.path.join(infile)
    except AttributeError:
        pass
    doc = etree_.parse(infile, parser=parser, **kwargs)
    return doc

def parsexmlstring_(instring, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        try:
            parser = etree_.ETCompatXMLParser()
        except AttributeError:
            # fallback to xml.etree
            parser = etree_.XMLParser()
    element = etree_.fromstring(instring, parser=parser, **kwargs)
    return element

#
# Namespace prefix definition table (and other attributes, too)
#
# The module generatedsnamespaces, if it is importable, must contain
# a dictionary named GeneratedsNamespaceDefs.  This Python dictionary
# should map element type names (strings) to XML schema namespace prefix
# definitions.  The export method for any class for which there is
# a namespace prefix definition, will export that definition in the
# XML representation of that element.  See the export method of
# any generated element type class for an example of the use of this
# table.
# A sample table is:
#
#     # File: generatedsnamespaces.py
#
#     GenerateDSNamespaceDefs = {
#         "ElementtypeA": "http://www.xxx.com/namespaceA",
#         "ElementtypeB": "http://www.xxx.com/namespaceB",
#     }
#
# Additionally, the generatedsnamespaces module can contain a python
# dictionary named GenerateDSNamespaceTypePrefixes that associates element
# types with the namespace prefixes that are to be added to the
# "xsi:type" attribute value.  See the exportAttributes method of
# any generated element type and the generation of "xsi:type" for an
# example of the use of this table.
# An example table:
#
#     # File: generatedsnamespaces.py
#
#     GenerateDSNamespaceTypePrefixes = {
#         "ElementtypeC": "aaa:",
#         "ElementtypeD": "bbb:",
#     }
#

try:
    from generatedsnamespaces import GenerateDSNamespaceDefs as GenerateDSNamespaceDefs_
except ModulenotfoundExp_ :
    GenerateDSNamespaceDefs_ = {}
try:
    from generatedsnamespaces import GenerateDSNamespaceTypePrefixes as GenerateDSNamespaceTypePrefixes_
except ModulenotfoundExp_ :
    GenerateDSNamespaceTypePrefixes_ = {}

#
# You can replace the following class definition by defining an
# importable module named "generatedscollector" containing a class
# named "GdsCollector".  See the default class definition below for
# clues about the possible content of that class.
#
try:
    from generatedscollector import GdsCollector as GdsCollector_
except ModulenotfoundExp_ :

    class GdsCollector_(object):

        def __init__(self, messages=None):
            if messages is None:
                self.messages = []
            else:
                self.messages = messages

        def add_message(self, msg):
            self.messages.append(msg)

        def get_messages(self):
            return self.messages

        def clear_messages(self):
            self.messages = []

        def print_messages(self):
            for msg in self.messages:
                print("Warning: {}".format(msg))

        def write_messages(self, outstream):
            for msg in self.messages:
                outstream.write("Warning: {}\n".format(msg))


#
# The super-class for enum types
#

try:
    from enum import Enum
except ModulenotfoundExp_ :
    Enum = object

#
# The root super-class for element type classes
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from ..generatedssuper import GeneratedsSuper
except ModulenotfoundExp_ as exp:
    
    class GeneratedsSuper(object):
        __slots__ = ['gds_collector_', 'gds_elementtree_node_', 'original_tagname_', 'parent_object_', 'ns_prefix_']
        __hash__ = object.__hash__
        tzoff_pattern = re_.compile(r'(\+|-)((0\d|1[0-3]):[0-5]\d|14:00)$')
        class _FixedOffsetTZ(datetime_.tzinfo):
            def __init__(self, offset, name):
                self.__offset = datetime_.timedelta(minutes=offset)
                self.__name = name
            def utcoffset(self, dt):
                return self.__offset
            def tzname(self, dt):
                return self.__name
            def dst(self, dt):
                return None
        @staticmethod
        def gds_subclass_slots(member_data_items):
            slots = []
            for member in member_data_items:
                slots.append(member)
                slots.append("%s_nsprefix_" % member)
            return slots
        def gds_format_string(self, input_data, input_name=''):
            return input_data
        def gds_parse_string(self, input_data, node=None, input_name=''):
            return input_data
        def gds_validate_string(self, input_data, node=None, input_name=''):
            if not input_data:
                return ''
            else:
                return input_data
        def gds_format_base64(self, input_data, input_name=''):
            return base64.b64encode(input_data)
        def gds_validate_base64(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer(self, input_data, input_name=''):
            return '%d' % input_data
        def gds_parse_integer(self, input_data, node=None, input_name=''):
            try:
                ival = int(input_data)
            except (TypeError, ValueError) as exp:
                raise_parse_error(node, 'Requires integer value: %s' % exp)
            return ival
        def gds_validate_integer(self, input_data, node=None, input_name=''):
            try:
                value = int(input_data)
            except (TypeError, ValueError):
                raise_parse_error(node, 'Requires integer value')
            return value
        def gds_format_integer_list(self, input_data, input_name=''):
            if len(input_data) > 0 and not isinstance(input_data[0], BaseStrType_):
                input_data = [str(s) for s in input_data]
            return '%s' % ' '.join(input_data)
        def gds_validate_integer_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    int(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of integer values')
            return values
        def gds_format_float(self, input_data, input_name=''):
            return ('%.15f' % input_data).rstrip('0')
        def gds_parse_float(self, input_data, node=None, input_name=''):
            try:
                fval_ = float(input_data)
            except (TypeError, ValueError) as exp:
                raise_parse_error(node, 'Requires float or double value: %s' % exp)
            return fval_
        def gds_validate_float(self, input_data, node=None, input_name=''):
            try:
                value = float(input_data)
            except (TypeError, ValueError):
                raise_parse_error(node, 'Requires float value')
            return value
        def gds_format_float_list(self, input_data, input_name=''):
            if len(input_data) > 0 and not isinstance(input_data[0], BaseStrType_):
                input_data = [str(s) for s in input_data]
            return '%s' % ' '.join(input_data)
        def gds_validate_float_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of float values')
            return values
        def gds_format_decimal(self, input_data, input_name=''):
            return_value = '%s' % input_data
            if '.' in return_value:
                return_value = return_value.rstrip('0')
                if return_value.endswith('.'):
                    return_value = return_value.rstrip('.')
            return return_value
        def gds_parse_decimal(self, input_data, node=None, input_name=''):
            try:
                decimal_value = decimal_.Decimal(input_data)
            except (TypeError, ValueError):
                raise_parse_error(node, 'Requires decimal value')
            return decimal_value
        def gds_validate_decimal(self, input_data, node=None, input_name=''):
            try:
                value = decimal_.Decimal(input_data)
            except (TypeError, ValueError):
                raise_parse_error(node, 'Requires decimal value')
            return value
        def gds_format_decimal_list(self, input_data, input_name=''):
            if len(input_data) > 0 and not isinstance(input_data[0], BaseStrType_):
                input_data = [str(s) for s in input_data]
            return ' '.join([self.gds_format_decimal(item) for item in input_data])
        def gds_validate_decimal_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    decimal_.Decimal(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of decimal values')
            return values
        def gds_format_double(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_parse_double(self, input_data, node=None, input_name=''):
            try:
                fval_ = float(input_data)
            except (TypeError, ValueError) as exp:
                raise_parse_error(node, 'Requires double or float value: %s' % exp)
            return fval_
        def gds_validate_double(self, input_data, node=None, input_name=''):
            try:
                value = float(input_data)
            except (TypeError, ValueError):
                raise_parse_error(node, 'Requires double or float value')
            return value
        def gds_format_double_list(self, input_data, input_name=''):
            if len(input_data) > 0 and not isinstance(input_data[0], BaseStrType_):
                input_data = [str(s) for s in input_data]
            return '%s' % ' '.join(input_data)
        def gds_validate_double_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(
                        node, 'Requires sequence of double or float values')
            return values
        def gds_format_boolean(self, input_data, input_name=''):
            return ('%s' % input_data).lower()
        def gds_parse_boolean(self, input_data, node=None, input_name=''):
            if input_data in ('true', '1'):
                bval = True
            elif input_data in ('false', '0'):
                bval = False
            else:
                raise_parse_error(node, 'Requires boolean value')
            return bval
        def gds_validate_boolean(self, input_data, node=None, input_name=''):
            if input_data not in (True, 1, False, 0, ):
                raise_parse_error(
                    node,
                    'Requires boolean value '
                    '(one of True, 1, False, 0)')
            return input_data
        def gds_format_boolean_list(self, input_data, input_name=''):
            if len(input_data) > 0 and not isinstance(input_data[0], BaseStrType_):
                input_data = [str(s) for s in input_data]
            return '%s' % ' '.join(input_data)
        def gds_validate_boolean_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                if value not in (True, 1, False, 0, ):
                    raise_parse_error(
                        node,
                        'Requires sequence of boolean values '
                        '(one of True, 1, False, 0)')
            return values
        def gds_validate_datetime(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_datetime(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d.%s' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        @classmethod
        def gds_parse_datetime(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            time_parts = input_data.split('.')
            if len(time_parts) > 1:
                micro_seconds = int(float('0.' + time_parts[1]) * 1000000)
                input_data = '%s.%s' % (
                    time_parts[0], "{}".format(micro_seconds).rjust(6, "0"), )
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt
        def gds_validate_date(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_date(self, input_data, input_name=''):
            _svalue = '%04d-%02d-%02d' % (
                input_data.year,
                input_data.month,
                input_data.day,
            )
            try:
                if input_data.tzinfo is not None:
                    tzoff = input_data.tzinfo.utcoffset(input_data)
                    if tzoff is not None:
                        total_seconds = tzoff.seconds + (86400 * tzoff.days)
                        if total_seconds == 0:
                            _svalue += 'Z'
                        else:
                            if total_seconds < 0:
                                _svalue += '-'
                                total_seconds *= -1
                            else:
                                _svalue += '+'
                            hours = total_seconds // 3600
                            minutes = (total_seconds - (hours * 3600)) // 60
                            _svalue += '{0:02d}:{1:02d}'.format(
                                hours, minutes)
            except AttributeError:
                pass
            return _svalue
        @classmethod
        def gds_parse_date(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            dt = datetime_.datetime.strptime(input_data, '%Y-%m-%d')
            dt = dt.replace(tzinfo=tz)
            return dt.date()
        def gds_validate_time(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_time(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%02d:%02d:%02d' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%02d:%02d:%02d.%s' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        def gds_validate_simple_patterns(self, patterns, target):
            # pat is a list of lists of strings/patterns.
            # The target value must match at least one of the patterns
            # in order for the test to succeed.
            found1 = True
            for patterns1 in patterns:
                found2 = False
                for patterns2 in patterns1:
                    mo = re_.search(patterns2, target)
                    if mo is not None and len(mo.group(0)) == len(target):
                        found2 = True
                        break
                if not found2:
                    found1 = False
                    break
            return found1
        @classmethod
        def gds_parse_time(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            if len(input_data.split('.')) > 1:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt.time()
        def gds_check_cardinality_(
                self, value, input_name,
                min_occurs=0, max_occurs=1, required=None):
            if value is None:
                length = 0
            elif isinstance(value, list):
                length = len(value)
            else:
                length = 1
            if required is not None :
                if required and length < 1:
                    self.gds_collector_.add_message(
                        "Required value {}{} is missing".format(
                            input_name, self.gds_get_node_lineno_()))
            if length < min_occurs:
                self.gds_collector_.add_message(
                    "Number of values for {}{} is below "
                    "the minimum allowed, "
                    "expected at least {}, found {}".format(
                        input_name, self.gds_get_node_lineno_(),
                        min_occurs, length))
            elif length > max_occurs:
                self.gds_collector_.add_message(
                    "Number of values for {}{} is above "
                    "the maximum allowed, "
                    "expected at most {}, found {}".format(
                        input_name, self.gds_get_node_lineno_(),
                        max_occurs, length))
        def gds_validate_builtin_ST_(
                self, validator, value, input_name,
                min_occurs=None, max_occurs=None, required=None):
            if value is not None:
                try:
                    validator(value, input_name=input_name)
                except GDSParseError as parse_error:
                    self.gds_collector_.add_message(str(parse_error))
        def gds_validate_defined_ST_(
                self, validator, value, input_name,
                min_occurs=None, max_occurs=None, required=None):
            if value is not None:
                try:
                    validator(value)
                except GDSParseError as parse_error:
                    self.gds_collector_.add_message(str(parse_error))
        def gds_str_lower(self, instring):
            return instring.lower()
        def get_path_(self, node):
            path_list = []
            self.get_path_list_(node, path_list)
            path_list.reverse()
            path = '/'.join(path_list)
            return path
        Tag_strip_pattern_ = re_.compile(r'\{.*\}')
        def get_path_list_(self, node, path_list):
            if node is None:
                return
            tag = GeneratedsSuper.Tag_strip_pattern_.sub('', node.tag)
            if tag:
                path_list.append(tag)
            self.get_path_list_(node.getparent(), path_list)
        def get_class_obj_(self, node, default_class=None):
            class_obj1 = default_class
            if 'xsi' in node.nsmap:
                classname = node.get('{%s}type' % node.nsmap['xsi'])
                if classname is not None:
                    names = classname.split(':')
                    if len(names) == 2:
                        classname = names[1]
                    class_obj2 = globals().get(classname)
                    if class_obj2 is not None:
                        class_obj1 = class_obj2
            return class_obj1
        def gds_build_any(self, node, type_name=None):
            # provide default value in case option --disable-xml is used.
            content = ""
            content = etree_.tostring(node, encoding="unicode")
            return content
        @classmethod
        def gds_reverse_node_mapping(cls, mapping):
            return dict(((v, k) for k, v in mapping.items()))
        @staticmethod
        def gds_encode(instring):
            if sys.version_info.major == 2:
                if ExternalEncoding:
                    encoding = ExternalEncoding
                else:
                    encoding = 'utf-8'
                return instring.encode(encoding)
            else:
                return instring
        @staticmethod
        def convert_unicode(instring):
            if isinstance(instring, str):
                result = quote_xml(instring)
            elif sys.version_info.major == 2 and isinstance(instring, unicode):
                result = quote_xml(instring).encode('utf8')
            else:
                result = GeneratedsSuper.gds_encode(str(instring))
            return result
        def __eq__(self, other):
            if type(self) != type(other):
                return False
            mro = self.__class__.__mro__
            return all(
                getattr(self, attribute) == getattr(other, attribute)
                for cls in islice(mro, 0, len(mro) - 2)
                for attribute in cls.member_data_items_)
        def __ne__(self, other):
            return not self.__eq__(other)
        # Django ETL transform hooks.
        def gds_djo_etl_transform(self):
            pass
        def gds_djo_etl_transform_db_obj(self, dbobj):
            pass
        # SQLAlchemy ETL transform hooks.
        def gds_sqa_etl_transform(self):
            return 0, None
        def gds_sqa_etl_transform_db_obj(self, dbobj):
            pass
        def gds_get_node_lineno_(self):
            if (hasattr(self, "gds_elementtree_node_") and
                    self.gds_elementtree_node_ is not None):
                return ' near line {}'.format(
                    self.gds_elementtree_node_.sourceline)
            else:
                return ""
    
    
    def getSubclassFromModule_(module, class_):
        '''Get the subclass of a class from a specific module.'''
        name = class_.__name__ + 'Sub'
        if hasattr(module, name):
            return getattr(module, name)
        else:
            return None


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = ''
# Set this to false in order to deactivate during export, the use of
# name space prefixes captured from the input document.
UseCapturedNS_ = True
CapturedNsmap_ = {}
Tag_pattern_ = re_.compile(r'({.*})?(.*)')
String_cleanup_pat_ = re_.compile(r"[\n\r\s]+")
Namespace_extract_pat_ = re_.compile(r'{(.*)}(.*)')
CDATA_pattern_ = re_.compile(r"<!\[CDATA\[.*?\]\]>", re_.DOTALL)

# Change this to redirect the generated superclass module to use a
# specific subclass module.
CurrentSubclassModule_ = None

#
# Support/utility functions.
#


def showIndent(outfile, level, pretty_print=True):
    if pretty_print:
        for idx in range(level):
            outfile.write('    ')


def quote_xml(inStr):
    "Escape markup chars, but do not modify CDATA sections."
    if not inStr:
        return ''
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s2 = ''
    pos = 0
    matchobjects = CDATA_pattern_.finditer(s1)
    for mo in matchobjects:
        s3 = s1[pos:mo.start()]
        s2 += quote_xml_aux(s3)
        s2 += s1[mo.start():mo.end()]
        pos = mo.end()
    s3 = s1[pos:]
    s2 += quote_xml_aux(s3)
    return s2


def quote_xml_aux(inStr):
    s1 = inStr.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1


def quote_attrib(inStr):
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1


def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1


def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text


def find_attr_value_(attr_name, node):
    attrs = node.attrib
    attr_parts = attr_name.split(':')
    value = None
    if len(attr_parts) == 1:
        value = attrs.get(attr_name)
    elif len(attr_parts) == 2:
        prefix, name = attr_parts
        namespace = node.nsmap.get(prefix)
        if namespace is not None:
            value = attrs.get('{%s}%s' % (namespace, name, ))
    return value


def encode_str_2_3(instr):
    return instr


class GDSParseError(Exception):
    pass


def raise_parse_error(node, msg):
    if node is not None:
        msg = '%s (element %s/line %d)' % (msg, node.tag, node.sourceline, )
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    TypeBase64 = 8
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace,
               pretty_print=True):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(
                outfile, level, namespace, name_=name,
                pretty_print=pretty_print)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeBase64:
            outfile.write('<%s>%s</%s>' % (
                self.name,
                base64.b64encode(self.value),
                self.name))
    def to_etree(self, element, mapping_=None, nsmap_=None):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                if len(element) > 0:
                    if element[-1].tail is None:
                        element[-1].tail = self.value
                    else:
                        element[-1].tail += self.value
                else:
                    if element.text is None:
                        element.text = self.value
                    else:
                        element.text += self.value
        elif self.category == MixedContainer.CategorySimple:
            subelement = etree_.SubElement(
                element, '%s' % self.name)
            subelement.text = self.to_etree_simple()
        else:    # category == MixedContainer.CategoryComplex
            self.value.to_etree(element)
    def to_etree_simple(self, mapping_=None, nsmap_=None):
        if self.content_type == MixedContainer.TypeString:
            text = self.value
        elif (self.content_type == MixedContainer.TypeInteger or
                self.content_type == MixedContainer.TypeBoolean):
            text = '%d' % self.value
        elif (self.content_type == MixedContainer.TypeFloat or
                self.content_type == MixedContainer.TypeDecimal):
            text = '%f' % self.value
        elif self.content_type == MixedContainer.TypeDouble:
            text = '%g' % self.value
        elif self.content_type == MixedContainer.TypeBase64:
            text = '%s' % base64.b64encode(self.value)
        return text
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type,
                    self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type,
                    self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s",\n' % (
                    self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0,
            optional=0, child_attrs=None, choice=None):
        self.name = name
        self.data_type = data_type
        self.container = container
        self.child_attrs = child_attrs
        self.choice = choice
        self.optional = optional
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container
    def set_child_attrs(self, child_attrs): self.child_attrs = child_attrs
    def get_child_attrs(self): return self.child_attrs
    def set_choice(self, choice): self.choice = choice
    def get_choice(self): return self.choice
    def set_optional(self, optional): self.optional = optional
    def get_optional(self): return self.optional


def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)

#
# Data representation classes.
#

from .BaseTypes import *
from .CommonTypes import *

class corr_supplierLegalEntityRF(GeneratedsSuper):
    """Юридическое лицо РФ"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'legalForm': MemberSpec_('legalForm', 'zfcs_okopfRef', 0, 0, {'name': 'legalForm', 'type': 'zfcs_okopfRef'}, None),
        'fullName': MemberSpec_('fullName', ['zfcs_longTextMinType', 'xs:string'], 0, 0, {'name': 'fullName', 'type': 'xs:string'}, None),
        'shortName': MemberSpec_('shortName', ['zfcs_longTextMinType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'shortName', 'type': 'xs:string'}, None),
        'firmName': MemberSpec_('firmName', ['zfcs_longTextMinType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'firmName', 'type': 'xs:string'}, None),
        'status': MemberSpec_('status', ['zfcs_participantStatusContract2015Type', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'status', 'type': 'xs:string'}, None),
        'ERSMSPInclusionDate': MemberSpec_('ERSMSPInclusionDate', 'xs:date', 0, 1, {'minOccurs': '0', 'name': 'ERSMSPInclusionDate', 'type': 'xs:date'}, None),
        'contractPrice': MemberSpec_('contractPrice', ['moneyPositiveType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'contractPrice', 'type': 'xs:string'}, None),
        'OKPO': MemberSpec_('OKPO', ['zfcs_okpoType', 'xs:string'], 0, 0, {'name': 'OKPO', 'type': 'xs:string'}, None),
        'INN': MemberSpec_('INN', ['innType', 'xs:string'], 0, 0, {'name': 'INN', 'type': 'xs:string'}, None),
        'KPP': MemberSpec_('KPP', ['kppType', 'xs:string'], 0, 0, {'name': 'KPP', 'type': 'xs:string'}, None),
        'registrationDate': MemberSpec_('registrationDate', 'xs:date', 0, 0, {'name': 'registrationDate', 'type': 'xs:date'}, None),
        'OKTMO': MemberSpec_('OKTMO', 'zfcs_OKTMORef', 0, 0, {'name': 'OKTMO', 'type': 'zfcs_OKTMORef'}, None),
        'personalAccount': MemberSpec_('personalAccount', ['zfcs_personalAccountType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'personalAccount', 'type': 'xs:string'}, None),
        'address': MemberSpec_('address', ['zfcs_contract2015AddressType', 'xs:string'], 0, 0, {'name': 'address', 'type': 'xs:string'}, None),
        'postAdressInfo': MemberSpec_('postAdressInfo', 'postAdressInfo', 0, 1, {'minOccurs': '0', 'name': 'postAdressInfo', 'type': 'postAdressInfo'}, None),
        'postAddress': MemberSpec_('postAddress', ['zfcs_contract2015AddressType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'postAddress', 'type': 'xs:string'}, None),
        'contactInfo': MemberSpec_('contactInfo', 'contactInfo', 0, 1, {'minOccurs': '0', 'name': 'contactInfo', 'type': 'zfcs_contactPersonType'}, None),
        'contactEMail': MemberSpec_('contactEMail', ['eMailType', 'xs:string'], 0, 0, {'name': 'contactEMail', 'type': 'xs:string'}, None),
        'contactPhone': MemberSpec_('contactPhone', ['phoneType', 'xs:string'], 0, 0, {'name': 'contactPhone', 'type': 'xs:string'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, legalForm=None, fullName=None, shortName=None, firmName=None, status=None, ERSMSPInclusionDate=None, contractPrice=None, OKPO=None, INN=None, KPP=None, registrationDate=None, OKTMO=None, personalAccount=None, address=None, postAdressInfo=None, postAddress=None, contactInfo=None, contactEMail=None, contactPhone=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.legalForm = legalForm
        self.legalForm_nsprefix_ = None
        self.fullName = fullName
        self.validate_zfcs_longTextMinType(self.fullName)
        self.fullName_nsprefix_ = None
        self.shortName = shortName
        self.validate_zfcs_longTextMinType(self.shortName)
        self.shortName_nsprefix_ = None
        self.firmName = firmName
        self.validate_zfcs_longTextMinType(self.firmName)
        self.firmName_nsprefix_ = None
        self.status = status
        self.validate_zfcs_participantStatusContract2015Type(self.status)
        self.status_nsprefix_ = None
        if isinstance(ERSMSPInclusionDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(ERSMSPInclusionDate, '%Y-%m-%d').date()
        else:
            initvalue_ = ERSMSPInclusionDate
        self.ERSMSPInclusionDate = initvalue_
        self.ERSMSPInclusionDate_nsprefix_ = None
        self.contractPrice = contractPrice
        self.validate_moneyPositiveType(self.contractPrice)
        self.contractPrice_nsprefix_ = None
        self.OKPO = OKPO
        self.validate_zfcs_okpoType(self.OKPO)
        self.OKPO_nsprefix_ = None
        self.INN = INN
        self.validate_innType(self.INN)
        self.INN_nsprefix_ = None
        self.KPP = KPP
        self.validate_kppType(self.KPP)
        self.KPP_nsprefix_ = None
        if isinstance(registrationDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(registrationDate, '%Y-%m-%d').date()
        else:
            initvalue_ = registrationDate
        self.registrationDate = initvalue_
        self.registrationDate_nsprefix_ = None
        self.OKTMO = OKTMO
        self.OKTMO_nsprefix_ = None
        self.personalAccount = personalAccount
        self.validate_zfcs_personalAccountType(self.personalAccount)
        self.personalAccount_nsprefix_ = None
        self.address = address
        self.validate_zfcs_contract2015AddressType(self.address)
        self.address_nsprefix_ = None
        self.postAdressInfo = postAdressInfo
        self.postAdressInfo_nsprefix_ = None
        self.postAddress = postAddress
        self.validate_zfcs_contract2015AddressType(self.postAddress)
        self.postAddress_nsprefix_ = None
        self.contactInfo = contactInfo
        self.contactInfo_nsprefix_ = None
        self.contactEMail = contactEMail
        self.validate_eMailType(self.contactEMail)
        self.contactEMail_nsprefix_ = None
        self.contactPhone = contactPhone
        self.validate_phoneType(self.contactPhone)
        self.contactPhone_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, corr_supplierLegalEntityRF)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if corr_supplierLegalEntityRF.subclass:
            return corr_supplierLegalEntityRF.subclass(*args_, **kwargs_)
        else:
            return corr_supplierLegalEntityRF(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_zfcs_longTextMinType(self, value):
        result = True
        # Validate type zfcs_longTextMinType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 2000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on zfcs_longTextMinType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on zfcs_longTextMinType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_zfcs_participantStatusContract2015Type(self, value):
        result = True
        # Validate type zfcs_participantStatusContract2015Type, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['10', '20', '30', '31', '40', '41']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on zfcs_participantStatusContract2015Type' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_moneyPositiveType(self, value):
        result = True
        # Validate type moneyPositiveType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 21:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on moneyPositiveType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on moneyPositiveType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_moneyPositiveType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_moneyPositiveType_patterns_, ))
                result = False
        return result
    validate_moneyPositiveType_patterns_ = [['^(\\d+(\\.\\d{1,2})?)$']]
    def validate_zfcs_okpoType(self, value):
        result = True
        # Validate type zfcs_okpoType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 10:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on zfcs_okpoType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on zfcs_okpoType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_innType(self, value):
        result = True
        # Validate type innType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 12:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on innType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_innType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_innType_patterns_, ))
                result = False
        return result
    validate_innType_patterns_ = [['^(\\d{1,12})$']]
    def validate_kppType(self, value):
        result = True
        # Validate type kppType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) != 9:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd length restriction on kppType' % {"value": encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_zfcs_personalAccountType(self, value):
        result = True
        # Validate type zfcs_personalAccountType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) != 11:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd length restriction on zfcs_personalAccountType' % {"value": encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_zfcs_contract2015AddressType(self, value):
        result = True
        # Validate type zfcs_contract2015AddressType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on zfcs_contract2015AddressType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on zfcs_contract2015AddressType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_eMailType(self, value):
        result = True
        # Validate type eMailType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 256:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on eMailType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on eMailType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_phoneType(self, value):
        result = True
        # Validate type phoneType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 30:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on phoneType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on phoneType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.legalForm is not None or
            self.fullName is not None or
            self.shortName is not None or
            self.firmName is not None or
            self.status is not None or
            self.ERSMSPInclusionDate is not None or
            self.contractPrice is not None or
            self.OKPO is not None or
            self.INN is not None or
            self.KPP is not None or
            self.registrationDate is not None or
            self.OKTMO is not None or
            self.personalAccount is not None or
            self.address is not None or
            self.postAdressInfo is not None or
            self.postAddress is not None or
            self.contactInfo is not None or
            self.contactEMail is not None or
            self.contactPhone is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'legalForm':
            obj_ = zfcs_okopfRef.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.legalForm = obj_
            obj_.original_tagname_ = 'legalForm'
        elif nodeName_ == 'fullName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'fullName')
            value_ = self.gds_validate_string(value_, node, 'fullName')
            self.fullName = value_
            self.fullName_nsprefix_ = child_.prefix
            # validate type zfcs_longTextMinType
            self.validate_zfcs_longTextMinType(self.fullName)
        elif nodeName_ == 'shortName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'shortName')
            value_ = self.gds_validate_string(value_, node, 'shortName')
            self.shortName = value_
            self.shortName_nsprefix_ = child_.prefix
            # validate type zfcs_longTextMinType
            self.validate_zfcs_longTextMinType(self.shortName)
        elif nodeName_ == 'firmName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'firmName')
            value_ = self.gds_validate_string(value_, node, 'firmName')
            self.firmName = value_
            self.firmName_nsprefix_ = child_.prefix
            # validate type zfcs_longTextMinType
            self.validate_zfcs_longTextMinType(self.firmName)
        elif nodeName_ == 'status':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'status')
            value_ = self.gds_validate_string(value_, node, 'status')
            self.status = value_
            self.status_nsprefix_ = child_.prefix
            # validate type zfcs_participantStatusContract2015Type
            self.validate_zfcs_participantStatusContract2015Type(self.status)
        elif nodeName_ == 'ERSMSPInclusionDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.ERSMSPInclusionDate = dval_
            self.ERSMSPInclusionDate_nsprefix_ = child_.prefix
        elif nodeName_ == 'contractPrice':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'contractPrice')
            value_ = self.gds_validate_string(value_, node, 'contractPrice')
            self.contractPrice = value_
            self.contractPrice_nsprefix_ = child_.prefix
            # validate type moneyPositiveType
            self.validate_moneyPositiveType(self.contractPrice)
        elif nodeName_ == 'OKPO':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'OKPO')
            value_ = self.gds_validate_string(value_, node, 'OKPO')
            self.OKPO = value_
            self.OKPO_nsprefix_ = child_.prefix
            # validate type zfcs_okpoType
            self.validate_zfcs_okpoType(self.OKPO)
        elif nodeName_ == 'INN':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'INN')
            value_ = self.gds_validate_string(value_, node, 'INN')
            self.INN = value_
            self.INN_nsprefix_ = child_.prefix
            # validate type innType
            self.validate_innType(self.INN)
        elif nodeName_ == 'KPP':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'KPP')
            value_ = self.gds_validate_string(value_, node, 'KPP')
            self.KPP = value_
            self.KPP_nsprefix_ = child_.prefix
            # validate type kppType
            self.validate_kppType(self.KPP)
        elif nodeName_ == 'registrationDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.registrationDate = dval_
            self.registrationDate_nsprefix_ = child_.prefix
        elif nodeName_ == 'OKTMO':
            obj_ = zfcs_OKTMORef.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.OKTMO = obj_
            obj_.original_tagname_ = 'OKTMO'
        elif nodeName_ == 'personalAccount':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'personalAccount')
            value_ = self.gds_validate_string(value_, node, 'personalAccount')
            self.personalAccount = value_
            self.personalAccount_nsprefix_ = child_.prefix
            # validate type zfcs_personalAccountType
            self.validate_zfcs_personalAccountType(self.personalAccount)
        elif nodeName_ == 'address':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'address')
            value_ = self.gds_validate_string(value_, node, 'address')
            self.address = value_
            self.address_nsprefix_ = child_.prefix
            # validate type zfcs_contract2015AddressType
            self.validate_zfcs_contract2015AddressType(self.address)
        elif nodeName_ == 'postAdressInfo':
            obj_ = postAdressInfo.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.postAdressInfo = obj_
            obj_.original_tagname_ = 'postAdressInfo'
        elif nodeName_ == 'postAddress':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'postAddress')
            value_ = self.gds_validate_string(value_, node, 'postAddress')
            self.postAddress = value_
            self.postAddress_nsprefix_ = child_.prefix
            # validate type zfcs_contract2015AddressType
            self.validate_zfcs_contract2015AddressType(self.postAddress)
        elif nodeName_ == 'contactInfo':
            obj_ = zfcs_contactPersonType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.contactInfo = obj_
            obj_.original_tagname_ = 'contactInfo'
        elif nodeName_ == 'contactEMail':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'contactEMail')
            value_ = self.gds_validate_string(value_, node, 'contactEMail')
            self.contactEMail = value_
            self.contactEMail_nsprefix_ = child_.prefix
            # validate type eMailType
            self.validate_eMailType(self.contactEMail)
        elif nodeName_ == 'contactPhone':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'contactPhone')
            value_ = self.gds_validate_string(value_, node, 'contactPhone')
            self.contactPhone = value_
            self.contactPhone_nsprefix_ = child_.prefix
            # validate type phoneType
            self.validate_phoneType(self.contactPhone)
# end class corr_supplierLegalEntityRF


class postAdressInfo(GeneratedsSuper):
    """Почтовый адрес.
    При приеме контролируется, что поля mailFacilityName и postBoxNumber
    заполняются/не заполняются парой"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'mailingAdress': MemberSpec_('mailingAdress', ['zfcs_contract2015AddressType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'mailingAdress', 'type': 'xs:string'}, None),
        'mailFacilityName': MemberSpec_('mailFacilityName', ['zfcs_contract2015AddressType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'mailFacilityName', 'type': 'xs:string'}, None),
        'postBoxNumber': MemberSpec_('postBoxNumber', ['zfcs_contract2015AddressType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'postBoxNumber', 'type': 'xs:string'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, mailingAdress=None, mailFacilityName=None, postBoxNumber=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.mailingAdress = mailingAdress
        self.validate_zfcs_contract2015AddressType(self.mailingAdress)
        self.mailingAdress_nsprefix_ = None
        self.mailFacilityName = mailFacilityName
        self.validate_zfcs_contract2015AddressType(self.mailFacilityName)
        self.mailFacilityName_nsprefix_ = None
        self.postBoxNumber = postBoxNumber
        self.validate_zfcs_contract2015AddressType(self.postBoxNumber)
        self.postBoxNumber_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, postAdressInfo)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if postAdressInfo.subclass:
            return postAdressInfo.subclass(*args_, **kwargs_)
        else:
            return postAdressInfo(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_zfcs_contract2015AddressType(self, value):
        result = True
        # Validate type zfcs_contract2015AddressType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on zfcs_contract2015AddressType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on zfcs_contract2015AddressType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.mailingAdress is not None or
            self.mailFacilityName is not None or
            self.postBoxNumber is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'mailingAdress':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'mailingAdress')
            value_ = self.gds_validate_string(value_, node, 'mailingAdress')
            self.mailingAdress = value_
            self.mailingAdress_nsprefix_ = child_.prefix
            # validate type zfcs_contract2015AddressType
            self.validate_zfcs_contract2015AddressType(self.mailingAdress)
        elif nodeName_ == 'mailFacilityName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'mailFacilityName')
            value_ = self.gds_validate_string(value_, node, 'mailFacilityName')
            self.mailFacilityName = value_
            self.mailFacilityName_nsprefix_ = child_.prefix
            # validate type zfcs_contract2015AddressType
            self.validate_zfcs_contract2015AddressType(self.mailFacilityName)
        elif nodeName_ == 'postBoxNumber':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'postBoxNumber')
            value_ = self.gds_validate_string(value_, node, 'postBoxNumber')
            self.postBoxNumber = value_
            self.postBoxNumber_nsprefix_ = child_.prefix
            # validate type zfcs_contract2015AddressType
            self.validate_zfcs_contract2015AddressType(self.postBoxNumber)
# end class postAdressInfo


class corr_supplierLegalEntityForeignState(GeneratedsSuper):
    """Юридическое лицо иностранного государства"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'fullName': MemberSpec_('fullName', ['zfcs_longTextMinType', 'xs:string'], 0, 0, {'name': 'fullName', 'type': 'xs:string'}, None),
        'shortName': MemberSpec_('shortName', ['zfcs_longTextMinType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'shortName', 'type': 'xs:string'}, None),
        'firmName': MemberSpec_('firmName', ['zfcs_longTextMinType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'firmName', 'type': 'xs:string'}, None),
        'fullNameLat': MemberSpec_('fullNameLat', ['zfcs_longTextMinType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'fullNameLat', 'type': 'xs:string'}, None),
        'status': MemberSpec_('status', ['zfcs_participantStatusContract2015Type', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'status', 'type': 'xs:string'}, None),
        'taxPayerCode': MemberSpec_('taxPayerCode', ['taxPayerCode', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'taxPayerCode', 'type': 'xs:string'}, None),
        'personalAccount': MemberSpec_('personalAccount', ['zfcs_personalAccountType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'personalAccount', 'type': 'xs:string'}, None),
        'registerInRFTaxBodies': MemberSpec_('registerInRFTaxBodies', 'registerInRFTaxBodies', 0, 1, {'minOccurs': '0', 'name': 'registerInRFTaxBodies', 'type': 'registerInRFTaxBodies'}, None),
        'placeOfStayInRegCountry': MemberSpec_('placeOfStayInRegCountry', 'placeOfStayInRegCountry', 0, 0, {'name': 'placeOfStayInRegCountry', 'type': 'placeOfStayInRegCountry'}, None),
        'placeOfStayInRF': MemberSpec_('placeOfStayInRF', 'placeOfStayInRF', 0, 1, {'minOccurs': '0', 'name': 'placeOfStayInRF', 'type': 'placeOfStayInRF'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, fullName=None, shortName=None, firmName=None, fullNameLat=None, status=None, taxPayerCode=None, personalAccount=None, registerInRFTaxBodies=None, placeOfStayInRegCountry=None, placeOfStayInRF=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.fullName = fullName
        self.validate_zfcs_longTextMinType(self.fullName)
        self.fullName_nsprefix_ = None
        self.shortName = shortName
        self.validate_zfcs_longTextMinType(self.shortName)
        self.shortName_nsprefix_ = None
        self.firmName = firmName
        self.validate_zfcs_longTextMinType(self.firmName)
        self.firmName_nsprefix_ = None
        self.fullNameLat = fullNameLat
        self.validate_zfcs_longTextMinType(self.fullNameLat)
        self.fullNameLat_nsprefix_ = None
        self.status = status
        self.validate_zfcs_participantStatusContract2015Type(self.status)
        self.status_nsprefix_ = None
        self.taxPayerCode = taxPayerCode
        self.taxPayerCode_nsprefix_ = None
        self.personalAccount = personalAccount
        self.validate_zfcs_personalAccountType(self.personalAccount)
        self.personalAccount_nsprefix_ = None
        self.registerInRFTaxBodies = registerInRFTaxBodies
        self.registerInRFTaxBodies_nsprefix_ = None
        self.placeOfStayInRegCountry = placeOfStayInRegCountry
        self.placeOfStayInRegCountry_nsprefix_ = None
        self.placeOfStayInRF = placeOfStayInRF
        self.placeOfStayInRF_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, corr_supplierLegalEntityForeignState)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if corr_supplierLegalEntityForeignState.subclass:
            return corr_supplierLegalEntityForeignState.subclass(*args_, **kwargs_)
        else:
            return corr_supplierLegalEntityForeignState(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_zfcs_longTextMinType(self, value):
        result = True
        # Validate type zfcs_longTextMinType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 2000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on zfcs_longTextMinType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on zfcs_longTextMinType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_zfcs_participantStatusContract2015Type(self, value):
        result = True
        # Validate type zfcs_participantStatusContract2015Type, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['10', '20', '30', '31', '40', '41']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on zfcs_participantStatusContract2015Type' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_zfcs_personalAccountType(self, value):
        result = True
        # Validate type zfcs_personalAccountType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) != 11:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd length restriction on zfcs_personalAccountType' % {"value": encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.fullName is not None or
            self.shortName is not None or
            self.firmName is not None or
            self.fullNameLat is not None or
            self.status is not None or
            self.taxPayerCode is not None or
            self.personalAccount is not None or
            self.registerInRFTaxBodies is not None or
            self.placeOfStayInRegCountry is not None or
            self.placeOfStayInRF is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'fullName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'fullName')
            value_ = self.gds_validate_string(value_, node, 'fullName')
            self.fullName = value_
            self.fullName_nsprefix_ = child_.prefix
            # validate type zfcs_longTextMinType
            self.validate_zfcs_longTextMinType(self.fullName)
        elif nodeName_ == 'shortName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'shortName')
            value_ = self.gds_validate_string(value_, node, 'shortName')
            self.shortName = value_
            self.shortName_nsprefix_ = child_.prefix
            # validate type zfcs_longTextMinType
            self.validate_zfcs_longTextMinType(self.shortName)
        elif nodeName_ == 'firmName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'firmName')
            value_ = self.gds_validate_string(value_, node, 'firmName')
            self.firmName = value_
            self.firmName_nsprefix_ = child_.prefix
            # validate type zfcs_longTextMinType
            self.validate_zfcs_longTextMinType(self.firmName)
        elif nodeName_ == 'fullNameLat':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'fullNameLat')
            value_ = self.gds_validate_string(value_, node, 'fullNameLat')
            self.fullNameLat = value_
            self.fullNameLat_nsprefix_ = child_.prefix
            # validate type zfcs_longTextMinType
            self.validate_zfcs_longTextMinType(self.fullNameLat)
        elif nodeName_ == 'status':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'status')
            value_ = self.gds_validate_string(value_, node, 'status')
            self.status = value_
            self.status_nsprefix_ = child_.prefix
            # validate type zfcs_participantStatusContract2015Type
            self.validate_zfcs_participantStatusContract2015Type(self.status)
        elif nodeName_ == 'taxPayerCode':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'taxPayerCode')
            value_ = self.gds_validate_string(value_, node, 'taxPayerCode')
            self.taxPayerCode = value_
            self.taxPayerCode_nsprefix_ = child_.prefix
        elif nodeName_ == 'personalAccount':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'personalAccount')
            value_ = self.gds_validate_string(value_, node, 'personalAccount')
            self.personalAccount = value_
            self.personalAccount_nsprefix_ = child_.prefix
            # validate type zfcs_personalAccountType
            self.validate_zfcs_personalAccountType(self.personalAccount)
        elif nodeName_ == 'registerInRFTaxBodies':
            obj_ = registerInRFTaxBodies.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.registerInRFTaxBodies = obj_
            obj_.original_tagname_ = 'registerInRFTaxBodies'
        elif nodeName_ == 'placeOfStayInRegCountry':
            obj_ = placeOfStayInRegCountry.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.placeOfStayInRegCountry = obj_
            obj_.original_tagname_ = 'placeOfStayInRegCountry'
        elif nodeName_ == 'placeOfStayInRF':
            obj_ = placeOfStayInRF.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.placeOfStayInRF = obj_
            obj_.original_tagname_ = 'placeOfStayInRF'
# end class corr_supplierLegalEntityForeignState


class taxPayerCode(GeneratedsSuper):
    """Код налогоплательщика в стране регистрации или его аналог.
    При приеме контролируется заполнение данного поля или\и блока "Поставщик
    состоит на учете в налоговых органах на территории РФ"
    (legalEntityForeignState/registerInRFTaxBodies)"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, taxPayerCode)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if taxPayerCode.subclass:
            return taxPayerCode.subclass(*args_, **kwargs_)
        else:
            return taxPayerCode(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_taxPayerCode(self, value):
        result = True
        # Validate type taxPayerCode, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 100:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on taxPayerCode' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on taxPayerCode' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class taxPayerCode


class registerInRFTaxBodies(GeneratedsSuper):
    """Поставщик состоит на учете в налоговых органах на территории РФ.
    При приеме контролируется заполнение данного блока или\и поля "Код
    налогоплательщика в стране регистрации или его аналог"
    (/legalEntityForeignState/taxPayerCode)"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'INN': MemberSpec_('INN', ['innType', 'xs:string'], 0, 0, {'name': 'INN', 'type': 'xs:string'}, None),
        'KPP': MemberSpec_('KPP', ['kppType', 'xs:string'], 0, 0, {'name': 'KPP', 'type': 'xs:string'}, None),
        'registrationDate': MemberSpec_('registrationDate', 'xs:date', 0, 0, {'name': 'registrationDate', 'type': 'xs:date'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, INN=None, KPP=None, registrationDate=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.INN = INN
        self.validate_innType(self.INN)
        self.INN_nsprefix_ = None
        self.KPP = KPP
        self.validate_kppType(self.KPP)
        self.KPP_nsprefix_ = None
        if isinstance(registrationDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(registrationDate, '%Y-%m-%d').date()
        else:
            initvalue_ = registrationDate
        self.registrationDate = initvalue_
        self.registrationDate_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, registerInRFTaxBodies)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if registerInRFTaxBodies.subclass:
            return registerInRFTaxBodies.subclass(*args_, **kwargs_)
        else:
            return registerInRFTaxBodies(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_innType(self, value):
        result = True
        # Validate type innType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 12:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on innType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_innType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_innType_patterns_, ))
                result = False
        return result
    validate_innType_patterns_ = [['^(\\d{1,12})$']]
    def validate_kppType(self, value):
        result = True
        # Validate type kppType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) != 9:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd length restriction on kppType' % {"value": encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.INN is not None or
            self.KPP is not None or
            self.registrationDate is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'INN':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'INN')
            value_ = self.gds_validate_string(value_, node, 'INN')
            self.INN = value_
            self.INN_nsprefix_ = child_.prefix
            # validate type innType
            self.validate_innType(self.INN)
        elif nodeName_ == 'KPP':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'KPP')
            value_ = self.gds_validate_string(value_, node, 'KPP')
            self.KPP = value_
            self.KPP_nsprefix_ = child_.prefix
            # validate type kppType
            self.validate_kppType(self.KPP)
        elif nodeName_ == 'registrationDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.registrationDate = dval_
            self.registrationDate_nsprefix_ = child_.prefix
# end class registerInRFTaxBodies


class placeOfStayInRegCountry(GeneratedsSuper):
    """Место нахождения в стране регистрации"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'country': MemberSpec_('country', 'zfcs_countryRef', 0, 1, {'minOccurs': '0', 'name': 'country', 'type': 'zfcs_countryRef'}, None),
        'address': MemberSpec_('address', ['zfcs_contract2015AddressType', 'xs:string'], 0, 0, {'name': 'address', 'type': 'xs:string'}, None),
        'postAddress': MemberSpec_('postAddress', ['zfcs_contract2015AddressType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'postAddress', 'type': 'xs:string'}, None),
        'contactEMail': MemberSpec_('contactEMail', ['eMailType', 'xs:string'], 0, 0, {'name': 'contactEMail', 'type': 'xs:string'}, None),
        'contactPhone': MemberSpec_('contactPhone', ['phoneType', 'xs:string'], 0, 0, {'name': 'contactPhone', 'type': 'xs:string'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, country=None, address=None, postAddress=None, contactEMail=None, contactPhone=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.country = country
        self.country_nsprefix_ = None
        self.address = address
        self.validate_zfcs_contract2015AddressType(self.address)
        self.address_nsprefix_ = None
        self.postAddress = postAddress
        self.validate_zfcs_contract2015AddressType(self.postAddress)
        self.postAddress_nsprefix_ = None
        self.contactEMail = contactEMail
        self.validate_eMailType(self.contactEMail)
        self.contactEMail_nsprefix_ = None
        self.contactPhone = contactPhone
        self.validate_phoneType(self.contactPhone)
        self.contactPhone_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, placeOfStayInRegCountry)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if placeOfStayInRegCountry.subclass:
            return placeOfStayInRegCountry.subclass(*args_, **kwargs_)
        else:
            return placeOfStayInRegCountry(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_zfcs_contract2015AddressType(self, value):
        result = True
        # Validate type zfcs_contract2015AddressType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on zfcs_contract2015AddressType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on zfcs_contract2015AddressType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_eMailType(self, value):
        result = True
        # Validate type eMailType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 256:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on eMailType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on eMailType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_phoneType(self, value):
        result = True
        # Validate type phoneType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 30:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on phoneType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on phoneType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.country is not None or
            self.address is not None or
            self.postAddress is not None or
            self.contactEMail is not None or
            self.contactPhone is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'country':
            obj_ = zfcs_countryRef.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.country = obj_
            obj_.original_tagname_ = 'country'
        elif nodeName_ == 'address':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'address')
            value_ = self.gds_validate_string(value_, node, 'address')
            self.address = value_
            self.address_nsprefix_ = child_.prefix
            # validate type zfcs_contract2015AddressType
            self.validate_zfcs_contract2015AddressType(self.address)
        elif nodeName_ == 'postAddress':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'postAddress')
            value_ = self.gds_validate_string(value_, node, 'postAddress')
            self.postAddress = value_
            self.postAddress_nsprefix_ = child_.prefix
            # validate type zfcs_contract2015AddressType
            self.validate_zfcs_contract2015AddressType(self.postAddress)
        elif nodeName_ == 'contactEMail':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'contactEMail')
            value_ = self.gds_validate_string(value_, node, 'contactEMail')
            self.contactEMail = value_
            self.contactEMail_nsprefix_ = child_.prefix
            # validate type eMailType
            self.validate_eMailType(self.contactEMail)
        elif nodeName_ == 'contactPhone':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'contactPhone')
            value_ = self.gds_validate_string(value_, node, 'contactPhone')
            self.contactPhone = value_
            self.contactPhone_nsprefix_ = child_.prefix
            # validate type phoneType
            self.validate_phoneType(self.contactPhone)
# end class placeOfStayInRegCountry


class placeOfStayInRF(GeneratedsSuper):
    """Наличие у поставщика места пребывания на территории РФ"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'OKTMO': MemberSpec_('OKTMO', 'zfcs_OKTMORef', 0, 0, {'name': 'OKTMO', 'type': 'zfcs_OKTMORef'}, None),
        'address': MemberSpec_('address', ['zfcs_contract2015AddressType', 'xs:string'], 0, 0, {'name': 'address', 'type': 'xs:string'}, None),
        'postAdressInfo': MemberSpec_('postAdressInfo', 'postAdressInfo', 0, 1, {'minOccurs': '0', 'name': 'postAdressInfo', 'type': 'postAdressInfo'}, None),
        'postAddress': MemberSpec_('postAddress', ['zfcs_contract2015AddressType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'postAddress', 'type': 'xs:string'}, None),
        'contactEMail': MemberSpec_('contactEMail', ['eMailType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'contactEMail', 'type': 'xs:string'}, None),
        'contactPhone': MemberSpec_('contactPhone', ['phoneType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'contactPhone', 'type': 'xs:string'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, OKTMO=None, address=None, postAdressInfo=None, postAddress=None, contactEMail=None, contactPhone=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.OKTMO = OKTMO
        self.OKTMO_nsprefix_ = None
        self.address = address
        self.validate_zfcs_contract2015AddressType(self.address)
        self.address_nsprefix_ = None
        self.postAdressInfo = postAdressInfo
        self.postAdressInfo_nsprefix_ = None
        self.postAddress = postAddress
        self.validate_zfcs_contract2015AddressType(self.postAddress)
        self.postAddress_nsprefix_ = None
        self.contactEMail = contactEMail
        self.validate_eMailType(self.contactEMail)
        self.contactEMail_nsprefix_ = None
        self.contactPhone = contactPhone
        self.validate_phoneType(self.contactPhone)
        self.contactPhone_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, placeOfStayInRF)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if placeOfStayInRF.subclass:
            return placeOfStayInRF.subclass(*args_, **kwargs_)
        else:
            return placeOfStayInRF(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_zfcs_contract2015AddressType(self, value):
        result = True
        # Validate type zfcs_contract2015AddressType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on zfcs_contract2015AddressType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on zfcs_contract2015AddressType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_eMailType(self, value):
        result = True
        # Validate type eMailType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 256:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on eMailType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on eMailType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_phoneType(self, value):
        result = True
        # Validate type phoneType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 30:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on phoneType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on phoneType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.OKTMO is not None or
            self.address is not None or
            self.postAdressInfo is not None or
            self.postAddress is not None or
            self.contactEMail is not None or
            self.contactPhone is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'OKTMO':
            obj_ = zfcs_OKTMORef.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.OKTMO = obj_
            obj_.original_tagname_ = 'OKTMO'
        elif nodeName_ == 'address':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'address')
            value_ = self.gds_validate_string(value_, node, 'address')
            self.address = value_
            self.address_nsprefix_ = child_.prefix
            # validate type zfcs_contract2015AddressType
            self.validate_zfcs_contract2015AddressType(self.address)
        elif nodeName_ == 'postAdressInfo':
            obj_ = postAdressInfo.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.postAdressInfo = obj_
            obj_.original_tagname_ = 'postAdressInfo'
        elif nodeName_ == 'postAddress':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'postAddress')
            value_ = self.gds_validate_string(value_, node, 'postAddress')
            self.postAddress = value_
            self.postAddress_nsprefix_ = child_.prefix
            # validate type zfcs_contract2015AddressType
            self.validate_zfcs_contract2015AddressType(self.postAddress)
        elif nodeName_ == 'contactEMail':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'contactEMail')
            value_ = self.gds_validate_string(value_, node, 'contactEMail')
            self.contactEMail = value_
            self.contactEMail_nsprefix_ = child_.prefix
            # validate type eMailType
            self.validate_eMailType(self.contactEMail)
        elif nodeName_ == 'contactPhone':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'contactPhone')
            value_ = self.gds_validate_string(value_, node, 'contactPhone')
            self.contactPhone = value_
            self.contactPhone_nsprefix_ = child_.prefix
            # validate type phoneType
            self.validate_phoneType(self.contactPhone)
# end class placeOfStayInRF


class corr_supplierIndividualPersonRF(GeneratedsSuper):
    """Физическое лицо РФ"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'lastName': MemberSpec_('lastName', ['lastName', 'xs:string'], 0, 0, {'name': 'lastName', 'type': 'xs:string'}, None),
        'firstName': MemberSpec_('firstName', ['firstName', 'xs:string'], 0, 0, {'name': 'firstName', 'type': 'xs:string'}, None),
        'middleName': MemberSpec_('middleName', ['middleName', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'middleName', 'type': 'xs:string'}, None),
        'INN': MemberSpec_('INN', ['innType', 'xs:string'], 0, 0, {'name': 'INN', 'type': 'xs:string'}, None),
        'isIP': MemberSpec_('isIP', 'xs:boolean', 0, 1, {'minOccurs': '0', 'name': 'isIP', 'type': 'xs:boolean'}, None),
        'registrationDate': MemberSpec_('registrationDate', 'xs:date', 0, 0, {'name': 'registrationDate', 'type': 'xs:date'}, None),
        'status': MemberSpec_('status', ['zfcs_participantStatusContract2015Type', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'status', 'type': 'xs:string'}, None),
        'ERSMSPInclusionDate': MemberSpec_('ERSMSPInclusionDate', 'xs:date', 0, 1, {'minOccurs': '0', 'name': 'ERSMSPInclusionDate', 'type': 'xs:date'}, None),
        'OKTMO': MemberSpec_('OKTMO', 'zfcs_OKTMORef', 0, 0, {'name': 'OKTMO', 'type': 'zfcs_OKTMORef'}, None),
        'personalAccount': MemberSpec_('personalAccount', ['zfcs_personalAccountType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'personalAccount', 'type': 'xs:string'}, None),
        'address': MemberSpec_('address', ['zfcs_contract2015AddressType', 'xs:string'], 0, 0, {'name': 'address', 'type': 'xs:string'}, None),
        'postAddressInfo': MemberSpec_('postAddressInfo', 'postAddressInfo', 0, 1, {'minOccurs': '0', 'name': 'postAddressInfo', 'type': 'postAddressInfo'}, None),
        'postAddress': MemberSpec_('postAddress', ['zfcs_contract2015AddressType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'postAddress', 'type': 'xs:string'}, None),
        'contactEMail': MemberSpec_('contactEMail', ['eMailType', 'xs:string'], 0, 0, {'name': 'contactEMail', 'type': 'xs:string'}, None),
        'contactPhone': MemberSpec_('contactPhone', ['phoneType', 'xs:string'], 0, 0, {'name': 'contactPhone', 'type': 'xs:string'}, None),
        'isCulture': MemberSpec_('isCulture', 'xs:boolean', 0, 1, {'minOccurs': '0', 'name': 'isCulture', 'type': 'xs:boolean'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, lastName=None, firstName=None, middleName=None, INN=None, isIP=None, registrationDate=None, status=None, ERSMSPInclusionDate=None, OKTMO=None, personalAccount=None, address=None, postAddressInfo=None, postAddress=None, contactEMail=None, contactPhone=None, isCulture=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.lastName = lastName
        self.lastName_nsprefix_ = None
        self.firstName = firstName
        self.firstName_nsprefix_ = None
        self.middleName = middleName
        self.middleName_nsprefix_ = None
        self.INN = INN
        self.validate_innType(self.INN)
        self.INN_nsprefix_ = None
        self.isIP = isIP
        self.isIP_nsprefix_ = None
        if isinstance(registrationDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(registrationDate, '%Y-%m-%d').date()
        else:
            initvalue_ = registrationDate
        self.registrationDate = initvalue_
        self.registrationDate_nsprefix_ = None
        self.status = status
        self.validate_zfcs_participantStatusContract2015Type(self.status)
        self.status_nsprefix_ = None
        if isinstance(ERSMSPInclusionDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(ERSMSPInclusionDate, '%Y-%m-%d').date()
        else:
            initvalue_ = ERSMSPInclusionDate
        self.ERSMSPInclusionDate = initvalue_
        self.ERSMSPInclusionDate_nsprefix_ = None
        self.OKTMO = OKTMO
        self.OKTMO_nsprefix_ = None
        self.personalAccount = personalAccount
        self.validate_zfcs_personalAccountType(self.personalAccount)
        self.personalAccount_nsprefix_ = None
        self.address = address
        self.validate_zfcs_contract2015AddressType(self.address)
        self.address_nsprefix_ = None
        self.postAddressInfo = postAddressInfo
        self.postAddressInfo_nsprefix_ = None
        self.postAddress = postAddress
        self.validate_zfcs_contract2015AddressType(self.postAddress)
        self.postAddress_nsprefix_ = None
        self.contactEMail = contactEMail
        self.validate_eMailType(self.contactEMail)
        self.contactEMail_nsprefix_ = None
        self.contactPhone = contactPhone
        self.validate_phoneType(self.contactPhone)
        self.contactPhone_nsprefix_ = None
        self.isCulture = isCulture
        self.isCulture_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, corr_supplierIndividualPersonRF)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if corr_supplierIndividualPersonRF.subclass:
            return corr_supplierIndividualPersonRF.subclass(*args_, **kwargs_)
        else:
            return corr_supplierIndividualPersonRF(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_innType(self, value):
        result = True
        # Validate type innType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 12:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on innType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_innType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_innType_patterns_, ))
                result = False
        return result
    validate_innType_patterns_ = [['^(\\d{1,12})$']]
    def validate_zfcs_participantStatusContract2015Type(self, value):
        result = True
        # Validate type zfcs_participantStatusContract2015Type, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['10', '20', '30', '31', '40', '41']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on zfcs_participantStatusContract2015Type' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_zfcs_personalAccountType(self, value):
        result = True
        # Validate type zfcs_personalAccountType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) != 11:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd length restriction on zfcs_personalAccountType' % {"value": encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_zfcs_contract2015AddressType(self, value):
        result = True
        # Validate type zfcs_contract2015AddressType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on zfcs_contract2015AddressType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on zfcs_contract2015AddressType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_eMailType(self, value):
        result = True
        # Validate type eMailType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 256:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on eMailType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on eMailType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_phoneType(self, value):
        result = True
        # Validate type phoneType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 30:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on phoneType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on phoneType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.lastName is not None or
            self.firstName is not None or
            self.middleName is not None or
            self.INN is not None or
            self.isIP is not None or
            self.registrationDate is not None or
            self.status is not None or
            self.ERSMSPInclusionDate is not None or
            self.OKTMO is not None or
            self.personalAccount is not None or
            self.address is not None or
            self.postAddressInfo is not None or
            self.postAddress is not None or
            self.contactEMail is not None or
            self.contactPhone is not None or
            self.isCulture is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'lastName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'lastName')
            value_ = self.gds_validate_string(value_, node, 'lastName')
            self.lastName = value_
            self.lastName_nsprefix_ = child_.prefix
        elif nodeName_ == 'firstName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'firstName')
            value_ = self.gds_validate_string(value_, node, 'firstName')
            self.firstName = value_
            self.firstName_nsprefix_ = child_.prefix
        elif nodeName_ == 'middleName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'middleName')
            value_ = self.gds_validate_string(value_, node, 'middleName')
            self.middleName = value_
            self.middleName_nsprefix_ = child_.prefix
        elif nodeName_ == 'INN':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'INN')
            value_ = self.gds_validate_string(value_, node, 'INN')
            self.INN = value_
            self.INN_nsprefix_ = child_.prefix
            # validate type innType
            self.validate_innType(self.INN)
        elif nodeName_ == 'isIP':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'isIP')
            ival_ = self.gds_validate_boolean(ival_, node, 'isIP')
            self.isIP = ival_
            self.isIP_nsprefix_ = child_.prefix
        elif nodeName_ == 'registrationDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.registrationDate = dval_
            self.registrationDate_nsprefix_ = child_.prefix
        elif nodeName_ == 'status':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'status')
            value_ = self.gds_validate_string(value_, node, 'status')
            self.status = value_
            self.status_nsprefix_ = child_.prefix
            # validate type zfcs_participantStatusContract2015Type
            self.validate_zfcs_participantStatusContract2015Type(self.status)
        elif nodeName_ == 'ERSMSPInclusionDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.ERSMSPInclusionDate = dval_
            self.ERSMSPInclusionDate_nsprefix_ = child_.prefix
        elif nodeName_ == 'OKTMO':
            obj_ = zfcs_OKTMORef.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.OKTMO = obj_
            obj_.original_tagname_ = 'OKTMO'
        elif nodeName_ == 'personalAccount':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'personalAccount')
            value_ = self.gds_validate_string(value_, node, 'personalAccount')
            self.personalAccount = value_
            self.personalAccount_nsprefix_ = child_.prefix
            # validate type zfcs_personalAccountType
            self.validate_zfcs_personalAccountType(self.personalAccount)
        elif nodeName_ == 'address':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'address')
            value_ = self.gds_validate_string(value_, node, 'address')
            self.address = value_
            self.address_nsprefix_ = child_.prefix
            # validate type zfcs_contract2015AddressType
            self.validate_zfcs_contract2015AddressType(self.address)
        elif nodeName_ == 'postAddressInfo':
            obj_ = postAddressInfo.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.postAddressInfo = obj_
            obj_.original_tagname_ = 'postAddressInfo'
        elif nodeName_ == 'postAddress':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'postAddress')
            value_ = self.gds_validate_string(value_, node, 'postAddress')
            self.postAddress = value_
            self.postAddress_nsprefix_ = child_.prefix
            # validate type zfcs_contract2015AddressType
            self.validate_zfcs_contract2015AddressType(self.postAddress)
        elif nodeName_ == 'contactEMail':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'contactEMail')
            value_ = self.gds_validate_string(value_, node, 'contactEMail')
            self.contactEMail = value_
            self.contactEMail_nsprefix_ = child_.prefix
            # validate type eMailType
            self.validate_eMailType(self.contactEMail)
        elif nodeName_ == 'contactPhone':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'contactPhone')
            value_ = self.gds_validate_string(value_, node, 'contactPhone')
            self.contactPhone = value_
            self.contactPhone_nsprefix_ = child_.prefix
            # validate type phoneType
            self.validate_phoneType(self.contactPhone)
        elif nodeName_ == 'isCulture':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'isCulture')
            ival_ = self.gds_validate_boolean(ival_, node, 'isCulture')
            self.isCulture = ival_
            self.isCulture_nsprefix_ = child_.prefix
# end class corr_supplierIndividualPersonRF


class lastName(GeneratedsSuper):
    """Фамилия"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, lastName)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if lastName.subclass:
            return lastName.subclass(*args_, **kwargs_)
        else:
            return lastName(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_lastName(self, value):
        result = True
        # Validate type lastName, a restriction on xs:string.
        pass
        return result
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class lastName


class firstName(GeneratedsSuper):
    """Имя"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, firstName)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if firstName.subclass:
            return firstName.subclass(*args_, **kwargs_)
        else:
            return firstName(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_firstName(self, value):
        result = True
        # Validate type firstName, a restriction on xs:string.
        pass
        return result
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class firstName


class middleName(GeneratedsSuper):
    """Отчество"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, middleName)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if middleName.subclass:
            return middleName.subclass(*args_, **kwargs_)
        else:
            return middleName(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_middleName(self, value):
        result = True
        # Validate type middleName, a restriction on xs:string.
        pass
        return result
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class middleName


class postAddressInfo(GeneratedsSuper):
    """Почтовый адрес.
    При приеме контролируется, что поля mailFacilityName и postBoxNumber
    заполняются/не заполняются парой"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'mailingAdress': MemberSpec_('mailingAdress', ['zfcs_contract2015AddressType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'mailingAdress', 'type': 'xs:string'}, None),
        'mailFacilityName': MemberSpec_('mailFacilityName', ['zfcs_contract2015AddressType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'mailFacilityName', 'type': 'xs:string'}, None),
        'postBoxNumber': MemberSpec_('postBoxNumber', ['zfcs_contract2015AddressType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'postBoxNumber', 'type': 'xs:string'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, mailingAdress=None, mailFacilityName=None, postBoxNumber=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.mailingAdress = mailingAdress
        self.validate_zfcs_contract2015AddressType(self.mailingAdress)
        self.mailingAdress_nsprefix_ = None
        self.mailFacilityName = mailFacilityName
        self.validate_zfcs_contract2015AddressType(self.mailFacilityName)
        self.mailFacilityName_nsprefix_ = None
        self.postBoxNumber = postBoxNumber
        self.validate_zfcs_contract2015AddressType(self.postBoxNumber)
        self.postBoxNumber_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, postAddressInfo)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if postAddressInfo.subclass:
            return postAddressInfo.subclass(*args_, **kwargs_)
        else:
            return postAddressInfo(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_zfcs_contract2015AddressType(self, value):
        result = True
        # Validate type zfcs_contract2015AddressType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on zfcs_contract2015AddressType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on zfcs_contract2015AddressType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.mailingAdress is not None or
            self.mailFacilityName is not None or
            self.postBoxNumber is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'mailingAdress':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'mailingAdress')
            value_ = self.gds_validate_string(value_, node, 'mailingAdress')
            self.mailingAdress = value_
            self.mailingAdress_nsprefix_ = child_.prefix
            # validate type zfcs_contract2015AddressType
            self.validate_zfcs_contract2015AddressType(self.mailingAdress)
        elif nodeName_ == 'mailFacilityName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'mailFacilityName')
            value_ = self.gds_validate_string(value_, node, 'mailFacilityName')
            self.mailFacilityName = value_
            self.mailFacilityName_nsprefix_ = child_.prefix
            # validate type zfcs_contract2015AddressType
            self.validate_zfcs_contract2015AddressType(self.mailFacilityName)
        elif nodeName_ == 'postBoxNumber':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'postBoxNumber')
            value_ = self.gds_validate_string(value_, node, 'postBoxNumber')
            self.postBoxNumber = value_
            self.postBoxNumber_nsprefix_ = child_.prefix
            # validate type zfcs_contract2015AddressType
            self.validate_zfcs_contract2015AddressType(self.postBoxNumber)
# end class postAddressInfo


class corr_supplierIndividualPersonForeignState(GeneratedsSuper):
    """Физическое лицо иностранного государства"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'lastName': MemberSpec_('lastName', ['lastName', 'xs:string'], 0, 0, {'name': 'lastName', 'type': 'xs:string'}, None),
        'firstName': MemberSpec_('firstName', ['firstName', 'xs:string'], 0, 0, {'name': 'firstName', 'type': 'xs:string'}, None),
        'middleName': MemberSpec_('middleName', ['middleName', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'middleName', 'type': 'xs:string'}, None),
        'lastNameLat': MemberSpec_('lastNameLat', ['lastNameLat', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'lastNameLat', 'type': 'xs:string'}, None),
        'firstNameLat': MemberSpec_('firstNameLat', ['firstNameLat', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'firstNameLat', 'type': 'xs:string'}, None),
        'middleNameLat': MemberSpec_('middleNameLat', ['middleNameLat', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'middleNameLat', 'type': 'xs:string'}, None),
        'taxPayerCode': MemberSpec_('taxPayerCode', ['taxPayerCode', 'xs:string'], 0, 0, {'name': 'taxPayerCode', 'type': 'xs:string'}, None),
        'personalAccount': MemberSpec_('personalAccount', ['zfcs_personalAccountType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'personalAccount', 'type': 'xs:string'}, None),
        'registerInRFTaxBodies': MemberSpec_('registerInRFTaxBodies', 'registerInRFTaxBodies', 0, 1, {'minOccurs': '0', 'name': 'registerInRFTaxBodies', 'type': 'registerInRFTaxBodies'}, None),
        'placeOfStayInRegCountry': MemberSpec_('placeOfStayInRegCountry', 'placeOfStayInRegCountry', 0, 0, {'name': 'placeOfStayInRegCountry', 'type': 'placeOfStayInRegCountry'}, None),
        'placeOfStayInRF': MemberSpec_('placeOfStayInRF', 'placeOfStayInRF', 0, 1, {'minOccurs': '0', 'name': 'placeOfStayInRF', 'type': 'placeOfStayInRF'}, None),
        'isCulture': MemberSpec_('isCulture', 'xs:boolean', 0, 1, {'minOccurs': '0', 'name': 'isCulture', 'type': 'xs:boolean'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, lastName=None, firstName=None, middleName=None, lastNameLat=None, firstNameLat=None, middleNameLat=None, taxPayerCode=None, personalAccount=None, registerInRFTaxBodies=None, placeOfStayInRegCountry=None, placeOfStayInRF=None, isCulture=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.lastName = lastName
        self.lastName_nsprefix_ = None
        self.firstName = firstName
        self.firstName_nsprefix_ = None
        self.middleName = middleName
        self.middleName_nsprefix_ = None
        self.lastNameLat = lastNameLat
        self.lastNameLat_nsprefix_ = None
        self.firstNameLat = firstNameLat
        self.firstNameLat_nsprefix_ = None
        self.middleNameLat = middleNameLat
        self.middleNameLat_nsprefix_ = None
        self.taxPayerCode = taxPayerCode
        self.taxPayerCode_nsprefix_ = None
        self.personalAccount = personalAccount
        self.validate_zfcs_personalAccountType(self.personalAccount)
        self.personalAccount_nsprefix_ = None
        self.registerInRFTaxBodies = registerInRFTaxBodies
        self.registerInRFTaxBodies_nsprefix_ = None
        self.placeOfStayInRegCountry = placeOfStayInRegCountry
        self.placeOfStayInRegCountry_nsprefix_ = None
        self.placeOfStayInRF = placeOfStayInRF
        self.placeOfStayInRF_nsprefix_ = None
        self.isCulture = isCulture
        self.isCulture_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, corr_supplierIndividualPersonForeignState)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if corr_supplierIndividualPersonForeignState.subclass:
            return corr_supplierIndividualPersonForeignState.subclass(*args_, **kwargs_)
        else:
            return corr_supplierIndividualPersonForeignState(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_zfcs_personalAccountType(self, value):
        result = True
        # Validate type zfcs_personalAccountType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) != 11:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd length restriction on zfcs_personalAccountType' % {"value": encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.lastName is not None or
            self.firstName is not None or
            self.middleName is not None or
            self.lastNameLat is not None or
            self.firstNameLat is not None or
            self.middleNameLat is not None or
            self.taxPayerCode is not None or
            self.personalAccount is not None or
            self.registerInRFTaxBodies is not None or
            self.placeOfStayInRegCountry is not None or
            self.placeOfStayInRF is not None or
            self.isCulture is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'lastName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'lastName')
            value_ = self.gds_validate_string(value_, node, 'lastName')
            self.lastName = value_
            self.lastName_nsprefix_ = child_.prefix
        elif nodeName_ == 'firstName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'firstName')
            value_ = self.gds_validate_string(value_, node, 'firstName')
            self.firstName = value_
            self.firstName_nsprefix_ = child_.prefix
        elif nodeName_ == 'middleName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'middleName')
            value_ = self.gds_validate_string(value_, node, 'middleName')
            self.middleName = value_
            self.middleName_nsprefix_ = child_.prefix
        elif nodeName_ == 'lastNameLat':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'lastNameLat')
            value_ = self.gds_validate_string(value_, node, 'lastNameLat')
            self.lastNameLat = value_
            self.lastNameLat_nsprefix_ = child_.prefix
        elif nodeName_ == 'firstNameLat':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'firstNameLat')
            value_ = self.gds_validate_string(value_, node, 'firstNameLat')
            self.firstNameLat = value_
            self.firstNameLat_nsprefix_ = child_.prefix
        elif nodeName_ == 'middleNameLat':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'middleNameLat')
            value_ = self.gds_validate_string(value_, node, 'middleNameLat')
            self.middleNameLat = value_
            self.middleNameLat_nsprefix_ = child_.prefix
        elif nodeName_ == 'taxPayerCode':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'taxPayerCode')
            value_ = self.gds_validate_string(value_, node, 'taxPayerCode')
            self.taxPayerCode = value_
            self.taxPayerCode_nsprefix_ = child_.prefix
        elif nodeName_ == 'personalAccount':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'personalAccount')
            value_ = self.gds_validate_string(value_, node, 'personalAccount')
            self.personalAccount = value_
            self.personalAccount_nsprefix_ = child_.prefix
            # validate type zfcs_personalAccountType
            self.validate_zfcs_personalAccountType(self.personalAccount)
        elif nodeName_ == 'registerInRFTaxBodies':
            obj_ = registerInRFTaxBodies.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.registerInRFTaxBodies = obj_
            obj_.original_tagname_ = 'registerInRFTaxBodies'
        elif nodeName_ == 'placeOfStayInRegCountry':
            obj_ = placeOfStayInRegCountry.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.placeOfStayInRegCountry = obj_
            obj_.original_tagname_ = 'placeOfStayInRegCountry'
        elif nodeName_ == 'placeOfStayInRF':
            obj_ = placeOfStayInRF.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.placeOfStayInRF = obj_
            obj_.original_tagname_ = 'placeOfStayInRF'
        elif nodeName_ == 'isCulture':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'isCulture')
            ival_ = self.gds_validate_boolean(ival_, node, 'isCulture')
            self.isCulture = ival_
            self.isCulture_nsprefix_ = child_.prefix
# end class corr_supplierIndividualPersonForeignState


class lastNameLat(GeneratedsSuper):
    """Фамилия (латинскими буквами)"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, lastNameLat)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if lastNameLat.subclass:
            return lastNameLat.subclass(*args_, **kwargs_)
        else:
            return lastNameLat(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_lastNameLat(self, value):
        result = True
        # Validate type lastNameLat, a restriction on xs:string.
        pass
        return result
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class lastNameLat


class firstNameLat(GeneratedsSuper):
    """Имя (латинскими буквами)"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, firstNameLat)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if firstNameLat.subclass:
            return firstNameLat.subclass(*args_, **kwargs_)
        else:
            return firstNameLat(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_firstNameLat(self, value):
        result = True
        # Validate type firstNameLat, a restriction on xs:string.
        pass
        return result
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class firstNameLat


class middleNameLat(GeneratedsSuper):
    """Отчество (латинскими буквами)"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, middleNameLat)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if middleNameLat.subclass:
            return middleNameLat.subclass(*args_, **kwargs_)
        else:
            return middleNameLat(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_middleNameLat(self, value):
        result = True
        # Validate type middleNameLat, a restriction on xs:string.
        pass
        return result
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class middleNameLat


class zfcs_attachmentListType(GeneratedsSuper):
    """Прикрепленные документы"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'attachment': MemberSpec_('attachment', 'zfcs_attachmentType', 1, 0, {'maxOccurs': 'unbounded', 'name': 'attachment', 'type': 'zfcs_attachmentType'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, attachment=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if attachment is None:
            self.attachment = []
        else:
            self.attachment = attachment
        self.attachment_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, zfcs_attachmentListType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if zfcs_attachmentListType.subclass:
            return zfcs_attachmentListType.subclass(*args_, **kwargs_)
        else:
            return zfcs_attachmentListType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.attachment
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'attachment':
            obj_ = zfcs_attachmentType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.attachment.append(obj_)
            obj_.original_tagname_ = 'attachment'
# end class zfcs_attachmentListType


class zfcs_attachmentType(GeneratedsSuper):
    """Прикрепленный документ"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'publishedContentId': MemberSpec_('publishedContentId', ['guidType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'publishedContentId', 'type': 'xs:string'}, None),
        'fileName': MemberSpec_('fileName', ['fileName', 'xs:string'], 0, 0, {'name': 'fileName', 'type': 'xs:string'}, None),
        'fileSize': MemberSpec_('fileSize', ['fileSize', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'fileSize', 'type': 'xs:string'}, None),
        'docDescription': MemberSpec_('docDescription', ['docDescription', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'docDescription', 'type': 'xs:string'}, None),
        'docDate': MemberSpec_('docDate', 'xs:dateTime', 0, 1, {'minOccurs': '0', 'name': 'docDate', 'type': 'xs:dateTime'}, None),
        'url': MemberSpec_('url', ['url', 'xs:string'], 0, 0, {'name': 'url', 'type': 'xs:string'}, 1),
        'contentId': MemberSpec_('contentId', ['guidType', 'xs:string'], 0, 0, {'name': 'contentId', 'type': 'xs:string'}, 1),
        'content': MemberSpec_('content', ['content', 'xs:base64Binary'], 0, 0, {'name': 'content', 'type': 'xs:base64Binary'}, 1),
        'cryptoSigns': MemberSpec_('cryptoSigns', 'cryptoSigns', 0, 1, {'minOccurs': '0', 'name': 'cryptoSigns', 'type': 'cryptoSigns'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, publishedContentId=None, fileName=None, fileSize=None, docDescription=None, docDate=None, url=None, contentId=None, content=None, cryptoSigns=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.publishedContentId = publishedContentId
        self.validate_guidType(self.publishedContentId)
        self.publishedContentId_nsprefix_ = None
        self.fileName = fileName
        self.fileName_nsprefix_ = None
        self.fileSize = fileSize
        self.fileSize_nsprefix_ = None
        self.docDescription = docDescription
        self.docDescription_nsprefix_ = None
        if isinstance(docDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(docDate, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = docDate
        self.docDate = initvalue_
        self.docDate_nsprefix_ = None
        self.url = url
        self.url_nsprefix_ = None
        self.contentId = contentId
        self.validate_guidType(self.contentId)
        self.contentId_nsprefix_ = None
        self.content = content
        self.content_nsprefix_ = None
        self.cryptoSigns = cryptoSigns
        self.cryptoSigns_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, zfcs_attachmentType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if zfcs_attachmentType.subclass:
            return zfcs_attachmentType.subclass(*args_, **kwargs_)
        else:
            return zfcs_attachmentType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_guidType(self, value):
        result = True
        # Validate type guidType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 36:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on guidType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on guidType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.publishedContentId is not None or
            self.fileName is not None or
            self.fileSize is not None or
            self.docDescription is not None or
            self.docDate is not None or
            self.url is not None or
            self.contentId is not None or
            self.content is not None or
            self.cryptoSigns is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'publishedContentId':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'publishedContentId')
            value_ = self.gds_validate_string(value_, node, 'publishedContentId')
            self.publishedContentId = value_
            self.publishedContentId_nsprefix_ = child_.prefix
            # validate type guidType
            self.validate_guidType(self.publishedContentId)
        elif nodeName_ == 'fileName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'fileName')
            value_ = self.gds_validate_string(value_, node, 'fileName')
            self.fileName = value_
            self.fileName_nsprefix_ = child_.prefix
        elif nodeName_ == 'fileSize':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'fileSize')
            value_ = self.gds_validate_string(value_, node, 'fileSize')
            self.fileSize = value_
            self.fileSize_nsprefix_ = child_.prefix
        elif nodeName_ == 'docDescription':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'docDescription')
            value_ = self.gds_validate_string(value_, node, 'docDescription')
            self.docDescription = value_
            self.docDescription_nsprefix_ = child_.prefix
        elif nodeName_ == 'docDate':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.docDate = dval_
            self.docDate_nsprefix_ = child_.prefix
        elif nodeName_ == 'url':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'url')
            value_ = self.gds_validate_string(value_, node, 'url')
            self.url = value_
            self.url_nsprefix_ = child_.prefix
        elif nodeName_ == 'contentId':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'contentId')
            value_ = self.gds_validate_string(value_, node, 'contentId')
            self.contentId = value_
            self.contentId_nsprefix_ = child_.prefix
            # validate type guidType
            self.validate_guidType(self.contentId)
        elif nodeName_ == 'content':
            sval_ = child_.text
            if sval_ is not None:
                try:
                    bval_ = base64.b64decode(sval_)
                except (TypeError, ValueError) as exp:
                    raise_parse_error(child_, 'requires base64 encoded string: %s' % exp)
                bval_ = self.gds_validate_base64(bval_, node, 'content')
            else:
                bval_ = None
            self.content = bval_
            self.content_nsprefix_ = child_.prefix
        elif nodeName_ == 'cryptoSigns':
            obj_ = cryptoSigns.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.cryptoSigns = obj_
            obj_.original_tagname_ = 'cryptoSigns'
# end class zfcs_attachmentType


class fileName(GeneratedsSuper):
    """Имя файла"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, fileName)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if fileName.subclass:
            return fileName.subclass(*args_, **kwargs_)
        else:
            return fileName(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_fileName(self, value):
        result = True
        # Validate type fileName, a restriction on xs:string.
        pass
        return result
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class fileName


class fileSize(GeneratedsSuper):
    """Размер файла"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, fileSize)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if fileSize.subclass:
            return fileSize.subclass(*args_, **kwargs_)
        else:
            return fileSize(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_fileSize(self, value):
        result = True
        # Validate type fileSize, a restriction on xs:string.
        pass
        return result
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class fileSize


class docDescription(GeneratedsSuper):
    """Описание прикрепляемого документа"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, docDescription)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if docDescription.subclass:
            return docDescription.subclass(*args_, **kwargs_)
        else:
            return docDescription(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_docDescription(self, value):
        result = True
        # Validate type docDescription, a restriction on xs:string.
        pass
        return result
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class docDescription


class url(GeneratedsSuper):
    """Ссылка для скачивания прикрепленного документа. Поле заполняется при
    передаче документов из ЕИС во внешние системы"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, url)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if url.subclass:
            return url.subclass(*args_, **kwargs_)
        else:
            return url(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_url(self, value):
        result = True
        # Validate type url, a restriction on xs:string.
        pass
        return result
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class url


class content(GeneratedsSuper):
    """Содержимое файла. Поле contentId или content должно быть заполнено при
    приеме в ЕИС документов от внешних систем"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, content)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if content.subclass:
            return content.subclass(*args_, **kwargs_)
        else:
            return content(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_content(self, value):
        result = True
        return result
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class content


class cryptoSigns(GeneratedsSuper):
    """Электронная подпись документа"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'signature': MemberSpec_('signature', 'xs:base64Binary', 1, 0, {'maxOccurs': 'unbounded', 'name': 'signature', 'type': 'signature'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, signature=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if signature is None:
            self.signature = []
        else:
            self.signature = signature
        self.signature_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, cryptoSigns)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if cryptoSigns.subclass:
            return cryptoSigns.subclass(*args_, **kwargs_)
        else:
            return cryptoSigns(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.signature
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'signature':
            obj_ = signature.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.signature.append(obj_)
            obj_.original_tagname_ = 'signature'
# end class cryptoSigns


class signature(GeneratedsSuper):
    """Электронная подписьТип электронной подписи:
    CAdES-BES;
    CAdES-A"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'type_': MemberSpec_('type_', 'base:signatureType', 0, 1, {'use': 'optional'}),
        'valueOf_': MemberSpec_('valueOf_', 'xs:base64Binary', 0),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_) + ['valueOf_']
    subclass = None
    superclass = None
    def __init__(self, type_=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, signature)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if signature.subclass:
            return signature.subclass(*args_, **kwargs_)
        else:
            return signature(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_signatureType(self, value):
        # Validate type base:signatureType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['CAdES-BES', 'CAdES-A']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on signatureType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
            self.validate_signatureType(self.type_)    # validate type signatureType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class signature


class zfcs_contactInfoType(GeneratedsSuper):
    """Контактная информация"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'orgPostAddress': MemberSpec_('orgPostAddress', ['zfcs_longTextType', 'xs:string'], 0, 0, {'name': 'orgPostAddress', 'type': 'xs:string'}, None),
        'orgFactAddress': MemberSpec_('orgFactAddress', ['zfcs_longTextType', 'xs:string'], 0, 0, {'name': 'orgFactAddress', 'type': 'xs:string'}, None),
        'contactPerson': MemberSpec_('contactPerson', 'zfcs_contactPersonType', 0, 0, {'name': 'contactPerson', 'type': 'zfcs_contactPersonType'}, None),
        'contactEMail': MemberSpec_('contactEMail', ['eMailType', 'xs:string'], 0, 0, {'name': 'contactEMail', 'type': 'xs:string'}, None),
        'contactPhone': MemberSpec_('contactPhone', ['phoneType', 'xs:string'], 0, 0, {'name': 'contactPhone', 'type': 'xs:string'}, None),
        'contactFax': MemberSpec_('contactFax', ['phoneType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'contactFax', 'type': 'xs:string'}, None),
        'addInfo': MemberSpec_('addInfo', ['zfcs_longTextType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'addInfo', 'type': 'xs:string'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, orgPostAddress=None, orgFactAddress=None, contactPerson=None, contactEMail=None, contactPhone=None, contactFax=None, addInfo=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.orgPostAddress = orgPostAddress
        self.validate_zfcs_longTextType(self.orgPostAddress)
        self.orgPostAddress_nsprefix_ = None
        self.orgFactAddress = orgFactAddress
        self.validate_zfcs_longTextType(self.orgFactAddress)
        self.orgFactAddress_nsprefix_ = None
        self.contactPerson = contactPerson
        self.contactPerson_nsprefix_ = None
        self.contactEMail = contactEMail
        self.validate_eMailType(self.contactEMail)
        self.contactEMail_nsprefix_ = None
        self.contactPhone = contactPhone
        self.validate_phoneType(self.contactPhone)
        self.contactPhone_nsprefix_ = None
        self.contactFax = contactFax
        self.validate_phoneType(self.contactFax)
        self.contactFax_nsprefix_ = None
        self.addInfo = addInfo
        self.validate_zfcs_longTextType(self.addInfo)
        self.addInfo_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, zfcs_contactInfoType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if zfcs_contactInfoType.subclass:
            return zfcs_contactInfoType.subclass(*args_, **kwargs_)
        else:
            return zfcs_contactInfoType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_zfcs_longTextType(self, value):
        result = True
        # Validate type zfcs_longTextType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 2000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on zfcs_longTextType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_eMailType(self, value):
        result = True
        # Validate type eMailType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 256:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on eMailType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on eMailType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_phoneType(self, value):
        result = True
        # Validate type phoneType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 30:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on phoneType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on phoneType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.orgPostAddress is not None or
            self.orgFactAddress is not None or
            self.contactPerson is not None or
            self.contactEMail is not None or
            self.contactPhone is not None or
            self.contactFax is not None or
            self.addInfo is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'orgPostAddress':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'orgPostAddress')
            value_ = self.gds_validate_string(value_, node, 'orgPostAddress')
            self.orgPostAddress = value_
            self.orgPostAddress_nsprefix_ = child_.prefix
            # validate type zfcs_longTextType
            self.validate_zfcs_longTextType(self.orgPostAddress)
        elif nodeName_ == 'orgFactAddress':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'orgFactAddress')
            value_ = self.gds_validate_string(value_, node, 'orgFactAddress')
            self.orgFactAddress = value_
            self.orgFactAddress_nsprefix_ = child_.prefix
            # validate type zfcs_longTextType
            self.validate_zfcs_longTextType(self.orgFactAddress)
        elif nodeName_ == 'contactPerson':
            obj_ = zfcs_contactPersonType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.contactPerson = obj_
            obj_.original_tagname_ = 'contactPerson'
        elif nodeName_ == 'contactEMail':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'contactEMail')
            value_ = self.gds_validate_string(value_, node, 'contactEMail')
            self.contactEMail = value_
            self.contactEMail_nsprefix_ = child_.prefix
            # validate type eMailType
            self.validate_eMailType(self.contactEMail)
        elif nodeName_ == 'contactPhone':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'contactPhone')
            value_ = self.gds_validate_string(value_, node, 'contactPhone')
            self.contactPhone = value_
            self.contactPhone_nsprefix_ = child_.prefix
            # validate type phoneType
            self.validate_phoneType(self.contactPhone)
        elif nodeName_ == 'contactFax':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'contactFax')
            value_ = self.gds_validate_string(value_, node, 'contactFax')
            self.contactFax = value_
            self.contactFax_nsprefix_ = child_.prefix
            # validate type phoneType
            self.validate_phoneType(self.contactFax)
        elif nodeName_ == 'addInfo':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'addInfo')
            value_ = self.gds_validate_string(value_, node, 'addInfo')
            self.addInfo = value_
            self.addInfo_nsprefix_ = child_.prefix
            # validate type zfcs_longTextType
            self.validate_zfcs_longTextType(self.addInfo)
# end class zfcs_contactInfoType


class zfcs_contactPersonType(GeneratedsSuper):
    """ФИО"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'lastName': MemberSpec_('lastName', ['lastName', 'xs:string'], 0, 0, {'name': 'lastName', 'type': 'xs:string'}, None),
        'firstName': MemberSpec_('firstName', ['firstName', 'xs:string'], 0, 0, {'name': 'firstName', 'type': 'xs:string'}, None),
        'middleName': MemberSpec_('middleName', ['middleName', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'middleName', 'type': 'xs:string'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, lastName=None, firstName=None, middleName=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.lastName = lastName
        self.lastName_nsprefix_ = None
        self.firstName = firstName
        self.firstName_nsprefix_ = None
        self.middleName = middleName
        self.middleName_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, zfcs_contactPersonType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if zfcs_contactPersonType.subclass:
            return zfcs_contactPersonType.subclass(*args_, **kwargs_)
        else:
            return zfcs_contactPersonType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.lastName is not None or
            self.firstName is not None or
            self.middleName is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'lastName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'lastName')
            value_ = self.gds_validate_string(value_, node, 'lastName')
            self.lastName = value_
            self.lastName_nsprefix_ = child_.prefix
        elif nodeName_ == 'firstName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'firstName')
            value_ = self.gds_validate_string(value_, node, 'firstName')
            self.firstName = value_
            self.firstName_nsprefix_ = child_.prefix
        elif nodeName_ == 'middleName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'middleName')
            value_ = self.gds_validate_string(value_, node, 'middleName')
            self.middleName = value_
            self.middleName_nsprefix_ = child_.prefix
# end class zfcs_contactPersonType


class zfcs_abandonedReasonType(GeneratedsSuper):
    """Основания признания процедуры несостоявшейся"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'code': MemberSpec_('code', ['abandonedReasonCode', 'xs:string'], 0, 0, {'name': 'code', 'type': 'xs:string'}, None),
        'objectName': MemberSpec_('objectName', ['abandonedReasonObjectName', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'objectName', 'type': 'xs:string'}, None),
        'name': MemberSpec_('name', ['abandonedReasonName', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'name', 'type': 'xs:string'}, None),
        'type_': MemberSpec_('type_', ['zfcs_abandonedReasonTypeEnum', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'type', 'type': 'xs:string'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, code=None, objectName=None, name=None, type_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.code = code
        self.validate_abandonedReasonCode(self.code)
        self.code_nsprefix_ = None
        self.objectName = objectName
        self.validate_abandonedReasonObjectName(self.objectName)
        self.objectName_nsprefix_ = None
        self.name = name
        self.validate_abandonedReasonName(self.name)
        self.name_nsprefix_ = None
        self.type_ = type_
        self.validate_zfcs_abandonedReasonTypeEnum(self.type_)
        self.type__nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, zfcs_abandonedReasonType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if zfcs_abandonedReasonType.subclass:
            return zfcs_abandonedReasonType.subclass(*args_, **kwargs_)
        else:
            return zfcs_abandonedReasonType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_abandonedReasonCode(self, value):
        result = True
        # Validate type abandonedReasonCode, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 20:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on abandonedReasonCode' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on abandonedReasonCode' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_abandonedReasonObjectName(self, value):
        result = True
        # Validate type abandonedReasonObjectName, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 350:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on abandonedReasonObjectName' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on abandonedReasonObjectName' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_abandonedReasonName(self, value):
        result = True
        # Validate type abandonedReasonName, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on abandonedReasonName' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on abandonedReasonName' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_zfcs_abandonedReasonTypeEnum(self, value):
        result = True
        # Validate type zfcs_abandonedReasonTypeEnum, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['OR', 'NR', 'OV', 'NV', 'OV2', 'O', 'NS', 'ON', 'OO', 'OV3', 'OP', 'OV4', 'NV4', 'NV3', 'NV2']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on zfcs_abandonedReasonTypeEnum' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.code is not None or
            self.objectName is not None or
            self.name is not None or
            self.type_ is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'code':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'code')
            value_ = self.gds_validate_string(value_, node, 'code')
            self.code = value_
            self.code_nsprefix_ = child_.prefix
            # validate type abandonedReasonCode
            self.validate_abandonedReasonCode(self.code)
        elif nodeName_ == 'objectName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'objectName')
            value_ = self.gds_validate_string(value_, node, 'objectName')
            self.objectName = value_
            self.objectName_nsprefix_ = child_.prefix
            # validate type abandonedReasonObjectName
            self.validate_abandonedReasonObjectName(self.objectName)
        elif nodeName_ == 'name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'name')
            value_ = self.gds_validate_string(value_, node, 'name')
            self.name = value_
            self.name_nsprefix_ = child_.prefix
            # validate type abandonedReasonName
            self.validate_abandonedReasonName(self.name)
        elif nodeName_ == 'type':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'type')
            value_ = self.gds_validate_string(value_, node, 'type')
            self.type_ = value_
            self.type_nsprefix_ = child_.prefix
            # validate type zfcs_abandonedReasonTypeEnum
            self.validate_zfcs_abandonedReasonTypeEnum(self.type_)
# end class zfcs_abandonedReasonType


class zfcs_baseRef(GeneratedsSuper):
    """Основание для решения по результатам общественного обсуждения"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'code': MemberSpec_('code', ['code', 'xs:string'], 0, 0, {'name': 'code', 'type': 'xs:string'}, None),
        'name': MemberSpec_('name', ['name', 'xs:string'], 0, 0, {'name': 'name', 'type': 'xs:string'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, code=None, name=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.code = code
        self.code_nsprefix_ = None
        self.name = name
        self.name_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, zfcs_baseRef)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if zfcs_baseRef.subclass:
            return zfcs_baseRef.subclass(*args_, **kwargs_)
        else:
            return zfcs_baseRef(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.code is not None or
            self.name is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'code':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'code')
            value_ = self.gds_validate_string(value_, node, 'code')
            self.code = value_
            self.code_nsprefix_ = child_.prefix
        elif nodeName_ == 'name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'name')
            value_ = self.gds_validate_string(value_, node, 'name')
            self.name = value_
            self.name_nsprefix_ = child_.prefix
# end class zfcs_baseRef


class code(GeneratedsSuper):
    """Код"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, code)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if code.subclass:
            return code.subclass(*args_, **kwargs_)
        else:
            return code(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_code(self, value):
        result = True
        # Validate type code, a restriction on xs:string.
        pass
        return result
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class code


class name(GeneratedsSuper):
    """Наименование"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, name)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if name.subclass:
            return name.subclass(*args_, **kwargs_)
        else:
            return name(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_name(self, value):
        result = True
        # Validate type name, a restriction on xs:string.
        pass
        return result
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class name


class zfcs_decisionRef(GeneratedsSuper):
    """Решение по общественному обсуждению"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'code': MemberSpec_('code', ['code', 'xs:string'], 0, 0, {'name': 'code', 'type': 'xs:string'}, None),
        'name': MemberSpec_('name', ['name', 'xs:string'], 0, 0, {'name': 'name', 'type': 'xs:string'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, code=None, name=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.code = code
        self.code_nsprefix_ = None
        self.name = name
        self.name_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, zfcs_decisionRef)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if zfcs_decisionRef.subclass:
            return zfcs_decisionRef.subclass(*args_, **kwargs_)
        else:
            return zfcs_decisionRef(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.code is not None or
            self.name is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'code':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'code')
            value_ = self.gds_validate_string(value_, node, 'code')
            self.code = value_
            self.code_nsprefix_ = child_.prefix
        elif nodeName_ == 'name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'name')
            value_ = self.gds_validate_string(value_, node, 'name')
            self.name = value_
            self.name_nsprefix_ = child_.prefix
# end class zfcs_decisionRef


class zfcs_timelineViolationType(GeneratedsSuper):
    """Уведомление о нарушении контроля времени получения подтвержденияВерсия
    схемы"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'schemeVersion': MemberSpec_('schemeVersion', 'base:schemeVersionType', 0, 0, {'use': 'required'}),
        'refId': MemberSpec_('refId', ['refId', 'xs:string'], 0, 0, {'name': 'refId', 'type': 'xs:string'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, schemeVersion=None, refId=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.schemeVersion = _cast(None, schemeVersion)
        self.schemeVersion_nsprefix_ = None
        self.refId = refId
        self.refId_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, zfcs_timelineViolationType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if zfcs_timelineViolationType.subclass:
            return zfcs_timelineViolationType.subclass(*args_, **kwargs_)
        else:
            return zfcs_timelineViolationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_schemeVersionType(self, value):
        # Validate type base:schemeVersionType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['1.0', '4.1', '4.2', '4.3', '4.3.100', '4.4', '4.4.2', '4.5', '4.6', '5.0', '5.1', '5.2', '6.0', '6.1', '6.2', '6.2.100', '6.3', '6.4', '7.0', '7.1', '7.2', '7.3', '7.5', '8.0', '8.1', '8.2', '8.2.100', '8.3', '9.0', '9.1', '9.2', '9.3', '10.0', '10.1', '10.2', '10.2.310', '10.3', '11.0']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on schemeVersionType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            self.refId is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('schemeVersion', node)
        if value is not None and 'schemeVersion' not in already_processed:
            already_processed.add('schemeVersion')
            self.schemeVersion = value
            self.validate_schemeVersionType(self.schemeVersion)    # validate type schemeVersionType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'refId':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'refId')
            value_ = self.gds_validate_string(value_, node, 'refId')
            self.refId = value_
            self.refId_nsprefix_ = child_.prefix
# end class zfcs_timelineViolationType


class refId(GeneratedsSuper):
    """Идентификатор обработанного пакета данных"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, refId)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if refId.subclass:
            return refId.subclass(*args_, **kwargs_)
        else:
            return refId(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_refId(self, value):
        result = True
        # Validate type refId, a restriction on xs:string.
        pass
        return result
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class refId


class zfcs_addInfoType(GeneratedsSuper):
    """Запись реестра дополнительной информацииВерсия схемы"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'schemeVersion': MemberSpec_('schemeVersion', 'base:schemeVersionType', 0, 0, {'use': 'required'}),
        'externalId': MemberSpec_('externalId', ['externalIdType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'externalId', 'type': 'xs:string'}, None),
        'id': MemberSpec_('id', 'xs:long', 0, 1, {'minOccurs': '0', 'name': 'id', 'type': 'xs:long'}, None),
        'registryNum': MemberSpec_('registryNum', ['purchaseNumberType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'registryNum', 'type': 'xs:string'}, None),
        'publishOrg': MemberSpec_('publishOrg', 'xs:string', 0, 0, {'name': 'publishOrg', 'type': 'xs:string'}, None),
        'versionNumber': MemberSpec_('versionNumber', ['zfcs_revisionNumType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'versionNumber', 'type': 'xs:string'}, None),
        'docPublishDate': MemberSpec_('docPublishDate', 'xs:dateTime', 0, 1, {'minOccurs': '0', 'name': 'docPublishDate', 'type': 'xs:dateTime'}, None),
        'firstPublishDate': MemberSpec_('firstPublishDate', 'xs:dateTime', 0, 1, {'minOccurs': '0', 'name': 'firstPublishDate', 'type': 'xs:dateTime'}, None),
        'href': MemberSpec_('href', ['hrefType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'href', 'type': 'xs:string'}, None),
        'printForm': MemberSpec_('printForm', 'xs:string', 0, 1, {'minOccurs': '0', 'name': 'printForm', 'type': 'xs:string'}, None),
        'infoType': MemberSpec_('infoType', ['zfcs_addInfoTypeEnum', 'xs:string'], 0, 0, {'name': 'infoType', 'type': 'xs:string'}, None),
        'contract': MemberSpec_('contract', 'contract', 0, 0, {'name': 'contract', 'type': 'contract'}, 3),
        'contractNotPublished': MemberSpec_('contractNotPublished', 'contractNotPublished', 0, 0, {'name': 'contractNotPublished', 'type': 'contractNotPublished'}, 3),
        'purchase': MemberSpec_('purchase', 'purchase', 0, 0, {'name': 'purchase', 'type': 'purchase'}, None),
        'contractor': MemberSpec_('contractor', 'contractor', 0, 0, {'name': 'contractor', 'type': 'contractor'}, None),
        'attachments': MemberSpec_('attachments', 'zfcs_attachmentListType', 0, 1, {'minOccurs': '0', 'name': 'attachments', 'type': 'zfcs_attachmentListType'}, None),
        'modificationReason': MemberSpec_('modificationReason', ['zfcs_longTextType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'modificationReason', 'type': 'xs:string'}, None),
        'extPrintForm': MemberSpec_('extPrintForm', 'xs:string', 0, 1, {'minOccurs': '0', 'name': 'extPrintForm', 'type': 'xs:string'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, schemeVersion=None, externalId=None, id=None, registryNum=None, publishOrg=None, versionNumber=None, docPublishDate=None, firstPublishDate=None, href=None, printForm=None, infoType=None, contract=None, contractNotPublished=None, purchase=None, contractor=None, attachments=None, modificationReason=None, extPrintForm=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.schemeVersion = _cast(None, schemeVersion)
        self.schemeVersion_nsprefix_ = None
        self.externalId = externalId
        self.validate_externalIdType(self.externalId)
        self.externalId_nsprefix_ = None
        self.id = id
        self.id_nsprefix_ = None
        self.registryNum = registryNum
        self.validate_purchaseNumberType(self.registryNum)
        self.registryNum_nsprefix_ = None
        self.publishOrg = publishOrg
        self.publishOrg_nsprefix_ = None
        self.versionNumber = versionNumber
        self.validate_zfcs_revisionNumType(self.versionNumber)
        self.versionNumber_nsprefix_ = None
        if isinstance(docPublishDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(docPublishDate, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = docPublishDate
        self.docPublishDate = initvalue_
        self.docPublishDate_nsprefix_ = None
        if isinstance(firstPublishDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(firstPublishDate, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = firstPublishDate
        self.firstPublishDate = initvalue_
        self.firstPublishDate_nsprefix_ = None
        self.href = href
        self.validate_hrefType(self.href)
        self.href_nsprefix_ = None
        self.printForm = printForm
        self.printForm_nsprefix_ = None
        self.infoType = infoType
        self.validate_zfcs_addInfoTypeEnum(self.infoType)
        self.infoType_nsprefix_ = None
        self.contract = contract
        self.contract_nsprefix_ = None
        self.contractNotPublished = contractNotPublished
        self.contractNotPublished_nsprefix_ = None
        self.purchase = purchase
        self.purchase_nsprefix_ = None
        self.contractor = contractor
        self.contractor_nsprefix_ = None
        self.attachments = attachments
        self.attachments_nsprefix_ = None
        self.modificationReason = modificationReason
        self.validate_zfcs_longTextType(self.modificationReason)
        self.modificationReason_nsprefix_ = None
        self.extPrintForm = extPrintForm
        self.extPrintForm_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, zfcs_addInfoType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if zfcs_addInfoType.subclass:
            return zfcs_addInfoType.subclass(*args_, **kwargs_)
        else:
            return zfcs_addInfoType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_externalIdType(self, value):
        result = True
        # Validate type externalIdType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 40:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on externalIdType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on externalIdType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_purchaseNumberType(self, value):
        result = True
        # Validate type purchaseNumberType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_purchaseNumberType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_purchaseNumberType_patterns_, ))
                result = False
        return result
    validate_purchaseNumberType_patterns_ = [['^(\\d{19})$']]
    def validate_zfcs_revisionNumType(self, value):
        result = True
        # Validate type zfcs_revisionNumType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 3:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on zfcs_revisionNumType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_zfcs_revisionNumType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_zfcs_revisionNumType_patterns_, ))
                result = False
        return result
    validate_zfcs_revisionNumType_patterns_ = [['^(\\d{1,3})$']]
    def validate_hrefType(self, value):
        result = True
        # Validate type hrefType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on hrefType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on hrefType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_zfcs_addInfoTypeEnum(self, value):
        result = True
        # Validate type zfcs_addInfoTypeEnum, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['O', 'B', 'S']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on zfcs_addInfoTypeEnum' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_zfcs_longTextType(self, value):
        result = True
        # Validate type zfcs_longTextType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 2000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on zfcs_longTextType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_schemeVersionType(self, value):
        # Validate type base:schemeVersionType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['1.0', '4.1', '4.2', '4.3', '4.3.100', '4.4', '4.4.2', '4.5', '4.6', '5.0', '5.1', '5.2', '6.0', '6.1', '6.2', '6.2.100', '6.3', '6.4', '7.0', '7.1', '7.2', '7.3', '7.5', '8.0', '8.1', '8.2', '8.2.100', '8.3', '9.0', '9.1', '9.2', '9.3', '10.0', '10.1', '10.2', '10.2.310', '10.3', '11.0']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on schemeVersionType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            self.externalId is not None or
            self.id is not None or
            self.registryNum is not None or
            self.publishOrg is not None or
            self.versionNumber is not None or
            self.docPublishDate is not None or
            self.firstPublishDate is not None or
            self.href is not None or
            self.printForm is not None or
            self.infoType is not None or
            self.contract is not None or
            self.contractNotPublished is not None or
            self.purchase is not None or
            self.contractor is not None or
            self.attachments is not None or
            self.modificationReason is not None or
            self.extPrintForm is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('schemeVersion', node)
        if value is not None and 'schemeVersion' not in already_processed:
            already_processed.add('schemeVersion')
            self.schemeVersion = value
            self.validate_schemeVersionType(self.schemeVersion)    # validate type schemeVersionType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'externalId':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'externalId')
            value_ = self.gds_validate_string(value_, node, 'externalId')
            self.externalId = value_
            self.externalId_nsprefix_ = child_.prefix
            # validate type externalIdType
            self.validate_externalIdType(self.externalId)
        elif nodeName_ == 'id' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'id')
            ival_ = self.gds_validate_integer(ival_, node, 'id')
            self.id = ival_
            self.id_nsprefix_ = child_.prefix
        elif nodeName_ == 'registryNum':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'registryNum')
            value_ = self.gds_validate_string(value_, node, 'registryNum')
            self.registryNum = value_
            self.registryNum_nsprefix_ = child_.prefix
            # validate type purchaseNumberType
            self.validate_purchaseNumberType(self.registryNum)
        elif nodeName_ == 'publishOrg':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'publishOrg')
            value_ = self.gds_validate_string(value_, node, 'publishOrg')
            self.publishOrg = value_
            self.publishOrg_nsprefix_ = child_.prefix
        elif nodeName_ == 'versionNumber':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'versionNumber')
            value_ = self.gds_validate_string(value_, node, 'versionNumber')
            self.versionNumber = value_
            self.versionNumber_nsprefix_ = child_.prefix
            # validate type zfcs_revisionNumType
            self.validate_zfcs_revisionNumType(self.versionNumber)
        elif nodeName_ == 'docPublishDate':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.docPublishDate = dval_
            self.docPublishDate_nsprefix_ = child_.prefix
        elif nodeName_ == 'firstPublishDate':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.firstPublishDate = dval_
            self.firstPublishDate_nsprefix_ = child_.prefix
        elif nodeName_ == 'href':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'href')
            value_ = self.gds_validate_string(value_, node, 'href')
            self.href = value_
            self.href_nsprefix_ = child_.prefix
            # validate type hrefType
            self.validate_hrefType(self.href)
        elif nodeName_ == 'printForm':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'printForm')
            value_ = self.gds_validate_string(value_, node, 'printForm')
            self.printForm = value_
            self.printForm_nsprefix_ = child_.prefix
        elif nodeName_ == 'infoType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'infoType')
            value_ = self.gds_validate_string(value_, node, 'infoType')
            self.infoType = value_
            self.infoType_nsprefix_ = child_.prefix
            # validate type zfcs_addInfoTypeEnum
            self.validate_zfcs_addInfoTypeEnum(self.infoType)
        elif nodeName_ == 'contract':
            obj_ = contract.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.contract = obj_
            obj_.original_tagname_ = 'contract'
        elif nodeName_ == 'contractNotPublished':
            obj_ = contractNotPublished.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.contractNotPublished = obj_
            obj_.original_tagname_ = 'contractNotPublished'
        elif nodeName_ == 'purchase':
            obj_ = purchase.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.purchase = obj_
            obj_.original_tagname_ = 'purchase'
        elif nodeName_ == 'contractor':
            obj_ = contractor.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.contractor = obj_
            obj_.original_tagname_ = 'contractor'
        elif nodeName_ == 'attachments':
            obj_ = zfcs_attachmentListType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.attachments = obj_
            obj_.original_tagname_ = 'attachments'
        elif nodeName_ == 'modificationReason':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'modificationReason')
            value_ = self.gds_validate_string(value_, node, 'modificationReason')
            self.modificationReason = value_
            self.modificationReason_nsprefix_ = child_.prefix
            # validate type zfcs_longTextType
            self.validate_zfcs_longTextType(self.modificationReason)
        elif nodeName_ == 'extPrintForm':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'extPrintForm')
            value_ = self.gds_validate_string(value_, node, 'extPrintForm')
            self.extPrintForm = value_
            self.extPrintForm_nsprefix_ = child_.prefix
# end class zfcs_addInfoType


class contract(GeneratedsSuper):
    """Информация о контракте размещена"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'regNum': MemberSpec_('regNum', 'xs:string', 0, 0, {'name': 'regNum', 'type': 'xs:string'}, 3),
        'number': MemberSpec_('number', ['zfcs_contract.Number2015Type', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'number', 'type': 'xs:string'}, 3),
        'defenseContractNumber': MemberSpec_('defenseContractNumber', ['zfcs_contract.defenseNum2015Type', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'defenseContractNumber', 'type': 'xs:string'}, 3),
        'signDate': MemberSpec_('signDate', 'xs:date', 0, 1, {'minOccurs': '0', 'name': 'signDate', 'type': 'xs:date'}, 3),
        'customer': MemberSpec_('customer', 'customer', 0, 1, {'minOccurs': '0', 'name': 'customer', 'type': 'xs:string'}, 3),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, regNum=None, number=None, defenseContractNumber=None, signDate=None, customer=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.regNum = regNum
        self.regNum_nsprefix_ = None
        self.number = number
        self.validate_zfcs_contract_Number2015Type(self.number)
        self.number_nsprefix_ = None
        self.defenseContractNumber = defenseContractNumber
        self.validate_zfcs_contract_defenseNum2015Type(self.defenseContractNumber)
        self.defenseContractNumber_nsprefix_ = None
        if isinstance(signDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(signDate, '%Y-%m-%d').date()
        else:
            initvalue_ = signDate
        self.signDate = initvalue_
        self.signDate_nsprefix_ = None
        self.customer = customer
        self.customer_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, contract)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if contract.subclass:
            return contract.subclass(*args_, **kwargs_)
        else:
            return contract(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_zfcs_contract_Number2015Type(self, value):
        result = True
        # Validate type zfcs_contract.Number2015Type, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 100:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on zfcs_contract.Number2015Type' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on zfcs_contract.Number2015Type' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_zfcs_contract_defenseNum2015Type(self, value):
        result = True
        # Validate type zfcs_contract.defenseNum2015Type, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 25:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on zfcs_contract.defenseNum2015Type' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on zfcs_contract.defenseNum2015Type' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.regNum is not None or
            self.number is not None or
            self.defenseContractNumber is not None or
            self.signDate is not None or
            self.customer is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'regNum':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'regNum')
            value_ = self.gds_validate_string(value_, node, 'regNum')
            self.regNum = value_
            self.regNum_nsprefix_ = child_.prefix
        elif nodeName_ == 'number':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'number')
            value_ = self.gds_validate_string(value_, node, 'number')
            self.number = value_
            self.number_nsprefix_ = child_.prefix
            # validate type zfcs_contract.Number2015Type
            self.validate_zfcs_contract_Number2015Type(self.number)
        elif nodeName_ == 'defenseContractNumber':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'defenseContractNumber')
            value_ = self.gds_validate_string(value_, node, 'defenseContractNumber')
            self.defenseContractNumber = value_
            self.defenseContractNumber_nsprefix_ = child_.prefix
            # validate type zfcs_contract.defenseNum2015Type
            self.validate_zfcs_contract_defenseNum2015Type(self.defenseContractNumber)
        elif nodeName_ == 'signDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.signDate = dval_
            self.signDate_nsprefix_ = child_.prefix
        elif nodeName_ == 'customer':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'customer')
            value_ = self.gds_validate_string(value_, node, 'customer')
            self.customer = value_
            self.customer_nsprefix_ = child_.prefix
# end class contract


class contractNotPublished(GeneratedsSuper):
    """Информация о контракте не размещена"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'number': MemberSpec_('number', ['zfcs_contract.Number2015Type', 'xs:string'], 0, 0, {'name': 'number', 'type': 'xs:string'}, 3),
        'signDate': MemberSpec_('signDate', 'xs:date', 0, 0, {'name': 'signDate', 'type': 'xs:date'}, 3),
        'customer': MemberSpec_('customer', 'customer', 0, 1, {'minOccurs': '0', 'name': 'customer', 'type': 'xs:string'}, 3),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, number=None, signDate=None, customer=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.number = number
        self.validate_zfcs_contract_Number2015Type(self.number)
        self.number_nsprefix_ = None
        if isinstance(signDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(signDate, '%Y-%m-%d').date()
        else:
            initvalue_ = signDate
        self.signDate = initvalue_
        self.signDate_nsprefix_ = None
        self.customer = customer
        self.customer_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, contractNotPublished)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if contractNotPublished.subclass:
            return contractNotPublished.subclass(*args_, **kwargs_)
        else:
            return contractNotPublished(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_zfcs_contract_Number2015Type(self, value):
        result = True
        # Validate type zfcs_contract.Number2015Type, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 100:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on zfcs_contract.Number2015Type' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on zfcs_contract.Number2015Type' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.number is not None or
            self.signDate is not None or
            self.customer is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'number':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'number')
            value_ = self.gds_validate_string(value_, node, 'number')
            self.number = value_
            self.number_nsprefix_ = child_.prefix
            # validate type zfcs_contract.Number2015Type
            self.validate_zfcs_contract_Number2015Type(self.number)
        elif nodeName_ == 'signDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.signDate = dval_
            self.signDate_nsprefix_ = child_.prefix
        elif nodeName_ == 'customer':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'customer')
            value_ = self.gds_validate_string(value_, node, 'customer')
            self.customer = value_
            self.customer_nsprefix_ = child_.prefix
# end class contractNotPublished


class purchase(GeneratedsSuper):
    """Закупка"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'purchaseNumber': MemberSpec_('purchaseNumber', ['purchaseNumberType', 'xs:string'], 0, 0, {'name': 'purchaseNumber', 'type': 'xs:string'}, None),
        'lotNumber': MemberSpec_('lotNumber', 'xs:integer', 0, 1, {'minOccurs': '0', 'name': 'lotNumber', 'type': 'xs:integer'}, None),
        'purchaseObjectInfo': MemberSpec_('purchaseObjectInfo', ['zfcs_longTextMinType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'purchaseObjectInfo', 'type': 'xs:string'}, None),
        'placingWay': MemberSpec_('placingWay', 'placingWay', 0, 1, {'minOccurs': '0', 'name': 'placingWay', 'type': 'placingWay'}, None),
        'customer': MemberSpec_('customer', 'customer', 0, 1, {'minOccurs': '0', 'name': 'customer', 'type': 'xs:string'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, purchaseNumber=None, lotNumber=None, purchaseObjectInfo=None, placingWay=None, customer=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.purchaseNumber = purchaseNumber
        self.validate_purchaseNumberType(self.purchaseNumber)
        self.purchaseNumber_nsprefix_ = None
        self.lotNumber = lotNumber
        self.lotNumber_nsprefix_ = None
        self.purchaseObjectInfo = purchaseObjectInfo
        self.validate_zfcs_longTextMinType(self.purchaseObjectInfo)
        self.purchaseObjectInfo_nsprefix_ = None
        self.placingWay = placingWay
        self.placingWay_nsprefix_ = None
        self.customer = customer
        self.customer_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, purchase)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if purchase.subclass:
            return purchase.subclass(*args_, **kwargs_)
        else:
            return purchase(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_purchaseNumberType(self, value):
        result = True
        # Validate type purchaseNumberType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_purchaseNumberType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_purchaseNumberType_patterns_, ))
                result = False
        return result
    validate_purchaseNumberType_patterns_ = [['^(\\d{19})$']]
    def validate_zfcs_longTextMinType(self, value):
        result = True
        # Validate type zfcs_longTextMinType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 2000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on zfcs_longTextMinType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on zfcs_longTextMinType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.purchaseNumber is not None or
            self.lotNumber is not None or
            self.purchaseObjectInfo is not None or
            self.placingWay is not None or
            self.customer is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'purchaseNumber':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'purchaseNumber')
            value_ = self.gds_validate_string(value_, node, 'purchaseNumber')
            self.purchaseNumber = value_
            self.purchaseNumber_nsprefix_ = child_.prefix
            # validate type purchaseNumberType
            self.validate_purchaseNumberType(self.purchaseNumber)
        elif nodeName_ == 'lotNumber' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'lotNumber')
            ival_ = self.gds_validate_integer(ival_, node, 'lotNumber')
            self.lotNumber = ival_
            self.lotNumber_nsprefix_ = child_.prefix
        elif nodeName_ == 'purchaseObjectInfo':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'purchaseObjectInfo')
            value_ = self.gds_validate_string(value_, node, 'purchaseObjectInfo')
            self.purchaseObjectInfo = value_
            self.purchaseObjectInfo_nsprefix_ = child_.prefix
            # validate type zfcs_longTextMinType
            self.validate_zfcs_longTextMinType(self.purchaseObjectInfo)
        elif nodeName_ == 'placingWay':
            obj_ = placingWay.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.placingWay = obj_
            obj_.original_tagname_ = 'placingWay'
        elif nodeName_ == 'customer':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'customer')
            value_ = self.gds_validate_string(value_, node, 'customer')
            self.customer = value_
            self.customer_nsprefix_ = child_.prefix
# end class purchase


class placingWay(GeneratedsSuper):
    """Подспособ определения поставщика (для печатной формы). Игнорируется при
    приеме. Автоматически определяется из сведений о закупке"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'code': MemberSpec_('code', ['placingWayCodeType', 'xs:string'], 0, 0, {'name': 'code', 'type': 'xs:string'}, None),
        'name': MemberSpec_('name', ['name', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'name', 'type': 'xs:string'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, code=None, name=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.code = code
        self.validate_placingWayCodeType(self.code)
        self.code_nsprefix_ = None
        self.name = name
        self.name_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, placingWay)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if placingWay.subclass:
            return placingWay.subclass(*args_, **kwargs_)
        else:
            return placingWay(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_placingWayCodeType(self, value):
        result = True
        # Validate type placingWayCodeType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 7:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on placingWayCodeType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on placingWayCodeType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.code is not None or
            self.name is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'code':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'code')
            value_ = self.gds_validate_string(value_, node, 'code')
            self.code = value_
            self.code_nsprefix_ = child_.prefix
            # validate type placingWayCodeType
            self.validate_placingWayCodeType(self.code)
        elif nodeName_ == 'name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'name')
            value_ = self.gds_validate_string(value_, node, 'name')
            self.name = value_
            self.name_nsprefix_ = child_.prefix
# end class placingWay


class contractor(GeneratedsSuper):
    """Поставщик (подрядчик, исполнитель)"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'organizationRF': MemberSpec_('organizationRF', 'organizationRF', 0, 0, {'name': 'organizationRF', 'type': 'organizationRF'}, 4),
        'personRF': MemberSpec_('personRF', 'personRF', 0, 0, {'name': 'personRF', 'type': 'personRF'}, 4),
        'organizationForeignState': MemberSpec_('organizationForeignState', 'organizationForeignState', 0, 0, {'name': 'organizationForeignState', 'type': 'organizationForeignState'}, 4),
        'personForeignState': MemberSpec_('personForeignState', 'personForeignState', 0, 0, {'name': 'personForeignState', 'type': 'personForeignState'}, 4),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, organizationRF=None, personRF=None, organizationForeignState=None, personForeignState=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.organizationRF = organizationRF
        self.organizationRF_nsprefix_ = None
        self.personRF = personRF
        self.personRF_nsprefix_ = None
        self.organizationForeignState = organizationForeignState
        self.organizationForeignState_nsprefix_ = None
        self.personForeignState = personForeignState
        self.personForeignState_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, contractor)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if contractor.subclass:
            return contractor.subclass(*args_, **kwargs_)
        else:
            return contractor(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.organizationRF is not None or
            self.personRF is not None or
            self.organizationForeignState is not None or
            self.personForeignState is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'organizationRF':
            obj_ = organizationRF.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.organizationRF = obj_
            obj_.original_tagname_ = 'organizationRF'
        elif nodeName_ == 'personRF':
            obj_ = personRF.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.personRF = obj_
            obj_.original_tagname_ = 'personRF'
        elif nodeName_ == 'organizationForeignState':
            obj_ = organizationForeignState.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.organizationForeignState = obj_
            obj_.original_tagname_ = 'organizationForeignState'
        elif nodeName_ == 'personForeignState':
            obj_ = personForeignState.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.personForeignState = obj_
            obj_.original_tagname_ = 'personForeignState'
# end class contractor


class organizationRF(GeneratedsSuper):
    """Юридическое лицо РФ"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'fullName': MemberSpec_('fullName', ['zfcs_longTextType', 'xs:string'], 0, 0, {'name': 'fullName', 'type': 'xs:string'}, 4),
        'firmName': MemberSpec_('firmName', ['zfcs_longTextMinType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'firmName', 'type': 'xs:string'}, 4),
        'inn': MemberSpec_('inn', ['innOrganizationType', 'xs:string'], 0, 0, {'name': 'inn', 'type': 'xs:string'}, 4),
        'kpp': MemberSpec_('kpp', ['kppType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'kpp', 'type': 'xs:string'}, 4),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, fullName=None, firmName=None, inn=None, kpp=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.fullName = fullName
        self.validate_zfcs_longTextType(self.fullName)
        self.fullName_nsprefix_ = None
        self.firmName = firmName
        self.validate_zfcs_longTextMinType(self.firmName)
        self.firmName_nsprefix_ = None
        self.inn = inn
        self.validate_innOrganizationType(self.inn)
        self.inn_nsprefix_ = None
        self.kpp = kpp
        self.validate_kppType(self.kpp)
        self.kpp_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, organizationRF)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if organizationRF.subclass:
            return organizationRF.subclass(*args_, **kwargs_)
        else:
            return organizationRF(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_zfcs_longTextType(self, value):
        result = True
        # Validate type zfcs_longTextType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 2000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on zfcs_longTextType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_zfcs_longTextMinType(self, value):
        result = True
        # Validate type zfcs_longTextMinType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 2000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on zfcs_longTextMinType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on zfcs_longTextMinType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_innOrganizationType(self, value):
        result = True
        # Validate type innOrganizationType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_innOrganizationType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_innOrganizationType_patterns_, ))
                result = False
        return result
    validate_innOrganizationType_patterns_ = [['^(\\d{10})$']]
    def validate_kppType(self, value):
        result = True
        # Validate type kppType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) != 9:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd length restriction on kppType' % {"value": encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.fullName is not None or
            self.firmName is not None or
            self.inn is not None or
            self.kpp is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'fullName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'fullName')
            value_ = self.gds_validate_string(value_, node, 'fullName')
            self.fullName = value_
            self.fullName_nsprefix_ = child_.prefix
            # validate type zfcs_longTextType
            self.validate_zfcs_longTextType(self.fullName)
        elif nodeName_ == 'firmName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'firmName')
            value_ = self.gds_validate_string(value_, node, 'firmName')
            self.firmName = value_
            self.firmName_nsprefix_ = child_.prefix
            # validate type zfcs_longTextMinType
            self.validate_zfcs_longTextMinType(self.firmName)
        elif nodeName_ == 'inn':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'inn')
            value_ = self.gds_validate_string(value_, node, 'inn')
            self.inn = value_
            self.inn_nsprefix_ = child_.prefix
            # validate type innOrganizationType
            self.validate_innOrganizationType(self.inn)
        elif nodeName_ == 'kpp':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'kpp')
            value_ = self.gds_validate_string(value_, node, 'kpp')
            self.kpp = value_
            self.kpp_nsprefix_ = child_.prefix
            # validate type kppType
            self.validate_kppType(self.kpp)
# end class organizationRF


class personRF(GeneratedsSuper):
    """Физическое лицо РФ"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'name': MemberSpec_('name', 'zfcs_contactPersonType', 0, 0, {'name': 'name', 'type': 'zfcs_contactPersonType'}, 4),
        'inn': MemberSpec_('inn', ['innIndividualType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'inn', 'type': 'xs:string'}, 4),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, name=None, inn=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.name = name
        self.name_nsprefix_ = None
        self.inn = inn
        self.validate_innIndividualType(self.inn)
        self.inn_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, personRF)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if personRF.subclass:
            return personRF.subclass(*args_, **kwargs_)
        else:
            return personRF(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_innIndividualType(self, value):
        result = True
        # Validate type innIndividualType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_innIndividualType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_innIndividualType_patterns_, ))
                result = False
        return result
    validate_innIndividualType_patterns_ = [['^(\\d{12})$']]
    def hasContent_(self):
        if (
            self.name is not None or
            self.inn is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'name':
            obj_ = zfcs_contactPersonType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.name = obj_
            obj_.original_tagname_ = 'name'
        elif nodeName_ == 'inn':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'inn')
            value_ = self.gds_validate_string(value_, node, 'inn')
            self.inn = value_
            self.inn_nsprefix_ = child_.prefix
            # validate type innIndividualType
            self.validate_innIndividualType(self.inn)
# end class personRF


class organizationForeignState(GeneratedsSuper):
    """Юридическое лицо иностранного государства"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'fullName': MemberSpec_('fullName', ['zfcs_longTextType', 'xs:string'], 0, 0, {'name': 'fullName', 'type': 'xs:string'}, 4),
        'firmName': MemberSpec_('firmName', ['zfcs_longTextMinType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'firmName', 'type': 'xs:string'}, 4),
        'inn': MemberSpec_('inn', ['zfcs_innAnalogType', 'xs:string'], 0, 0, {'name': 'inn', 'type': 'xs:string'}, 4),
        'kpp': MemberSpec_('kpp', ['kppType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'kpp', 'type': 'xs:string'}, 4),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, fullName=None, firmName=None, inn=None, kpp=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.fullName = fullName
        self.validate_zfcs_longTextType(self.fullName)
        self.fullName_nsprefix_ = None
        self.firmName = firmName
        self.validate_zfcs_longTextMinType(self.firmName)
        self.firmName_nsprefix_ = None
        self.inn = inn
        self.validate_zfcs_innAnalogType(self.inn)
        self.inn_nsprefix_ = None
        self.kpp = kpp
        self.validate_kppType(self.kpp)
        self.kpp_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, organizationForeignState)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if organizationForeignState.subclass:
            return organizationForeignState.subclass(*args_, **kwargs_)
        else:
            return organizationForeignState(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_zfcs_longTextType(self, value):
        result = True
        # Validate type zfcs_longTextType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 2000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on zfcs_longTextType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_zfcs_longTextMinType(self, value):
        result = True
        # Validate type zfcs_longTextMinType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 2000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on zfcs_longTextMinType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on zfcs_longTextMinType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_zfcs_innAnalogType(self, value):
        result = True
        # Validate type zfcs_innAnalogType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 20:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on zfcs_innAnalogType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_zfcs_innAnalogType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_zfcs_innAnalogType_patterns_, ))
                result = False
        return result
    validate_zfcs_innAnalogType_patterns_ = [['^(\\d+)$']]
    def validate_kppType(self, value):
        result = True
        # Validate type kppType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) != 9:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd length restriction on kppType' % {"value": encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.fullName is not None or
            self.firmName is not None or
            self.inn is not None or
            self.kpp is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'fullName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'fullName')
            value_ = self.gds_validate_string(value_, node, 'fullName')
            self.fullName = value_
            self.fullName_nsprefix_ = child_.prefix
            # validate type zfcs_longTextType
            self.validate_zfcs_longTextType(self.fullName)
        elif nodeName_ == 'firmName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'firmName')
            value_ = self.gds_validate_string(value_, node, 'firmName')
            self.firmName = value_
            self.firmName_nsprefix_ = child_.prefix
            # validate type zfcs_longTextMinType
            self.validate_zfcs_longTextMinType(self.firmName)
        elif nodeName_ == 'inn':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'inn')
            value_ = self.gds_validate_string(value_, node, 'inn')
            self.inn = value_
            self.inn_nsprefix_ = child_.prefix
            # validate type zfcs_innAnalogType
            self.validate_zfcs_innAnalogType(self.inn)
        elif nodeName_ == 'kpp':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'kpp')
            value_ = self.gds_validate_string(value_, node, 'kpp')
            self.kpp = value_
            self.kpp_nsprefix_ = child_.prefix
            # validate type kppType
            self.validate_kppType(self.kpp)
# end class organizationForeignState


class personForeignState(GeneratedsSuper):
    """Физическое лицо иностранного государства"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'name': MemberSpec_('name', 'zfcs_contactPersonType', 0, 0, {'name': 'name', 'type': 'zfcs_contactPersonType'}, 4),
        'inn': MemberSpec_('inn', ['zfcs_innAnalogType', 'xs:string'], 0, 0, {'name': 'inn', 'type': 'xs:string'}, 4),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, name=None, inn=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.name = name
        self.name_nsprefix_ = None
        self.inn = inn
        self.validate_zfcs_innAnalogType(self.inn)
        self.inn_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, personForeignState)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if personForeignState.subclass:
            return personForeignState.subclass(*args_, **kwargs_)
        else:
            return personForeignState(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_zfcs_innAnalogType(self, value):
        result = True
        # Validate type zfcs_innAnalogType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 20:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on zfcs_innAnalogType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_zfcs_innAnalogType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_zfcs_innAnalogType_patterns_, ))
                result = False
        return result
    validate_zfcs_innAnalogType_patterns_ = [['^(\\d+)$']]
    def hasContent_(self):
        if (
            self.name is not None or
            self.inn is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'name':
            obj_ = zfcs_contactPersonType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.name = obj_
            obj_.original_tagname_ = 'name'
        elif nodeName_ == 'inn':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'inn')
            value_ = self.gds_validate_string(value_, node, 'inn')
            self.inn = value_
            self.inn_nsprefix_ = child_.prefix
            # validate type zfcs_innAnalogType
            self.validate_zfcs_innAnalogType(self.inn)
# end class personForeignState


class zfcs_addInfoInvalidType(GeneratedsSuper):
    """Информация о недействительности записи реестра дополнительной
    информацииВерсия схемы"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'schemeVersion': MemberSpec_('schemeVersion', 'base:schemeVersionType', 0, 0, {'use': 'required'}),
        'externalId': MemberSpec_('externalId', ['externalIdType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'externalId', 'type': 'xs:string'}, None),
        'id': MemberSpec_('id', 'xs:long', 0, 1, {'minOccurs': '0', 'name': 'id', 'type': 'xs:long'}, None),
        'registryNum': MemberSpec_('registryNum', ['purchaseNumberType', 'xs:string'], 0, 0, {'name': 'registryNum', 'type': 'xs:string'}, None),
        'publishOrg': MemberSpec_('publishOrg', 'xs:string', 0, 0, {'name': 'publishOrg', 'type': 'xs:string'}, None),
        'versionNumber': MemberSpec_('versionNumber', ['zfcs_revisionNumType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'versionNumber', 'type': 'xs:string'}, None),
        'docPublishDate': MemberSpec_('docPublishDate', 'xs:dateTime', 0, 1, {'minOccurs': '0', 'name': 'docPublishDate', 'type': 'xs:dateTime'}, None),
        'firstPublishDate': MemberSpec_('firstPublishDate', 'xs:dateTime', 0, 1, {'minOccurs': '0', 'name': 'firstPublishDate', 'type': 'xs:dateTime'}, None),
        'href': MemberSpec_('href', ['hrefType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'href', 'type': 'xs:string'}, None),
        'printForm': MemberSpec_('printForm', 'xs:string', 0, 1, {'minOccurs': '0', 'name': 'printForm', 'type': 'xs:string'}, None),
        'infoType': MemberSpec_('infoType', ['zfcs_addInfoTypeEnum', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'infoType', 'type': 'xs:string'}, None),
        'invalidityInfo': MemberSpec_('invalidityInfo', 'invalidityInfo', 0, 0, {'name': 'invalidityInfo', 'type': 'invalidityInfo'}, None),
        'contract': MemberSpec_('contract', 'contract', 0, 1, {'minOccurs': '0', 'name': 'contract', 'type': 'contract'}, 6),
        'contractNotPublished': MemberSpec_('contractNotPublished', 'contractNotPublished', 0, 1, {'minOccurs': '0', 'name': 'contractNotPublished', 'type': 'contractNotPublished'}, 6),
        'purchase': MemberSpec_('purchase', 'purchase', 0, 1, {'minOccurs': '0', 'name': 'purchase', 'type': 'purchase'}, None),
        'contractor': MemberSpec_('contractor', 'contractor', 0, 1, {'minOccurs': '0', 'name': 'contractor', 'type': 'contractor'}, None),
        'attachments': MemberSpec_('attachments', 'zfcs_attachmentListType', 0, 1, {'minOccurs': '0', 'name': 'attachments', 'type': 'zfcs_attachmentListType'}, None),
        'extPrintForm': MemberSpec_('extPrintForm', 'xs:string', 0, 1, {'minOccurs': '0', 'name': 'extPrintForm', 'type': 'xs:string'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, schemeVersion=None, externalId=None, id=None, registryNum=None, publishOrg=None, versionNumber=None, docPublishDate=None, firstPublishDate=None, href=None, printForm=None, infoType=None, invalidityInfo=None, contract=None, contractNotPublished=None, purchase=None, contractor=None, attachments=None, extPrintForm=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.schemeVersion = _cast(None, schemeVersion)
        self.schemeVersion_nsprefix_ = None
        self.externalId = externalId
        self.validate_externalIdType(self.externalId)
        self.externalId_nsprefix_ = None
        self.id = id
        self.id_nsprefix_ = None
        self.registryNum = registryNum
        self.validate_purchaseNumberType(self.registryNum)
        self.registryNum_nsprefix_ = None
        self.publishOrg = publishOrg
        self.publishOrg_nsprefix_ = None
        self.versionNumber = versionNumber
        self.validate_zfcs_revisionNumType(self.versionNumber)
        self.versionNumber_nsprefix_ = None
        if isinstance(docPublishDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(docPublishDate, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = docPublishDate
        self.docPublishDate = initvalue_
        self.docPublishDate_nsprefix_ = None
        if isinstance(firstPublishDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(firstPublishDate, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = firstPublishDate
        self.firstPublishDate = initvalue_
        self.firstPublishDate_nsprefix_ = None
        self.href = href
        self.validate_hrefType(self.href)
        self.href_nsprefix_ = None
        self.printForm = printForm
        self.printForm_nsprefix_ = None
        self.infoType = infoType
        self.validate_zfcs_addInfoTypeEnum(self.infoType)
        self.infoType_nsprefix_ = None
        self.invalidityInfo = invalidityInfo
        self.invalidityInfo_nsprefix_ = None
        self.contract = contract
        self.contract_nsprefix_ = None
        self.contractNotPublished = contractNotPublished
        self.contractNotPublished_nsprefix_ = None
        self.purchase = purchase
        self.purchase_nsprefix_ = None
        self.contractor = contractor
        self.contractor_nsprefix_ = None
        self.attachments = attachments
        self.attachments_nsprefix_ = None
        self.extPrintForm = extPrintForm
        self.extPrintForm_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, zfcs_addInfoInvalidType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if zfcs_addInfoInvalidType.subclass:
            return zfcs_addInfoInvalidType.subclass(*args_, **kwargs_)
        else:
            return zfcs_addInfoInvalidType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_externalIdType(self, value):
        result = True
        # Validate type externalIdType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 40:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on externalIdType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on externalIdType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_purchaseNumberType(self, value):
        result = True
        # Validate type purchaseNumberType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_purchaseNumberType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_purchaseNumberType_patterns_, ))
                result = False
        return result
    validate_purchaseNumberType_patterns_ = [['^(\\d{19})$']]
    def validate_zfcs_revisionNumType(self, value):
        result = True
        # Validate type zfcs_revisionNumType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 3:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on zfcs_revisionNumType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_zfcs_revisionNumType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_zfcs_revisionNumType_patterns_, ))
                result = False
        return result
    validate_zfcs_revisionNumType_patterns_ = [['^(\\d{1,3})$']]
    def validate_hrefType(self, value):
        result = True
        # Validate type hrefType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on hrefType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on hrefType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_zfcs_addInfoTypeEnum(self, value):
        result = True
        # Validate type zfcs_addInfoTypeEnum, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['O', 'B', 'S']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on zfcs_addInfoTypeEnum' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_schemeVersionType(self, value):
        # Validate type base:schemeVersionType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['1.0', '4.1', '4.2', '4.3', '4.3.100', '4.4', '4.4.2', '4.5', '4.6', '5.0', '5.1', '5.2', '6.0', '6.1', '6.2', '6.2.100', '6.3', '6.4', '7.0', '7.1', '7.2', '7.3', '7.5', '8.0', '8.1', '8.2', '8.2.100', '8.3', '9.0', '9.1', '9.2', '9.3', '10.0', '10.1', '10.2', '10.2.310', '10.3', '11.0']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on schemeVersionType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            self.externalId is not None or
            self.id is not None or
            self.registryNum is not None or
            self.publishOrg is not None or
            self.versionNumber is not None or
            self.docPublishDate is not None or
            self.firstPublishDate is not None or
            self.href is not None or
            self.printForm is not None or
            self.infoType is not None or
            self.invalidityInfo is not None or
            self.contract is not None or
            self.contractNotPublished is not None or
            self.purchase is not None or
            self.contractor is not None or
            self.attachments is not None or
            self.extPrintForm is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('schemeVersion', node)
        if value is not None and 'schemeVersion' not in already_processed:
            already_processed.add('schemeVersion')
            self.schemeVersion = value
            self.validate_schemeVersionType(self.schemeVersion)    # validate type schemeVersionType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'externalId':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'externalId')
            value_ = self.gds_validate_string(value_, node, 'externalId')
            self.externalId = value_
            self.externalId_nsprefix_ = child_.prefix
            # validate type externalIdType
            self.validate_externalIdType(self.externalId)
        elif nodeName_ == 'id' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'id')
            ival_ = self.gds_validate_integer(ival_, node, 'id')
            self.id = ival_
            self.id_nsprefix_ = child_.prefix
        elif nodeName_ == 'registryNum':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'registryNum')
            value_ = self.gds_validate_string(value_, node, 'registryNum')
            self.registryNum = value_
            self.registryNum_nsprefix_ = child_.prefix
            # validate type purchaseNumberType
            self.validate_purchaseNumberType(self.registryNum)
        elif nodeName_ == 'publishOrg':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'publishOrg')
            value_ = self.gds_validate_string(value_, node, 'publishOrg')
            self.publishOrg = value_
            self.publishOrg_nsprefix_ = child_.prefix
        elif nodeName_ == 'versionNumber':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'versionNumber')
            value_ = self.gds_validate_string(value_, node, 'versionNumber')
            self.versionNumber = value_
            self.versionNumber_nsprefix_ = child_.prefix
            # validate type zfcs_revisionNumType
            self.validate_zfcs_revisionNumType(self.versionNumber)
        elif nodeName_ == 'docPublishDate':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.docPublishDate = dval_
            self.docPublishDate_nsprefix_ = child_.prefix
        elif nodeName_ == 'firstPublishDate':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.firstPublishDate = dval_
            self.firstPublishDate_nsprefix_ = child_.prefix
        elif nodeName_ == 'href':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'href')
            value_ = self.gds_validate_string(value_, node, 'href')
            self.href = value_
            self.href_nsprefix_ = child_.prefix
            # validate type hrefType
            self.validate_hrefType(self.href)
        elif nodeName_ == 'printForm':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'printForm')
            value_ = self.gds_validate_string(value_, node, 'printForm')
            self.printForm = value_
            self.printForm_nsprefix_ = child_.prefix
        elif nodeName_ == 'infoType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'infoType')
            value_ = self.gds_validate_string(value_, node, 'infoType')
            self.infoType = value_
            self.infoType_nsprefix_ = child_.prefix
            # validate type zfcs_addInfoTypeEnum
            self.validate_zfcs_addInfoTypeEnum(self.infoType)
        elif nodeName_ == 'invalidityInfo':
            obj_ = invalidityInfo.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.invalidityInfo = obj_
            obj_.original_tagname_ = 'invalidityInfo'
        elif nodeName_ == 'contract':
            obj_ = contract.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.contract = obj_
            obj_.original_tagname_ = 'contract'
        elif nodeName_ == 'contractNotPublished':
            obj_ = contractNotPublished.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.contractNotPublished = obj_
            obj_.original_tagname_ = 'contractNotPublished'
        elif nodeName_ == 'purchase':
            obj_ = purchase.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.purchase = obj_
            obj_.original_tagname_ = 'purchase'
        elif nodeName_ == 'contractor':
            obj_ = contractor.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.contractor = obj_
            obj_.original_tagname_ = 'contractor'
        elif nodeName_ == 'attachments':
            obj_ = zfcs_attachmentListType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.attachments = obj_
            obj_.original_tagname_ = 'attachments'
        elif nodeName_ == 'extPrintForm':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'extPrintForm')
            value_ = self.gds_validate_string(value_, node, 'extPrintForm')
            self.extPrintForm = value_
            self.extPrintForm_nsprefix_ = child_.prefix
# end class zfcs_addInfoInvalidType


class invalidityInfo(GeneratedsSuper):
    """Информация о недействительности"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'date': MemberSpec_('date', 'xs:dateTime', 0, 1, {'minOccurs': '0', 'name': 'date', 'type': 'xs:dateTime'}, None),
        'reason': MemberSpec_('reason', ['zfcs_longTextMinType', 'xs:string'], 0, 0, {'name': 'reason', 'type': 'xs:string'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, date=None, reason=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if isinstance(date, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(date, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = date
        self.date = initvalue_
        self.date_nsprefix_ = None
        self.reason = reason
        self.validate_zfcs_longTextMinType(self.reason)
        self.reason_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, invalidityInfo)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if invalidityInfo.subclass:
            return invalidityInfo.subclass(*args_, **kwargs_)
        else:
            return invalidityInfo(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_zfcs_longTextMinType(self, value):
        result = True
        # Validate type zfcs_longTextMinType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 2000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on zfcs_longTextMinType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on zfcs_longTextMinType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.date is not None or
            self.reason is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'date':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.date = dval_
            self.date_nsprefix_ = child_.prefix
        elif nodeName_ == 'reason':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'reason')
            value_ = self.gds_validate_string(value_, node, 'reason')
            self.reason = value_
            self.reason_nsprefix_ = child_.prefix
            # validate type zfcs_longTextMinType
            self.validate_zfcs_longTextMinType(self.reason)
# end class invalidityInfo


class zfcs_contract2015Type(GeneratedsSuper):
    """Информация (проект информации) о заключенном контракте с
    01.01.2015Версия схемы"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'schemeVersion': MemberSpec_('schemeVersion', 'base:schemeVersionType', 0, 0, {'use': 'required'}),
        'id': MemberSpec_('id', 'xs:long', 0, 1, {'minOccurs': '0', 'name': 'id', 'type': 'xs:long'}, None),
        'externalId': MemberSpec_('externalId', ['externalIdType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'externalId', 'type': 'xs:string'}, None),
        'directDate': MemberSpec_('directDate', 'xs:dateTime', 0, 1, {'minOccurs': '0', 'name': 'directDate', 'type': 'xs:dateTime'}, None),
        'publishDate': MemberSpec_('publishDate', 'xs:dateTime', 0, 1, {'minOccurs': '0', 'name': 'publishDate', 'type': 'xs:dateTime'}, None),
        'versionNumber': MemberSpec_('versionNumber', ['versionNumberType', 'xs:int'], 0, 1, {'minOccurs': '0', 'name': 'versionNumber', 'type': 'xs:int'}, None),
        'foundation': MemberSpec_('foundation', 'foundation', 0, 0, {'name': 'foundation', 'type': 'foundation'}, None),
        'conclusionContractSt95Ch17_1': MemberSpec_('conclusionContractSt95Ch17_1', 'xs:boolean', 0, 1, {'minOccurs': '0', 'name': 'conclusionContractSt95Ch17.1', 'type': 'xs:boolean'}, None),
        'customer': MemberSpec_('customer', 'zfcs_organizationRef', 0, 0, {'name': 'customer', 'type': 'customer'}, None),
        'placer': MemberSpec_('placer', 'placer', 0, 1, {'minOccurs': '0', 'name': 'placer', 'type': 'placer'}, None),
        'finances': MemberSpec_('finances', 'finances', 0, 0, {'name': 'finances', 'type': 'finances'}, None),
        'protocolDate': MemberSpec_('protocolDate', 'xs:date', 0, 1, {'minOccurs': '0', 'name': 'protocolDate', 'type': 'xs:date'}, None),
        'documentBase': MemberSpec_('documentBase', ['zfcs_longTextMinType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'documentBase', 'type': 'xs:string'}, None),
        'documentCode': MemberSpec_('documentCode', ['documentCode', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'documentCode', 'type': 'xs:string'}, None),
        'signDate': MemberSpec_('signDate', 'xs:date', 0, 1, {'minOccurs': '0', 'name': 'signDate', 'type': 'xs:date'}, None),
        'regNum': MemberSpec_('regNum', ['zfcs_contract.regNum2015Type', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'regNum', 'type': 'xs:string'}, None),
        'number': MemberSpec_('number', ['zfcs_contract.Number2015Type', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'number', 'type': 'xs:string'}, None),
        'contractSubject': MemberSpec_('contractSubject', ['text2000Type', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'contractSubject', 'type': 'xs:string'}, None),
        'constructionWorksInfo': MemberSpec_('constructionWorksInfo', 'constructionWorksInfo', 0, 1, {'minOccurs': '0', 'name': 'constructionWorksInfo', 'type': 'constructionWorksInfo'}, None),
        'bankSupportContractRequiredInfo': MemberSpec_('bankSupportContractRequiredInfo', 'bankSupportContractRequiredInfoType', 0, 1, {'minOccurs': '0', 'name': 'bankSupportContractRequiredInfo', 'type': 'bankSupportContractRequiredInfoType'}, None),
        'defenseContractNumber': MemberSpec_('defenseContractNumber', ['zfcs_contract.defenseNum2015Type', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'defenseContractNumber', 'type': 'xs:string'}, None),
        'isGOZ': MemberSpec_('isGOZ', 'xs:boolean', 0, 1, {'fixed': 'true', 'minOccurs': '0', 'name': 'isGOZ', 'type': 'xs:boolean'}, None),
        'IGK': MemberSpec_('IGK', ['contractKSNumType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'IGK', 'type': 'xs:string'}, None),
        'contractLifeCycle': MemberSpec_('contractLifeCycle', 'xs:boolean', 0, 1, {'minOccurs': '0', 'name': 'contractLifeCycle', 'type': 'xs:boolean'}, None),
        'priceInfo': MemberSpec_('priceInfo', 'priceInfo', 0, 0, {'name': 'priceInfo', 'type': 'priceInfo'}, None),
        'advancePaymentSum': MemberSpec_('advancePaymentSum', 'advancePaymentSum', 0, 1, {'minOccurs': '0', 'name': 'advancePaymentSum', 'type': 'advancePaymentSum'}, None),
        'isSMPOrSONOTender': MemberSpec_('isSMPOrSONOTender', 'xs:boolean', 0, 1, {'minOccurs': '0', 'name': 'isSMPOrSONOTender', 'type': 'xs:boolean'}, None),
        'isSMPOrSONOEngage': MemberSpec_('isSMPOrSONOEngage', 'xs:boolean', 0, 1, {'minOccurs': '0', 'name': 'isSMPOrSONOEngage', 'type': 'xs:boolean'}, None),
        'subContractorsSum': MemberSpec_('subContractorsSum', 'subContractorsSum', 0, 1, {'minOccurs': '0', 'name': 'subContractorsSum', 'type': 'subContractorsSum'}, None),
        'quantityContractStages': MemberSpec_('quantityContractStages', 'xs:int', 0, 1, {'minOccurs': '0', 'name': 'quantityContractStages', 'type': 'xs:int'}, None),
        'executionPeriod': MemberSpec_('executionPeriod', 'executionPeriod', 0, 0, {'name': 'executionPeriod', 'type': 'executionPeriod'}, None),
        'enforcement': MemberSpec_('enforcement', 'zfcs_contract2015EnforcementType', 0, 1, {'minOccurs': '0', 'name': 'enforcement', 'type': 'zfcs_contract2015EnforcementType'}, None),
        'subsequentMaintenanceEnforcement': MemberSpec_('subsequentMaintenanceEnforcement', 'zfcs_contract2015EnforcementType', 0, 1, {'minOccurs': '0', 'name': 'subsequentMaintenanceEnforcement', 'type': 'zfcs_contract2015EnforcementType'}, None),
        'st14Info': MemberSpec_('st14Info', 'st14Info', 0, 1, {'minOccurs': '0', 'name': 'st14Info', 'type': 'st14Info'}, None),
        'qualityGuaranteeInfo': MemberSpec_('qualityGuaranteeInfo', 'qualityGuaranteeInfo', 0, 1, {'minOccurs': '0', 'name': 'qualityGuaranteeInfo', 'type': 'qualityGuaranteeInfo'}, None),
        'guaranteeReturns': MemberSpec_('guaranteeReturns', 'zfcs_contract2015BankGuaranteeReturnType', 0, 1, {'minOccurs': '0', 'name': 'guaranteeReturns', 'type': 'zfcs_contract2015BankGuaranteeReturnType'}, None),
        'energyServiceContractInfo': MemberSpec_('energyServiceContractInfo', ['zfcs_longTextMinType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'energyServiceContractInfo', 'type': 'xs:string'}, None),
        'products': MemberSpec_('products', 'products', 0, 0, {'name': 'products', 'type': 'products'}, None),
        'suppliers': MemberSpec_('suppliers', 'suppliers', 0, 0, {'name': 'suppliers', 'type': 'suppliers'}, None),
        'href': MemberSpec_('href', ['hrefType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'href', 'type': 'xs:string'}, None),
        'printForm': MemberSpec_('printForm', 'xs:string', 0, 1, {'minOccurs': '0', 'name': 'printForm', 'type': 'xs:string'}, None),
        'extPrintForm': MemberSpec_('extPrintForm', 'xs:string', 0, 1, {'minOccurs': '0', 'name': 'extPrintForm', 'type': 'xs:string'}, None),
        'scanDocuments': MemberSpec_('scanDocuments', 'xs:string', 0, 1, {'minOccurs': '0', 'name': 'scanDocuments', 'type': 'xs:string'}, None),
        'medicalDocuments': MemberSpec_('medicalDocuments', 'xs:string', 0, 1, {'minOccurs': '0', 'name': 'medicalDocuments', 'type': 'xs:string'}, None),
        'singleSupplierP25Part1St93Documents': MemberSpec_('singleSupplierP25Part1St93Documents', 'xs:string', 0, 1, {'minOccurs': '0', 'name': 'singleSupplierP25Part1St93Documents', 'type': 'xs:string'}, None),
        'budgetObligations': MemberSpec_('budgetObligations', 'xs:string', 0, 1, {'minOccurs': '0', 'name': 'budgetObligations', 'type': 'xs:string'}, None),
        'attachments': MemberSpec_('attachments', 'xs:string', 0, 1, {'minOccurs': '0', 'name': 'attachments', 'type': 'xs:string'}, None),
        'modification': MemberSpec_('modification', 'modification', 0, 1, {'minOccurs': '0', 'name': 'modification', 'type': 'modification'}, None),
        'currentContractStage': MemberSpec_('currentContractStage', 'xs:string', 0, 1, {'minOccurs': '0', 'name': 'currentContractStage', 'type': 'xs:string'}, None),
        'okpd2okved2': MemberSpec_('okpd2okved2', 'xs:boolean', 0, 1, {'minOccurs': '0', 'name': 'okpd2okved2', 'type': 'xs:boolean'}, None),
        'isInvalid': MemberSpec_('isInvalid', 'xs:boolean', 0, 1, {'minOccurs': '0', 'name': 'isInvalid', 'type': 'xs:boolean'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, schemeVersion=None, id=None, externalId=None, directDate=None, publishDate=None, versionNumber=None, foundation=None, conclusionContractSt95Ch17_1=None, customer=None, placer=None, finances=None, protocolDate=None, documentBase=None, documentCode=None, signDate=None, regNum=None, number=None, contractSubject=None, constructionWorksInfo=None, bankSupportContractRequiredInfo=None, defenseContractNumber=None, isGOZ=None, IGK=None, contractLifeCycle=None, priceInfo=None, advancePaymentSum=None, isSMPOrSONOTender=None, isSMPOrSONOEngage=None, subContractorsSum=None, quantityContractStages=None, executionPeriod=None, enforcement=None, subsequentMaintenanceEnforcement=None, st14Info=None, qualityGuaranteeInfo=None, guaranteeReturns=None, energyServiceContractInfo=None, products=None, suppliers=None, href=None, printForm=None, extPrintForm=None, scanDocuments=None, medicalDocuments=None, singleSupplierP25Part1St93Documents=None, budgetObligations=None, attachments=None, modification=None, currentContractStage=None, okpd2okved2=None, isInvalid=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.schemeVersion = _cast(None, schemeVersion)
        self.schemeVersion_nsprefix_ = None
        self.id = id
        self.id_nsprefix_ = None
        self.externalId = externalId
        self.validate_externalIdType(self.externalId)
        self.externalId_nsprefix_ = None
        if isinstance(directDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(directDate, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = directDate
        self.directDate = initvalue_
        self.directDate_nsprefix_ = None
        if isinstance(publishDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(publishDate, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = publishDate
        self.publishDate = initvalue_
        self.publishDate_nsprefix_ = None
        self.versionNumber = versionNumber
        self.validate_versionNumberType(self.versionNumber)
        self.versionNumber_nsprefix_ = None
        self.foundation = foundation
        self.foundation_nsprefix_ = None
        self.conclusionContractSt95Ch17_1 = conclusionContractSt95Ch17_1
        self.conclusionContractSt95Ch17_1_nsprefix_ = None
        self.customer = customer
        self.customer_nsprefix_ = None
        self.placer = placer
        self.placer_nsprefix_ = None
        self.finances = finances
        self.finances_nsprefix_ = None
        if isinstance(protocolDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(protocolDate, '%Y-%m-%d').date()
        else:
            initvalue_ = protocolDate
        self.protocolDate = initvalue_
        self.protocolDate_nsprefix_ = None
        self.documentBase = documentBase
        self.validate_zfcs_longTextMinType(self.documentBase)
        self.documentBase_nsprefix_ = None
        self.documentCode = documentCode
        self.documentCode_nsprefix_ = None
        if isinstance(signDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(signDate, '%Y-%m-%d').date()
        else:
            initvalue_ = signDate
        self.signDate = initvalue_
        self.signDate_nsprefix_ = None
        self.regNum = regNum
        self.validate_zfcs_contract_regNum2015Type(self.regNum)
        self.regNum_nsprefix_ = None
        self.number = number
        self.validate_zfcs_contract_Number2015Type(self.number)
        self.number_nsprefix_ = None
        self.contractSubject = contractSubject
        self.validate_text2000Type(self.contractSubject)
        self.contractSubject_nsprefix_ = None
        self.constructionWorksInfo = constructionWorksInfo
        self.constructionWorksInfo_nsprefix_ = None
        self.bankSupportContractRequiredInfo = bankSupportContractRequiredInfo
        self.bankSupportContractRequiredInfo_nsprefix_ = None
        self.defenseContractNumber = defenseContractNumber
        self.validate_zfcs_contract_defenseNum2015Type(self.defenseContractNumber)
        self.defenseContractNumber_nsprefix_ = None
        self.isGOZ = isGOZ
        self.isGOZ_nsprefix_ = None
        self.IGK = IGK
        self.validate_contractKSNumType(self.IGK)
        self.IGK_nsprefix_ = None
        self.contractLifeCycle = contractLifeCycle
        self.contractLifeCycle_nsprefix_ = None
        self.priceInfo = priceInfo
        self.priceInfo_nsprefix_ = None
        self.advancePaymentSum = advancePaymentSum
        self.advancePaymentSum_nsprefix_ = None
        self.isSMPOrSONOTender = isSMPOrSONOTender
        self.isSMPOrSONOTender_nsprefix_ = None
        self.isSMPOrSONOEngage = isSMPOrSONOEngage
        self.isSMPOrSONOEngage_nsprefix_ = None
        self.subContractorsSum = subContractorsSum
        self.subContractorsSum_nsprefix_ = None
        self.quantityContractStages = quantityContractStages
        self.quantityContractStages_nsprefix_ = None
        self.executionPeriod = executionPeriod
        self.executionPeriod_nsprefix_ = None
        self.enforcement = enforcement
        self.enforcement_nsprefix_ = None
        self.subsequentMaintenanceEnforcement = subsequentMaintenanceEnforcement
        self.subsequentMaintenanceEnforcement_nsprefix_ = None
        self.st14Info = st14Info
        self.st14Info_nsprefix_ = None
        self.qualityGuaranteeInfo = qualityGuaranteeInfo
        self.qualityGuaranteeInfo_nsprefix_ = None
        self.guaranteeReturns = guaranteeReturns
        self.guaranteeReturns_nsprefix_ = None
        self.energyServiceContractInfo = energyServiceContractInfo
        self.validate_zfcs_longTextMinType(self.energyServiceContractInfo)
        self.energyServiceContractInfo_nsprefix_ = None
        self.products = products
        self.products_nsprefix_ = None
        self.suppliers = suppliers
        self.suppliers_nsprefix_ = None
        self.href = href
        self.validate_hrefType(self.href)
        self.href_nsprefix_ = None
        self.printForm = printForm
        self.printForm_nsprefix_ = None
        self.extPrintForm = extPrintForm
        self.extPrintForm_nsprefix_ = None
        self.scanDocuments = scanDocuments
        self.scanDocuments_nsprefix_ = None
        self.medicalDocuments = medicalDocuments
        self.medicalDocuments_nsprefix_ = None
        self.singleSupplierP25Part1St93Documents = singleSupplierP25Part1St93Documents
        self.singleSupplierP25Part1St93Documents_nsprefix_ = None
        self.budgetObligations = budgetObligations
        self.budgetObligations_nsprefix_ = None
        self.attachments = attachments
        self.attachments_nsprefix_ = None
        self.modification = modification
        self.modification_nsprefix_ = None
        self.currentContractStage = currentContractStage
        self.currentContractStage_nsprefix_ = None
        self.okpd2okved2 = okpd2okved2
        self.okpd2okved2_nsprefix_ = None
        self.isInvalid = isInvalid
        self.isInvalid_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, zfcs_contract2015Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if zfcs_contract2015Type.subclass:
            return zfcs_contract2015Type.subclass(*args_, **kwargs_)
        else:
            return zfcs_contract2015Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_externalIdType(self, value):
        result = True
        # Validate type externalIdType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 40:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on externalIdType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on externalIdType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_versionNumberType(self, value):
        result = True
        # Validate type versionNumberType, a restriction on xs:int.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            if value < 0:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on versionNumberType' % {"value": value, "lineno": lineno} )
                result = False
        return result
    def validate_zfcs_longTextMinType(self, value):
        result = True
        # Validate type zfcs_longTextMinType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 2000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on zfcs_longTextMinType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on zfcs_longTextMinType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_zfcs_contract_regNum2015Type(self, value):
        result = True
        # Validate type zfcs_contract.regNum2015Type, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 19:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on zfcs_contract.regNum2015Type' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on zfcs_contract.regNum2015Type' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_zfcs_contract_Number2015Type(self, value):
        result = True
        # Validate type zfcs_contract.Number2015Type, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 100:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on zfcs_contract.Number2015Type' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on zfcs_contract.Number2015Type' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_text2000Type(self, value):
        result = True
        # Validate type text2000Type, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 2000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on text2000Type' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on text2000Type' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_zfcs_contract_defenseNum2015Type(self, value):
        result = True
        # Validate type zfcs_contract.defenseNum2015Type, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 25:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on zfcs_contract.defenseNum2015Type' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on zfcs_contract.defenseNum2015Type' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_contractKSNumType(self, value):
        result = True
        # Validate type contractKSNumType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 20:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on contractKSNumType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on contractKSNumType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_hrefType(self, value):
        result = True
        # Validate type hrefType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on hrefType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on hrefType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_schemeVersionType(self, value):
        # Validate type base:schemeVersionType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['1.0', '4.1', '4.2', '4.3', '4.3.100', '4.4', '4.4.2', '4.5', '4.6', '5.0', '5.1', '5.2', '6.0', '6.1', '6.2', '6.2.100', '6.3', '6.4', '7.0', '7.1', '7.2', '7.3', '7.5', '8.0', '8.1', '8.2', '8.2.100', '8.3', '9.0', '9.1', '9.2', '9.3', '10.0', '10.1', '10.2', '10.2.310', '10.3', '11.0']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on schemeVersionType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            self.id is not None or
            self.externalId is not None or
            self.directDate is not None or
            self.publishDate is not None or
            self.versionNumber is not None or
            self.foundation is not None or
            self.conclusionContractSt95Ch17_1 is not None or
            self.customer is not None or
            self.placer is not None or
            self.finances is not None or
            self.protocolDate is not None or
            self.documentBase is not None or
            self.documentCode is not None or
            self.signDate is not None or
            self.regNum is not None or
            self.number is not None or
            self.contractSubject is not None or
            self.constructionWorksInfo is not None or
            self.bankSupportContractRequiredInfo is not None or
            self.defenseContractNumber is not None or
            self.isGOZ is not None or
            self.IGK is not None or
            self.contractLifeCycle is not None or
            self.priceInfo is not None or
            self.advancePaymentSum is not None or
            self.isSMPOrSONOTender is not None or
            self.isSMPOrSONOEngage is not None or
            self.subContractorsSum is not None or
            self.quantityContractStages is not None or
            self.executionPeriod is not None or
            self.enforcement is not None or
            self.subsequentMaintenanceEnforcement is not None or
            self.st14Info is not None or
            self.qualityGuaranteeInfo is not None or
            self.guaranteeReturns is not None or
            self.energyServiceContractInfo is not None or
            self.products is not None or
            self.suppliers is not None or
            self.href is not None or
            self.printForm is not None or
            self.extPrintForm is not None or
            self.scanDocuments is not None or
            self.medicalDocuments is not None or
            self.singleSupplierP25Part1St93Documents is not None or
            self.budgetObligations is not None or
            self.attachments is not None or
            self.modification is not None or
            self.currentContractStage is not None or
            self.okpd2okved2 is not None or
            self.isInvalid is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('schemeVersion', node)
        if value is not None and 'schemeVersion' not in already_processed:
            already_processed.add('schemeVersion')
            self.schemeVersion = value
            self.validate_schemeVersionType(self.schemeVersion)    # validate type schemeVersionType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'id' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'id')
            ival_ = self.gds_validate_integer(ival_, node, 'id')
            self.id = ival_
            self.id_nsprefix_ = child_.prefix
        elif nodeName_ == 'externalId':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'externalId')
            value_ = self.gds_validate_string(value_, node, 'externalId')
            self.externalId = value_
            self.externalId_nsprefix_ = child_.prefix
            # validate type externalIdType
            self.validate_externalIdType(self.externalId)
        elif nodeName_ == 'directDate':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.directDate = dval_
            self.directDate_nsprefix_ = child_.prefix
        elif nodeName_ == 'publishDate':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.publishDate = dval_
            self.publishDate_nsprefix_ = child_.prefix
        elif nodeName_ == 'versionNumber' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'versionNumber')
            ival_ = self.gds_validate_integer(ival_, node, 'versionNumber')
            self.versionNumber = ival_
            self.versionNumber_nsprefix_ = child_.prefix
            # validate type versionNumberType
            self.validate_versionNumberType(self.versionNumber)
        elif nodeName_ == 'foundation':
            obj_ = foundation.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.foundation = obj_
            obj_.original_tagname_ = 'foundation'
        elif nodeName_ == 'conclusionContractSt95Ch17.1':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'conclusionContractSt95Ch17_1')
            ival_ = self.gds_validate_boolean(ival_, node, 'conclusionContractSt95Ch17_1')
            self.conclusionContractSt95Ch17_1 = ival_
            self.conclusionContractSt95Ch17_1_nsprefix_ = child_.prefix
        elif nodeName_ == 'customer':
            obj_ = customer.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.customer = obj_
            obj_.original_tagname_ = 'customer'
        elif nodeName_ == 'placer':
            obj_ = placer.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.placer = obj_
            obj_.original_tagname_ = 'placer'
        elif nodeName_ == 'finances':
            obj_ = finances.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.finances = obj_
            obj_.original_tagname_ = 'finances'
        elif nodeName_ == 'protocolDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.protocolDate = dval_
            self.protocolDate_nsprefix_ = child_.prefix
        elif nodeName_ == 'documentBase':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'documentBase')
            value_ = self.gds_validate_string(value_, node, 'documentBase')
            self.documentBase = value_
            self.documentBase_nsprefix_ = child_.prefix
            # validate type zfcs_longTextMinType
            self.validate_zfcs_longTextMinType(self.documentBase)
        elif nodeName_ == 'documentCode':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'documentCode')
            value_ = self.gds_validate_string(value_, node, 'documentCode')
            self.documentCode = value_
            self.documentCode_nsprefix_ = child_.prefix
        elif nodeName_ == 'signDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.signDate = dval_
            self.signDate_nsprefix_ = child_.prefix
        elif nodeName_ == 'regNum':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'regNum')
            value_ = self.gds_validate_string(value_, node, 'regNum')
            self.regNum = value_
            self.regNum_nsprefix_ = child_.prefix
            # validate type zfcs_contract.regNum2015Type
            self.validate_zfcs_contract_regNum2015Type(self.regNum)
        elif nodeName_ == 'number':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'number')
            value_ = self.gds_validate_string(value_, node, 'number')
            self.number = value_
            self.number_nsprefix_ = child_.prefix
            # validate type zfcs_contract.Number2015Type
            self.validate_zfcs_contract_Number2015Type(self.number)
        elif nodeName_ == 'contractSubject':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'contractSubject')
            value_ = self.gds_validate_string(value_, node, 'contractSubject')
            self.contractSubject = value_
            self.contractSubject_nsprefix_ = child_.prefix
            # validate type text2000Type
            self.validate_text2000Type(self.contractSubject)
        elif nodeName_ == 'constructionWorksInfo':
            obj_ = constructionWorksInfo.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.constructionWorksInfo = obj_
            obj_.original_tagname_ = 'constructionWorksInfo'
        elif nodeName_ == 'bankSupportContractRequiredInfo':
            obj_ = bankSupportContractRequiredInfoType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.bankSupportContractRequiredInfo = obj_
            obj_.original_tagname_ = 'bankSupportContractRequiredInfo'
        elif nodeName_ == 'defenseContractNumber':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'defenseContractNumber')
            value_ = self.gds_validate_string(value_, node, 'defenseContractNumber')
            self.defenseContractNumber = value_
            self.defenseContractNumber_nsprefix_ = child_.prefix
            # validate type zfcs_contract.defenseNum2015Type
            self.validate_zfcs_contract_defenseNum2015Type(self.defenseContractNumber)
        elif nodeName_ == 'isGOZ':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'isGOZ')
            ival_ = self.gds_validate_boolean(ival_, node, 'isGOZ')
            self.isGOZ = ival_
            self.isGOZ_nsprefix_ = child_.prefix
        elif nodeName_ == 'IGK':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'IGK')
            value_ = self.gds_validate_string(value_, node, 'IGK')
            self.IGK = value_
            self.IGK_nsprefix_ = child_.prefix
            # validate type contractKSNumType
            self.validate_contractKSNumType(self.IGK)
        elif nodeName_ == 'contractLifeCycle':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'contractLifeCycle')
            ival_ = self.gds_validate_boolean(ival_, node, 'contractLifeCycle')
            self.contractLifeCycle = ival_
            self.contractLifeCycle_nsprefix_ = child_.prefix
        elif nodeName_ == 'priceInfo':
            obj_ = priceInfo.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.priceInfo = obj_
            obj_.original_tagname_ = 'priceInfo'
        elif nodeName_ == 'advancePaymentSum':
            obj_ = advancePaymentSum.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.advancePaymentSum = obj_
            obj_.original_tagname_ = 'advancePaymentSum'
        elif nodeName_ == 'isSMPOrSONOTender':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'isSMPOrSONOTender')
            ival_ = self.gds_validate_boolean(ival_, node, 'isSMPOrSONOTender')
            self.isSMPOrSONOTender = ival_
            self.isSMPOrSONOTender_nsprefix_ = child_.prefix
        elif nodeName_ == 'isSMPOrSONOEngage':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'isSMPOrSONOEngage')
            ival_ = self.gds_validate_boolean(ival_, node, 'isSMPOrSONOEngage')
            self.isSMPOrSONOEngage = ival_
            self.isSMPOrSONOEngage_nsprefix_ = child_.prefix
        elif nodeName_ == 'subContractorsSum':
            obj_ = subContractorsSum.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.subContractorsSum = obj_
            obj_.original_tagname_ = 'subContractorsSum'
        elif nodeName_ == 'quantityContractStages' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'quantityContractStages')
            ival_ = self.gds_validate_integer(ival_, node, 'quantityContractStages')
            self.quantityContractStages = ival_
            self.quantityContractStages_nsprefix_ = child_.prefix
        elif nodeName_ == 'executionPeriod':
            obj_ = executionPeriod.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.executionPeriod = obj_
            obj_.original_tagname_ = 'executionPeriod'
        elif nodeName_ == 'enforcement':
            obj_ = zfcs_contract2015EnforcementType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.enforcement = obj_
            obj_.original_tagname_ = 'enforcement'
        elif nodeName_ == 'subsequentMaintenanceEnforcement':
            obj_ = zfcs_contract2015EnforcementType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.subsequentMaintenanceEnforcement = obj_
            obj_.original_tagname_ = 'subsequentMaintenanceEnforcement'
        elif nodeName_ == 'st14Info':
            obj_ = st14Info.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.st14Info = obj_
            obj_.original_tagname_ = 'st14Info'
        elif nodeName_ == 'qualityGuaranteeInfo':
            obj_ = qualityGuaranteeInfo.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.qualityGuaranteeInfo = obj_
            obj_.original_tagname_ = 'qualityGuaranteeInfo'
        elif nodeName_ == 'guaranteeReturns':
            obj_ = zfcs_contract2015BankGuaranteeReturnType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.guaranteeReturns = obj_
            obj_.original_tagname_ = 'guaranteeReturns'
        elif nodeName_ == 'energyServiceContractInfo':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'energyServiceContractInfo')
            value_ = self.gds_validate_string(value_, node, 'energyServiceContractInfo')
            self.energyServiceContractInfo = value_
            self.energyServiceContractInfo_nsprefix_ = child_.prefix
            # validate type zfcs_longTextMinType
            self.validate_zfcs_longTextMinType(self.energyServiceContractInfo)
        elif nodeName_ == 'products':
            obj_ = products.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.products = obj_
            obj_.original_tagname_ = 'products'
        elif nodeName_ == 'suppliers':
            obj_ = suppliers.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.suppliers = obj_
            obj_.original_tagname_ = 'suppliers'
        elif nodeName_ == 'href':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'href')
            value_ = self.gds_validate_string(value_, node, 'href')
            self.href = value_
            self.href_nsprefix_ = child_.prefix
            # validate type hrefType
            self.validate_hrefType(self.href)
        elif nodeName_ == 'printForm':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'printForm')
            value_ = self.gds_validate_string(value_, node, 'printForm')
            self.printForm = value_
            self.printForm_nsprefix_ = child_.prefix
        elif nodeName_ == 'extPrintForm':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'extPrintForm')
            value_ = self.gds_validate_string(value_, node, 'extPrintForm')
            self.extPrintForm = value_
            self.extPrintForm_nsprefix_ = child_.prefix
        elif nodeName_ == 'scanDocuments':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'scanDocuments')
            value_ = self.gds_validate_string(value_, node, 'scanDocuments')
            self.scanDocuments = value_
            self.scanDocuments_nsprefix_ = child_.prefix
        elif nodeName_ == 'medicalDocuments':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'medicalDocuments')
            value_ = self.gds_validate_string(value_, node, 'medicalDocuments')
            self.medicalDocuments = value_
            self.medicalDocuments_nsprefix_ = child_.prefix
        elif nodeName_ == 'singleSupplierP25Part1St93Documents':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'singleSupplierP25Part1St93Documents')
            value_ = self.gds_validate_string(value_, node, 'singleSupplierP25Part1St93Documents')
            self.singleSupplierP25Part1St93Documents = value_
            self.singleSupplierP25Part1St93Documents_nsprefix_ = child_.prefix
        elif nodeName_ == 'budgetObligations':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'budgetObligations')
            value_ = self.gds_validate_string(value_, node, 'budgetObligations')
            self.budgetObligations = value_
            self.budgetObligations_nsprefix_ = child_.prefix
        elif nodeName_ == 'attachments':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'attachments')
            value_ = self.gds_validate_string(value_, node, 'attachments')
            self.attachments = value_
            self.attachments_nsprefix_ = child_.prefix
        elif nodeName_ == 'modification':
            obj_ = modification.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.modification = obj_
            obj_.original_tagname_ = 'modification'
        elif nodeName_ == 'currentContractStage':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'currentContractStage')
            value_ = self.gds_validate_string(value_, node, 'currentContractStage')
            self.currentContractStage = value_
            self.currentContractStage_nsprefix_ = child_.prefix
        elif nodeName_ == 'okpd2okved2':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'okpd2okved2')
            ival_ = self.gds_validate_boolean(ival_, node, 'okpd2okved2')
            self.okpd2okved2 = ival_
            self.okpd2okved2_nsprefix_ = child_.prefix
        elif nodeName_ == 'isInvalid':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'isInvalid')
            ival_ = self.gds_validate_boolean(ival_, node, 'isInvalid')
            self.isInvalid = ival_
            self.isInvalid_nsprefix_ = child_.prefix
# end class zfcs_contract2015Type


class foundation(GeneratedsSuper):
    """Основание заключения контракта"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'oosOrder': MemberSpec_('oosOrder', 'oosOrder', 0, 0, {'name': 'oosOrder', 'type': 'oosOrder'}, 8),
        'fcsOrder': MemberSpec_('fcsOrder', 'fcsOrder', 0, 0, {'name': 'fcsOrder', 'type': 'fcsOrder'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, oosOrder=None, fcsOrder=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.oosOrder = oosOrder
        self.oosOrder_nsprefix_ = None
        self.fcsOrder = fcsOrder
        self.fcsOrder_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, foundation)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if foundation.subclass:
            return foundation.subclass(*args_, **kwargs_)
        else:
            return foundation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.oosOrder is not None or
            self.fcsOrder is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'oosOrder':
            obj_ = oosOrder.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.oosOrder = obj_
            obj_.original_tagname_ = 'oosOrder'
        elif nodeName_ == 'fcsOrder':
            obj_ = fcsOrder.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.fcsOrder = obj_
            obj_.original_tagname_ = 'fcsOrder'
# end class foundation


class oosOrder(GeneratedsSuper):
    """Размещение заказа по закону №94-ФЗ"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'order': MemberSpec_('order', 'order', 0, 0, {'name': 'order', 'type': 'order'}, 9),
        'singleCustomer': MemberSpec_('singleCustomer', 'singleCustomer', 0, 0, {'name': 'singleCustomer', 'type': 'zfcs_contract2015SingleCustomerType'}, 9),
        'notOosOrder': MemberSpec_('notOosOrder', 'notOosOrder', 0, 0, {'name': 'notOosOrder', 'type': 'notOosOrder'}, 9),
        'other': MemberSpec_('other', 'other', 0, 0, {'name': 'other', 'type': 'other'}, 9),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, order=None, singleCustomer=None, notOosOrder=None, other=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.order = order
        self.order_nsprefix_ = None
        self.singleCustomer = singleCustomer
        self.singleCustomer_nsprefix_ = None
        self.notOosOrder = notOosOrder
        self.notOosOrder_nsprefix_ = None
        self.other = other
        self.other_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, oosOrder)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if oosOrder.subclass:
            return oosOrder.subclass(*args_, **kwargs_)
        else:
            return oosOrder(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.order is not None or
            self.singleCustomer is not None or
            self.notOosOrder is not None or
            self.other is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'order':
            obj_ = order.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.order = obj_
            obj_.original_tagname_ = 'order'
        elif nodeName_ == 'singleCustomer':
            class_obj_ = self.get_class_obj_(child_, zfcs_contract2015SingleCustomerType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.singleCustomer = obj_
            obj_.original_tagname_ = 'singleCustomer'
        elif nodeName_ == 'notOosOrder':
            obj_ = notOosOrder.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.notOosOrder = obj_
            obj_.original_tagname_ = 'notOosOrder'
        elif nodeName_ == 'other':
            obj_ = other.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.other = obj_
            obj_.original_tagname_ = 'other'
# end class oosOrder


class order(GeneratedsSuper):
    """Заказ"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'notificationNumber': MemberSpec_('notificationNumber', ['zfcs_notificationNumberType94', 'xs:string'], 0, 0, {'name': 'notificationNumber', 'type': 'xs:string'}, 9),
        'lotNumber': MemberSpec_('lotNumber', 'xs:int', 0, 0, {'name': 'lotNumber', 'type': 'xs:int'}, 9),
        'placing': MemberSpec_('placing', ['zfcs_contract2015.purchasePlacing94Type', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'placing', 'type': 'xs:string'}, 9),
        'singleCustomer': MemberSpec_('singleCustomer', 'singleCustomer', 0, 1, {'minOccurs': '0', 'name': 'singleCustomer', 'type': 'zfcs_contract2015SingleCustomerType'}, 9),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, notificationNumber=None, lotNumber=None, placing=None, singleCustomer=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.notificationNumber = notificationNumber
        self.validate_zfcs_notificationNumberType94(self.notificationNumber)
        self.notificationNumber_nsprefix_ = None
        self.lotNumber = lotNumber
        self.lotNumber_nsprefix_ = None
        self.placing = placing
        self.validate_zfcs_contract2015_purchasePlacing94Type(self.placing)
        self.placing_nsprefix_ = None
        self.singleCustomer = singleCustomer
        self.singleCustomer_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, order)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if order.subclass:
            return order.subclass(*args_, **kwargs_)
        else:
            return order(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_zfcs_notificationNumberType94(self, value):
        result = True
        # Validate type zfcs_notificationNumberType94, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_zfcs_notificationNumberType94_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_zfcs_notificationNumberType94_patterns_, ))
                result = False
        return result
    validate_zfcs_notificationNumberType94_patterns_ = [['^(\\d{19})$']]
    def validate_zfcs_contract2015_purchasePlacing94Type(self, value):
        result = True
        # Validate type zfcs_contract2015.purchasePlacing94Type, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['1', '2', '3', '4', '5', '6', '11011', '11021', '11031', '12011', '13011', '14011', '20000']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on zfcs_contract2015.purchasePlacing94Type' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.notificationNumber is not None or
            self.lotNumber is not None or
            self.placing is not None or
            self.singleCustomer is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'notificationNumber':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'notificationNumber')
            value_ = self.gds_validate_string(value_, node, 'notificationNumber')
            self.notificationNumber = value_
            self.notificationNumber_nsprefix_ = child_.prefix
            # validate type zfcs_notificationNumberType94
            self.validate_zfcs_notificationNumberType94(self.notificationNumber)
        elif nodeName_ == 'lotNumber' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'lotNumber')
            ival_ = self.gds_validate_integer(ival_, node, 'lotNumber')
            self.lotNumber = ival_
            self.lotNumber_nsprefix_ = child_.prefix
        elif nodeName_ == 'placing':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'placing')
            value_ = self.gds_validate_string(value_, node, 'placing')
            self.placing = value_
            self.placing_nsprefix_ = child_.prefix
            # validate type zfcs_contract2015.purchasePlacing94Type
            self.validate_zfcs_contract2015_purchasePlacing94Type(self.placing)
        elif nodeName_ == 'singleCustomer':
            class_obj_ = self.get_class_obj_(child_, zfcs_contract2015SingleCustomerType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.singleCustomer = obj_
            obj_.original_tagname_ = 'singleCustomer'
# end class order


class notOosOrder(GeneratedsSuper):
    """Заказ не размещался на ЕИС"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'placing': MemberSpec_('placing', 'xs:string', 0, 0, {'name': 'placing', 'type': 'xs:string'}, 9),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, placing=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.placing = placing
        self.placing_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, notOosOrder)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if notOosOrder.subclass:
            return notOosOrder.subclass(*args_, **kwargs_)
        else:
            return notOosOrder(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.placing is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'placing':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'placing')
            value_ = self.gds_validate_string(value_, node, 'placing')
            self.placing = value_
            self.placing_nsprefix_ = child_.prefix
# end class notOosOrder


class other(GeneratedsSuper):
    """Контракт заключен по результатам процедур размещения заказов, начатых до
    1 января 2011 года"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'notificationNumber': MemberSpec_('notificationNumber', ['notificationNumber', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'notificationNumber', 'type': 'xs:string'}, 9),
        'placing': MemberSpec_('placing', 'xs:string', 0, 1, {'minOccurs': '0', 'name': 'placing', 'type': 'xs:string'}, 9),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, notificationNumber=None, placing=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.notificationNumber = notificationNumber
        self.notificationNumber_nsprefix_ = None
        self.placing = placing
        self.placing_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, other)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if other.subclass:
            return other.subclass(*args_, **kwargs_)
        else:
            return other(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.notificationNumber is not None or
            self.placing is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'notificationNumber':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'notificationNumber')
            value_ = self.gds_validate_string(value_, node, 'notificationNumber')
            self.notificationNumber = value_
            self.notificationNumber_nsprefix_ = child_.prefix
        elif nodeName_ == 'placing':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'placing')
            value_ = self.gds_validate_string(value_, node, 'placing')
            self.placing = value_
            self.placing_nsprefix_ = child_.prefix
# end class other


class notificationNumber(GeneratedsSuper):
    """Номер извещения о проведении"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, notificationNumber)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if notificationNumber.subclass:
            return notificationNumber.subclass(*args_, **kwargs_)
        else:
            return notificationNumber(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_notificationNumber(self, value):
        result = True
        # Validate type notificationNumber, a restriction on xs:string.
        pass
        return result
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class notificationNumber


class fcsOrder(GeneratedsSuper):
    """Размещение закупки по закону №44-ФЗ"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'order': MemberSpec_('order', 'order', 0, 0, {'name': 'order', 'type': 'order'}, 10),
        'singleCustomer': MemberSpec_('singleCustomer', 'zfcs_contract2015SingleCustomerType', 0, 0, {'name': 'singleCustomer', 'type': 'singleCustomer'}, None),
        'notOosOrder': MemberSpec_('notOosOrder', 'notOosOrder', 0, 0, {'name': 'notOosOrder', 'type': 'notOosOrder'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, order=None, singleCustomer=None, notOosOrder=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.order = order
        self.order_nsprefix_ = None
        self.singleCustomer = singleCustomer
        self.singleCustomer_nsprefix_ = None
        self.notOosOrder = notOosOrder
        self.notOosOrder_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, fcsOrder)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if fcsOrder.subclass:
            return fcsOrder.subclass(*args_, **kwargs_)
        else:
            return fcsOrder(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.order is not None or
            self.singleCustomer is not None or
            self.notOosOrder is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'order':
            obj_ = order.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.order = obj_
            obj_.original_tagname_ = 'order'
        elif nodeName_ == 'singleCustomer':
            obj_ = singleCustomer.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.singleCustomer = obj_
            obj_.original_tagname_ = 'singleCustomer'
        elif nodeName_ == 'notOosOrder':
            obj_ = notOosOrder.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.notOosOrder = obj_
            obj_.original_tagname_ = 'notOosOrder'
# end class fcsOrder


class placing(GeneratedsSuper):
    """Способ определения поставщиков (подрядчиков, исполнителей)
    11011 - открытый конкурс;
    11021 - конкурс с ограниченным участием;
    11031 - двухэтапный конкурс;
    12011 - электронный аукцион;
    13011 - запрос котировок;
    14011 - запрос предложений;
    11013 - открытый конкурс в электронной форме;
    11023 - конкурс с ограниченным участием в электронной форме;
    11033 - двухэтапный конкурс в электронной форме;
    13013 - запрос котировок в электронной форме;
    14013 - запрос предложений в электронной форме;
    20000 - закупка у единственного поставщика (подрядчика, исполнителя);
    30000 - способ определения поставщика (подрядчика, исполнителя),
    установленный Правительством Российской Федерации в соответствии со
    статьей 111 Федерального закона.
    11044 - закрытый конкурс в электронной форме;
    11054 - закрытый конкурс с ограниченным участием в электронной форме;
    11064 - закрытый двухэтапный конкурс в электронной форме;
    12024 - закрытый аукцион в электронной форме;
    40000 - Закупка товара у единственного поставщика на сумму, предусмотренную
    частью 12 статьи 93 Закона № 44-ФЗ."""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, placing)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if placing.subclass:
            return placing.subclass(*args_, **kwargs_)
        else:
            return placing(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_placing(self, value):
        result = True
        # Validate type placing, a restriction on zfcs_contract2015.purchasePlacingType.
        pass
        return result
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class placing


class document(GeneratedsSuper):
    """Наименование документа, подтверждающего заключение контракта с
    единственным поставщиком"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'code': MemberSpec_('code', 'xs:string', 0, 0, {'name': 'code', 'type': 'xs:string'}, None),
        'name': MemberSpec_('name', 'xs:string', 0, 1, {'minOccurs': '0', 'name': 'name', 'type': 'xs:string'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, code=None, name=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.code = code
        self.code_nsprefix_ = None
        self.name = name
        self.name_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, document)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if document.subclass:
            return document.subclass(*args_, **kwargs_)
        else:
            return document(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.code is not None or
            self.name is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'code':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'code')
            value_ = self.gds_validate_string(value_, node, 'code')
            self.code = value_
            self.code_nsprefix_ = child_.prefix
        elif nodeName_ == 'name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'name')
            value_ = self.gds_validate_string(value_, node, 'name')
            self.name = value_
            self.name_nsprefix_ = child_.prefix
# end class document


class placer(GeneratedsSuper):
    """Информация об организации, разместившей контракт. Обязательно указание
    блока в случае приема в ЕИС по альтернативной интеграции под логином
    пользователя организации, имеющей несколько ролей"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'responsibleOrg': MemberSpec_('responsibleOrg', 'zfcs_organizationRef', 0, 0, {'name': 'responsibleOrg', 'type': 'zfcs_organizationRef'}, None),
        'responsibleRole': MemberSpec_('responsibleRole', ['zfcs_placerRoleContract2015Type', 'xs:string'], 0, 0, {'name': 'responsibleRole', 'type': 'xs:string'}, None),
        'placerChange': MemberSpec_('placerChange', 'xs:boolean', 0, 1, {'fixed': 'true', 'minOccurs': '0', 'name': 'placerChange', 'type': 'xs:boolean'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, responsibleOrg=None, responsibleRole=None, placerChange=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.responsibleOrg = responsibleOrg
        self.responsibleOrg_nsprefix_ = None
        self.responsibleRole = responsibleRole
        self.validate_zfcs_placerRoleContract2015Type(self.responsibleRole)
        self.responsibleRole_nsprefix_ = None
        self.placerChange = placerChange
        self.placerChange_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, placer)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if placer.subclass:
            return placer.subclass(*args_, **kwargs_)
        else:
            return placer(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_zfcs_placerRoleContract2015Type(self, value):
        result = True
        # Validate type zfcs_placerRoleContract2015Type, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['CU', 'RA', 'AI', 'OA', 'CS', 'CN', 'SR']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on zfcs_placerRoleContract2015Type' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.responsibleOrg is not None or
            self.responsibleRole is not None or
            self.placerChange is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'responsibleOrg':
            class_obj_ = self.get_class_obj_(child_, zfcs_organizationRef)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.responsibleOrg = obj_
            obj_.original_tagname_ = 'responsibleOrg'
        elif nodeName_ == 'responsibleRole':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'responsibleRole')
            value_ = self.gds_validate_string(value_, node, 'responsibleRole')
            self.responsibleRole = value_
            self.responsibleRole_nsprefix_ = child_.prefix
            # validate type zfcs_placerRoleContract2015Type
            self.validate_zfcs_placerRoleContract2015Type(self.responsibleRole)
        elif nodeName_ == 'placerChange':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'placerChange')
            ival_ = self.gds_validate_boolean(ival_, node, 'placerChange')
            self.placerChange = ival_
            self.placerChange_nsprefix_ = child_.prefix
# end class placer


class finances(GeneratedsSuper):
    """Финансирование"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'budgetFunds': MemberSpec_('budgetFunds', 'budgetFunds', 0, 1, {'minOccurs': '0', 'name': 'budgetFunds', 'type': 'budgetFunds'}, None),
        'extrabudgetFunds': MemberSpec_('extrabudgetFunds', 'extrabudgetFunds', 0, 1, {'minOccurs': '0', 'name': 'extrabudgetFunds', 'type': 'extrabudgetFunds'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, budgetFunds=None, extrabudgetFunds=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.budgetFunds = budgetFunds
        self.budgetFunds_nsprefix_ = None
        self.extrabudgetFunds = extrabudgetFunds
        self.extrabudgetFunds_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, finances)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if finances.subclass:
            return finances.subclass(*args_, **kwargs_)
        else:
            return finances(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.budgetFunds is not None or
            self.extrabudgetFunds is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'budgetFunds':
            obj_ = budgetFunds.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.budgetFunds = obj_
            obj_.original_tagname_ = 'budgetFunds'
        elif nodeName_ == 'extrabudgetFunds':
            obj_ = extrabudgetFunds.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.extrabudgetFunds = obj_
            obj_.original_tagname_ = 'extrabudgetFunds'
# end class finances


class budgetFunds(GeneratedsSuper):
    """Бюджетные средства"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'budget': MemberSpec_('budget', 'zfcs_budgetFundsContract2015', 0, 0, {'name': 'budget', 'type': 'zfcs_budgetFundsContract2015'}, None),
        'OKTMO': MemberSpec_('OKTMO', 'zfcs_OKTMORef', 0, 0, {'name': 'OKTMO', 'type': 'zfcs_OKTMORef'}, None),
        'budgetLevel': MemberSpec_('budgetLevel', ['zfcs_budgetLevelContract2015Type', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'budgetLevel', 'type': 'xs:string'}, None),
        'fundsBudgetLevel': MemberSpec_('fundsBudgetLevel', ['zfcs_fundsBudgetLevelContract2015Type', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'fundsBudgetLevel', 'type': 'xs:string'}, None),
        'KBKsChange': MemberSpec_('KBKsChange', 'xs:boolean', 0, 1, {'minOccurs': '0', 'name': 'KBKsChange', 'type': 'xs:boolean'}, 14),
        'KVRsChange': MemberSpec_('KVRsChange', 'xs:boolean', 0, 1, {'minOccurs': '0', 'name': 'KVRsChange', 'type': 'xs:boolean'}, 14),
        'targetArticlesChange': MemberSpec_('targetArticlesChange', 'xs:boolean', 0, 1, {'minOccurs': '0', 'name': 'targetArticlesChange', 'type': 'xs:boolean'}, 14),
        'stages': MemberSpec_('stages', 'stages', 1, 0, {'maxOccurs': 'unbounded', 'name': 'stages', 'type': 'stages'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, budget=None, OKTMO=None, budgetLevel=None, fundsBudgetLevel=None, KBKsChange=None, KVRsChange=None, targetArticlesChange=None, stages=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.budget = budget
        self.budget_nsprefix_ = None
        self.OKTMO = OKTMO
        self.OKTMO_nsprefix_ = None
        self.budgetLevel = budgetLevel
        self.validate_zfcs_budgetLevelContract2015Type(self.budgetLevel)
        self.budgetLevel_nsprefix_ = None
        self.fundsBudgetLevel = fundsBudgetLevel
        self.validate_zfcs_fundsBudgetLevelContract2015Type(self.fundsBudgetLevel)
        self.fundsBudgetLevel_nsprefix_ = None
        self.KBKsChange = KBKsChange
        self.KBKsChange_nsprefix_ = None
        self.KVRsChange = KVRsChange
        self.KVRsChange_nsprefix_ = None
        self.targetArticlesChange = targetArticlesChange
        self.targetArticlesChange_nsprefix_ = None
        if stages is None:
            self.stages = []
        else:
            self.stages = stages
        self.stages_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, budgetFunds)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if budgetFunds.subclass:
            return budgetFunds.subclass(*args_, **kwargs_)
        else:
            return budgetFunds(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_zfcs_budgetLevelContract2015Type(self, value):
        result = True
        # Validate type zfcs_budgetLevelContract2015Type, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['10', '20', '30', '41', '42', '43', '50', '11', '12', '13', '14', '15', '16', '17']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on zfcs_budgetLevelContract2015Type' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_zfcs_fundsBudgetLevelContract2015Type(self, value):
        result = True
        # Validate type zfcs_fundsBudgetLevelContract2015Type, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['41', '42', '43', '50']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on zfcs_fundsBudgetLevelContract2015Type' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.budget is not None or
            self.OKTMO is not None or
            self.budgetLevel is not None or
            self.fundsBudgetLevel is not None or
            self.KBKsChange is not None or
            self.KVRsChange is not None or
            self.targetArticlesChange is not None or
            self.stages
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'budget':
            obj_ = zfcs_budgetFundsContract2015.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.budget = obj_
            obj_.original_tagname_ = 'budget'
        elif nodeName_ == 'OKTMO':
            obj_ = zfcs_OKTMORef.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.OKTMO = obj_
            obj_.original_tagname_ = 'OKTMO'
        elif nodeName_ == 'budgetLevel':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'budgetLevel')
            value_ = self.gds_validate_string(value_, node, 'budgetLevel')
            self.budgetLevel = value_
            self.budgetLevel_nsprefix_ = child_.prefix
            # validate type zfcs_budgetLevelContract2015Type
            self.validate_zfcs_budgetLevelContract2015Type(self.budgetLevel)
        elif nodeName_ == 'fundsBudgetLevel':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'fundsBudgetLevel')
            value_ = self.gds_validate_string(value_, node, 'fundsBudgetLevel')
            self.fundsBudgetLevel = value_
            self.fundsBudgetLevel_nsprefix_ = child_.prefix
            # validate type zfcs_fundsBudgetLevelContract2015Type
            self.validate_zfcs_fundsBudgetLevelContract2015Type(self.fundsBudgetLevel)
        elif nodeName_ == 'KBKsChange':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'KBKsChange')
            ival_ = self.gds_validate_boolean(ival_, node, 'KBKsChange')
            self.KBKsChange = ival_
            self.KBKsChange_nsprefix_ = child_.prefix
        elif nodeName_ == 'KVRsChange':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'KVRsChange')
            ival_ = self.gds_validate_boolean(ival_, node, 'KVRsChange')
            self.KVRsChange = ival_
            self.KVRsChange_nsprefix_ = child_.prefix
        elif nodeName_ == 'targetArticlesChange':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'targetArticlesChange')
            ival_ = self.gds_validate_boolean(ival_, node, 'targetArticlesChange')
            self.targetArticlesChange = ival_
            self.targetArticlesChange_nsprefix_ = child_.prefix
        elif nodeName_ == 'stages':
            obj_ = stages.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.stages.append(obj_)
            obj_.original_tagname_ = 'stages'
# end class budgetFunds


class stages(GeneratedsSuper):
    """Этапы исполнения контракта"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'externalSid': MemberSpec_('externalSid', ['externalIdType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'externalSid', 'type': 'xs:string'}, None),
        'guid': MemberSpec_('guid', ['guidType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'guid', 'type': 'xs:string'}, None),
        'startDate': MemberSpec_('startDate', 'xs:date', 0, 1, {'minOccurs': '0', 'name': 'startDate', 'type': 'xs:date'}, None),
        'sid': MemberSpec_('sid', 'xs:long', 0, 1, {'minOccurs': '0', 'name': 'sid', 'type': 'xs:long'}, None),
        'endDate': MemberSpec_('endDate', 'xs:date', 0, 0, {'name': 'endDate', 'type': 'xs:date'}, None),
        'payments': MemberSpec_('payments', 'payments', 1, 0, {'maxOccurs': 'unbounded', 'name': 'payments', 'type': 'payments'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, externalSid=None, guid=None, startDate=None, sid=None, endDate=None, payments=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.externalSid = externalSid
        self.validate_externalIdType(self.externalSid)
        self.externalSid_nsprefix_ = None
        self.guid = guid
        self.validate_guidType(self.guid)
        self.guid_nsprefix_ = None
        if isinstance(startDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(startDate, '%Y-%m-%d').date()
        else:
            initvalue_ = startDate
        self.startDate = initvalue_
        self.startDate_nsprefix_ = None
        self.sid = sid
        self.sid_nsprefix_ = None
        if isinstance(endDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(endDate, '%Y-%m-%d').date()
        else:
            initvalue_ = endDate
        self.endDate = initvalue_
        self.endDate_nsprefix_ = None
        if payments is None:
            self.payments = []
        else:
            self.payments = payments
        self.payments_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, stages)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if stages.subclass:
            return stages.subclass(*args_, **kwargs_)
        else:
            return stages(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_externalIdType(self, value):
        result = True
        # Validate type externalIdType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 40:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on externalIdType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on externalIdType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_guidType(self, value):
        result = True
        # Validate type guidType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 36:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on guidType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on guidType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.externalSid is not None or
            self.guid is not None or
            self.startDate is not None or
            self.sid is not None or
            self.endDate is not None or
            self.payments
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'externalSid':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'externalSid')
            value_ = self.gds_validate_string(value_, node, 'externalSid')
            self.externalSid = value_
            self.externalSid_nsprefix_ = child_.prefix
            # validate type externalIdType
            self.validate_externalIdType(self.externalSid)
        elif nodeName_ == 'guid':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'guid')
            value_ = self.gds_validate_string(value_, node, 'guid')
            self.guid = value_
            self.guid_nsprefix_ = child_.prefix
            # validate type guidType
            self.validate_guidType(self.guid)
        elif nodeName_ == 'startDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.startDate = dval_
            self.startDate_nsprefix_ = child_.prefix
        elif nodeName_ == 'sid' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'sid')
            ival_ = self.gds_validate_integer(ival_, node, 'sid')
            self.sid = ival_
            self.sid_nsprefix_ = child_.prefix
        elif nodeName_ == 'endDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.endDate = dval_
            self.endDate_nsprefix_ = child_.prefix
        elif nodeName_ == 'payments':
            obj_ = payments.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.payments.append(obj_)
            obj_.original_tagname_ = 'payments'
# end class stages


class payments(GeneratedsSuper):
    """Платежи по этапу"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'KBK': MemberSpec_('KBK', ['kbkType', 'xs:string'], 0, 0, {'name': 'KBK', 'type': 'xs:string'}, 15),
        'KBK2016': MemberSpec_('KBK2016', ['kbkType', 'xs:string'], 0, 0, {'name': 'KBK2016', 'type': 'xs:string'}, 15),
        'KVR': MemberSpec_('KVR', 'xs:string', 0, 0, {'name': 'KVR', 'type': 'xs:string'}, 15),
        'targetArticle': MemberSpec_('targetArticle', ['targetArticleType', 'xs:string'], 0, 0, {'name': 'targetArticle', 'type': 'xs:string'}, 15),
        'comment': MemberSpec_('comment', ['zfcs_longTextMinType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'comment', 'type': 'xs:string'}, None),
        'paymentMonth': MemberSpec_('paymentMonth', ['monthType', 'xs:byte'], 0, 1, {'minOccurs': '0', 'name': 'paymentMonth', 'type': 'xs:byte'}, None),
        'paymentYear': MemberSpec_('paymentYear', ['zfcs_yearType', 'xs:int'], 0, 0, {'name': 'paymentYear', 'type': 'xs:int'}, None),
        'paymentSum': MemberSpec_('paymentSum', ['moneyPositiveType', 'xs:string'], 0, 0, {'name': 'paymentSum', 'type': 'xs:string'}, None),
        'paymentSumRUR': MemberSpec_('paymentSumRUR', ['moneyPositiveType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'paymentSumRUR', 'type': 'xs:string'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, KBK=None, KBK2016=None, KVR=None, targetArticle=None, comment=None, paymentMonth=None, paymentYear=None, paymentSum=None, paymentSumRUR=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.KBK = KBK
        self.validate_kbkType(self.KBK)
        self.KBK_nsprefix_ = None
        self.KBK2016 = KBK2016
        self.validate_kbkType(self.KBK2016)
        self.KBK2016_nsprefix_ = None
        self.KVR = KVR
        self.KVR_nsprefix_ = None
        self.targetArticle = targetArticle
        self.validate_targetArticleType(self.targetArticle)
        self.targetArticle_nsprefix_ = None
        self.comment = comment
        self.validate_zfcs_longTextMinType(self.comment)
        self.comment_nsprefix_ = None
        self.paymentMonth = paymentMonth
        self.validate_monthType(self.paymentMonth)
        self.paymentMonth_nsprefix_ = None
        self.paymentYear = paymentYear
        self.validate_zfcs_yearType(self.paymentYear)
        self.paymentYear_nsprefix_ = None
        self.paymentSum = paymentSum
        self.validate_moneyPositiveType(self.paymentSum)
        self.paymentSum_nsprefix_ = None
        self.paymentSumRUR = paymentSumRUR
        self.validate_moneyPositiveType(self.paymentSumRUR)
        self.paymentSumRUR_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, payments)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if payments.subclass:
            return payments.subclass(*args_, **kwargs_)
        else:
            return payments(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_kbkType(self, value):
        result = True
        # Validate type kbkType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) != 20:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd length restriction on kbkType' % {"value": encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_targetArticleType(self, value):
        result = True
        # Validate type targetArticleType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) != 10:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd length restriction on targetArticleType' % {"value": encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_zfcs_longTextMinType(self, value):
        result = True
        # Validate type zfcs_longTextMinType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 2000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on zfcs_longTextMinType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on zfcs_longTextMinType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_monthType(self, value):
        result = True
        # Validate type monthType, a restriction on xs:byte.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            if value < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on monthType' % {"value": value, "lineno": lineno} )
                result = False
            if value > 12:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxInclusive restriction on monthType' % {"value": value, "lineno": lineno} )
                result = False
        return result
    def validate_zfcs_yearType(self, value):
        result = True
        # Validate type zfcs_yearType, a restriction on xs:int.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_zfcs_yearType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_zfcs_yearType_patterns_, ))
                result = False
        return result
    validate_zfcs_yearType_patterns_ = [['^(\\d{4})$']]
    def validate_moneyPositiveType(self, value):
        result = True
        # Validate type moneyPositiveType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 21:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on moneyPositiveType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on moneyPositiveType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_moneyPositiveType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_moneyPositiveType_patterns_, ))
                result = False
        return result
    validate_moneyPositiveType_patterns_ = [['^(\\d+(\\.\\d{1,2})?)$']]
    def hasContent_(self):
        if (
            self.KBK is not None or
            self.KBK2016 is not None or
            self.KVR is not None or
            self.targetArticle is not None or
            self.comment is not None or
            self.paymentMonth is not None or
            self.paymentYear is not None or
            self.paymentSum is not None or
            self.paymentSumRUR is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'KBK':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'KBK')
            value_ = self.gds_validate_string(value_, node, 'KBK')
            self.KBK = value_
            self.KBK_nsprefix_ = child_.prefix
            # validate type kbkType
            self.validate_kbkType(self.KBK)
        elif nodeName_ == 'KBK2016':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'KBK2016')
            value_ = self.gds_validate_string(value_, node, 'KBK2016')
            self.KBK2016 = value_
            self.KBK2016_nsprefix_ = child_.prefix
            # validate type kbkType
            self.validate_kbkType(self.KBK2016)
        elif nodeName_ == 'KVR':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'KVR')
            value_ = self.gds_validate_string(value_, node, 'KVR')
            self.KVR = value_
            self.KVR_nsprefix_ = child_.prefix
        elif nodeName_ == 'targetArticle':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'targetArticle')
            value_ = self.gds_validate_string(value_, node, 'targetArticle')
            self.targetArticle = value_
            self.targetArticle_nsprefix_ = child_.prefix
            # validate type targetArticleType
            self.validate_targetArticleType(self.targetArticle)
        elif nodeName_ == 'comment':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'comment')
            value_ = self.gds_validate_string(value_, node, 'comment')
            self.comment = value_
            self.comment_nsprefix_ = child_.prefix
            # validate type zfcs_longTextMinType
            self.validate_zfcs_longTextMinType(self.comment)
        elif nodeName_ == 'paymentMonth' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'paymentMonth')
            ival_ = self.gds_validate_integer(ival_, node, 'paymentMonth')
            self.paymentMonth = ival_
            self.paymentMonth_nsprefix_ = child_.prefix
            # validate type monthType
            self.validate_monthType(self.paymentMonth)
        elif nodeName_ == 'paymentYear' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'paymentYear')
            ival_ = self.gds_validate_integer(ival_, node, 'paymentYear')
            self.paymentYear = ival_
            self.paymentYear_nsprefix_ = child_.prefix
            # validate type zfcs_yearType
            self.validate_zfcs_yearType(self.paymentYear)
        elif nodeName_ == 'paymentSum':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'paymentSum')
            value_ = self.gds_validate_string(value_, node, 'paymentSum')
            self.paymentSum = value_
            self.paymentSum_nsprefix_ = child_.prefix
            # validate type moneyPositiveType
            self.validate_moneyPositiveType(self.paymentSum)
        elif nodeName_ == 'paymentSumRUR':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'paymentSumRUR')
            value_ = self.gds_validate_string(value_, node, 'paymentSumRUR')
            self.paymentSumRUR = value_
            self.paymentSumRUR_nsprefix_ = child_.prefix
            # validate type moneyPositiveType
            self.validate_moneyPositiveType(self.paymentSumRUR)
# end class payments


class extrabudgetFunds(GeneratedsSuper):
    """Внебюджетные средства"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'extrabudget': MemberSpec_('extrabudget', 'zfcs_extraBudgetFundsContract2015', 0, 1, {'minOccurs': '0', 'name': 'extrabudget', 'type': 'zfcs_extraBudgetFundsContract2015'}, None),
        'stages': MemberSpec_('stages', 'stages', 1, 0, {'maxOccurs': 'unbounded', 'name': 'stages', 'type': 'stages'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, extrabudget=None, stages=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.extrabudget = extrabudget
        self.extrabudget_nsprefix_ = None
        if stages is None:
            self.stages = []
        else:
            self.stages = stages
        self.stages_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, extrabudgetFunds)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if extrabudgetFunds.subclass:
            return extrabudgetFunds.subclass(*args_, **kwargs_)
        else:
            return extrabudgetFunds(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.extrabudget is not None or
            self.stages
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'extrabudget':
            obj_ = zfcs_extraBudgetFundsContract2015.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.extrabudget = obj_
            obj_.original_tagname_ = 'extrabudget'
        elif nodeName_ == 'stages':
            obj_ = stages.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.stages.append(obj_)
            obj_.original_tagname_ = 'stages'
# end class extrabudgetFunds


class documentCode(GeneratedsSuper):
    """Код документа, подтверждающего основание заключения контракта (для
    печатной формы)"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, documentCode)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if documentCode.subclass:
            return documentCode.subclass(*args_, **kwargs_)
        else:
            return documentCode(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_documentCode(self, value):
        result = True
        # Validate type documentCode, a restriction on xs:string.
        pass
        return result
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class documentCode


class constructionWorksInfo(GeneratedsSuper):
    """Информация, указываемая в случае, если предмет контракта относится к
    работам по строительству"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'isConstructionWorks': MemberSpec_('isConstructionWorks', 'xs:boolean', 0, 0, {'fixed': 'true', 'name': 'isConstructionWorks', 'type': 'xs:boolean'}, None),
        'constructionWorkGroup': MemberSpec_('constructionWorkGroup', 'constructionWorkGroup', 0, 0, {'name': 'constructionWorkGroup', 'type': 'constructionWorkGroup'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, isConstructionWorks=None, constructionWorkGroup=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.isConstructionWorks = isConstructionWorks
        self.isConstructionWorks_nsprefix_ = None
        self.constructionWorkGroup = constructionWorkGroup
        self.constructionWorkGroup_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, constructionWorksInfo)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if constructionWorksInfo.subclass:
            return constructionWorksInfo.subclass(*args_, **kwargs_)
        else:
            return constructionWorksInfo(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.isConstructionWorks is not None or
            self.constructionWorkGroup is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'isConstructionWorks':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'isConstructionWorks')
            ival_ = self.gds_validate_boolean(ival_, node, 'isConstructionWorks')
            self.isConstructionWorks = ival_
            self.isConstructionWorks_nsprefix_ = child_.prefix
        elif nodeName_ == 'constructionWorkGroup':
            obj_ = constructionWorkGroup.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.constructionWorkGroup = obj_
            obj_.original_tagname_ = 'constructionWorkGroup'
# end class constructionWorksInfo


class constructionWorkGroup(GeneratedsSuper):
    """Группа работ по строительству"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'code': MemberSpec_('code', ['groupBuildCodeType', 'xs:string'], 0, 0, {'name': 'code', 'type': 'xs:string'}, None),
        'name': MemberSpec_('name', ['text1000Type', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'name', 'type': 'xs:string'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, code=None, name=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.code = code
        self.validate_groupBuildCodeType(self.code)
        self.code_nsprefix_ = None
        self.name = name
        self.validate_text1000Type(self.name)
        self.name_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, constructionWorkGroup)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if constructionWorkGroup.subclass:
            return constructionWorkGroup.subclass(*args_, **kwargs_)
        else:
            return constructionWorkGroup(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_groupBuildCodeType(self, value):
        result = True
        # Validate type groupBuildCodeType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 5:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on groupBuildCodeType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on groupBuildCodeType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_text1000Type(self, value):
        result = True
        # Validate type text1000Type, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on text1000Type' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on text1000Type' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.code is not None or
            self.name is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'code':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'code')
            value_ = self.gds_validate_string(value_, node, 'code')
            self.code = value_
            self.code_nsprefix_ = child_.prefix
            # validate type groupBuildCodeType
            self.validate_groupBuildCodeType(self.code)
        elif nodeName_ == 'name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'name')
            value_ = self.gds_validate_string(value_, node, 'name')
            self.name = value_
            self.name_nsprefix_ = child_.prefix
            # validate type text1000Type
            self.validate_text1000Type(self.name)
# end class constructionWorkGroup


class priceInfo(GeneratedsSuper):
    """Информация о цене контракта"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'price': MemberSpec_('price', ['moneyPositiveType', 'xs:string'], 0, 0, {'name': 'price', 'type': 'xs:string'}, 17),
        'priceType': MemberSpec_('priceType', ['priceType', 'xs:string'], 0, 0, {'name': 'priceType', 'type': 'xs:string'}, 17),
        'priceFormula': MemberSpec_('priceFormula', ['zfcs_longTextMinType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'priceFormula', 'type': 'xs:string'}, 17),
        'maxPriceAndPriceFormulaSpecified': MemberSpec_('maxPriceAndPriceFormulaSpecified', 'xs:boolean', 0, 1, {'minOccurs': '0', 'name': 'maxPriceAndPriceFormulaSpecified', 'type': 'xs:boolean'}, 17),
        'currency': MemberSpec_('currency', 'zfcs_currencyRef', 0, 0, {'name': 'currency', 'type': 'zfcs_currencyRef'}, 17),
        'currencyRate': MemberSpec_('currencyRate', 'zfcs_currencyRateContract2015', 0, 1, {'minOccurs': '0', 'name': 'currencyRate', 'type': 'zfcs_currencyRateContract2015'}, 17),
        'priceRUR': MemberSpec_('priceRUR', ['moneyPositiveType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'priceRUR', 'type': 'xs:string'}, 17),
        'priceVAT': MemberSpec_('priceVAT', ['moneyPositiveType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'priceVAT', 'type': 'xs:string'}, 17),
        'priceVATRUR': MemberSpec_('priceVATRUR', ['moneyPositiveType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'priceVATRUR', 'type': 'xs:string'}, 17),
        'amountsReducedByTaxes': MemberSpec_('amountsReducedByTaxes', 'xs:boolean', 0, 1, {'fixed': 'true', 'minOccurs': '0', 'name': 'amountsReducedByTaxes', 'type': 'xs:boolean'}, 17),
        'rightToConcludeContractPriceInfo': MemberSpec_('rightToConcludeContractPriceInfo', 'zfcs_contract2015PriceInfoType', 0, 0, {'name': 'rightToConcludeContractPriceInfo', 'type': 'rightToConcludeContractPriceInfo'}, 17),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, price=None, priceType=None, priceFormula=None, maxPriceAndPriceFormulaSpecified=None, currency=None, currencyRate=None, priceRUR=None, priceVAT=None, priceVATRUR=None, amountsReducedByTaxes=None, rightToConcludeContractPriceInfo=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.price = price
        self.validate_moneyPositiveType(self.price)
        self.price_nsprefix_ = None
        self.priceType = priceType
        self.priceType_nsprefix_ = None
        self.priceFormula = priceFormula
        self.validate_zfcs_longTextMinType(self.priceFormula)
        self.priceFormula_nsprefix_ = None
        self.maxPriceAndPriceFormulaSpecified = maxPriceAndPriceFormulaSpecified
        self.maxPriceAndPriceFormulaSpecified_nsprefix_ = None
        self.currency = currency
        self.currency_nsprefix_ = None
        self.currencyRate = currencyRate
        self.currencyRate_nsprefix_ = None
        self.priceRUR = priceRUR
        self.validate_moneyPositiveType(self.priceRUR)
        self.priceRUR_nsprefix_ = None
        self.priceVAT = priceVAT
        self.validate_moneyPositiveType(self.priceVAT)
        self.priceVAT_nsprefix_ = None
        self.priceVATRUR = priceVATRUR
        self.validate_moneyPositiveType(self.priceVATRUR)
        self.priceVATRUR_nsprefix_ = None
        self.amountsReducedByTaxes = amountsReducedByTaxes
        self.amountsReducedByTaxes_nsprefix_ = None
        self.rightToConcludeContractPriceInfo = rightToConcludeContractPriceInfo
        self.rightToConcludeContractPriceInfo_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, priceInfo)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if priceInfo.subclass:
            return priceInfo.subclass(*args_, **kwargs_)
        else:
            return priceInfo(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_moneyPositiveType(self, value):
        result = True
        # Validate type moneyPositiveType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 21:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on moneyPositiveType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on moneyPositiveType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_moneyPositiveType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_moneyPositiveType_patterns_, ))
                result = False
        return result
    validate_moneyPositiveType_patterns_ = [['^(\\d+(\\.\\d{1,2})?)$']]
    def validate_zfcs_longTextMinType(self, value):
        result = True
        # Validate type zfcs_longTextMinType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 2000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on zfcs_longTextMinType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on zfcs_longTextMinType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.price is not None or
            self.priceType is not None or
            self.priceFormula is not None or
            self.maxPriceAndPriceFormulaSpecified is not None or
            self.currency is not None or
            self.currencyRate is not None or
            self.priceRUR is not None or
            self.priceVAT is not None or
            self.priceVATRUR is not None or
            self.amountsReducedByTaxes is not None or
            self.rightToConcludeContractPriceInfo is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'price':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'price')
            value_ = self.gds_validate_string(value_, node, 'price')
            self.price = value_
            self.price_nsprefix_ = child_.prefix
            # validate type moneyPositiveType
            self.validate_moneyPositiveType(self.price)
        elif nodeName_ == 'priceType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'priceType')
            value_ = self.gds_validate_string(value_, node, 'priceType')
            self.priceType = value_
            self.priceType_nsprefix_ = child_.prefix
        elif nodeName_ == 'priceFormula':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'priceFormula')
            value_ = self.gds_validate_string(value_, node, 'priceFormula')
            self.priceFormula = value_
            self.priceFormula_nsprefix_ = child_.prefix
            # validate type zfcs_longTextMinType
            self.validate_zfcs_longTextMinType(self.priceFormula)
        elif nodeName_ == 'maxPriceAndPriceFormulaSpecified':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'maxPriceAndPriceFormulaSpecified')
            ival_ = self.gds_validate_boolean(ival_, node, 'maxPriceAndPriceFormulaSpecified')
            self.maxPriceAndPriceFormulaSpecified = ival_
            self.maxPriceAndPriceFormulaSpecified_nsprefix_ = child_.prefix
        elif nodeName_ == 'currency':
            obj_ = zfcs_currencyRef.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.currency = obj_
            obj_.original_tagname_ = 'currency'
        elif nodeName_ == 'currencyRate':
            obj_ = zfcs_currencyRateContract2015.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.currencyRate = obj_
            obj_.original_tagname_ = 'currencyRate'
        elif nodeName_ == 'priceRUR':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'priceRUR')
            value_ = self.gds_validate_string(value_, node, 'priceRUR')
            self.priceRUR = value_
            self.priceRUR_nsprefix_ = child_.prefix
            # validate type moneyPositiveType
            self.validate_moneyPositiveType(self.priceRUR)
        elif nodeName_ == 'priceVAT':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'priceVAT')
            value_ = self.gds_validate_string(value_, node, 'priceVAT')
            self.priceVAT = value_
            self.priceVAT_nsprefix_ = child_.prefix
            # validate type moneyPositiveType
            self.validate_moneyPositiveType(self.priceVAT)
        elif nodeName_ == 'priceVATRUR':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'priceVATRUR')
            value_ = self.gds_validate_string(value_, node, 'priceVATRUR')
            self.priceVATRUR = value_
            self.priceVATRUR_nsprefix_ = child_.prefix
            # validate type moneyPositiveType
            self.validate_moneyPositiveType(self.priceVATRUR)
        elif nodeName_ == 'amountsReducedByTaxes':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'amountsReducedByTaxes')
            ival_ = self.gds_validate_boolean(ival_, node, 'amountsReducedByTaxes')
            self.amountsReducedByTaxes = ival_
            self.amountsReducedByTaxes_nsprefix_ = child_.prefix
        elif nodeName_ == 'rightToConcludeContractPriceInfo':
            obj_ = rightToConcludeContractPriceInfo.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.rightToConcludeContractPriceInfo = obj_
            obj_.original_tagname_ = 'rightToConcludeContractPriceInfo'
# end class priceInfo


class priceType(GeneratedsSuper):
    """Способ указания цены контракта:
    P - цена контракта;
    OP - ориентировочное значение цены контракта;
    MP - максимальное значение цены контракта.
    Если признак maxPriсeAndPriceFormulaSpecified установлен в true, то
    допускается указание только значения MP"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, priceType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if priceType.subclass:
            return priceType.subclass(*args_, **kwargs_)
        else:
            return priceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_priceType(self, value):
        result = True
        # Validate type priceType, a restriction on xs:string.
        pass
        return result
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class priceType


class advancePaymentSum(GeneratedsSuper):
    """Предусмотрена выплата аванса. В блоке должно быть заполнено либо поле
    sumInPercents либо поле priceValue. Оба поля одновременно заполнены
    быть не могут.
    Не может быть заполнен если заполнен блок "Цена за право заключения
    контракта" (priceInfo\rightToConcludeContractPriceInfo)"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'sumInPercents': MemberSpec_('sumInPercents', ['percentRestr0100Type', 'xs:double'], 0, 1, {'minOccurs': '0', 'name': 'sumInPercents', 'type': 'xs:double'}, None),
        'priceValue': MemberSpec_('priceValue', ['moneyPositiveType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'priceValue', 'type': 'xs:string'}, None),
        'priceValueRUR': MemberSpec_('priceValueRUR', ['moneyPositiveType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'priceValueRUR', 'type': 'xs:string'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, sumInPercents=None, priceValue=None, priceValueRUR=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.sumInPercents = sumInPercents
        self.validate_percentRestr0100Type(self.sumInPercents)
        self.sumInPercents_nsprefix_ = None
        self.priceValue = priceValue
        self.validate_moneyPositiveType(self.priceValue)
        self.priceValue_nsprefix_ = None
        self.priceValueRUR = priceValueRUR
        self.validate_moneyPositiveType(self.priceValueRUR)
        self.priceValueRUR_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, advancePaymentSum)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if advancePaymentSum.subclass:
            return advancePaymentSum.subclass(*args_, **kwargs_)
        else:
            return advancePaymentSum(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_percentRestr0100Type(self, value):
        result = True
        # Validate type percentRestr0100Type, a restriction on xs:double.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, float):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (float)' % {"value": value, "lineno": lineno, })
                return False
            if value < 0:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on percentRestr0100Type' % {"value": value, "lineno": lineno} )
                result = False
            if value > 100:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxInclusive restriction on percentRestr0100Type' % {"value": value, "lineno": lineno} )
                result = False
        return result
    def validate_moneyPositiveType(self, value):
        result = True
        # Validate type moneyPositiveType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 21:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on moneyPositiveType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on moneyPositiveType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_moneyPositiveType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_moneyPositiveType_patterns_, ))
                result = False
        return result
    validate_moneyPositiveType_patterns_ = [['^(\\d+(\\.\\d{1,2})?)$']]
    def hasContent_(self):
        if (
            self.sumInPercents is not None or
            self.priceValue is not None or
            self.priceValueRUR is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'sumInPercents' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_double(sval_, node, 'sumInPercents')
            fval_ = self.gds_validate_double(fval_, node, 'sumInPercents')
            self.sumInPercents = fval_
            self.sumInPercents_nsprefix_ = child_.prefix
            # validate type percentRestr0100Type
            self.validate_percentRestr0100Type(self.sumInPercents)
        elif nodeName_ == 'priceValue':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'priceValue')
            value_ = self.gds_validate_string(value_, node, 'priceValue')
            self.priceValue = value_
            self.priceValue_nsprefix_ = child_.prefix
            # validate type moneyPositiveType
            self.validate_moneyPositiveType(self.priceValue)
        elif nodeName_ == 'priceValueRUR':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'priceValueRUR')
            value_ = self.gds_validate_string(value_, node, 'priceValueRUR')
            self.priceValueRUR = value_
            self.priceValueRUR_nsprefix_ = child_.prefix
            # validate type moneyPositiveType
            self.validate_moneyPositiveType(self.priceValueRUR)
# end class advancePaymentSum


class subContractorsSum(GeneratedsSuper):
    """Объем привлечения к исполнению контракта субподрядчиков"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'sumInPercents': MemberSpec_('sumInPercents', ['sumInPercents', 'xs:double'], 0, 0, {'name': 'sumInPercents', 'type': 'xs:double'}, None),
        'priceValueRUR': MemberSpec_('priceValueRUR', ['moneyPositiveType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'priceValueRUR', 'type': 'xs:string'}, None),
        'subContractors': MemberSpec_('subContractors', 'subContractors', 0, 1, {'minOccurs': '0', 'name': 'subContractors', 'type': 'subContractors'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, sumInPercents=None, priceValueRUR=None, subContractors=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.sumInPercents = sumInPercents
        self.sumInPercents_nsprefix_ = None
        self.priceValueRUR = priceValueRUR
        self.validate_moneyPositiveType(self.priceValueRUR)
        self.priceValueRUR_nsprefix_ = None
        self.subContractors = subContractors
        self.subContractors_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, subContractorsSum)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if subContractorsSum.subclass:
            return subContractorsSum.subclass(*args_, **kwargs_)
        else:
            return subContractorsSum(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_moneyPositiveType(self, value):
        result = True
        # Validate type moneyPositiveType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 21:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on moneyPositiveType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on moneyPositiveType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_moneyPositiveType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_moneyPositiveType_patterns_, ))
                result = False
        return result
    validate_moneyPositiveType_patterns_ = [['^(\\d+(\\.\\d{1,2})?)$']]
    def hasContent_(self):
        if (
            self.sumInPercents is not None or
            self.priceValueRUR is not None or
            self.subContractors is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'sumInPercents' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_double(sval_, node, 'sumInPercents')
            fval_ = self.gds_validate_double(fval_, node, 'sumInPercents')
            self.sumInPercents = fval_
            self.sumInPercents_nsprefix_ = child_.prefix
        elif nodeName_ == 'priceValueRUR':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'priceValueRUR')
            value_ = self.gds_validate_string(value_, node, 'priceValueRUR')
            self.priceValueRUR = value_
            self.priceValueRUR_nsprefix_ = child_.prefix
            # validate type moneyPositiveType
            self.validate_moneyPositiveType(self.priceValueRUR)
        elif nodeName_ == 'subContractors':
            obj_ = subContractors.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.subContractors = obj_
            obj_.original_tagname_ = 'subContractors'
# end class subContractorsSum


class sumInPercents(GeneratedsSuper):
    """Объем в процентах"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, sumInPercents)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if sumInPercents.subclass:
            return sumInPercents.subclass(*args_, **kwargs_)
        else:
            return sumInPercents(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_sumInPercents(self, value):
        result = True
        # Validate type sumInPercents, a restriction on xs:double.
        pass
        return result
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class sumInPercents


class subContractors(GeneratedsSuper):
    """Информация о субподрядчиках, соисполнителях (СМП, СОНО)"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'subContractor': MemberSpec_('subContractor', 'subContractor', 1, 0, {'maxOccurs': 'unbounded', 'name': 'subContractor', 'type': 'subContractor'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, subContractor=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if subContractor is None:
            self.subContractor = []
        else:
            self.subContractor = subContractor
        self.subContractor_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, subContractors)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if subContractors.subclass:
            return subContractors.subclass(*args_, **kwargs_)
        else:
            return subContractors(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.subContractor
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'subContractor':
            obj_ = subContractor.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.subContractor.append(obj_)
            obj_.original_tagname_ = 'subContractor'
# end class subContractors


class subContractor(GeneratedsSuper):
    """Субподрядчик, соисполнитель"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'legalEntityRF': MemberSpec_('legalEntityRF', 'legalEntityRF', 0, 0, {'name': 'legalEntityRF', 'type': 'legalEntityRF'}, 18),
        'individualBusinessmanRF': MemberSpec_('individualBusinessmanRF', 'individualBusinessmanRF', 0, 0, {'name': 'individualBusinessmanRF', 'type': 'individualBusinessmanRF'}, 18),
        'notPublishedOnEIS': MemberSpec_('notPublishedOnEIS', 'xs:boolean', 0, 0, {'fixed': 'true', 'name': 'notPublishedOnEIS', 'type': 'xs:boolean'}, 18),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, legalEntityRF=None, individualBusinessmanRF=None, notPublishedOnEIS=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.legalEntityRF = legalEntityRF
        self.legalEntityRF_nsprefix_ = None
        self.individualBusinessmanRF = individualBusinessmanRF
        self.individualBusinessmanRF_nsprefix_ = None
        self.notPublishedOnEIS = notPublishedOnEIS
        self.notPublishedOnEIS_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, subContractor)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if subContractor.subclass:
            return subContractor.subclass(*args_, **kwargs_)
        else:
            return subContractor(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.legalEntityRF is not None or
            self.individualBusinessmanRF is not None or
            self.notPublishedOnEIS is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'legalEntityRF':
            obj_ = legalEntityRF.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.legalEntityRF = obj_
            obj_.original_tagname_ = 'legalEntityRF'
        elif nodeName_ == 'individualBusinessmanRF':
            obj_ = individualBusinessmanRF.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.individualBusinessmanRF = obj_
            obj_.original_tagname_ = 'individualBusinessmanRF'
        elif nodeName_ == 'notPublishedOnEIS':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'notPublishedOnEIS')
            ival_ = self.gds_validate_boolean(ival_, node, 'notPublishedOnEIS')
            self.notPublishedOnEIS = ival_
            self.notPublishedOnEIS_nsprefix_ = child_.prefix
# end class subContractor


class legalEntityRF(GeneratedsSuper):
    """Юридическое лицо РФ"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'legalForm': MemberSpec_('legalForm', 'zfcs_okopfRef', 0, 1, {'minOccurs': '0', 'name': 'legalForm', 'type': 'zfcs_okopfRef'}, 18),
        'fullName': MemberSpec_('fullName', ['zfcs_longTextMinType', 'xs:string'], 0, 0, {'name': 'fullName', 'type': 'xs:string'}, 18),
        'firmName': MemberSpec_('firmName', ['zfcs_longTextMinType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'firmName', 'type': 'xs:string'}, 18),
        'INN': MemberSpec_('INN', ['innType', 'xs:string'], 0, 0, {'name': 'INN', 'type': 'xs:string'}, 18),
        'KPP': MemberSpec_('KPP', ['kppType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'KPP', 'type': 'xs:string'}, 18),
        'registrationDate': MemberSpec_('registrationDate', 'xs:date', 0, 1, {'minOccurs': '0', 'name': 'registrationDate', 'type': 'xs:date'}, 18),
        'status': MemberSpec_('status', ['zfcs_participantStatusContract2015Type', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'status', 'type': 'xs:string'}, 18),
        'ERSMSPInclusionDate': MemberSpec_('ERSMSPInclusionDate', 'xs:date', 0, 1, {'minOccurs': '0', 'name': 'ERSMSPInclusionDate', 'type': 'xs:date'}, 18),
        'address': MemberSpec_('address', ['address', 'xs:string'], 0, 0, {'name': 'address', 'type': 'xs:string'}, 18),
        'postalServiceUserAdress': MemberSpec_('postalServiceUserAdress', ['zfcs_contract2015AddressType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'postalServiceUserAdress', 'type': 'xs:string'}, 18),
        'postalObjectName': MemberSpec_('postalObjectName', ['zfcs_contract2015AddressType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'postalObjectName', 'type': 'xs:string'}, 18),
        'cellNum': MemberSpec_('cellNum', ['zfcs_contract2015AddressType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'cellNum', 'type': 'xs:string'}, 18),
        'subContractInfo': MemberSpec_('subContractInfo', 'zfcs_contract2015SubContractInfoType', 0, 0, {'name': 'subContractInfo', 'type': 'zfcs_contract2015SubContractInfoType'}, 18),
        'subPurchaseObjectsInfo': MemberSpec_('subPurchaseObjectsInfo', 'subPurchaseObjectsInfo', 0, 1, {'minOccurs': '0', 'name': 'subPurchaseObjectsInfo', 'type': 'subPurchaseObjectsInfo'}, 18),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, legalForm=None, fullName=None, firmName=None, INN=None, KPP=None, registrationDate=None, status=None, ERSMSPInclusionDate=None, address=None, postalServiceUserAdress=None, postalObjectName=None, cellNum=None, subContractInfo=None, subPurchaseObjectsInfo=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.legalForm = legalForm
        self.legalForm_nsprefix_ = None
        self.fullName = fullName
        self.validate_zfcs_longTextMinType(self.fullName)
        self.fullName_nsprefix_ = None
        self.firmName = firmName
        self.validate_zfcs_longTextMinType(self.firmName)
        self.firmName_nsprefix_ = None
        self.INN = INN
        self.validate_innType(self.INN)
        self.INN_nsprefix_ = None
        self.KPP = KPP
        self.validate_kppType(self.KPP)
        self.KPP_nsprefix_ = None
        if isinstance(registrationDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(registrationDate, '%Y-%m-%d').date()
        else:
            initvalue_ = registrationDate
        self.registrationDate = initvalue_
        self.registrationDate_nsprefix_ = None
        self.status = status
        self.validate_zfcs_participantStatusContract2015Type(self.status)
        self.status_nsprefix_ = None
        if isinstance(ERSMSPInclusionDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(ERSMSPInclusionDate, '%Y-%m-%d').date()
        else:
            initvalue_ = ERSMSPInclusionDate
        self.ERSMSPInclusionDate = initvalue_
        self.ERSMSPInclusionDate_nsprefix_ = None
        self.address = address
        self.address_nsprefix_ = None
        self.postalServiceUserAdress = postalServiceUserAdress
        self.validate_zfcs_contract2015AddressType(self.postalServiceUserAdress)
        self.postalServiceUserAdress_nsprefix_ = None
        self.postalObjectName = postalObjectName
        self.validate_zfcs_contract2015AddressType(self.postalObjectName)
        self.postalObjectName_nsprefix_ = None
        self.cellNum = cellNum
        self.validate_zfcs_contract2015AddressType(self.cellNum)
        self.cellNum_nsprefix_ = None
        self.subContractInfo = subContractInfo
        self.subContractInfo_nsprefix_ = None
        self.subPurchaseObjectsInfo = subPurchaseObjectsInfo
        self.subPurchaseObjectsInfo_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, legalEntityRF)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if legalEntityRF.subclass:
            return legalEntityRF.subclass(*args_, **kwargs_)
        else:
            return legalEntityRF(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_zfcs_longTextMinType(self, value):
        result = True
        # Validate type zfcs_longTextMinType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 2000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on zfcs_longTextMinType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on zfcs_longTextMinType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_innType(self, value):
        result = True
        # Validate type innType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 12:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on innType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_innType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_innType_patterns_, ))
                result = False
        return result
    validate_innType_patterns_ = [['^(\\d{1,12})$']]
    def validate_kppType(self, value):
        result = True
        # Validate type kppType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) != 9:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd length restriction on kppType' % {"value": encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_zfcs_participantStatusContract2015Type(self, value):
        result = True
        # Validate type zfcs_participantStatusContract2015Type, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['10', '20', '30', '31', '40', '41']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on zfcs_participantStatusContract2015Type' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_zfcs_contract2015AddressType(self, value):
        result = True
        # Validate type zfcs_contract2015AddressType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on zfcs_contract2015AddressType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on zfcs_contract2015AddressType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.legalForm is not None or
            self.fullName is not None or
            self.firmName is not None or
            self.INN is not None or
            self.KPP is not None or
            self.registrationDate is not None or
            self.status is not None or
            self.ERSMSPInclusionDate is not None or
            self.address is not None or
            self.postalServiceUserAdress is not None or
            self.postalObjectName is not None or
            self.cellNum is not None or
            self.subContractInfo is not None or
            self.subPurchaseObjectsInfo is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'legalForm':
            obj_ = zfcs_okopfRef.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.legalForm = obj_
            obj_.original_tagname_ = 'legalForm'
        elif nodeName_ == 'fullName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'fullName')
            value_ = self.gds_validate_string(value_, node, 'fullName')
            self.fullName = value_
            self.fullName_nsprefix_ = child_.prefix
            # validate type zfcs_longTextMinType
            self.validate_zfcs_longTextMinType(self.fullName)
        elif nodeName_ == 'firmName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'firmName')
            value_ = self.gds_validate_string(value_, node, 'firmName')
            self.firmName = value_
            self.firmName_nsprefix_ = child_.prefix
            # validate type zfcs_longTextMinType
            self.validate_zfcs_longTextMinType(self.firmName)
        elif nodeName_ == 'INN':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'INN')
            value_ = self.gds_validate_string(value_, node, 'INN')
            self.INN = value_
            self.INN_nsprefix_ = child_.prefix
            # validate type innType
            self.validate_innType(self.INN)
        elif nodeName_ == 'KPP':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'KPP')
            value_ = self.gds_validate_string(value_, node, 'KPP')
            self.KPP = value_
            self.KPP_nsprefix_ = child_.prefix
            # validate type kppType
            self.validate_kppType(self.KPP)
        elif nodeName_ == 'registrationDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.registrationDate = dval_
            self.registrationDate_nsprefix_ = child_.prefix
        elif nodeName_ == 'status':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'status')
            value_ = self.gds_validate_string(value_, node, 'status')
            self.status = value_
            self.status_nsprefix_ = child_.prefix
            # validate type zfcs_participantStatusContract2015Type
            self.validate_zfcs_participantStatusContract2015Type(self.status)
        elif nodeName_ == 'ERSMSPInclusionDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.ERSMSPInclusionDate = dval_
            self.ERSMSPInclusionDate_nsprefix_ = child_.prefix
        elif nodeName_ == 'address':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'address')
            value_ = self.gds_validate_string(value_, node, 'address')
            self.address = value_
            self.address_nsprefix_ = child_.prefix
        elif nodeName_ == 'postalServiceUserAdress':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'postalServiceUserAdress')
            value_ = self.gds_validate_string(value_, node, 'postalServiceUserAdress')
            self.postalServiceUserAdress = value_
            self.postalServiceUserAdress_nsprefix_ = child_.prefix
            # validate type zfcs_contract2015AddressType
            self.validate_zfcs_contract2015AddressType(self.postalServiceUserAdress)
        elif nodeName_ == 'postalObjectName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'postalObjectName')
            value_ = self.gds_validate_string(value_, node, 'postalObjectName')
            self.postalObjectName = value_
            self.postalObjectName_nsprefix_ = child_.prefix
            # validate type zfcs_contract2015AddressType
            self.validate_zfcs_contract2015AddressType(self.postalObjectName)
        elif nodeName_ == 'cellNum':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'cellNum')
            value_ = self.gds_validate_string(value_, node, 'cellNum')
            self.cellNum = value_
            self.cellNum_nsprefix_ = child_.prefix
            # validate type zfcs_contract2015AddressType
            self.validate_zfcs_contract2015AddressType(self.cellNum)
        elif nodeName_ == 'subContractInfo':
            obj_ = zfcs_contract2015SubContractInfoType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.subContractInfo = obj_
            obj_.original_tagname_ = 'subContractInfo'
        elif nodeName_ == 'subPurchaseObjectsInfo':
            obj_ = subPurchaseObjectsInfo.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.subPurchaseObjectsInfo = obj_
            obj_.original_tagname_ = 'subPurchaseObjectsInfo'
# end class legalEntityRF


class address(GeneratedsSuper):
    """Адрес места нахождения"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, address)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if address.subclass:
            return address.subclass(*args_, **kwargs_)
        else:
            return address(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_address(self, value):
        result = True
        # Validate type address, a restriction on xs:string.
        pass
        return result
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class address


class subPurchaseObjectsInfo(GeneratedsSuper):
    """Информация об объектах закупки в субподрядном договоре"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'subPurchaseObjectInfo': MemberSpec_('subPurchaseObjectInfo', 'zfcs_contract2015PurchaseObjectInfoType', 1, 0, {'maxOccurs': 'unbounded', 'name': 'subPurchaseObjectInfo', 'type': 'zfcs_contract2015PurchaseObjectInfoType'}, 18),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, subPurchaseObjectInfo=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if subPurchaseObjectInfo is None:
            self.subPurchaseObjectInfo = []
        else:
            self.subPurchaseObjectInfo = subPurchaseObjectInfo
        self.subPurchaseObjectInfo_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, subPurchaseObjectsInfo)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if subPurchaseObjectsInfo.subclass:
            return subPurchaseObjectsInfo.subclass(*args_, **kwargs_)
        else:
            return subPurchaseObjectsInfo(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.subPurchaseObjectInfo
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'subPurchaseObjectInfo':
            class_obj_ = self.get_class_obj_(child_, zfcs_contract2015PurchaseObjectInfoType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.subPurchaseObjectInfo.append(obj_)
            obj_.original_tagname_ = 'subPurchaseObjectInfo'
# end class subPurchaseObjectsInfo


class individualBusinessmanRF(GeneratedsSuper):
    """Индивидуальный предприниматель РФ"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'lastName': MemberSpec_('lastName', ['lastName', 'xs:string'], 0, 0, {'name': 'lastName', 'type': 'xs:string'}, 18),
        'firstName': MemberSpec_('firstName', ['firstName', 'xs:string'], 0, 0, {'name': 'firstName', 'type': 'xs:string'}, 18),
        'middleName': MemberSpec_('middleName', ['middleName', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'middleName', 'type': 'xs:string'}, 18),
        'INN': MemberSpec_('INN', ['innType', 'xs:string'], 0, 0, {'name': 'INN', 'type': 'xs:string'}, 18),
        'registrationDate': MemberSpec_('registrationDate', 'xs:date', 0, 1, {'minOccurs': '0', 'name': 'registrationDate', 'type': 'xs:date'}, 18),
        'status': MemberSpec_('status', ['zfcs_participantStatusContract2015Type', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'status', 'type': 'xs:string'}, 18),
        'ERSMSPInclusionDate': MemberSpec_('ERSMSPInclusionDate', 'xs:date', 0, 1, {'minOccurs': '0', 'name': 'ERSMSPInclusionDate', 'type': 'xs:date'}, 18),
        'address': MemberSpec_('address', ['address', 'xs:string'], 0, 0, {'name': 'address', 'type': 'xs:string'}, 18),
        'postalServiceUserAdress': MemberSpec_('postalServiceUserAdress', ['zfcs_contract2015AddressType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'postalServiceUserAdress', 'type': 'xs:string'}, 18),
        'postalObjectName': MemberSpec_('postalObjectName', ['zfcs_contract2015AddressType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'postalObjectName', 'type': 'xs:string'}, 18),
        'cellNum': MemberSpec_('cellNum', ['zfcs_contract2015AddressType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'cellNum', 'type': 'xs:string'}, 18),
        'subContractInfo': MemberSpec_('subContractInfo', 'zfcs_contract2015SubContractInfoType', 0, 0, {'name': 'subContractInfo', 'type': 'zfcs_contract2015SubContractInfoType'}, 18),
        'subPurchaseObjectsInfo': MemberSpec_('subPurchaseObjectsInfo', 'subPurchaseObjectsInfo', 0, 1, {'minOccurs': '0', 'name': 'subPurchaseObjectsInfo', 'type': 'subPurchaseObjectsInfo'}, 18),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, lastName=None, firstName=None, middleName=None, INN=None, registrationDate=None, status=None, ERSMSPInclusionDate=None, address=None, postalServiceUserAdress=None, postalObjectName=None, cellNum=None, subContractInfo=None, subPurchaseObjectsInfo=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.lastName = lastName
        self.lastName_nsprefix_ = None
        self.firstName = firstName
        self.firstName_nsprefix_ = None
        self.middleName = middleName
        self.middleName_nsprefix_ = None
        self.INN = INN
        self.validate_innType(self.INN)
        self.INN_nsprefix_ = None
        if isinstance(registrationDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(registrationDate, '%Y-%m-%d').date()
        else:
            initvalue_ = registrationDate
        self.registrationDate = initvalue_
        self.registrationDate_nsprefix_ = None
        self.status = status
        self.validate_zfcs_participantStatusContract2015Type(self.status)
        self.status_nsprefix_ = None
        if isinstance(ERSMSPInclusionDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(ERSMSPInclusionDate, '%Y-%m-%d').date()
        else:
            initvalue_ = ERSMSPInclusionDate
        self.ERSMSPInclusionDate = initvalue_
        self.ERSMSPInclusionDate_nsprefix_ = None
        self.address = address
        self.address_nsprefix_ = None
        self.postalServiceUserAdress = postalServiceUserAdress
        self.validate_zfcs_contract2015AddressType(self.postalServiceUserAdress)
        self.postalServiceUserAdress_nsprefix_ = None
        self.postalObjectName = postalObjectName
        self.validate_zfcs_contract2015AddressType(self.postalObjectName)
        self.postalObjectName_nsprefix_ = None
        self.cellNum = cellNum
        self.validate_zfcs_contract2015AddressType(self.cellNum)
        self.cellNum_nsprefix_ = None
        self.subContractInfo = subContractInfo
        self.subContractInfo_nsprefix_ = None
        self.subPurchaseObjectsInfo = subPurchaseObjectsInfo
        self.subPurchaseObjectsInfo_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, individualBusinessmanRF)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if individualBusinessmanRF.subclass:
            return individualBusinessmanRF.subclass(*args_, **kwargs_)
        else:
            return individualBusinessmanRF(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_innType(self, value):
        result = True
        # Validate type innType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 12:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on innType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_innType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_innType_patterns_, ))
                result = False
        return result
    validate_innType_patterns_ = [['^(\\d{1,12})$']]
    def validate_zfcs_participantStatusContract2015Type(self, value):
        result = True
        # Validate type zfcs_participantStatusContract2015Type, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['10', '20', '30', '31', '40', '41']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on zfcs_participantStatusContract2015Type' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_zfcs_contract2015AddressType(self, value):
        result = True
        # Validate type zfcs_contract2015AddressType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on zfcs_contract2015AddressType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on zfcs_contract2015AddressType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.lastName is not None or
            self.firstName is not None or
            self.middleName is not None or
            self.INN is not None or
            self.registrationDate is not None or
            self.status is not None or
            self.ERSMSPInclusionDate is not None or
            self.address is not None or
            self.postalServiceUserAdress is not None or
            self.postalObjectName is not None or
            self.cellNum is not None or
            self.subContractInfo is not None or
            self.subPurchaseObjectsInfo is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'lastName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'lastName')
            value_ = self.gds_validate_string(value_, node, 'lastName')
            self.lastName = value_
            self.lastName_nsprefix_ = child_.prefix
        elif nodeName_ == 'firstName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'firstName')
            value_ = self.gds_validate_string(value_, node, 'firstName')
            self.firstName = value_
            self.firstName_nsprefix_ = child_.prefix
        elif nodeName_ == 'middleName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'middleName')
            value_ = self.gds_validate_string(value_, node, 'middleName')
            self.middleName = value_
            self.middleName_nsprefix_ = child_.prefix
        elif nodeName_ == 'INN':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'INN')
            value_ = self.gds_validate_string(value_, node, 'INN')
            self.INN = value_
            self.INN_nsprefix_ = child_.prefix
            # validate type innType
            self.validate_innType(self.INN)
        elif nodeName_ == 'registrationDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.registrationDate = dval_
            self.registrationDate_nsprefix_ = child_.prefix
        elif nodeName_ == 'status':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'status')
            value_ = self.gds_validate_string(value_, node, 'status')
            self.status = value_
            self.status_nsprefix_ = child_.prefix
            # validate type zfcs_participantStatusContract2015Type
            self.validate_zfcs_participantStatusContract2015Type(self.status)
        elif nodeName_ == 'ERSMSPInclusionDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.ERSMSPInclusionDate = dval_
            self.ERSMSPInclusionDate_nsprefix_ = child_.prefix
        elif nodeName_ == 'address':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'address')
            value_ = self.gds_validate_string(value_, node, 'address')
            self.address = value_
            self.address_nsprefix_ = child_.prefix
        elif nodeName_ == 'postalServiceUserAdress':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'postalServiceUserAdress')
            value_ = self.gds_validate_string(value_, node, 'postalServiceUserAdress')
            self.postalServiceUserAdress = value_
            self.postalServiceUserAdress_nsprefix_ = child_.prefix
            # validate type zfcs_contract2015AddressType
            self.validate_zfcs_contract2015AddressType(self.postalServiceUserAdress)
        elif nodeName_ == 'postalObjectName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'postalObjectName')
            value_ = self.gds_validate_string(value_, node, 'postalObjectName')
            self.postalObjectName = value_
            self.postalObjectName_nsprefix_ = child_.prefix
            # validate type zfcs_contract2015AddressType
            self.validate_zfcs_contract2015AddressType(self.postalObjectName)
        elif nodeName_ == 'cellNum':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'cellNum')
            value_ = self.gds_validate_string(value_, node, 'cellNum')
            self.cellNum = value_
            self.cellNum_nsprefix_ = child_.prefix
            # validate type zfcs_contract2015AddressType
            self.validate_zfcs_contract2015AddressType(self.cellNum)
        elif nodeName_ == 'subContractInfo':
            obj_ = zfcs_contract2015SubContractInfoType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.subContractInfo = obj_
            obj_.original_tagname_ = 'subContractInfo'
        elif nodeName_ == 'subPurchaseObjectsInfo':
            obj_ = subPurchaseObjectsInfo.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.subPurchaseObjectsInfo = obj_
            obj_.original_tagname_ = 'subPurchaseObjectsInfo'
# end class individualBusinessmanRF


class executionPeriod(GeneratedsSuper):
    """Срок исполнения контракта"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'startDate': MemberSpec_('startDate', 'xs:date', 0, 0, {'name': 'startDate', 'type': 'xs:date'}, None),
        'stages': MemberSpec_('stages', 'stages', 1, 0, {'maxOccurs': 'unbounded', 'name': 'stages', 'type': 'stages'}, None),
        'endDate': MemberSpec_('endDate', 'xs:date', 0, 0, {'name': 'endDate', 'type': 'xs:date'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, startDate=None, stages=None, endDate=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if isinstance(startDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(startDate, '%Y-%m-%d').date()
        else:
            initvalue_ = startDate
        self.startDate = initvalue_
        self.startDate_nsprefix_ = None
        if stages is None:
            self.stages = []
        else:
            self.stages = stages
        self.stages_nsprefix_ = None
        if isinstance(endDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(endDate, '%Y-%m-%d').date()
        else:
            initvalue_ = endDate
        self.endDate = initvalue_
        self.endDate_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, executionPeriod)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if executionPeriod.subclass:
            return executionPeriod.subclass(*args_, **kwargs_)
        else:
            return executionPeriod(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.startDate is not None or
            self.stages or
            self.endDate is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'startDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.startDate = dval_
            self.startDate_nsprefix_ = child_.prefix
        elif nodeName_ == 'stages':
            obj_ = stages.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.stages.append(obj_)
            obj_.original_tagname_ = 'stages'
        elif nodeName_ == 'endDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.endDate = dval_
            self.endDate_nsprefix_ = child_.prefix
# end class executionPeriod


class stageAdvancePaymentSum(GeneratedsSuper):
    """Процент и размер аванса по этапу контракта. Указание допустимо при
    заполненом блоке advancePaymentSum"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'sumInPercents': MemberSpec_('sumInPercents', ['sumInPercents', 'xs:double'], 0, 1, {'minOccurs': '0', 'name': 'sumInPercents', 'type': 'xs:double'}, None),
        'priceValue': MemberSpec_('priceValue', ['moneyPositiveType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'priceValue', 'type': 'xs:string'}, None),
        'priceValueRUR': MemberSpec_('priceValueRUR', ['moneyPositiveType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'priceValueRUR', 'type': 'xs:string'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, sumInPercents=None, priceValue=None, priceValueRUR=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.sumInPercents = sumInPercents
        self.sumInPercents_nsprefix_ = None
        self.priceValue = priceValue
        self.validate_moneyPositiveType(self.priceValue)
        self.priceValue_nsprefix_ = None
        self.priceValueRUR = priceValueRUR
        self.validate_moneyPositiveType(self.priceValueRUR)
        self.priceValueRUR_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, stageAdvancePaymentSum)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if stageAdvancePaymentSum.subclass:
            return stageAdvancePaymentSum.subclass(*args_, **kwargs_)
        else:
            return stageAdvancePaymentSum(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_moneyPositiveType(self, value):
        result = True
        # Validate type moneyPositiveType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 21:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on moneyPositiveType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on moneyPositiveType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_moneyPositiveType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_moneyPositiveType_patterns_, ))
                result = False
        return result
    validate_moneyPositiveType_patterns_ = [['^(\\d+(\\.\\d{1,2})?)$']]
    def hasContent_(self):
        if (
            self.sumInPercents is not None or
            self.priceValue is not None or
            self.priceValueRUR is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'sumInPercents' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_double(sval_, node, 'sumInPercents')
            fval_ = self.gds_validate_double(fval_, node, 'sumInPercents')
            self.sumInPercents = fval_
            self.sumInPercents_nsprefix_ = child_.prefix
        elif nodeName_ == 'priceValue':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'priceValue')
            value_ = self.gds_validate_string(value_, node, 'priceValue')
            self.priceValue = value_
            self.priceValue_nsprefix_ = child_.prefix
            # validate type moneyPositiveType
            self.validate_moneyPositiveType(self.priceValue)
        elif nodeName_ == 'priceValueRUR':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'priceValueRUR')
            value_ = self.gds_validate_string(value_, node, 'priceValueRUR')
            self.priceValueRUR = value_
            self.priceValueRUR_nsprefix_ = child_.prefix
            # validate type moneyPositiveType
            self.validate_moneyPositiveType(self.priceValueRUR)
# end class stageAdvancePaymentSum


class st14Info(GeneratedsSuper):
    """Информация о применении к закупке национального режима. Блок
    игнорируется и заполняется автоматически, в случае если контракт создан
    на основании извещения об осуществлении закупки (заполнен блок
    foundation\fcsOrder\order\notificationNumber) и в извещении в блоке
    restrictions выбрано ограничение «Запрет на допуск товаров, работ,
    услуг при осуществлении закупок, а также ограничения и условия допуска
    в соответствии с требованиями, установленными статьей 14 Федерального
    закона № 44-ФЗ» (код JB2149).
    Блок игнорируется и не устанавливается признак "К закупке применяется
    национальный режим в соответствии со статьей 14 Федерального закона №
    44-ФЗ", в случае если контракт создан на основании извещения об
    осуществлении закупки (заполнен блок
    foundation\fcsOrder\order\notificationNumber) и в извещении в блоке
    restrictions выбрано ограничение «Запрет на допуск товаров, работ,
    услуг при осуществлении закупок, а также ограничения и условия допуска
    в соответствии с требованиями, установленными статьей 14 Федерального
    закона № 44-ФЗ» (код JB2149) или в случае если данное ограничение
    выбрано, но при этом отсутствует хотя бы один НПА в извещении с не
    установленным признаком lot/restrictions/restriction/restrictionsSt14/r
    estrictionSt14/exception/imposibilityBan в true. Также блок
    игнорируется и не устанавливается признак, в случае если в качестве
    основания заключения контракта выбран блок
    foundation/fcsOrder/singleCustomer и код
    foundation/fcsOrder/singleCustomer/reason/code не равен 20220.
    В других случаях блок принимается и сохраняется.
    Содержимое блока принимается (или автоматически заполняется из связанного
    извещения) для сведений о контракте, первая версия которых размещена
    после 01.01.2020"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'NPAsInfo': MemberSpec_('NPAsInfo', 'NPAsInfo', 1, 0, {'maxOccurs': 'unbounded', 'name': 'NPAsInfo', 'type': 'NPAsInfo'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, NPAsInfo=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if NPAsInfo is None:
            self.NPAsInfo = []
        else:
            self.NPAsInfo = NPAsInfo
        self.NPAsInfo_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, st14Info)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if st14Info.subclass:
            return st14Info.subclass(*args_, **kwargs_)
        else:
            return st14Info(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.NPAsInfo
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'NPAsInfo':
            obj_ = NPAsInfo.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.NPAsInfo.append(obj_)
            obj_.original_tagname_ = 'NPAsInfo'
# end class st14Info


class NPAsInfo(GeneratedsSuper):
    """Нормативно-правовые акты, определяющие применение национального режима.
    При автоматическом заполнении из закупки не наследуются НПА, для
    которых установлен признак "Присутствуют обстоятельства, допускающие
    исключение, влекущее неприменение запрета, ограничения допуска"
    (restrictionSt14/exception/imposibilityBan) в значение true"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'NPAInfo': MemberSpec_('NPAInfo', 'NPASt14Ref', 0, 0, {'name': 'NPAInfo', 'type': 'NPASt14Ref'}, None),
        'requirementType': MemberSpec_('requirementType', ['text10Type', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'requirementType', 'type': 'xs:string'}, None),
        'requirementName': MemberSpec_('requirementName', ['text2000Type', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'requirementName', 'type': 'xs:string'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, NPAInfo=None, requirementType=None, requirementName=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.NPAInfo = NPAInfo
        self.NPAInfo_nsprefix_ = None
        self.requirementType = requirementType
        self.validate_text10Type(self.requirementType)
        self.requirementType_nsprefix_ = None
        self.requirementName = requirementName
        self.validate_text2000Type(self.requirementName)
        self.requirementName_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NPAsInfo)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NPAsInfo.subclass:
            return NPAsInfo.subclass(*args_, **kwargs_)
        else:
            return NPAsInfo(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_text10Type(self, value):
        result = True
        # Validate type text10Type, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 10:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on text10Type' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on text10Type' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_text2000Type(self, value):
        result = True
        # Validate type text2000Type, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 2000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on text2000Type' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on text2000Type' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.NPAInfo is not None or
            self.requirementType is not None or
            self.requirementName is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'NPAInfo':
            obj_ = NPASt14Ref.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.NPAInfo = obj_
            obj_.original_tagname_ = 'NPAInfo'
        elif nodeName_ == 'requirementType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'requirementType')
            value_ = self.gds_validate_string(value_, node, 'requirementType')
            self.requirementType = value_
            self.requirementType_nsprefix_ = child_.prefix
            # validate type text10Type
            self.validate_text10Type(self.requirementType)
        elif nodeName_ == 'requirementName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'requirementName')
            value_ = self.gds_validate_string(value_, node, 'requirementName')
            self.requirementName = value_
            self.requirementName_nsprefix_ = child_.prefix
            # validate type text2000Type
            self.validate_text2000Type(self.requirementName)
# end class NPAsInfo


class qualityGuaranteeInfo(GeneratedsSuper):
    """Информация о гарантии качества товара, работы услуги"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'providedPeriod': MemberSpec_('providedPeriod', 'providedPeriod', 0, 0, {'name': 'providedPeriod', 'type': 'providedPeriod'}, 19),
        'notPublishedOnEIS': MemberSpec_('notPublishedOnEIS', 'xs:boolean', 0, 0, {'fixed': 'true', 'name': 'notPublishedOnEIS', 'type': 'xs:boolean'}, None),
        'warrantyReqsText': MemberSpec_('warrantyReqsText', ['zfcs_longTextMinType', 'xs:string'], 0, 0, {'name': 'warrantyReqsText', 'type': 'xs:string'}, None),
        'manufacturerWarrantyReqsText': MemberSpec_('manufacturerWarrantyReqsText', ['zfcs_longTextMinType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'manufacturerWarrantyReqsText', 'type': 'xs:string'}, None),
        'isQAEnsuramceRequired': MemberSpec_('isQAEnsuramceRequired', 'xs:boolean', 0, 1, {'minOccurs': '0', 'name': 'isQAEnsuramceRequired', 'type': 'xs:boolean'}, None),
        'execObligationsGuaranteeInfo': MemberSpec_('execObligationsGuaranteeInfo', 'execObligationsGuaranteeInfo', 0, 1, {'minOccurs': '0', 'name': 'execObligationsGuaranteeInfo', 'type': 'execObligationsGuaranteeInfo'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, providedPeriod=None, notPublishedOnEIS=None, warrantyReqsText=None, manufacturerWarrantyReqsText=None, isQAEnsuramceRequired=None, execObligationsGuaranteeInfo=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.providedPeriod = providedPeriod
        self.providedPeriod_nsprefix_ = None
        self.notPublishedOnEIS = notPublishedOnEIS
        self.notPublishedOnEIS_nsprefix_ = None
        self.warrantyReqsText = warrantyReqsText
        self.validate_zfcs_longTextMinType(self.warrantyReqsText)
        self.warrantyReqsText_nsprefix_ = None
        self.manufacturerWarrantyReqsText = manufacturerWarrantyReqsText
        self.validate_zfcs_longTextMinType(self.manufacturerWarrantyReqsText)
        self.manufacturerWarrantyReqsText_nsprefix_ = None
        self.isQAEnsuramceRequired = isQAEnsuramceRequired
        self.isQAEnsuramceRequired_nsprefix_ = None
        self.execObligationsGuaranteeInfo = execObligationsGuaranteeInfo
        self.execObligationsGuaranteeInfo_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, qualityGuaranteeInfo)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if qualityGuaranteeInfo.subclass:
            return qualityGuaranteeInfo.subclass(*args_, **kwargs_)
        else:
            return qualityGuaranteeInfo(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_zfcs_longTextMinType(self, value):
        result = True
        # Validate type zfcs_longTextMinType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 2000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on zfcs_longTextMinType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on zfcs_longTextMinType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.providedPeriod is not None or
            self.notPublishedOnEIS is not None or
            self.warrantyReqsText is not None or
            self.manufacturerWarrantyReqsText is not None or
            self.isQAEnsuramceRequired is not None or
            self.execObligationsGuaranteeInfo is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'providedPeriod':
            obj_ = providedPeriod.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.providedPeriod = obj_
            obj_.original_tagname_ = 'providedPeriod'
        elif nodeName_ == 'notPublishedOnEIS':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'notPublishedOnEIS')
            ival_ = self.gds_validate_boolean(ival_, node, 'notPublishedOnEIS')
            self.notPublishedOnEIS = ival_
            self.notPublishedOnEIS_nsprefix_ = child_.prefix
        elif nodeName_ == 'warrantyReqsText':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'warrantyReqsText')
            value_ = self.gds_validate_string(value_, node, 'warrantyReqsText')
            self.warrantyReqsText = value_
            self.warrantyReqsText_nsprefix_ = child_.prefix
            # validate type zfcs_longTextMinType
            self.validate_zfcs_longTextMinType(self.warrantyReqsText)
        elif nodeName_ == 'manufacturerWarrantyReqsText':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'manufacturerWarrantyReqsText')
            value_ = self.gds_validate_string(value_, node, 'manufacturerWarrantyReqsText')
            self.manufacturerWarrantyReqsText = value_
            self.manufacturerWarrantyReqsText_nsprefix_ = child_.prefix
            # validate type zfcs_longTextMinType
            self.validate_zfcs_longTextMinType(self.manufacturerWarrantyReqsText)
        elif nodeName_ == 'isQAEnsuramceRequired':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'isQAEnsuramceRequired')
            ival_ = self.gds_validate_boolean(ival_, node, 'isQAEnsuramceRequired')
            self.isQAEnsuramceRequired = ival_
            self.isQAEnsuramceRequired_nsprefix_ = child_.prefix
        elif nodeName_ == 'execObligationsGuaranteeInfo':
            obj_ = execObligationsGuaranteeInfo.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.execObligationsGuaranteeInfo = obj_
            obj_.original_tagname_ = 'execObligationsGuaranteeInfo'
# end class qualityGuaranteeInfo


class providedPeriod(GeneratedsSuper):
    """Срок, на который предоставляется гарантияСрок в формате интервала дат"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'fromDate': MemberSpec_('fromDate', 'xs:date', 0, 0, {'name': 'fromDate', 'type': 'xs:date'}, 20),
        'toDate': MemberSpec_('toDate', 'xs:date', 0, 0, {'name': 'toDate', 'type': 'xs:date'}, 20),
        'otherPeriodText': MemberSpec_('otherPeriodText', ['text2000Type', 'xs:string'], 0, 0, {'name': 'otherPeriodText', 'type': 'xs:string'}, 20),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, fromDate=None, toDate=None, otherPeriodText=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if isinstance(fromDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(fromDate, '%Y-%m-%d').date()
        else:
            initvalue_ = fromDate
        self.fromDate = initvalue_
        self.fromDate_nsprefix_ = None
        if isinstance(toDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(toDate, '%Y-%m-%d').date()
        else:
            initvalue_ = toDate
        self.toDate = initvalue_
        self.toDate_nsprefix_ = None
        self.otherPeriodText = otherPeriodText
        self.validate_text2000Type(self.otherPeriodText)
        self.otherPeriodText_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, providedPeriod)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if providedPeriod.subclass:
            return providedPeriod.subclass(*args_, **kwargs_)
        else:
            return providedPeriod(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_text2000Type(self, value):
        result = True
        # Validate type text2000Type, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 2000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on text2000Type' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on text2000Type' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.fromDate is not None or
            self.toDate is not None or
            self.otherPeriodText is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'fromDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.fromDate = dval_
            self.fromDate_nsprefix_ = child_.prefix
        elif nodeName_ == 'toDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.toDate = dval_
            self.toDate_nsprefix_ = child_.prefix
        elif nodeName_ == 'otherPeriodText':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'otherPeriodText')
            value_ = self.gds_validate_string(value_, node, 'otherPeriodText')
            self.otherPeriodText = value_
            self.otherPeriodText_nsprefix_ = child_.prefix
            # validate type text2000Type
            self.validate_text2000Type(self.otherPeriodText)
# end class providedPeriod


class execObligationsGuaranteeInfo(GeneratedsSuper):
    """Обеспечение исполнения обязательств по предоставленной гарантии качества
    товаров, работ, услуг.
    Допускается заполнение блока только при установленном в true признаке
    isQAEnsuramceRequired"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'ensuringWay': MemberSpec_('ensuringWay', 'ensuringWay', 0, 0, {'name': 'ensuringWay', 'type': 'ensuringWay'}, None),
        'guaranteeReturns': MemberSpec_('guaranteeReturns', 'zfcs_contract2015BankGuaranteeReturnType', 0, 1, {'minOccurs': '0', 'name': 'guaranteeReturns', 'type': 'zfcs_contract2015BankGuaranteeReturnType'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, ensuringWay=None, guaranteeReturns=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.ensuringWay = ensuringWay
        self.ensuringWay_nsprefix_ = None
        self.guaranteeReturns = guaranteeReturns
        self.guaranteeReturns_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, execObligationsGuaranteeInfo)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if execObligationsGuaranteeInfo.subclass:
            return execObligationsGuaranteeInfo.subclass(*args_, **kwargs_)
        else:
            return execObligationsGuaranteeInfo(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.ensuringWay is not None or
            self.guaranteeReturns is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ensuringWay':
            obj_ = ensuringWay.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ensuringWay = obj_
            obj_.original_tagname_ = 'ensuringWay'
        elif nodeName_ == 'guaranteeReturns':
            obj_ = zfcs_contract2015BankGuaranteeReturnType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.guaranteeReturns = obj_
            obj_.original_tagname_ = 'guaranteeReturns'
# end class execObligationsGuaranteeInfo


class ensuringWay(GeneratedsSuper):
    """Способ обеспечения исполнения обязательств по предоставленной
    гарантии"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'bankGuarantee': MemberSpec_('bankGuarantee', 'bankGuarantee', 0, 0, {'name': 'bankGuarantee', 'type': 'bankGuarantee'}, 21),
        'cashAccount': MemberSpec_('cashAccount', 'cashAccount', 0, 0, {'name': 'cashAccount', 'type': 'cashAccount'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, bankGuarantee=None, cashAccount=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.bankGuarantee = bankGuarantee
        self.bankGuarantee_nsprefix_ = None
        self.cashAccount = cashAccount
        self.cashAccount_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ensuringWay)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ensuringWay.subclass:
            return ensuringWay.subclass(*args_, **kwargs_)
        else:
            return ensuringWay(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.bankGuarantee is not None or
            self.cashAccount is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'bankGuarantee':
            obj_ = bankGuarantee.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.bankGuarantee = obj_
            obj_.original_tagname_ = 'bankGuarantee'
        elif nodeName_ == 'cashAccount':
            obj_ = cashAccount.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.cashAccount = obj_
            obj_.original_tagname_ = 'cashAccount'
# end class ensuringWay


class bankGuarantee(GeneratedsSuper):
    """Банковская гарантия, выданная банком в соответствии со статьей 45"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'regNumber': MemberSpec_('regNumber', ['bankGuaranteeRegNumberType', 'xs:string'], 0, 0, {'name': 'regNumber', 'type': 'xs:string'}, 22),
        'regNumberNotPublishedOnEIS': MemberSpec_('regNumberNotPublishedOnEIS', 'xs:boolean', 0, 0, {'fixed': 'true', 'name': 'regNumberNotPublishedOnEIS', 'type': 'xs:boolean'}, 22),
        'docNumber': MemberSpec_('docNumber', ['bankGuaranteeDocNumberType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'docNumber', 'type': 'xs:string'}, 23),
        'docNumberNotPublishedOnEIS': MemberSpec_('docNumberNotPublishedOnEIS', 'xs:boolean', 0, 0, {'fixed': 'true', 'name': 'docNumberNotPublishedOnEIS', 'type': 'xs:boolean'}, 23),
        'currency': MemberSpec_('currency', 'zfcs_currencyRef', 0, 1, {'minOccurs': '0', 'name': 'currency', 'type': 'zfcs_currencyRef'}, None),
        'amount': MemberSpec_('amount', ['moneyPositiveType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'amount', 'type': 'xs:string'}, None),
        'currencyRate': MemberSpec_('currencyRate', 'zfcs_currencyRateContract2015', 0, 1, {'minOccurs': '0', 'name': 'currencyRate', 'type': 'zfcs_currencyRateContract2015'}, None),
        'amountRUR': MemberSpec_('amountRUR', ['moneyPositiveType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'amountRUR', 'type': 'xs:string'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, regNumber=None, regNumberNotPublishedOnEIS=None, docNumber=None, docNumberNotPublishedOnEIS=None, currency=None, amount=None, currencyRate=None, amountRUR=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.regNumber = regNumber
        self.validate_bankGuaranteeRegNumberType(self.regNumber)
        self.regNumber_nsprefix_ = None
        self.regNumberNotPublishedOnEIS = regNumberNotPublishedOnEIS
        self.regNumberNotPublishedOnEIS_nsprefix_ = None
        self.docNumber = docNumber
        self.validate_bankGuaranteeDocNumberType(self.docNumber)
        self.docNumber_nsprefix_ = None
        self.docNumberNotPublishedOnEIS = docNumberNotPublishedOnEIS
        self.docNumberNotPublishedOnEIS_nsprefix_ = None
        self.currency = currency
        self.currency_nsprefix_ = None
        self.amount = amount
        self.validate_moneyPositiveType(self.amount)
        self.amount_nsprefix_ = None
        self.currencyRate = currencyRate
        self.currencyRate_nsprefix_ = None
        self.amountRUR = amountRUR
        self.validate_moneyPositiveType(self.amountRUR)
        self.amountRUR_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, bankGuarantee)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if bankGuarantee.subclass:
            return bankGuarantee.subclass(*args_, **kwargs_)
        else:
            return bankGuarantee(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_bankGuaranteeRegNumberType(self, value):
        result = True
        # Validate type bankGuaranteeRegNumberType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 20:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on bankGuaranteeRegNumberType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on bankGuaranteeRegNumberType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_bankGuaranteeDocNumberType(self, value):
        result = True
        # Validate type bankGuaranteeDocNumberType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 23:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on bankGuaranteeDocNumberType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on bankGuaranteeDocNumberType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_moneyPositiveType(self, value):
        result = True
        # Validate type moneyPositiveType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 21:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on moneyPositiveType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on moneyPositiveType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_moneyPositiveType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_moneyPositiveType_patterns_, ))
                result = False
        return result
    validate_moneyPositiveType_patterns_ = [['^(\\d+(\\.\\d{1,2})?)$']]
    def hasContent_(self):
        if (
            self.regNumber is not None or
            self.regNumberNotPublishedOnEIS is not None or
            self.docNumber is not None or
            self.docNumberNotPublishedOnEIS is not None or
            self.currency is not None or
            self.amount is not None or
            self.currencyRate is not None or
            self.amountRUR is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'regNumber':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'regNumber')
            value_ = self.gds_validate_string(value_, node, 'regNumber')
            self.regNumber = value_
            self.regNumber_nsprefix_ = child_.prefix
            # validate type bankGuaranteeRegNumberType
            self.validate_bankGuaranteeRegNumberType(self.regNumber)
        elif nodeName_ == 'regNumberNotPublishedOnEIS':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'regNumberNotPublishedOnEIS')
            ival_ = self.gds_validate_boolean(ival_, node, 'regNumberNotPublishedOnEIS')
            self.regNumberNotPublishedOnEIS = ival_
            self.regNumberNotPublishedOnEIS_nsprefix_ = child_.prefix
        elif nodeName_ == 'docNumber':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'docNumber')
            value_ = self.gds_validate_string(value_, node, 'docNumber')
            self.docNumber = value_
            self.docNumber_nsprefix_ = child_.prefix
            # validate type bankGuaranteeDocNumberType
            self.validate_bankGuaranteeDocNumberType(self.docNumber)
        elif nodeName_ == 'docNumberNotPublishedOnEIS':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'docNumberNotPublishedOnEIS')
            ival_ = self.gds_validate_boolean(ival_, node, 'docNumberNotPublishedOnEIS')
            self.docNumberNotPublishedOnEIS = ival_
            self.docNumberNotPublishedOnEIS_nsprefix_ = child_.prefix
        elif nodeName_ == 'currency':
            obj_ = zfcs_currencyRef.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.currency = obj_
            obj_.original_tagname_ = 'currency'
        elif nodeName_ == 'amount':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'amount')
            value_ = self.gds_validate_string(value_, node, 'amount')
            self.amount = value_
            self.amount_nsprefix_ = child_.prefix
            # validate type moneyPositiveType
            self.validate_moneyPositiveType(self.amount)
        elif nodeName_ == 'currencyRate':
            obj_ = zfcs_currencyRateContract2015.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.currencyRate = obj_
            obj_.original_tagname_ = 'currencyRate'
        elif nodeName_ == 'amountRUR':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'amountRUR')
            value_ = self.gds_validate_string(value_, node, 'amountRUR')
            self.amountRUR = value_
            self.amountRUR_nsprefix_ = child_.prefix
            # validate type moneyPositiveType
            self.validate_moneyPositiveType(self.amountRUR)
# end class bankGuarantee


class cashAccount(GeneratedsSuper):
    """Внесение денежных средств на указанный заказчиком счет"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'currency': MemberSpec_('currency', 'zfcs_currencyRef', 0, 0, {'name': 'currency', 'type': 'zfcs_currencyRef'}, None),
        'amount': MemberSpec_('amount', ['moneyPositiveType', 'xs:string'], 0, 0, {'name': 'amount', 'type': 'xs:string'}, None),
        'currencyRate': MemberSpec_('currencyRate', 'zfcs_currencyRateContract2015', 0, 1, {'minOccurs': '0', 'name': 'currencyRate', 'type': 'zfcs_currencyRateContract2015'}, None),
        'amountRUR': MemberSpec_('amountRUR', ['moneyPositiveType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'amountRUR', 'type': 'xs:string'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, currency=None, amount=None, currencyRate=None, amountRUR=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.currency = currency
        self.currency_nsprefix_ = None
        self.amount = amount
        self.validate_moneyPositiveType(self.amount)
        self.amount_nsprefix_ = None
        self.currencyRate = currencyRate
        self.currencyRate_nsprefix_ = None
        self.amountRUR = amountRUR
        self.validate_moneyPositiveType(self.amountRUR)
        self.amountRUR_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, cashAccount)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if cashAccount.subclass:
            return cashAccount.subclass(*args_, **kwargs_)
        else:
            return cashAccount(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_moneyPositiveType(self, value):
        result = True
        # Validate type moneyPositiveType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 21:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on moneyPositiveType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on moneyPositiveType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_moneyPositiveType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_moneyPositiveType_patterns_, ))
                result = False
        return result
    validate_moneyPositiveType_patterns_ = [['^(\\d+(\\.\\d{1,2})?)$']]
    def hasContent_(self):
        if (
            self.currency is not None or
            self.amount is not None or
            self.currencyRate is not None or
            self.amountRUR is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'currency':
            obj_ = zfcs_currencyRef.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.currency = obj_
            obj_.original_tagname_ = 'currency'
        elif nodeName_ == 'amount':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'amount')
            value_ = self.gds_validate_string(value_, node, 'amount')
            self.amount = value_
            self.amount_nsprefix_ = child_.prefix
            # validate type moneyPositiveType
            self.validate_moneyPositiveType(self.amount)
        elif nodeName_ == 'currencyRate':
            obj_ = zfcs_currencyRateContract2015.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.currencyRate = obj_
            obj_.original_tagname_ = 'currencyRate'
        elif nodeName_ == 'amountRUR':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'amountRUR')
            value_ = self.gds_validate_string(value_, node, 'amountRUR')
            self.amountRUR = value_
            self.amountRUR_nsprefix_ = child_.prefix
            # validate type moneyPositiveType
            self.validate_moneyPositiveType(self.amountRUR)
# end class cashAccount


class products(GeneratedsSuper):
    """Объекты закупки"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'product': MemberSpec_('product', ['product', 'zfcs_contract2015PurchaseObjectInfoType', 'xs:string'], 1, 0, {'maxOccurs': 'unbounded', 'name': 'product', 'type': 'xs:string'}, None),
        'quantityUndefined': MemberSpec_('quantityUndefined', 'quantityUndefined', 0, 1, {'minOccurs': '0', 'name': 'quantityUndefined', 'type': 'xs:boolean'}, None),
        'productsChange': MemberSpec_('productsChange', 'productsChange', 0, 1, {'minOccurs': '0', 'name': 'productsChange', 'type': 'productsChange'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, product=None, quantityUndefined=None, productsChange=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if product is None:
            self.product = []
        else:
            self.product = product
        self.product_nsprefix_ = None
        self.quantityUndefined = quantityUndefined
        self.quantityUndefined_nsprefix_ = None
        self.productsChange = productsChange
        self.productsChange_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, products)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if products.subclass:
            return products.subclass(*args_, **kwargs_)
        else:
            return products(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.product or
            self.quantityUndefined is not None or
            self.productsChange is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'product':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'product')
            value_ = self.gds_validate_string(value_, node, 'product')
            self.product.append(value_)
            self.product_nsprefix_ = child_.prefix
        elif nodeName_ == 'quantityUndefined':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'quantityUndefined')
            ival_ = self.gds_validate_boolean(ival_, node, 'quantityUndefined')
            self.quantityUndefined = ival_
            self.quantityUndefined_nsprefix_ = child_.prefix
        elif nodeName_ == 'productsChange':
            obj_ = productsChange.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.productsChange = obj_
            obj_.original_tagname_ = 'productsChange'
# end class products


class medicalProductInfo(GeneratedsSuper):
    """Номенклатурная классификация медицинских изделий по видам (НКМИ) по
    КТРУ.
    Указание доступно и обязательно при наличии признака isMedicalProduct"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'medicalProductCode': MemberSpec_('medicalProductCode', ['ktruClassifierCodeType', 'xs:string'], 0, 0, {'name': 'medicalProductCode', 'type': 'xs:string'}, None),
        'medicalProductName': MemberSpec_('medicalProductName', ['text500Type', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'medicalProductName', 'type': 'xs:string'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, medicalProductCode=None, medicalProductName=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.medicalProductCode = medicalProductCode
        self.validate_ktruClassifierCodeType(self.medicalProductCode)
        self.medicalProductCode_nsprefix_ = None
        self.medicalProductName = medicalProductName
        self.validate_text500Type(self.medicalProductName)
        self.medicalProductName_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, medicalProductInfo)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if medicalProductInfo.subclass:
            return medicalProductInfo.subclass(*args_, **kwargs_)
        else:
            return medicalProductInfo(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_ktruClassifierCodeType(self, value):
        result = True
        # Validate type ktruClassifierCodeType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 30:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ktruClassifierCodeType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ktruClassifierCodeType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_text500Type(self, value):
        result = True
        # Validate type text500Type, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 500:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on text500Type' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on text500Type' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.medicalProductCode is not None or
            self.medicalProductName is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'medicalProductCode':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'medicalProductCode')
            value_ = self.gds_validate_string(value_, node, 'medicalProductCode')
            self.medicalProductCode = value_
            self.medicalProductCode_nsprefix_ = child_.prefix
            # validate type ktruClassifierCodeType
            self.validate_ktruClassifierCodeType(self.medicalProductCode)
        elif nodeName_ == 'medicalProductName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'medicalProductName')
            value_ = self.gds_validate_string(value_, node, 'medicalProductName')
            self.medicalProductName = value_
            self.medicalProductName_nsprefix_ = child_.prefix
            # validate type text500Type
            self.validate_text500Type(self.medicalProductName)
# end class medicalProductInfo


class productsChange(GeneratedsSuper):
    """Сведения об изменении объектов закупки"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'documents': MemberSpec_('documents', 'documents', 1, 0, {'maxOccurs': 'unbounded', 'name': 'documents', 'type': 'documents'}, None),
        'changeInfo': MemberSpec_('changeInfo', ['zfcs_longTextMinType', 'xs:string'], 0, 0, {'name': 'changeInfo', 'type': 'xs:string'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, documents=None, changeInfo=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if documents is None:
            self.documents = []
        else:
            self.documents = documents
        self.documents_nsprefix_ = None
        self.changeInfo = changeInfo
        self.validate_zfcs_longTextMinType(self.changeInfo)
        self.changeInfo_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, productsChange)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if productsChange.subclass:
            return productsChange.subclass(*args_, **kwargs_)
        else:
            return productsChange(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_zfcs_longTextMinType(self, value):
        result = True
        # Validate type zfcs_longTextMinType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 2000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on zfcs_longTextMinType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on zfcs_longTextMinType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.documents or
            self.changeInfo is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'documents':
            obj_ = documents.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.documents.append(obj_)
            obj_.original_tagname_ = 'documents'
        elif nodeName_ == 'changeInfo':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'changeInfo')
            value_ = self.gds_validate_string(value_, node, 'changeInfo')
            self.changeInfo = value_
            self.changeInfo_nsprefix_ = child_.prefix
            # validate type zfcs_longTextMinType
            self.validate_zfcs_longTextMinType(self.changeInfo)
# end class productsChange


class documents(GeneratedsSuper):
    """Документы"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'documentName': MemberSpec_('documentName', ['documentName', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'documentName', 'type': 'xs:string'}, None),
        'documentNum': MemberSpec_('documentNum', ['documentNum', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'documentNum', 'type': 'xs:string'}, None),
        'documentDate': MemberSpec_('documentDate', 'xs:date', 0, 0, {'name': 'documentDate', 'type': 'xs:date'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, documentName=None, documentNum=None, documentDate=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.documentName = documentName
        self.documentName_nsprefix_ = None
        self.documentNum = documentNum
        self.documentNum_nsprefix_ = None
        if isinstance(documentDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(documentDate, '%Y-%m-%d').date()
        else:
            initvalue_ = documentDate
        self.documentDate = initvalue_
        self.documentDate_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, documents)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if documents.subclass:
            return documents.subclass(*args_, **kwargs_)
        else:
            return documents(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.documentName is not None or
            self.documentNum is not None or
            self.documentDate is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'documentName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'documentName')
            value_ = self.gds_validate_string(value_, node, 'documentName')
            self.documentName = value_
            self.documentName_nsprefix_ = child_.prefix
        elif nodeName_ == 'documentNum':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'documentNum')
            value_ = self.gds_validate_string(value_, node, 'documentNum')
            self.documentNum = value_
            self.documentNum_nsprefix_ = child_.prefix
        elif nodeName_ == 'documentDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.documentDate = dval_
            self.documentDate_nsprefix_ = child_.prefix
# end class documents


class documentName(GeneratedsSuper):
    """Наименование"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, documentName)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if documentName.subclass:
            return documentName.subclass(*args_, **kwargs_)
        else:
            return documentName(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_documentName(self, value):
        result = True
        # Validate type documentName, a restriction on xs:string.
        pass
        return result
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class documentName


class documentNum(GeneratedsSuper):
    """Номер документа"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, documentNum)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if documentNum.subclass:
            return documentNum.subclass(*args_, **kwargs_)
        else:
            return documentNum(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_documentNum(self, value):
        result = True
        # Validate type documentNum, a restriction on xs:string.
        pass
        return result
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class documentNum


class suppliers(GeneratedsSuper):
    """Поставщики"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'supplier': MemberSpec_('supplier', 'zfcs_contract2015SupplierType', 1, 0, {'maxOccurs': 'unbounded', 'name': 'supplier', 'type': 'zfcs_contract2015SupplierType'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, supplier=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if supplier is None:
            self.supplier = []
        else:
            self.supplier = supplier
        self.supplier_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, suppliers)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if suppliers.subclass:
            return suppliers.subclass(*args_, **kwargs_)
        else:
            return suppliers(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.supplier
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'supplier':
            obj_ = zfcs_contract2015SupplierType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.supplier.append(obj_)
            obj_.original_tagname_ = 'supplier'
# end class suppliers


class modification(GeneratedsSuper):
    """Описание внесения изменений"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'contractChange': MemberSpec_('contractChange', 'contractChange', 0, 0, {'name': 'contractChange', 'type': 'contractChange'}, 24),
        'errorCorrection': MemberSpec_('errorCorrection', 'errorCorrection', 0, 0, {'name': 'errorCorrection', 'type': 'errorCorrection'}, 24),
        'attachments': MemberSpec_('attachments', 'xs:string', 0, 1, {'minOccurs': '0', 'name': 'attachments', 'type': 'xs:string'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, contractChange=None, errorCorrection=None, attachments=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.contractChange = contractChange
        self.contractChange_nsprefix_ = None
        self.errorCorrection = errorCorrection
        self.errorCorrection_nsprefix_ = None
        self.attachments = attachments
        self.attachments_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, modification)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if modification.subclass:
            return modification.subclass(*args_, **kwargs_)
        else:
            return modification(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.contractChange is not None or
            self.errorCorrection is not None or
            self.attachments is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'contractChange':
            obj_ = contractChange.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.contractChange = obj_
            obj_.original_tagname_ = 'contractChange'
        elif nodeName_ == 'errorCorrection':
            obj_ = errorCorrection.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.errorCorrection = obj_
            obj_.original_tagname_ = 'errorCorrection'
        elif nodeName_ == 'attachments':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'attachments')
            value_ = self.gds_validate_string(value_, node, 'attachments')
            self.attachments = value_
            self.attachments_nsprefix_ = child_.prefix
# end class modification


class contractChange(GeneratedsSuper):
    """Изменение контракта"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'reason': MemberSpec_('reason', 'reason', 0, 0, {'name': 'reason', 'type': 'reason'}, 24),
        'document': MemberSpec_('document', 'document', 0, 0, {'name': 'document', 'type': 'document'}, 24),
        'damagePayments': MemberSpec_('damagePayments', 'damagePayments', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'damagePayments', 'type': 'damagePayments'}, 24),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, reason=None, document=None, damagePayments=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.reason = reason
        self.reason_nsprefix_ = None
        self.document = document
        self.document_nsprefix_ = None
        if damagePayments is None:
            self.damagePayments = []
        else:
            self.damagePayments = damagePayments
        self.damagePayments_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, contractChange)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if contractChange.subclass:
            return contractChange.subclass(*args_, **kwargs_)
        else:
            return contractChange(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.reason is not None or
            self.document is not None or
            self.damagePayments
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'reason':
            obj_ = reason.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.reason = obj_
            obj_.original_tagname_ = 'reason'
        elif nodeName_ == 'document':
            obj_ = document.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.document = obj_
            obj_.original_tagname_ = 'document'
        elif nodeName_ == 'damagePayments':
            obj_ = damagePayments.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.damagePayments.append(obj_)
            obj_.original_tagname_ = 'damagePayments'
# end class contractChange


class reason(GeneratedsSuper):
    """Причина изменений условий контракта из справочника "Справочник: Причины
    изменения условий контракта" (nsiContractModificationReason)"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'code': MemberSpec_('code', 'xs:string', 0, 0, {'name': 'code', 'type': 'xs:string'}, 24),
        'name': MemberSpec_('name', 'xs:string', 0, 1, {'minOccurs': '0', 'name': 'name', 'type': 'xs:string'}, 24),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, code=None, name=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.code = code
        self.code_nsprefix_ = None
        self.name = name
        self.name_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, reason)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if reason.subclass:
            return reason.subclass(*args_, **kwargs_)
        else:
            return reason(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.code is not None or
            self.name is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'code':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'code')
            value_ = self.gds_validate_string(value_, node, 'code')
            self.code = value_
            self.code_nsprefix_ = child_.prefix
        elif nodeName_ == 'name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'name')
            value_ = self.gds_validate_string(value_, node, 'name')
            self.name = value_
            self.name_nsprefix_ = child_.prefix
# end class reason


class damagePayments(GeneratedsSuper):
    """Информация об оплате суммы возмещения фактически понесенного ущерба"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'document': MemberSpec_('document', 'document', 0, 0, {'name': 'document', 'type': 'zfcs_contract2015.documentInfo'}, 24),
        'currency': MemberSpec_('currency', 'zfcs_currencyRef', 0, 0, {'name': 'currency', 'type': 'zfcs_currencyRef'}, 24),
        'amount': MemberSpec_('amount', ['moneyPositiveType', 'xs:string'], 0, 0, {'name': 'amount', 'type': 'xs:string'}, 24),
        'currencyRate': MemberSpec_('currencyRate', 'zfcs_currencyRateContract2015', 0, 1, {'minOccurs': '0', 'name': 'currencyRate', 'type': 'zfcs_currencyRateContract2015'}, 24),
        'amountRUR': MemberSpec_('amountRUR', ['moneyPositiveType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'amountRUR', 'type': 'xs:string'}, 24),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, document=None, currency=None, amount=None, currencyRate=None, amountRUR=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.document = document
        self.document_nsprefix_ = None
        self.currency = currency
        self.currency_nsprefix_ = None
        self.amount = amount
        self.validate_moneyPositiveType(self.amount)
        self.amount_nsprefix_ = None
        self.currencyRate = currencyRate
        self.currencyRate_nsprefix_ = None
        self.amountRUR = amountRUR
        self.validate_moneyPositiveType(self.amountRUR)
        self.amountRUR_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, damagePayments)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if damagePayments.subclass:
            return damagePayments.subclass(*args_, **kwargs_)
        else:
            return damagePayments(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_moneyPositiveType(self, value):
        result = True
        # Validate type moneyPositiveType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 21:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on moneyPositiveType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on moneyPositiveType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_moneyPositiveType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_moneyPositiveType_patterns_, ))
                result = False
        return result
    validate_moneyPositiveType_patterns_ = [['^(\\d+(\\.\\d{1,2})?)$']]
    def hasContent_(self):
        if (
            self.document is not None or
            self.currency is not None or
            self.amount is not None or
            self.currencyRate is not None or
            self.amountRUR is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'document':
            obj_ = zfcs_contract2015_documentInfo.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.document = obj_
            obj_.original_tagname_ = 'document'
        elif nodeName_ == 'currency':
            obj_ = zfcs_currencyRef.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.currency = obj_
            obj_.original_tagname_ = 'currency'
        elif nodeName_ == 'amount':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'amount')
            value_ = self.gds_validate_string(value_, node, 'amount')
            self.amount = value_
            self.amount_nsprefix_ = child_.prefix
            # validate type moneyPositiveType
            self.validate_moneyPositiveType(self.amount)
        elif nodeName_ == 'currencyRate':
            obj_ = zfcs_currencyRateContract2015.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.currencyRate = obj_
            obj_.original_tagname_ = 'currencyRate'
        elif nodeName_ == 'amountRUR':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'amountRUR')
            value_ = self.gds_validate_string(value_, node, 'amountRUR')
            self.amountRUR = value_
            self.amountRUR_nsprefix_ = child_.prefix
            # validate type moneyPositiveType
            self.validate_moneyPositiveType(self.amountRUR)
# end class damagePayments


class errorCorrection(GeneratedsSuper):
    """Корректировка ошибок"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'description': MemberSpec_('description', ['zfcs_longTextMinType', 'xs:string'], 0, 0, {'name': 'description', 'type': 'xs:string'}, 24),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, description=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.description = description
        self.validate_zfcs_longTextMinType(self.description)
        self.description_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, errorCorrection)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if errorCorrection.subclass:
            return errorCorrection.subclass(*args_, **kwargs_)
        else:
            return errorCorrection(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_zfcs_longTextMinType(self, value):
        result = True
        # Validate type zfcs_longTextMinType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 2000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on zfcs_longTextMinType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on zfcs_longTextMinType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.description is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'description':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'description')
            value_ = self.gds_validate_string(value_, node, 'description')
            self.description = value_
            self.description_nsprefix_ = child_.prefix
            # validate type zfcs_longTextMinType
            self.validate_zfcs_longTextMinType(self.description)
# end class errorCorrection


class zfcs_contractProcedure2015Type(GeneratedsSuper):
    """Информация об исполнении (исполнении обязательств по предоставленной
    гарантии качества, расторжении, возврата переплаты по контракту,
    признании контракта недействительным) контракта с 01.01.2015Версия
    схемы"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'schemeVersion': MemberSpec_('schemeVersion', 'base:schemeVersionType', 0, 0, {'use': 'required'}),
        'id': MemberSpec_('id', ['id', 'xs:long'], 0, 1, {'minOccurs': '0', 'name': 'id', 'type': 'xs:long'}, None),
        'externalId': MemberSpec_('externalId', ['externalIdType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'externalId', 'type': 'xs:string'}, None),
        'regNum': MemberSpec_('regNum', ['zfcs_contract.regNum2015Type', 'xs:string'], 0, 0, {'name': 'regNum', 'type': 'xs:string'}, None),
        'defenseContractNumber': MemberSpec_('defenseContractNumber', ['zfcs_contract.defenseNum2015Type', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'defenseContractNumber', 'type': 'xs:string'}, None),
        'directDate': MemberSpec_('directDate', 'xs:dateTime', 0, 1, {'minOccurs': '0', 'name': 'directDate', 'type': 'xs:dateTime'}, None),
        'publishDate': MemberSpec_('publishDate', 'xs:dateTime', 0, 1, {'minOccurs': '0', 'name': 'publishDate', 'type': 'xs:dateTime'}, None),
        'versionNumber': MemberSpec_('versionNumber', ['versionNumberType', 'xs:int'], 0, 1, {'minOccurs': '0', 'name': 'versionNumber', 'type': 'xs:int'}, None),
        'executions': MemberSpec_('executions', 'executions', 0, 1, {'minOccurs': '0', 'name': 'executions', 'type': 'executions'}, None),
        'executionObligationGuarantee': MemberSpec_('executionObligationGuarantee', 'executionObligationGuarantee', 0, 1, {'minOccurs': '0', 'name': 'executionObligationGuarantee', 'type': 'executionObligationGuarantee'}, None),
        'termination': MemberSpec_('termination', 'termination', 0, 1, {'minOccurs': '0', 'name': 'termination', 'type': 'termination'}, None),
        'refundOverpaymentsInfo': MemberSpec_('refundOverpaymentsInfo', 'refundOverpaymentsInfo', 0, 1, {'minOccurs': '0', 'name': 'refundOverpaymentsInfo', 'type': 'refundOverpaymentsInfo'}, None),
        'contractInvalidation': MemberSpec_('contractInvalidation', 'contractInvalidation', 0, 1, {'minOccurs': '0', 'name': 'contractInvalidation', 'type': 'contractInvalidation'}, None),
        'bankGuaranteeTermination': MemberSpec_('bankGuaranteeTermination', 'zfcs_contractProcedure2015BankGuaranteeTerminationType', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'bankGuaranteeTermination', 'type': 'zfcs_contractProcedure2015BankGuaranteeTerminationType'}, None),
        'penalties': MemberSpec_('penalties', 'penalties', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'penalties', 'type': 'penalties'}, None),
        'delayWriteOffPenalties': MemberSpec_('delayWriteOffPenalties', 'delayWriteOffPenalties', 0, 1, {'minOccurs': '0', 'name': 'delayWriteOffPenalties', 'type': 'delayWriteOffPenalties'}, None),
        'bankGuaranteePayment': MemberSpec_('bankGuaranteePayment', 'zfcs_contractProcedure2015BankGuaranteePaymentType', 0, 1, {'minOccurs': '0', 'name': 'bankGuaranteePayment', 'type': 'zfcs_contractProcedure2015BankGuaranteePaymentType'}, None),
        'holdCashEnforcement': MemberSpec_('holdCashEnforcement', 'zfcs_contractProcedure2015HoldCashEnforcementType', 0, 1, {'minOccurs': '0', 'name': 'holdCashEnforcement', 'type': 'zfcs_contractProcedure2015HoldCashEnforcementType'}, None),
        'printForm': MemberSpec_('printForm', 'xs:string', 0, 1, {'minOccurs': '0', 'name': 'printForm', 'type': 'xs:string'}, None),
        'extPrintForm': MemberSpec_('extPrintForm', 'xs:string', 0, 1, {'minOccurs': '0', 'name': 'extPrintForm', 'type': 'xs:string'}, None),
        'terminationDocuments': MemberSpec_('terminationDocuments', 'xs:string', 0, 1, {'minOccurs': '0', 'name': 'terminationDocuments', 'type': 'xs:string'}, None),
        'paymentDocuments': MemberSpec_('paymentDocuments', 'xs:string', 0, 1, {'minOccurs': '0', 'name': 'paymentDocuments', 'type': 'xs:string'}, None),
        'receiptDocuments': MemberSpec_('receiptDocuments', 'xs:string', 0, 1, {'minOccurs': '0', 'name': 'receiptDocuments', 'type': 'xs:string'}, None),
        'productOriginDocuments': MemberSpec_('productOriginDocuments', 'xs:string', 0, 1, {'minOccurs': '0', 'name': 'productOriginDocuments', 'type': 'xs:string'}, None),
        'examinationResultsDocuments': MemberSpec_('examinationResultsDocuments', 'xs:string', 0, 1, {'minOccurs': '0', 'name': 'examinationResultsDocuments', 'type': 'xs:string'}, None),
        'budgetObligations': MemberSpec_('budgetObligations', 'xs:string', 0, 1, {'minOccurs': '0', 'name': 'budgetObligations', 'type': 'xs:string'}, None),
        'modificationReason': MemberSpec_('modificationReason', ['zfcs_longTextMinType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'modificationReason', 'type': 'xs:string'}, None),
        'currentContractStage': MemberSpec_('currentContractStage', 'xs:string', 0, 1, {'minOccurs': '0', 'name': 'currentContractStage', 'type': 'xs:string'}, None),
        'okpd2okved2': MemberSpec_('okpd2okved2', 'xs:boolean', 0, 1, {'minOccurs': '0', 'name': 'okpd2okved2', 'type': 'xs:boolean'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, schemeVersion=None, id=None, externalId=None, regNum=None, defenseContractNumber=None, directDate=None, publishDate=None, versionNumber=None, executions=None, executionObligationGuarantee=None, termination=None, refundOverpaymentsInfo=None, contractInvalidation=None, bankGuaranteeTermination=None, penalties=None, delayWriteOffPenalties=None, bankGuaranteePayment=None, holdCashEnforcement=None, printForm=None, extPrintForm=None, terminationDocuments=None, paymentDocuments=None, receiptDocuments=None, productOriginDocuments=None, examinationResultsDocuments=None, budgetObligations=None, modificationReason=None, currentContractStage=None, okpd2okved2=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.schemeVersion = _cast(None, schemeVersion)
        self.schemeVersion_nsprefix_ = None
        self.id = id
        self.id_nsprefix_ = None
        self.externalId = externalId
        self.validate_externalIdType(self.externalId)
        self.externalId_nsprefix_ = None
        self.regNum = regNum
        self.validate_zfcs_contract_regNum2015Type(self.regNum)
        self.regNum_nsprefix_ = None
        self.defenseContractNumber = defenseContractNumber
        self.validate_zfcs_contract_defenseNum2015Type(self.defenseContractNumber)
        self.defenseContractNumber_nsprefix_ = None
        if isinstance(directDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(directDate, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = directDate
        self.directDate = initvalue_
        self.directDate_nsprefix_ = None
        if isinstance(publishDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(publishDate, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = publishDate
        self.publishDate = initvalue_
        self.publishDate_nsprefix_ = None
        self.versionNumber = versionNumber
        self.validate_versionNumberType(self.versionNumber)
        self.versionNumber_nsprefix_ = None
        self.executions = executions
        self.executions_nsprefix_ = None
        self.executionObligationGuarantee = executionObligationGuarantee
        self.executionObligationGuarantee_nsprefix_ = None
        self.termination = termination
        self.termination_nsprefix_ = None
        self.refundOverpaymentsInfo = refundOverpaymentsInfo
        self.refundOverpaymentsInfo_nsprefix_ = None
        self.contractInvalidation = contractInvalidation
        self.contractInvalidation_nsprefix_ = None
        if bankGuaranteeTermination is None:
            self.bankGuaranteeTermination = []
        else:
            self.bankGuaranteeTermination = bankGuaranteeTermination
        self.bankGuaranteeTermination_nsprefix_ = None
        if penalties is None:
            self.penalties = []
        else:
            self.penalties = penalties
        self.penalties_nsprefix_ = None
        self.delayWriteOffPenalties = delayWriteOffPenalties
        self.delayWriteOffPenalties_nsprefix_ = None
        self.bankGuaranteePayment = bankGuaranteePayment
        self.bankGuaranteePayment_nsprefix_ = None
        self.holdCashEnforcement = holdCashEnforcement
        self.holdCashEnforcement_nsprefix_ = None
        self.printForm = printForm
        self.printForm_nsprefix_ = None
        self.extPrintForm = extPrintForm
        self.extPrintForm_nsprefix_ = None
        self.terminationDocuments = terminationDocuments
        self.terminationDocuments_nsprefix_ = None
        self.paymentDocuments = paymentDocuments
        self.paymentDocuments_nsprefix_ = None
        self.receiptDocuments = receiptDocuments
        self.receiptDocuments_nsprefix_ = None
        self.productOriginDocuments = productOriginDocuments
        self.productOriginDocuments_nsprefix_ = None
        self.examinationResultsDocuments = examinationResultsDocuments
        self.examinationResultsDocuments_nsprefix_ = None
        self.budgetObligations = budgetObligations
        self.budgetObligations_nsprefix_ = None
        self.modificationReason = modificationReason
        self.validate_zfcs_longTextMinType(self.modificationReason)
        self.modificationReason_nsprefix_ = None
        self.currentContractStage = currentContractStage
        self.currentContractStage_nsprefix_ = None
        self.okpd2okved2 = okpd2okved2
        self.okpd2okved2_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, zfcs_contractProcedure2015Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if zfcs_contractProcedure2015Type.subclass:
            return zfcs_contractProcedure2015Type.subclass(*args_, **kwargs_)
        else:
            return zfcs_contractProcedure2015Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_externalIdType(self, value):
        result = True
        # Validate type externalIdType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 40:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on externalIdType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on externalIdType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_zfcs_contract_regNum2015Type(self, value):
        result = True
        # Validate type zfcs_contract.regNum2015Type, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 19:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on zfcs_contract.regNum2015Type' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on zfcs_contract.regNum2015Type' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_zfcs_contract_defenseNum2015Type(self, value):
        result = True
        # Validate type zfcs_contract.defenseNum2015Type, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 25:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on zfcs_contract.defenseNum2015Type' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on zfcs_contract.defenseNum2015Type' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_versionNumberType(self, value):
        result = True
        # Validate type versionNumberType, a restriction on xs:int.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            if value < 0:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on versionNumberType' % {"value": value, "lineno": lineno} )
                result = False
        return result
    def validate_zfcs_longTextMinType(self, value):
        result = True
        # Validate type zfcs_longTextMinType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 2000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on zfcs_longTextMinType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on zfcs_longTextMinType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_schemeVersionType(self, value):
        # Validate type base:schemeVersionType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['1.0', '4.1', '4.2', '4.3', '4.3.100', '4.4', '4.4.2', '4.5', '4.6', '5.0', '5.1', '5.2', '6.0', '6.1', '6.2', '6.2.100', '6.3', '6.4', '7.0', '7.1', '7.2', '7.3', '7.5', '8.0', '8.1', '8.2', '8.2.100', '8.3', '9.0', '9.1', '9.2', '9.3', '10.0', '10.1', '10.2', '10.2.310', '10.3', '11.0']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on schemeVersionType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            self.id is not None or
            self.externalId is not None or
            self.regNum is not None or
            self.defenseContractNumber is not None or
            self.directDate is not None or
            self.publishDate is not None or
            self.versionNumber is not None or
            self.executions is not None or
            self.executionObligationGuarantee is not None or
            self.termination is not None or
            self.refundOverpaymentsInfo is not None or
            self.contractInvalidation is not None or
            self.bankGuaranteeTermination or
            self.penalties or
            self.delayWriteOffPenalties is not None or
            self.bankGuaranteePayment is not None or
            self.holdCashEnforcement is not None or
            self.printForm is not None or
            self.extPrintForm is not None or
            self.terminationDocuments is not None or
            self.paymentDocuments is not None or
            self.receiptDocuments is not None or
            self.productOriginDocuments is not None or
            self.examinationResultsDocuments is not None or
            self.budgetObligations is not None or
            self.modificationReason is not None or
            self.currentContractStage is not None or
            self.okpd2okved2 is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('schemeVersion', node)
        if value is not None and 'schemeVersion' not in already_processed:
            already_processed.add('schemeVersion')
            self.schemeVersion = value
            self.validate_schemeVersionType(self.schemeVersion)    # validate type schemeVersionType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'id' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'id')
            ival_ = self.gds_validate_integer(ival_, node, 'id')
            self.id = ival_
            self.id_nsprefix_ = child_.prefix
        elif nodeName_ == 'externalId':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'externalId')
            value_ = self.gds_validate_string(value_, node, 'externalId')
            self.externalId = value_
            self.externalId_nsprefix_ = child_.prefix
            # validate type externalIdType
            self.validate_externalIdType(self.externalId)
        elif nodeName_ == 'regNum':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'regNum')
            value_ = self.gds_validate_string(value_, node, 'regNum')
            self.regNum = value_
            self.regNum_nsprefix_ = child_.prefix
            # validate type zfcs_contract.regNum2015Type
            self.validate_zfcs_contract_regNum2015Type(self.regNum)
        elif nodeName_ == 'defenseContractNumber':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'defenseContractNumber')
            value_ = self.gds_validate_string(value_, node, 'defenseContractNumber')
            self.defenseContractNumber = value_
            self.defenseContractNumber_nsprefix_ = child_.prefix
            # validate type zfcs_contract.defenseNum2015Type
            self.validate_zfcs_contract_defenseNum2015Type(self.defenseContractNumber)
        elif nodeName_ == 'directDate':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.directDate = dval_
            self.directDate_nsprefix_ = child_.prefix
        elif nodeName_ == 'publishDate':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.publishDate = dval_
            self.publishDate_nsprefix_ = child_.prefix
        elif nodeName_ == 'versionNumber' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'versionNumber')
            ival_ = self.gds_validate_integer(ival_, node, 'versionNumber')
            self.versionNumber = ival_
            self.versionNumber_nsprefix_ = child_.prefix
            # validate type versionNumberType
            self.validate_versionNumberType(self.versionNumber)
        elif nodeName_ == 'executions':
            obj_ = executions.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.executions = obj_
            obj_.original_tagname_ = 'executions'
        elif nodeName_ == 'executionObligationGuarantee':
            obj_ = executionObligationGuarantee.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.executionObligationGuarantee = obj_
            obj_.original_tagname_ = 'executionObligationGuarantee'
        elif nodeName_ == 'termination':
            obj_ = termination.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.termination = obj_
            obj_.original_tagname_ = 'termination'
        elif nodeName_ == 'refundOverpaymentsInfo':
            obj_ = refundOverpaymentsInfo.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.refundOverpaymentsInfo = obj_
            obj_.original_tagname_ = 'refundOverpaymentsInfo'
        elif nodeName_ == 'contractInvalidation':
            obj_ = contractInvalidation.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.contractInvalidation = obj_
            obj_.original_tagname_ = 'contractInvalidation'
        elif nodeName_ == 'bankGuaranteeTermination':
            obj_ = zfcs_contractProcedure2015BankGuaranteeTerminationType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.bankGuaranteeTermination.append(obj_)
            obj_.original_tagname_ = 'bankGuaranteeTermination'
        elif nodeName_ == 'penalties':
            obj_ = penalties.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.penalties.append(obj_)
            obj_.original_tagname_ = 'penalties'
        elif nodeName_ == 'delayWriteOffPenalties':
            obj_ = delayWriteOffPenalties.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.delayWriteOffPenalties = obj_
            obj_.original_tagname_ = 'delayWriteOffPenalties'
        elif nodeName_ == 'bankGuaranteePayment':
            obj_ = zfcs_contractProcedure2015BankGuaranteePaymentType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.bankGuaranteePayment = obj_
            obj_.original_tagname_ = 'bankGuaranteePayment'
        elif nodeName_ == 'holdCashEnforcement':
            obj_ = zfcs_contractProcedure2015HoldCashEnforcementType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.holdCashEnforcement = obj_
            obj_.original_tagname_ = 'holdCashEnforcement'
        elif nodeName_ == 'printForm':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'printForm')
            value_ = self.gds_validate_string(value_, node, 'printForm')
            self.printForm = value_
            self.printForm_nsprefix_ = child_.prefix
        elif nodeName_ == 'extPrintForm':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'extPrintForm')
            value_ = self.gds_validate_string(value_, node, 'extPrintForm')
            self.extPrintForm = value_
            self.extPrintForm_nsprefix_ = child_.prefix
        elif nodeName_ == 'terminationDocuments':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'terminationDocuments')
            value_ = self.gds_validate_string(value_, node, 'terminationDocuments')
            self.terminationDocuments = value_
            self.terminationDocuments_nsprefix_ = child_.prefix
        elif nodeName_ == 'paymentDocuments':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'paymentDocuments')
            value_ = self.gds_validate_string(value_, node, 'paymentDocuments')
            self.paymentDocuments = value_
            self.paymentDocuments_nsprefix_ = child_.prefix
        elif nodeName_ == 'receiptDocuments':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'receiptDocuments')
            value_ = self.gds_validate_string(value_, node, 'receiptDocuments')
            self.receiptDocuments = value_
            self.receiptDocuments_nsprefix_ = child_.prefix
        elif nodeName_ == 'productOriginDocuments':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'productOriginDocuments')
            value_ = self.gds_validate_string(value_, node, 'productOriginDocuments')
            self.productOriginDocuments = value_
            self.productOriginDocuments_nsprefix_ = child_.prefix
        elif nodeName_ == 'examinationResultsDocuments':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'examinationResultsDocuments')
            value_ = self.gds_validate_string(value_, node, 'examinationResultsDocuments')
            self.examinationResultsDocuments = value_
            self.examinationResultsDocuments_nsprefix_ = child_.prefix
        elif nodeName_ == 'budgetObligations':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'budgetObligations')
            value_ = self.gds_validate_string(value_, node, 'budgetObligations')
            self.budgetObligations = value_
            self.budgetObligations_nsprefix_ = child_.prefix
        elif nodeName_ == 'modificationReason':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'modificationReason')
            value_ = self.gds_validate_string(value_, node, 'modificationReason')
            self.modificationReason = value_
            self.modificationReason_nsprefix_ = child_.prefix
            # validate type zfcs_longTextMinType
            self.validate_zfcs_longTextMinType(self.modificationReason)
        elif nodeName_ == 'currentContractStage':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'currentContractStage')
            value_ = self.gds_validate_string(value_, node, 'currentContractStage')
            self.currentContractStage = value_
            self.currentContractStage_nsprefix_ = child_.prefix
        elif nodeName_ == 'okpd2okved2':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'okpd2okved2')
            ival_ = self.gds_validate_boolean(ival_, node, 'okpd2okved2')
            self.okpd2okved2 = ival_
            self.okpd2okved2_nsprefix_ = child_.prefix
# end class zfcs_contractProcedure2015Type


class id(GeneratedsSuper):
    """Идентификатор документа ЕИС"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, id)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if id.subclass:
            return id.subclass(*args_, **kwargs_)
        else:
            return id(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_id(self, value):
        result = True
        # Validate type id, a restriction on xs:long.
        pass
        return result
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class id


class executions(GeneratedsSuper):
    """Информация об исполнении"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'stage': MemberSpec_('stage', 'stage', 0, 0, {'name': 'stage', 'type': 'stage'}, None),
        'ordinalNumber': MemberSpec_('ordinalNumber', 'xs:int', 0, 0, {'name': 'ordinalNumber', 'type': 'xs:int'}, None),
        'finalStageExecution': MemberSpec_('finalStageExecution', 'xs:boolean', 0, 0, {'name': 'finalStageExecution', 'type': 'xs:boolean'}, None),
        'execution': MemberSpec_('execution', 'execution', 1, 0, {'maxOccurs': 'unbounded', 'name': 'execution', 'type': 'execution'}, None),
        'productsCountries': MemberSpec_('productsCountries', 'productsCountries', 0, 1, {'minOccurs': '0', 'name': 'productsCountries', 'type': 'productsCountries'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, stage=None, ordinalNumber=None, finalStageExecution=None, execution=None, productsCountries=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.stage = stage
        self.stage_nsprefix_ = None
        self.ordinalNumber = ordinalNumber
        self.ordinalNumber_nsprefix_ = None
        self.finalStageExecution = finalStageExecution
        self.finalStageExecution_nsprefix_ = None
        if execution is None:
            self.execution = []
        else:
            self.execution = execution
        self.execution_nsprefix_ = None
        self.productsCountries = productsCountries
        self.productsCountries_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, executions)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if executions.subclass:
            return executions.subclass(*args_, **kwargs_)
        else:
            return executions(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.stage is not None or
            self.ordinalNumber is not None or
            self.finalStageExecution is not None or
            self.execution or
            self.productsCountries is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'stage':
            obj_ = stage.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.stage = obj_
            obj_.original_tagname_ = 'stage'
        elif nodeName_ == 'ordinalNumber' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'ordinalNumber')
            ival_ = self.gds_validate_integer(ival_, node, 'ordinalNumber')
            self.ordinalNumber = ival_
            self.ordinalNumber_nsprefix_ = child_.prefix
        elif nodeName_ == 'finalStageExecution':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'finalStageExecution')
            ival_ = self.gds_validate_boolean(ival_, node, 'finalStageExecution')
            self.finalStageExecution = ival_
            self.finalStageExecution_nsprefix_ = child_.prefix
        elif nodeName_ == 'execution':
            obj_ = execution.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.execution.append(obj_)
            obj_.original_tagname_ = 'execution'
        elif nodeName_ == 'productsCountries':
            obj_ = productsCountries.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.productsCountries = obj_
            obj_.original_tagname_ = 'productsCountries'
# end class executions


class stage(GeneratedsSuper):
    """Этап контракта"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'sid': MemberSpec_('sid', 'xs:long', 0, 0, {'name': 'sid', 'type': 'xs:long'}, 25),
        'externalSid': MemberSpec_('externalSid', ['externalIdType', 'xs:string'], 0, 0, {'name': 'externalSid', 'type': 'xs:string'}, 25),
        'endDate': MemberSpec_('endDate', 'xs:date', 0, 0, {'name': 'endDate', 'type': 'xs:date'}, 25),
        'oldStage': MemberSpec_('oldStage', 'xs:string', 0, 0, {'name': 'oldStage', 'type': 'xs:string'}, 25),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, sid=None, externalSid=None, endDate=None, oldStage=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.sid = sid
        self.sid_nsprefix_ = None
        self.externalSid = externalSid
        self.validate_externalIdType(self.externalSid)
        self.externalSid_nsprefix_ = None
        if isinstance(endDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(endDate, '%Y-%m-%d').date()
        else:
            initvalue_ = endDate
        self.endDate = initvalue_
        self.endDate_nsprefix_ = None
        self.oldStage = oldStage
        self.oldStage_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, stage)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if stage.subclass:
            return stage.subclass(*args_, **kwargs_)
        else:
            return stage(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_externalIdType(self, value):
        result = True
        # Validate type externalIdType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 40:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on externalIdType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on externalIdType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.sid is not None or
            self.externalSid is not None or
            self.endDate is not None or
            self.oldStage is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'sid' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'sid')
            ival_ = self.gds_validate_integer(ival_, node, 'sid')
            self.sid = ival_
            self.sid_nsprefix_ = child_.prefix
        elif nodeName_ == 'externalSid':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'externalSid')
            value_ = self.gds_validate_string(value_, node, 'externalSid')
            self.externalSid = value_
            self.externalSid_nsprefix_ = child_.prefix
            # validate type externalIdType
            self.validate_externalIdType(self.externalSid)
        elif nodeName_ == 'endDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.endDate = dval_
            self.endDate_nsprefix_ = child_.prefix
        elif nodeName_ == 'oldStage':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'oldStage')
            value_ = self.gds_validate_string(value_, node, 'oldStage')
            self.oldStage = value_
            self.oldStage_nsprefix_ = child_.prefix
# end class stage


class execution(GeneratedsSuper):
    """Детализация информации об исполнении контрактаБлок должен быть указан
    ТОЛЬКО в случае если:
    В блоке "Информация об исполнении" (executions) указан хотя бы один блок
    "Документ о приемке" (executions\execution\docAcceptance).
    Указанное поведение верно как приеме новых сведений об исполнении о
    контракте, так и при приеме измененний уже размещенных сведенийПри
    приеме контролируется, что в составе блока заполнен как минимум один
    блок quantityContractSubjects и/или quantityDrugContractSubjects"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'docAcceptance': MemberSpec_('docAcceptance', 'docAcceptance', 0, 0, {'name': 'docAcceptance', 'type': 'docAcceptance'}, 26),
        'payDoc': MemberSpec_('payDoc', 'payDoc', 0, 0, {'name': 'payDoc', 'type': 'payDoc'}, 26),
        'docExecution': MemberSpec_('docExecution', 'docExecution', 0, 0, {'name': 'docExecution', 'type': 'docExecution'}, None),
        'currency': MemberSpec_('currency', 'zfcs_currencyRef', 0, 0, {'name': 'currency', 'type': 'zfcs_currencyRef'}, None),
        'paid': MemberSpec_('paid', ['moneyPositiveType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'paid', 'type': 'xs:string'}, None),
        'currencyRate': MemberSpec_('currencyRate', 'zfcs_currencyRateContract2015', 0, 1, {'minOccurs': '0', 'name': 'currencyRate', 'type': 'zfcs_currencyRateContract2015'}, None),
        'paidRUR': MemberSpec_('paidRUR', ['moneyPositiveType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'paidRUR', 'type': 'xs:string'}, None),
        'paidVAT': MemberSpec_('paidVAT', ['moneyPositiveType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'paidVAT', 'type': 'xs:string'}, None),
        'paidVATRUR': MemberSpec_('paidVATRUR', ['moneyPositiveType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'paidVATRUR', 'type': 'xs:string'}, None),
        'improperExecutionText': MemberSpec_('improperExecutionText', ['zfcs_longTextMinType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'improperExecutionText', 'type': 'xs:string'}, None),
        'product': MemberSpec_('product', ['product', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'product', 'type': 'xs:string'}, None),
        'quantityContractSubjects': MemberSpec_('quantityContractSubjects', 'quantityContractSubjects', 0, 1, {'minOccurs': '0', 'name': 'quantityContractSubjects', 'type': 'quantityContractSubjects'}, 28),
        'quantityDrugContractSubjects': MemberSpec_('quantityDrugContractSubjects', 'quantityDrugContractSubjects', 0, 1, {'minOccurs': '0', 'name': 'quantityDrugContractSubjects', 'type': 'quantityDrugContractSubjects'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, docAcceptance=None, payDoc=None, docExecution=None, currency=None, paid=None, currencyRate=None, paidRUR=None, paidVAT=None, paidVATRUR=None, improperExecutionText=None, product=None, quantityContractSubjects=None, quantityDrugContractSubjects=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.docAcceptance = docAcceptance
        self.docAcceptance_nsprefix_ = None
        self.payDoc = payDoc
        self.payDoc_nsprefix_ = None
        self.docExecution = docExecution
        self.docExecution_nsprefix_ = None
        self.currency = currency
        self.currency_nsprefix_ = None
        self.paid = paid
        self.validate_moneyPositiveType(self.paid)
        self.paid_nsprefix_ = None
        self.currencyRate = currencyRate
        self.currencyRate_nsprefix_ = None
        self.paidRUR = paidRUR
        self.validate_moneyPositiveType(self.paidRUR)
        self.paidRUR_nsprefix_ = None
        self.paidVAT = paidVAT
        self.validate_moneyPositiveType(self.paidVAT)
        self.paidVAT_nsprefix_ = None
        self.paidVATRUR = paidVATRUR
        self.validate_moneyPositiveType(self.paidVATRUR)
        self.paidVATRUR_nsprefix_ = None
        self.improperExecutionText = improperExecutionText
        self.validate_zfcs_longTextMinType(self.improperExecutionText)
        self.improperExecutionText_nsprefix_ = None
        self.product = product
        self.product_nsprefix_ = None
        self.quantityContractSubjects = quantityContractSubjects
        self.quantityContractSubjects_nsprefix_ = None
        self.quantityDrugContractSubjects = quantityDrugContractSubjects
        self.quantityDrugContractSubjects_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, execution)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if execution.subclass:
            return execution.subclass(*args_, **kwargs_)
        else:
            return execution(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_moneyPositiveType(self, value):
        result = True
        # Validate type moneyPositiveType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 21:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on moneyPositiveType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on moneyPositiveType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_moneyPositiveType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_moneyPositiveType_patterns_, ))
                result = False
        return result
    validate_moneyPositiveType_patterns_ = [['^(\\d+(\\.\\d{1,2})?)$']]
    def validate_zfcs_longTextMinType(self, value):
        result = True
        # Validate type zfcs_longTextMinType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 2000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on zfcs_longTextMinType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on zfcs_longTextMinType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.docAcceptance is not None or
            self.payDoc is not None or
            self.docExecution is not None or
            self.currency is not None or
            self.paid is not None or
            self.currencyRate is not None or
            self.paidRUR is not None or
            self.paidVAT is not None or
            self.paidVATRUR is not None or
            self.improperExecutionText is not None or
            self.product is not None or
            self.quantityContractSubjects is not None or
            self.quantityDrugContractSubjects is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'docAcceptance':
            obj_ = docAcceptance.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.docAcceptance = obj_
            obj_.original_tagname_ = 'docAcceptance'
        elif nodeName_ == 'payDoc':
            obj_ = payDoc.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.payDoc = obj_
            obj_.original_tagname_ = 'payDoc'
        elif nodeName_ == 'docExecution':
            obj_ = docExecution.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.docExecution = obj_
            obj_.original_tagname_ = 'docExecution'
        elif nodeName_ == 'currency':
            obj_ = zfcs_currencyRef.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.currency = obj_
            obj_.original_tagname_ = 'currency'
        elif nodeName_ == 'paid':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'paid')
            value_ = self.gds_validate_string(value_, node, 'paid')
            self.paid = value_
            self.paid_nsprefix_ = child_.prefix
            # validate type moneyPositiveType
            self.validate_moneyPositiveType(self.paid)
        elif nodeName_ == 'currencyRate':
            obj_ = zfcs_currencyRateContract2015.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.currencyRate = obj_
            obj_.original_tagname_ = 'currencyRate'
        elif nodeName_ == 'paidRUR':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'paidRUR')
            value_ = self.gds_validate_string(value_, node, 'paidRUR')
            self.paidRUR = value_
            self.paidRUR_nsprefix_ = child_.prefix
            # validate type moneyPositiveType
            self.validate_moneyPositiveType(self.paidRUR)
        elif nodeName_ == 'paidVAT':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'paidVAT')
            value_ = self.gds_validate_string(value_, node, 'paidVAT')
            self.paidVAT = value_
            self.paidVAT_nsprefix_ = child_.prefix
            # validate type moneyPositiveType
            self.validate_moneyPositiveType(self.paidVAT)
        elif nodeName_ == 'paidVATRUR':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'paidVATRUR')
            value_ = self.gds_validate_string(value_, node, 'paidVATRUR')
            self.paidVATRUR = value_
            self.paidVATRUR_nsprefix_ = child_.prefix
            # validate type moneyPositiveType
            self.validate_moneyPositiveType(self.paidVATRUR)
        elif nodeName_ == 'improperExecutionText':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'improperExecutionText')
            value_ = self.gds_validate_string(value_, node, 'improperExecutionText')
            self.improperExecutionText = value_
            self.improperExecutionText_nsprefix_ = child_.prefix
            # validate type zfcs_longTextMinType
            self.validate_zfcs_longTextMinType(self.improperExecutionText)
        elif nodeName_ == 'product':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'product')
            value_ = self.gds_validate_string(value_, node, 'product')
            self.product = value_
            self.product_nsprefix_ = child_.prefix
        elif nodeName_ == 'quantityContractSubjects':
            obj_ = quantityContractSubjects.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.quantityContractSubjects = obj_
            obj_.original_tagname_ = 'quantityContractSubjects'
        elif nodeName_ == 'quantityDrugContractSubjects':
            obj_ = quantityDrugContractSubjects.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.quantityDrugContractSubjects = obj_
            obj_.original_tagname_ = 'quantityDrugContractSubjects'
# end class execution


class docAcceptance(GeneratedsSuper):
    """Документ о приемке"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'sid': MemberSpec_('sid', 'xs:long', 0, 1, {'minOccurs': '0', 'name': 'sid', 'type': 'xs:long'}, 26),
        'externalSid': MemberSpec_('externalSid', ['externalIdType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'externalSid', 'type': 'xs:string'}, 26),
        'code': MemberSpec_('code', 'xs:string', 0, 0, {'name': 'code', 'type': 'xs:string'}, 26),
        'name': MemberSpec_('name', 'xs:string', 0, 1, {'minOccurs': '0', 'name': 'name', 'type': 'xs:string'}, 26),
        'documentDate': MemberSpec_('documentDate', 'xs:date', 0, 0, {'name': 'documentDate', 'type': 'xs:date'}, 26),
        'documentNum': MemberSpec_('documentNum', ['documentNum', 'xs:string'], 0, 0, {'name': 'documentNum', 'type': 'xs:string'}, 26),
        'deliveryAcceptDate': MemberSpec_('deliveryAcceptDate', 'xs:date', 0, 1, {'minOccurs': '0', 'name': 'deliveryAcceptDate', 'type': 'xs:date'}, 26),
        'fulfilmentSum': MemberSpec_('fulfilmentSum', ['moneyPositiveType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'fulfilmentSum', 'type': 'xs:string'}, 26),
        'fulfilmentSumRUR': MemberSpec_('fulfilmentSumRUR', ['moneyPositiveType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'fulfilmentSumRUR', 'type': 'xs:string'}, 26),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, sid=None, externalSid=None, code=None, name=None, documentDate=None, documentNum=None, deliveryAcceptDate=None, fulfilmentSum=None, fulfilmentSumRUR=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.sid = sid
        self.sid_nsprefix_ = None
        self.externalSid = externalSid
        self.validate_externalIdType(self.externalSid)
        self.externalSid_nsprefix_ = None
        self.code = code
        self.code_nsprefix_ = None
        self.name = name
        self.name_nsprefix_ = None
        if isinstance(documentDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(documentDate, '%Y-%m-%d').date()
        else:
            initvalue_ = documentDate
        self.documentDate = initvalue_
        self.documentDate_nsprefix_ = None
        self.documentNum = documentNum
        self.documentNum_nsprefix_ = None
        if isinstance(deliveryAcceptDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(deliveryAcceptDate, '%Y-%m-%d').date()
        else:
            initvalue_ = deliveryAcceptDate
        self.deliveryAcceptDate = initvalue_
        self.deliveryAcceptDate_nsprefix_ = None
        self.fulfilmentSum = fulfilmentSum
        self.validate_moneyPositiveType(self.fulfilmentSum)
        self.fulfilmentSum_nsprefix_ = None
        self.fulfilmentSumRUR = fulfilmentSumRUR
        self.validate_moneyPositiveType(self.fulfilmentSumRUR)
        self.fulfilmentSumRUR_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, docAcceptance)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if docAcceptance.subclass:
            return docAcceptance.subclass(*args_, **kwargs_)
        else:
            return docAcceptance(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_externalIdType(self, value):
        result = True
        # Validate type externalIdType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 40:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on externalIdType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on externalIdType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_moneyPositiveType(self, value):
        result = True
        # Validate type moneyPositiveType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 21:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on moneyPositiveType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on moneyPositiveType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_moneyPositiveType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_moneyPositiveType_patterns_, ))
                result = False
        return result
    validate_moneyPositiveType_patterns_ = [['^(\\d+(\\.\\d{1,2})?)$']]
    def hasContent_(self):
        if (
            self.sid is not None or
            self.externalSid is not None or
            self.code is not None or
            self.name is not None or
            self.documentDate is not None or
            self.documentNum is not None or
            self.deliveryAcceptDate is not None or
            self.fulfilmentSum is not None or
            self.fulfilmentSumRUR is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'sid' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'sid')
            ival_ = self.gds_validate_integer(ival_, node, 'sid')
            self.sid = ival_
            self.sid_nsprefix_ = child_.prefix
        elif nodeName_ == 'externalSid':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'externalSid')
            value_ = self.gds_validate_string(value_, node, 'externalSid')
            self.externalSid = value_
            self.externalSid_nsprefix_ = child_.prefix
            # validate type externalIdType
            self.validate_externalIdType(self.externalSid)
        elif nodeName_ == 'code':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'code')
            value_ = self.gds_validate_string(value_, node, 'code')
            self.code = value_
            self.code_nsprefix_ = child_.prefix
        elif nodeName_ == 'name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'name')
            value_ = self.gds_validate_string(value_, node, 'name')
            self.name = value_
            self.name_nsprefix_ = child_.prefix
        elif nodeName_ == 'documentDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.documentDate = dval_
            self.documentDate_nsprefix_ = child_.prefix
        elif nodeName_ == 'documentNum':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'documentNum')
            value_ = self.gds_validate_string(value_, node, 'documentNum')
            self.documentNum = value_
            self.documentNum_nsprefix_ = child_.prefix
        elif nodeName_ == 'deliveryAcceptDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.deliveryAcceptDate = dval_
            self.deliveryAcceptDate_nsprefix_ = child_.prefix
        elif nodeName_ == 'fulfilmentSum':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'fulfilmentSum')
            value_ = self.gds_validate_string(value_, node, 'fulfilmentSum')
            self.fulfilmentSum = value_
            self.fulfilmentSum_nsprefix_ = child_.prefix
            # validate type moneyPositiveType
            self.validate_moneyPositiveType(self.fulfilmentSum)
        elif nodeName_ == 'fulfilmentSumRUR':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'fulfilmentSumRUR')
            value_ = self.gds_validate_string(value_, node, 'fulfilmentSumRUR')
            self.fulfilmentSumRUR = value_
            self.fulfilmentSumRUR_nsprefix_ = child_.prefix
            # validate type moneyPositiveType
            self.validate_moneyPositiveType(self.fulfilmentSumRUR)
# end class docAcceptance


class payDoc(GeneratedsSuper):
    """Платежный документ"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'sid': MemberSpec_('sid', 'xs:long', 0, 1, {'minOccurs': '0', 'name': 'sid', 'type': 'xs:long'}, 26),
        'externalSid': MemberSpec_('externalSid', ['externalIdType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'externalSid', 'type': 'xs:string'}, 26),
        'documentName': MemberSpec_('documentName', ['text1000Type', 'xs:string'], 0, 0, {'name': 'documentName', 'type': 'xs:string'}, 26),
        'documentDate': MemberSpec_('documentDate', 'xs:date', 0, 0, {'name': 'documentDate', 'type': 'xs:date'}, 26),
        'documentNum': MemberSpec_('documentNum', ['documentNum', 'xs:string'], 0, 0, {'name': 'documentNum', 'type': 'xs:string'}, 26),
        'payDocTypeInfo': MemberSpec_('payDocTypeInfo', 'payDocTypeInfo', 0, 1, {'minOccurs': '0', 'name': 'payDocTypeInfo', 'type': 'payDocTypeInfo'}, 26),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, sid=None, externalSid=None, documentName=None, documentDate=None, documentNum=None, payDocTypeInfo=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.sid = sid
        self.sid_nsprefix_ = None
        self.externalSid = externalSid
        self.validate_externalIdType(self.externalSid)
        self.externalSid_nsprefix_ = None
        self.documentName = documentName
        self.validate_text1000Type(self.documentName)
        self.documentName_nsprefix_ = None
        if isinstance(documentDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(documentDate, '%Y-%m-%d').date()
        else:
            initvalue_ = documentDate
        self.documentDate = initvalue_
        self.documentDate_nsprefix_ = None
        self.documentNum = documentNum
        self.documentNum_nsprefix_ = None
        self.payDocTypeInfo = payDocTypeInfo
        self.payDocTypeInfo_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, payDoc)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if payDoc.subclass:
            return payDoc.subclass(*args_, **kwargs_)
        else:
            return payDoc(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_externalIdType(self, value):
        result = True
        # Validate type externalIdType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 40:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on externalIdType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on externalIdType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_text1000Type(self, value):
        result = True
        # Validate type text1000Type, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on text1000Type' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on text1000Type' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.sid is not None or
            self.externalSid is not None or
            self.documentName is not None or
            self.documentDate is not None or
            self.documentNum is not None or
            self.payDocTypeInfo is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'sid' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'sid')
            ival_ = self.gds_validate_integer(ival_, node, 'sid')
            self.sid = ival_
            self.sid_nsprefix_ = child_.prefix
        elif nodeName_ == 'externalSid':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'externalSid')
            value_ = self.gds_validate_string(value_, node, 'externalSid')
            self.externalSid = value_
            self.externalSid_nsprefix_ = child_.prefix
            # validate type externalIdType
            self.validate_externalIdType(self.externalSid)
        elif nodeName_ == 'documentName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'documentName')
            value_ = self.gds_validate_string(value_, node, 'documentName')
            self.documentName = value_
            self.documentName_nsprefix_ = child_.prefix
            # validate type text1000Type
            self.validate_text1000Type(self.documentName)
        elif nodeName_ == 'documentDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.documentDate = dval_
            self.documentDate_nsprefix_ = child_.prefix
        elif nodeName_ == 'documentNum':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'documentNum')
            value_ = self.gds_validate_string(value_, node, 'documentNum')
            self.documentNum = value_
            self.documentNum_nsprefix_ = child_.prefix
        elif nodeName_ == 'payDocTypeInfo':
            obj_ = payDocTypeInfo.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.payDocTypeInfo = obj_
            obj_.original_tagname_ = 'payDocTypeInfo'
# end class payDoc


class payDocTypeInfo(GeneratedsSuper):
    """Тип платежного документа. Контролируется обязательность и допустимость
    заполнения, если первая версия информации о контракте размещена после
    выхода версии 11.0"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'advancePaymentPayDoc': MemberSpec_('advancePaymentPayDoc', 'advancePaymentPayDoc', 0, 0, {'name': 'advancePaymentPayDoc', 'type': 'advancePaymentPayDoc'}, 27),
        'docAcceptancePayDoc': MemberSpec_('docAcceptancePayDoc', 'docAcceptancePayDoc', 0, 0, {'name': 'docAcceptancePayDoc', 'type': 'docAcceptancePayDoc'}, 27),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, advancePaymentPayDoc=None, docAcceptancePayDoc=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.advancePaymentPayDoc = advancePaymentPayDoc
        self.advancePaymentPayDoc_nsprefix_ = None
        self.docAcceptancePayDoc = docAcceptancePayDoc
        self.docAcceptancePayDoc_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, payDocTypeInfo)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if payDocTypeInfo.subclass:
            return payDocTypeInfo.subclass(*args_, **kwargs_)
        else:
            return payDocTypeInfo(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.advancePaymentPayDoc is not None or
            self.docAcceptancePayDoc is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'advancePaymentPayDoc':
            obj_ = advancePaymentPayDoc.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.advancePaymentPayDoc = obj_
            obj_.original_tagname_ = 'advancePaymentPayDoc'
        elif nodeName_ == 'docAcceptancePayDoc':
            obj_ = docAcceptancePayDoc.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.docAcceptancePayDoc = obj_
            obj_.original_tagname_ = 'docAcceptancePayDoc'
# end class payDocTypeInfo


class advancePaymentPayDoc(GeneratedsSuper):
    """Платежный документ для выплаты аванса"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'isAdvancePaymentPayDoc': MemberSpec_('isAdvancePaymentPayDoc', 'xs:boolean', 0, 0, {'fixed': 'true', 'name': 'isAdvancePaymentPayDoc', 'type': 'xs:boolean'}, 27),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, isAdvancePaymentPayDoc=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.isAdvancePaymentPayDoc = isAdvancePaymentPayDoc
        self.isAdvancePaymentPayDoc_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, advancePaymentPayDoc)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if advancePaymentPayDoc.subclass:
            return advancePaymentPayDoc.subclass(*args_, **kwargs_)
        else:
            return advancePaymentPayDoc(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.isAdvancePaymentPayDoc is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'isAdvancePaymentPayDoc':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'isAdvancePaymentPayDoc')
            ival_ = self.gds_validate_boolean(ival_, node, 'isAdvancePaymentPayDoc')
            self.isAdvancePaymentPayDoc = ival_
            self.isAdvancePaymentPayDoc_nsprefix_ = child_.prefix
# end class advancePaymentPayDoc


class docAcceptancePayDoc(GeneratedsSuper):
    """Платежный документ для оплаты по документу(ам) о приемке"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'isDocAcceptancePayDoc': MemberSpec_('isDocAcceptancePayDoc', 'xs:boolean', 0, 0, {'fixed': 'true', 'name': 'isDocAcceptancePayDoc', 'type': 'xs:boolean'}, 27),
        'payDocToDocAcceptanceCompliances': MemberSpec_('payDocToDocAcceptanceCompliances', 'payDocToDocAcceptanceCompliances', 0, 0, {'name': 'payDocToDocAcceptanceCompliances', 'type': 'payDocToDocAcceptanceCompliances'}, 27),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, isDocAcceptancePayDoc=None, payDocToDocAcceptanceCompliances=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.isDocAcceptancePayDoc = isDocAcceptancePayDoc
        self.isDocAcceptancePayDoc_nsprefix_ = None
        self.payDocToDocAcceptanceCompliances = payDocToDocAcceptanceCompliances
        self.payDocToDocAcceptanceCompliances_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, docAcceptancePayDoc)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if docAcceptancePayDoc.subclass:
            return docAcceptancePayDoc.subclass(*args_, **kwargs_)
        else:
            return docAcceptancePayDoc(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.isDocAcceptancePayDoc is not None or
            self.payDocToDocAcceptanceCompliances is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'isDocAcceptancePayDoc':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'isDocAcceptancePayDoc')
            ival_ = self.gds_validate_boolean(ival_, node, 'isDocAcceptancePayDoc')
            self.isDocAcceptancePayDoc = ival_
            self.isDocAcceptancePayDoc_nsprefix_ = child_.prefix
        elif nodeName_ == 'payDocToDocAcceptanceCompliances':
            obj_ = payDocToDocAcceptanceCompliances.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.payDocToDocAcceptanceCompliances = obj_
            obj_.original_tagname_ = 'payDocToDocAcceptanceCompliances'
# end class docAcceptancePayDoc


class payDocToDocAcceptanceCompliances(GeneratedsSuper):
    """Соответствие платежного документа документам о приемке"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'docAcceptance': MemberSpec_('docAcceptance', 'docAcceptance', 1, 0, {'maxOccurs': 'unbounded', 'name': 'docAcceptance', 'type': 'docAcceptance'}, 27),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, docAcceptance=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if docAcceptance is None:
            self.docAcceptance = []
        else:
            self.docAcceptance = docAcceptance
        self.docAcceptance_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, payDocToDocAcceptanceCompliances)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if payDocToDocAcceptanceCompliances.subclass:
            return payDocToDocAcceptanceCompliances.subclass(*args_, **kwargs_)
        else:
            return payDocToDocAcceptanceCompliances(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.docAcceptance
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'docAcceptance':
            obj_ = docAcceptance.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.docAcceptance.append(obj_)
            obj_.original_tagname_ = 'docAcceptance'
# end class payDocToDocAcceptanceCompliances


class docExecution(GeneratedsSuper):
    """Документ об исполнении контракта"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'sid': MemberSpec_('sid', 'xs:long', 0, 1, {'minOccurs': '0', 'name': 'sid', 'type': 'xs:long'}, None),
        'externalSid': MemberSpec_('externalSid', ['externalIdType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'externalSid', 'type': 'xs:string'}, None),
        'code': MemberSpec_('code', 'xs:string', 0, 0, {'name': 'code', 'type': 'xs:string'}, None),
        'name': MemberSpec_('name', 'xs:string', 0, 1, {'minOccurs': '0', 'name': 'name', 'type': 'xs:string'}, None),
        'documentDate': MemberSpec_('documentDate', 'xs:date', 0, 0, {'name': 'documentDate', 'type': 'xs:date'}, None),
        'documentNum': MemberSpec_('documentNum', ['documentNum', 'xs:string'], 0, 0, {'name': 'documentNum', 'type': 'xs:string'}, None),
        'deliveryAcceptDate': MemberSpec_('deliveryAcceptDate', 'xs:date', 0, 1, {'minOccurs': '0', 'name': 'deliveryAcceptDate', 'type': 'xs:date'}, None),
        'fulfilmentSum': MemberSpec_('fulfilmentSum', ['moneyPositiveType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'fulfilmentSum', 'type': 'xs:string'}, None),
        'fulfilmentSumRUR': MemberSpec_('fulfilmentSumRUR', ['moneyPositiveType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'fulfilmentSumRUR', 'type': 'xs:string'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, sid=None, externalSid=None, code=None, name=None, documentDate=None, documentNum=None, deliveryAcceptDate=None, fulfilmentSum=None, fulfilmentSumRUR=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.sid = sid
        self.sid_nsprefix_ = None
        self.externalSid = externalSid
        self.validate_externalIdType(self.externalSid)
        self.externalSid_nsprefix_ = None
        self.code = code
        self.code_nsprefix_ = None
        self.name = name
        self.name_nsprefix_ = None
        if isinstance(documentDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(documentDate, '%Y-%m-%d').date()
        else:
            initvalue_ = documentDate
        self.documentDate = initvalue_
        self.documentDate_nsprefix_ = None
        self.documentNum = documentNum
        self.documentNum_nsprefix_ = None
        if isinstance(deliveryAcceptDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(deliveryAcceptDate, '%Y-%m-%d').date()
        else:
            initvalue_ = deliveryAcceptDate
        self.deliveryAcceptDate = initvalue_
        self.deliveryAcceptDate_nsprefix_ = None
        self.fulfilmentSum = fulfilmentSum
        self.validate_moneyPositiveType(self.fulfilmentSum)
        self.fulfilmentSum_nsprefix_ = None
        self.fulfilmentSumRUR = fulfilmentSumRUR
        self.validate_moneyPositiveType(self.fulfilmentSumRUR)
        self.fulfilmentSumRUR_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, docExecution)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if docExecution.subclass:
            return docExecution.subclass(*args_, **kwargs_)
        else:
            return docExecution(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_externalIdType(self, value):
        result = True
        # Validate type externalIdType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 40:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on externalIdType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on externalIdType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_moneyPositiveType(self, value):
        result = True
        # Validate type moneyPositiveType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 21:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on moneyPositiveType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on moneyPositiveType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_moneyPositiveType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_moneyPositiveType_patterns_, ))
                result = False
        return result
    validate_moneyPositiveType_patterns_ = [['^(\\d+(\\.\\d{1,2})?)$']]
    def hasContent_(self):
        if (
            self.sid is not None or
            self.externalSid is not None or
            self.code is not None or
            self.name is not None or
            self.documentDate is not None or
            self.documentNum is not None or
            self.deliveryAcceptDate is not None or
            self.fulfilmentSum is not None or
            self.fulfilmentSumRUR is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'sid' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'sid')
            ival_ = self.gds_validate_integer(ival_, node, 'sid')
            self.sid = ival_
            self.sid_nsprefix_ = child_.prefix
        elif nodeName_ == 'externalSid':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'externalSid')
            value_ = self.gds_validate_string(value_, node, 'externalSid')
            self.externalSid = value_
            self.externalSid_nsprefix_ = child_.prefix
            # validate type externalIdType
            self.validate_externalIdType(self.externalSid)
        elif nodeName_ == 'code':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'code')
            value_ = self.gds_validate_string(value_, node, 'code')
            self.code = value_
            self.code_nsprefix_ = child_.prefix
        elif nodeName_ == 'name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'name')
            value_ = self.gds_validate_string(value_, node, 'name')
            self.name = value_
            self.name_nsprefix_ = child_.prefix
        elif nodeName_ == 'documentDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.documentDate = dval_
            self.documentDate_nsprefix_ = child_.prefix
        elif nodeName_ == 'documentNum':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'documentNum')
            value_ = self.gds_validate_string(value_, node, 'documentNum')
            self.documentNum = value_
            self.documentNum_nsprefix_ = child_.prefix
        elif nodeName_ == 'deliveryAcceptDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.deliveryAcceptDate = dval_
            self.deliveryAcceptDate_nsprefix_ = child_.prefix
        elif nodeName_ == 'fulfilmentSum':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'fulfilmentSum')
            value_ = self.gds_validate_string(value_, node, 'fulfilmentSum')
            self.fulfilmentSum = value_
            self.fulfilmentSum_nsprefix_ = child_.prefix
            # validate type moneyPositiveType
            self.validate_moneyPositiveType(self.fulfilmentSum)
        elif nodeName_ == 'fulfilmentSumRUR':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'fulfilmentSumRUR')
            value_ = self.gds_validate_string(value_, node, 'fulfilmentSumRUR')
            self.fulfilmentSumRUR = value_
            self.fulfilmentSumRUR_nsprefix_ = child_.prefix
            # validate type moneyPositiveType
            self.validate_moneyPositiveType(self.fulfilmentSumRUR)
# end class docExecution


class product(GeneratedsSuper):
    """Объем поставленного товара, выполненных работ, оказанных услуг. Устарело
    не применяется, оставлено для обратной совместимости схем"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, product)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if product.subclass:
            return product.subclass(*args_, **kwargs_)
        else:
            return product(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_product(self, value):
        result = True
        # Validate type product, a restriction on xs:string.
        pass
        return result
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class product


class quantityContractSubjects(GeneratedsSuper):
    """Сведения об объеме и других характеристиках поставленных товаров,
    выполненных работ, оказанных услуг"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'quantityContractSubject': MemberSpec_('quantityContractSubject', 'quantityContractSubject', 1, 1, {'maxOccurs': 'unbounded', 'name': 'quantityContractSubject', 'type': 'quantityContractSubject'}, 28),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, quantityContractSubject=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if quantityContractSubject is None:
            self.quantityContractSubject = []
        else:
            self.quantityContractSubject = quantityContractSubject
        self.quantityContractSubject_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, quantityContractSubjects)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if quantityContractSubjects.subclass:
            return quantityContractSubjects.subclass(*args_, **kwargs_)
        else:
            return quantityContractSubjects(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.quantityContractSubject
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'quantityContractSubject':
            obj_ = quantityContractSubject.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.quantityContractSubject.append(obj_)
            obj_.original_tagname_ = 'quantityContractSubject'
# end class quantityContractSubjects


class quantityContractSubject(GeneratedsSuper):
    """Сведения об объеме"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'sid': MemberSpec_('sid', ['sid', 'xs:long'], 0, 1, {'minOccurs': '0', 'name': 'sid', 'type': 'xs:long'}, 29),
        'externalSid': MemberSpec_('externalSid', ['externalIdType', 'xs:string'], 0, 0, {'name': 'externalSid', 'type': 'xs:string'}, 29),
        'productInfo': MemberSpec_('productInfo', 'zfcs_contractProcedure2015SearchProductsAttrsType', 0, 0, {'name': 'productInfo', 'type': 'zfcs_contractProcedure2015SearchProductsAttrsType'}, 29),
        'indexNum': MemberSpec_('indexNum', ['quantityContractSubjectNumType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'indexNum', 'type': 'xs:string'}, None),
        'product': MemberSpec_('product', ['product', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'product', 'type': 'xs:string'}, None),
        'quantity': MemberSpec_('quantity', ['quantity18p11Type', 'xs:decimal'], 0, 1, {'minOccurs': '0', 'name': 'quantity', 'type': 'xs:decimal'}, 32),
        'volumeTextForm': MemberSpec_('volumeTextForm', ['text500Type', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'volumeTextForm', 'type': 'xs:string'}, 32),
        'nomenclature': MemberSpec_('nomenclature', ['text2000Type', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'nomenclature', 'type': 'xs:string'}, None),
        'originCountry': MemberSpec_('originCountry', 'zfcs_countryRef', 0, 1, {'minOccurs': '0', 'name': 'originCountry', 'type': 'zfcs_countryRef'}, None),
        'registrationCountry': MemberSpec_('registrationCountry', 'zfcs_countryRef', 0, 1, {'minOccurs': '0', 'name': 'registrationCountry', 'type': 'zfcs_countryRef'}, None),
        'fulfilledCost': MemberSpec_('fulfilledCost', ['moneyPositiveType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'fulfilledCost', 'type': 'xs:string'}, None),
        'fulfilmentCostRUR': MemberSpec_('fulfilmentCostRUR', ['moneyPositiveType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'fulfilmentCostRUR', 'type': 'xs:string'}, None),
        'unitPrice': MemberSpec_('unitPrice', ['moneyLongType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'unitPrice', 'type': 'xs:string'}, None),
        'unitPriceRUR': MemberSpec_('unitPriceRUR', ['moneyLongType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'unitPriceRUR', 'type': 'xs:string'}, None),
        'parentContractSubject': MemberSpec_('parentContractSubject', 'parentContractSubject', 0, 1, {'minOccurs': '0', 'name': 'parentContractSubject', 'type': 'parentContractSubject'}, None),
        'isMainVehicle': MemberSpec_('isMainVehicle', 'xs:boolean', 0, 1, {'minOccurs': '0', 'name': 'isMainVehicle', 'type': 'xs:boolean'}, None),
        'commonUnitMeasurement': MemberSpec_('commonUnitMeasurement', 'commonUnitsMeasurementsRef', 0, 1, {'minOccurs': '0', 'name': 'commonUnitMeasurement', 'type': 'commonUnitsMeasurementsRef'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, sid=None, externalSid=None, productInfo=None, indexNum=None, product=None, quantity=None, volumeTextForm=None, nomenclature=None, originCountry=None, registrationCountry=None, fulfilledCost=None, fulfilmentCostRUR=None, unitPrice=None, unitPriceRUR=None, parentContractSubject=None, isMainVehicle=None, commonUnitMeasurement=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.sid = sid
        self.sid_nsprefix_ = None
        self.externalSid = externalSid
        self.validate_externalIdType(self.externalSid)
        self.externalSid_nsprefix_ = None
        self.productInfo = productInfo
        self.productInfo_nsprefix_ = None
        self.indexNum = indexNum
        self.validate_quantityContractSubjectNumType(self.indexNum)
        self.indexNum_nsprefix_ = None
        self.product = product
        self.product_nsprefix_ = None
        self.quantity = quantity
        self.validate_quantity18p11Type(self.quantity)
        self.quantity_nsprefix_ = None
        self.volumeTextForm = volumeTextForm
        self.validate_text500Type(self.volumeTextForm)
        self.volumeTextForm_nsprefix_ = None
        self.nomenclature = nomenclature
        self.validate_text2000Type(self.nomenclature)
        self.nomenclature_nsprefix_ = None
        self.originCountry = originCountry
        self.originCountry_nsprefix_ = None
        self.registrationCountry = registrationCountry
        self.registrationCountry_nsprefix_ = None
        self.fulfilledCost = fulfilledCost
        self.validate_moneyPositiveType(self.fulfilledCost)
        self.fulfilledCost_nsprefix_ = None
        self.fulfilmentCostRUR = fulfilmentCostRUR
        self.validate_moneyPositiveType(self.fulfilmentCostRUR)
        self.fulfilmentCostRUR_nsprefix_ = None
        self.unitPrice = unitPrice
        self.validate_moneyLongType(self.unitPrice)
        self.unitPrice_nsprefix_ = None
        self.unitPriceRUR = unitPriceRUR
        self.validate_moneyLongType(self.unitPriceRUR)
        self.unitPriceRUR_nsprefix_ = None
        self.parentContractSubject = parentContractSubject
        self.parentContractSubject_nsprefix_ = None
        self.isMainVehicle = isMainVehicle
        self.isMainVehicle_nsprefix_ = None
        self.commonUnitMeasurement = commonUnitMeasurement
        self.commonUnitMeasurement_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, quantityContractSubject)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if quantityContractSubject.subclass:
            return quantityContractSubject.subclass(*args_, **kwargs_)
        else:
            return quantityContractSubject(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_externalIdType(self, value):
        result = True
        # Validate type externalIdType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 40:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on externalIdType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on externalIdType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_quantityContractSubjectNumType(self, value):
        result = True
        # Validate type quantityContractSubjectNumType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 13:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on quantityContractSubjectNumType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on quantityContractSubjectNumType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_quantityContractSubjectNumType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_quantityContractSubjectNumType_patterns_, ))
                result = False
        return result
    validate_quantityContractSubjectNumType_patterns_ = [['^((\\d{1,6})+(\\.\\d{1,6})?)$']]
    def validate_quantity18p11Type(self, value):
        result = True
        # Validate type quantity18p11Type, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, decimal_.Decimal):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (decimal_.Decimal)' % {"value": value, "lineno": lineno, })
                return False
            if len(str(value)) >= 29:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd totalDigits restriction on quantity18p11Type' % {"value": value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_quantity18p11Type_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_quantity18p11Type_patterns_, ))
                result = False
        return result
    validate_quantity18p11Type_patterns_ = [['^(\\d{1,18}(\\.\\d{1,11})?)$']]
    def validate_text500Type(self, value):
        result = True
        # Validate type text500Type, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 500:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on text500Type' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on text500Type' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_text2000Type(self, value):
        result = True
        # Validate type text2000Type, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 2000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on text2000Type' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on text2000Type' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_moneyPositiveType(self, value):
        result = True
        # Validate type moneyPositiveType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 21:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on moneyPositiveType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on moneyPositiveType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_moneyPositiveType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_moneyPositiveType_patterns_, ))
                result = False
        return result
    validate_moneyPositiveType_patterns_ = [['^(\\d+(\\.\\d{1,2})?)$']]
    def validate_moneyLongType(self, value):
        result = True
        # Validate type moneyLongType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 30:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on moneyLongType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on moneyLongType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_moneyLongType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_moneyLongType_patterns_, ))
                result = False
        return result
    validate_moneyLongType_patterns_ = [['^((-)?\\d+(\\.\\d{1,11})?)$']]
    def hasContent_(self):
        if (
            self.sid is not None or
            self.externalSid is not None or
            self.productInfo is not None or
            self.indexNum is not None or
            self.product is not None or
            self.quantity is not None or
            self.volumeTextForm is not None or
            self.nomenclature is not None or
            self.originCountry is not None or
            self.registrationCountry is not None or
            self.fulfilledCost is not None or
            self.fulfilmentCostRUR is not None or
            self.unitPrice is not None or
            self.unitPriceRUR is not None or
            self.parentContractSubject is not None or
            self.isMainVehicle is not None or
            self.commonUnitMeasurement is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'sid' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'sid')
            ival_ = self.gds_validate_integer(ival_, node, 'sid')
            self.sid = ival_
            self.sid_nsprefix_ = child_.prefix
        elif nodeName_ == 'externalSid':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'externalSid')
            value_ = self.gds_validate_string(value_, node, 'externalSid')
            self.externalSid = value_
            self.externalSid_nsprefix_ = child_.prefix
            # validate type externalIdType
            self.validate_externalIdType(self.externalSid)
        elif nodeName_ == 'productInfo':
            obj_ = zfcs_contractProcedure2015SearchProductsAttrsType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.productInfo = obj_
            obj_.original_tagname_ = 'productInfo'
        elif nodeName_ == 'indexNum':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'indexNum')
            value_ = self.gds_validate_string(value_, node, 'indexNum')
            self.indexNum = value_
            self.indexNum_nsprefix_ = child_.prefix
            # validate type quantityContractSubjectNumType
            self.validate_quantityContractSubjectNumType(self.indexNum)
        elif nodeName_ == 'product':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'product')
            value_ = self.gds_validate_string(value_, node, 'product')
            self.product = value_
            self.product_nsprefix_ = child_.prefix
        elif nodeName_ == 'quantity' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'quantity')
            fval_ = self.gds_validate_decimal(fval_, node, 'quantity')
            self.quantity = fval_
            self.quantity_nsprefix_ = child_.prefix
            # validate type quantity18p11Type
            self.validate_quantity18p11Type(self.quantity)
        elif nodeName_ == 'volumeTextForm':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'volumeTextForm')
            value_ = self.gds_validate_string(value_, node, 'volumeTextForm')
            self.volumeTextForm = value_
            self.volumeTextForm_nsprefix_ = child_.prefix
            # validate type text500Type
            self.validate_text500Type(self.volumeTextForm)
        elif nodeName_ == 'nomenclature':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'nomenclature')
            value_ = self.gds_validate_string(value_, node, 'nomenclature')
            self.nomenclature = value_
            self.nomenclature_nsprefix_ = child_.prefix
            # validate type text2000Type
            self.validate_text2000Type(self.nomenclature)
        elif nodeName_ == 'originCountry':
            obj_ = zfcs_countryRef.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.originCountry = obj_
            obj_.original_tagname_ = 'originCountry'
        elif nodeName_ == 'registrationCountry':
            obj_ = zfcs_countryRef.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.registrationCountry = obj_
            obj_.original_tagname_ = 'registrationCountry'
        elif nodeName_ == 'fulfilledCost':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'fulfilledCost')
            value_ = self.gds_validate_string(value_, node, 'fulfilledCost')
            self.fulfilledCost = value_
            self.fulfilledCost_nsprefix_ = child_.prefix
            # validate type moneyPositiveType
            self.validate_moneyPositiveType(self.fulfilledCost)
        elif nodeName_ == 'fulfilmentCostRUR':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'fulfilmentCostRUR')
            value_ = self.gds_validate_string(value_, node, 'fulfilmentCostRUR')
            self.fulfilmentCostRUR = value_
            self.fulfilmentCostRUR_nsprefix_ = child_.prefix
            # validate type moneyPositiveType
            self.validate_moneyPositiveType(self.fulfilmentCostRUR)
        elif nodeName_ == 'unitPrice':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'unitPrice')
            value_ = self.gds_validate_string(value_, node, 'unitPrice')
            self.unitPrice = value_
            self.unitPrice_nsprefix_ = child_.prefix
            # validate type moneyLongType
            self.validate_moneyLongType(self.unitPrice)
        elif nodeName_ == 'unitPriceRUR':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'unitPriceRUR')
            value_ = self.gds_validate_string(value_, node, 'unitPriceRUR')
            self.unitPriceRUR = value_
            self.unitPriceRUR_nsprefix_ = child_.prefix
            # validate type moneyLongType
            self.validate_moneyLongType(self.unitPriceRUR)
        elif nodeName_ == 'parentContractSubject':
            obj_ = parentContractSubject.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.parentContractSubject = obj_
            obj_.original_tagname_ = 'parentContractSubject'
        elif nodeName_ == 'isMainVehicle':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'isMainVehicle')
            ival_ = self.gds_validate_boolean(ival_, node, 'isMainVehicle')
            self.isMainVehicle = ival_
            self.isMainVehicle_nsprefix_ = child_.prefix
        elif nodeName_ == 'commonUnitMeasurement':
            obj_ = commonUnitsMeasurementsRef.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.commonUnitMeasurement = obj_
            obj_.original_tagname_ = 'commonUnitMeasurement'
# end class quantityContractSubject


class sid(GeneratedsSuper):
    """Уникальный идентификатор предмета контракта (объекта закупки) в ЕИС. При
    приеме контролируется обязательность заполнения. Также контролируется
    наличие в сведениях о контракте предмета контракта с таким sid. При
    этом предметы контракта не должны являться лекарственными препаратами
    (т.е. для них НЕ должен быть заполнен блок «Сведения об объекте закупки
    в том случае, когда объектом закупки является лекарственный препарат»
    (drugPurchaseObjectInfo))"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, sid)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if sid.subclass:
            return sid.subclass(*args_, **kwargs_)
        else:
            return sid(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_sid(self, value):
        result = True
        # Validate type sid, a restriction on xs:long.
        pass
        return result
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class sid


class parentContractSubject(GeneratedsSuper):
    """Родительский предмет контракта (объект закупки). Игнорируется при
    приеме. Автоматически заполняется только для «дочернего» объекта
    закупки"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'sid': MemberSpec_('sid', ['sid', 'xs:long'], 0, 0, {'name': 'sid', 'type': 'xs:long'}, 33),
        'externalSid': MemberSpec_('externalSid', ['externalIdType', 'xs:string'], 0, 0, {'name': 'externalSid', 'type': 'xs:string'}, 33),
        'productInfo': MemberSpec_('productInfo', 'zfcs_contractProcedure2015SearchProductsAttrsType', 0, 0, {'name': 'productInfo', 'type': 'zfcs_contractProcedure2015SearchProductsAttrsType'}, 33),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, sid=None, externalSid=None, productInfo=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.sid = sid
        self.sid_nsprefix_ = None
        self.externalSid = externalSid
        self.validate_externalIdType(self.externalSid)
        self.externalSid_nsprefix_ = None
        self.productInfo = productInfo
        self.productInfo_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, parentContractSubject)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if parentContractSubject.subclass:
            return parentContractSubject.subclass(*args_, **kwargs_)
        else:
            return parentContractSubject(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_externalIdType(self, value):
        result = True
        # Validate type externalIdType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 40:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on externalIdType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on externalIdType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.sid is not None or
            self.externalSid is not None or
            self.productInfo is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'sid' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'sid')
            ival_ = self.gds_validate_integer(ival_, node, 'sid')
            self.sid = ival_
            self.sid_nsprefix_ = child_.prefix
        elif nodeName_ == 'externalSid':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'externalSid')
            value_ = self.gds_validate_string(value_, node, 'externalSid')
            self.externalSid = value_
            self.externalSid_nsprefix_ = child_.prefix
            # validate type externalIdType
            self.validate_externalIdType(self.externalSid)
        elif nodeName_ == 'productInfo':
            obj_ = zfcs_contractProcedure2015SearchProductsAttrsType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.productInfo = obj_
            obj_.original_tagname_ = 'productInfo'
# end class parentContractSubject


class quantityDrugContractSubjects(GeneratedsSuper):
    """Сведения об объеме и других характеристиках поставленных товаров,
    выполненных работ, оказанных услуг для случая, когда предметом
    контракта (объектом закупки) является лекарственный препарат"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'quantityDrugContractSubject': MemberSpec_('quantityDrugContractSubject', 'quantityDrugContractSubject', 1, 0, {'maxOccurs': 'unbounded', 'name': 'quantityDrugContractSubject', 'type': 'quantityDrugContractSubject'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, quantityDrugContractSubject=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if quantityDrugContractSubject is None:
            self.quantityDrugContractSubject = []
        else:
            self.quantityDrugContractSubject = quantityDrugContractSubject
        self.quantityDrugContractSubject_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, quantityDrugContractSubjects)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if quantityDrugContractSubjects.subclass:
            return quantityDrugContractSubjects.subclass(*args_, **kwargs_)
        else:
            return quantityDrugContractSubjects(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.quantityDrugContractSubject
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'quantityDrugContractSubject':
            obj_ = quantityDrugContractSubject.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.quantityDrugContractSubject.append(obj_)
            obj_.original_tagname_ = 'quantityDrugContractSubject'
# end class quantityDrugContractSubjects


class quantityDrugContractSubject(GeneratedsSuper):
    """Сведения об объеме"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'sid': MemberSpec_('sid', ['sid', 'xs:long'], 0, 0, {'name': 'sid', 'type': 'xs:long'}, 34),
        'externalSid': MemberSpec_('externalSid', ['externalIdType', 'xs:string'], 0, 0, {'name': 'externalSid', 'type': 'xs:string'}, 34),
        'productInfo': MemberSpec_('productInfo', 'zfcs_contractProcedure2015SearchProductsAttrsType', 0, 0, {'name': 'productInfo', 'type': 'zfcs_contractProcedure2015SearchProductsAttrsType'}, 34),
        'drugProductInfo': MemberSpec_('drugProductInfo', 'zfcs_contractProcedure2015SearchDrugProductsAttrsType', 0, 0, {'name': 'drugProductInfo', 'type': 'zfcs_contractProcedure2015SearchDrugProductsAttrsType'}, None),
        'indexNum': MemberSpec_('indexNum', ['quantityContractSubjectNumType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'indexNum', 'type': 'xs:string'}, None),
        'product': MemberSpec_('product', ['product', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'product', 'type': 'xs:string'}, None),
        'consumerPackagesQuantity': MemberSpec_('consumerPackagesQuantity', ['consumerPackagesQuantity', 'xs:int'], 0, 0, {'name': 'consumerPackagesQuantity', 'type': 'xs:int'}, None),
        'sumaryDrugQuantity': MemberSpec_('sumaryDrugQuantity', ['drugSumaryPackagingQuantityType', 'xs:decimal'], 0, 1, {'minOccurs': '0', 'name': 'sumaryDrugQuantity', 'type': 'xs:decimal'}, None),
        'packagePrice': MemberSpec_('packagePrice', ['moneyPositiveType', 'xs:string'], 0, 0, {'name': 'packagePrice', 'type': 'xs:string'}, None),
        'VATRate': MemberSpec_('VATRate', ['VATRateEnum', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'VATRate', 'type': 'xs:string'}, None),
        'VATRUR': MemberSpec_('VATRUR', ['moneyPositiveType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'VATRUR', 'type': 'xs:string'}, None),
        'drugSeries': MemberSpec_('drugSeries', ['drugSeries', 'xs:string'], 0, 0, {'name': 'drugSeries', 'type': 'xs:string'}, None),
        'expirationDate': MemberSpec_('expirationDate', 'xs:date', 0, 0, {'name': 'expirationDate', 'type': 'xs:date'}, None),
        'isZNVLP': MemberSpec_('isZNVLP', 'xs:boolean', 0, 1, {'minOccurs': '0', 'name': 'isZNVLP', 'type': 'xs:boolean'}, None),
        'pricesZNVLPInfo': MemberSpec_('pricesZNVLPInfo', 'pricesZNVLPInfo', 0, 1, {'minOccurs': '0', 'name': 'pricesZNVLPInfo', 'type': 'pricesZNVLPInfo'}, None),
        'originCountry': MemberSpec_('originCountry', 'zfcs_countryRef', 0, 1, {'minOccurs': '0', 'name': 'originCountry', 'type': 'zfcs_countryRef'}, None),
        'registrationCountry': MemberSpec_('registrationCountry', 'zfcs_countryRef', 0, 1, {'minOccurs': '0', 'name': 'registrationCountry', 'type': 'zfcs_countryRef'}, None),
        'fulfilmentCostRUR': MemberSpec_('fulfilmentCostRUR', ['moneyPositiveType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'fulfilmentCostRUR', 'type': 'xs:string'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, sid=None, externalSid=None, productInfo=None, drugProductInfo=None, indexNum=None, product=None, consumerPackagesQuantity=None, sumaryDrugQuantity=None, packagePrice=None, VATRate=None, VATRUR=None, drugSeries=None, expirationDate=None, isZNVLP=None, pricesZNVLPInfo=None, originCountry=None, registrationCountry=None, fulfilmentCostRUR=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.sid = sid
        self.sid_nsprefix_ = None
        self.externalSid = externalSid
        self.validate_externalIdType(self.externalSid)
        self.externalSid_nsprefix_ = None
        self.productInfo = productInfo
        self.productInfo_nsprefix_ = None
        self.drugProductInfo = drugProductInfo
        self.drugProductInfo_nsprefix_ = None
        self.indexNum = indexNum
        self.validate_quantityContractSubjectNumType(self.indexNum)
        self.indexNum_nsprefix_ = None
        self.product = product
        self.product_nsprefix_ = None
        self.consumerPackagesQuantity = consumerPackagesQuantity
        self.consumerPackagesQuantity_nsprefix_ = None
        self.sumaryDrugQuantity = sumaryDrugQuantity
        self.validate_drugSumaryPackagingQuantityType(self.sumaryDrugQuantity)
        self.sumaryDrugQuantity_nsprefix_ = None
        self.packagePrice = packagePrice
        self.validate_moneyPositiveType(self.packagePrice)
        self.packagePrice_nsprefix_ = None
        self.VATRate = VATRate
        self.validate_VATRateEnum(self.VATRate)
        self.VATRate_nsprefix_ = None
        self.VATRUR = VATRUR
        self.validate_moneyPositiveType(self.VATRUR)
        self.VATRUR_nsprefix_ = None
        self.drugSeries = drugSeries
        self.drugSeries_nsprefix_ = None
        if isinstance(expirationDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(expirationDate, '%Y-%m-%d').date()
        else:
            initvalue_ = expirationDate
        self.expirationDate = initvalue_
        self.expirationDate_nsprefix_ = None
        self.isZNVLP = isZNVLP
        self.isZNVLP_nsprefix_ = None
        self.pricesZNVLPInfo = pricesZNVLPInfo
        self.pricesZNVLPInfo_nsprefix_ = None
        self.originCountry = originCountry
        self.originCountry_nsprefix_ = None
        self.registrationCountry = registrationCountry
        self.registrationCountry_nsprefix_ = None
        self.fulfilmentCostRUR = fulfilmentCostRUR
        self.validate_moneyPositiveType(self.fulfilmentCostRUR)
        self.fulfilmentCostRUR_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, quantityDrugContractSubject)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if quantityDrugContractSubject.subclass:
            return quantityDrugContractSubject.subclass(*args_, **kwargs_)
        else:
            return quantityDrugContractSubject(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_externalIdType(self, value):
        result = True
        # Validate type externalIdType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 40:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on externalIdType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on externalIdType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_quantityContractSubjectNumType(self, value):
        result = True
        # Validate type quantityContractSubjectNumType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 13:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on quantityContractSubjectNumType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on quantityContractSubjectNumType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_quantityContractSubjectNumType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_quantityContractSubjectNumType_patterns_, ))
                result = False
        return result
    validate_quantityContractSubjectNumType_patterns_ = [['^((\\d{1,6})+(\\.\\d{1,6})?)$']]
    def validate_drugSumaryPackagingQuantityType(self, value):
        result = True
        # Validate type drugSumaryPackagingQuantityType, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, decimal_.Decimal):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (decimal_.Decimal)' % {"value": value, "lineno": lineno, })
                return False
            if len(str(value)) >= 22:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd totalDigits restriction on drugSumaryPackagingQuantityType' % {"value": value, "lineno": lineno} )
                result = False
        return result
    def validate_moneyPositiveType(self, value):
        result = True
        # Validate type moneyPositiveType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 21:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on moneyPositiveType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on moneyPositiveType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_moneyPositiveType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_moneyPositiveType_patterns_, ))
                result = False
        return result
    validate_moneyPositiveType_patterns_ = [['^(\\d+(\\.\\d{1,2})?)$']]
    def validate_VATRateEnum(self, value):
        result = True
        # Validate type VATRateEnum, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['0', '10', '18', '20', 'n']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on VATRateEnum' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.sid is not None or
            self.externalSid is not None or
            self.productInfo is not None or
            self.drugProductInfo is not None or
            self.indexNum is not None or
            self.product is not None or
            self.consumerPackagesQuantity is not None or
            self.sumaryDrugQuantity is not None or
            self.packagePrice is not None or
            self.VATRate is not None or
            self.VATRUR is not None or
            self.drugSeries is not None or
            self.expirationDate is not None or
            self.isZNVLP is not None or
            self.pricesZNVLPInfo is not None or
            self.originCountry is not None or
            self.registrationCountry is not None or
            self.fulfilmentCostRUR is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'sid' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'sid')
            ival_ = self.gds_validate_integer(ival_, node, 'sid')
            self.sid = ival_
            self.sid_nsprefix_ = child_.prefix
        elif nodeName_ == 'externalSid':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'externalSid')
            value_ = self.gds_validate_string(value_, node, 'externalSid')
            self.externalSid = value_
            self.externalSid_nsprefix_ = child_.prefix
            # validate type externalIdType
            self.validate_externalIdType(self.externalSid)
        elif nodeName_ == 'productInfo':
            obj_ = zfcs_contractProcedure2015SearchProductsAttrsType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.productInfo = obj_
            obj_.original_tagname_ = 'productInfo'
        elif nodeName_ == 'drugProductInfo':
            obj_ = zfcs_contractProcedure2015SearchDrugProductsAttrsType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.drugProductInfo = obj_
            obj_.original_tagname_ = 'drugProductInfo'
        elif nodeName_ == 'indexNum':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'indexNum')
            value_ = self.gds_validate_string(value_, node, 'indexNum')
            self.indexNum = value_
            self.indexNum_nsprefix_ = child_.prefix
            # validate type quantityContractSubjectNumType
            self.validate_quantityContractSubjectNumType(self.indexNum)
        elif nodeName_ == 'product':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'product')
            value_ = self.gds_validate_string(value_, node, 'product')
            self.product = value_
            self.product_nsprefix_ = child_.prefix
        elif nodeName_ == 'consumerPackagesQuantity' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'consumerPackagesQuantity')
            ival_ = self.gds_validate_integer(ival_, node, 'consumerPackagesQuantity')
            self.consumerPackagesQuantity = ival_
            self.consumerPackagesQuantity_nsprefix_ = child_.prefix
        elif nodeName_ == 'sumaryDrugQuantity' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'sumaryDrugQuantity')
            fval_ = self.gds_validate_decimal(fval_, node, 'sumaryDrugQuantity')
            self.sumaryDrugQuantity = fval_
            self.sumaryDrugQuantity_nsprefix_ = child_.prefix
            # validate type drugSumaryPackagingQuantityType
            self.validate_drugSumaryPackagingQuantityType(self.sumaryDrugQuantity)
        elif nodeName_ == 'packagePrice':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'packagePrice')
            value_ = self.gds_validate_string(value_, node, 'packagePrice')
            self.packagePrice = value_
            self.packagePrice_nsprefix_ = child_.prefix
            # validate type moneyPositiveType
            self.validate_moneyPositiveType(self.packagePrice)
        elif nodeName_ == 'VATRate':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'VATRate')
            value_ = self.gds_validate_string(value_, node, 'VATRate')
            self.VATRate = value_
            self.VATRate_nsprefix_ = child_.prefix
            # validate type VATRateEnum
            self.validate_VATRateEnum(self.VATRate)
        elif nodeName_ == 'VATRUR':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'VATRUR')
            value_ = self.gds_validate_string(value_, node, 'VATRUR')
            self.VATRUR = value_
            self.VATRUR_nsprefix_ = child_.prefix
            # validate type moneyPositiveType
            self.validate_moneyPositiveType(self.VATRUR)
        elif nodeName_ == 'drugSeries':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'drugSeries')
            value_ = self.gds_validate_string(value_, node, 'drugSeries')
            self.drugSeries = value_
            self.drugSeries_nsprefix_ = child_.prefix
        elif nodeName_ == 'expirationDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.expirationDate = dval_
            self.expirationDate_nsprefix_ = child_.prefix
        elif nodeName_ == 'isZNVLP':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'isZNVLP')
            ival_ = self.gds_validate_boolean(ival_, node, 'isZNVLP')
            self.isZNVLP = ival_
            self.isZNVLP_nsprefix_ = child_.prefix
        elif nodeName_ == 'pricesZNVLPInfo':
            obj_ = pricesZNVLPInfo.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.pricesZNVLPInfo = obj_
            obj_.original_tagname_ = 'pricesZNVLPInfo'
        elif nodeName_ == 'originCountry':
            obj_ = zfcs_countryRef.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.originCountry = obj_
            obj_.original_tagname_ = 'originCountry'
        elif nodeName_ == 'registrationCountry':
            obj_ = zfcs_countryRef.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.registrationCountry = obj_
            obj_.original_tagname_ = 'registrationCountry'
        elif nodeName_ == 'fulfilmentCostRUR':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'fulfilmentCostRUR')
            value_ = self.gds_validate_string(value_, node, 'fulfilmentCostRUR')
            self.fulfilmentCostRUR = value_
            self.fulfilmentCostRUR_nsprefix_ = child_.prefix
            # validate type moneyPositiveType
            self.validate_moneyPositiveType(self.fulfilmentCostRUR)
# end class quantityDrugContractSubject


class MNNsInfo(GeneratedsSuper):
    """Международные, группировочные или химические наименования лекарственных
    препаратов (МНН)"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'MNNInfo': MemberSpec_('MNNInfo', 'MNNInfo', 1, 0, {'maxOccurs': 'unbounded', 'name': 'MNNInfo', 'type': 'MNNInfo'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, MNNInfo=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if MNNInfo is None:
            self.MNNInfo = []
        else:
            self.MNNInfo = MNNInfo
        self.MNNInfo_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MNNsInfo)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MNNsInfo.subclass:
            return MNNsInfo.subclass(*args_, **kwargs_)
        else:
            return MNNsInfo(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.MNNInfo
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'MNNInfo':
            obj_ = MNNInfo.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.MNNInfo.append(obj_)
            obj_.original_tagname_ = 'MNNInfo'
# end class MNNsInfo


class MNNInfo(GeneratedsSuper):
    """Международное, группировочное или химическое наименование лекарственного
    препарата (МНН)"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'MNNName': MemberSpec_('MNNName', ['drugName2000Type', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'MNNName', 'type': 'xs:string'}, None),
        'positionsTradeName': MemberSpec_('positionsTradeName', 'positionsTradeName', 0, 1, {'minOccurs': '0', 'name': 'positionsTradeName', 'type': 'positionsTradeName'}, None),
        'dosageUser': MemberSpec_('dosageUser', 'dosageUser', 0, 1, {'minOccurs': '0', 'name': 'dosageUser', 'type': 'dosageUser'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, MNNName=None, positionsTradeName=None, dosageUser=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.MNNName = MNNName
        self.validate_drugName2000Type(self.MNNName)
        self.MNNName_nsprefix_ = None
        self.positionsTradeName = positionsTradeName
        self.positionsTradeName_nsprefix_ = None
        self.dosageUser = dosageUser
        self.dosageUser_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MNNInfo)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MNNInfo.subclass:
            return MNNInfo.subclass(*args_, **kwargs_)
        else:
            return MNNInfo(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_drugName2000Type(self, value):
        result = True
        # Validate type drugName2000Type, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 2000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on drugName2000Type' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on drugName2000Type' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.MNNName is not None or
            self.positionsTradeName is not None or
            self.dosageUser is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'MNNName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'MNNName')
            value_ = self.gds_validate_string(value_, node, 'MNNName')
            self.MNNName = value_
            self.MNNName_nsprefix_ = child_.prefix
            # validate type drugName2000Type
            self.validate_drugName2000Type(self.MNNName)
        elif nodeName_ == 'positionsTradeName':
            obj_ = positionsTradeName.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.positionsTradeName = obj_
            obj_.original_tagname_ = 'positionsTradeName'
        elif nodeName_ == 'dosageUser':
            obj_ = dosageUser.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.dosageUser = obj_
            obj_.original_tagname_ = 'dosageUser'
# end class MNNInfo


class positionsTradeName(GeneratedsSuper):
    """Позиции по торговому наименованию лекарственного средства"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'positionTradeName': MemberSpec_('positionTradeName', 'positionTradeName', 1, 0, {'maxOccurs': 'unbounded', 'name': 'positionTradeName', 'type': 'positionTradeName'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, positionTradeName=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if positionTradeName is None:
            self.positionTradeName = []
        else:
            self.positionTradeName = positionTradeName
        self.positionTradeName_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, positionsTradeName)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if positionsTradeName.subclass:
            return positionsTradeName.subclass(*args_, **kwargs_)
        else:
            return positionsTradeName(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.positionTradeName
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'positionTradeName':
            obj_ = positionTradeName.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.positionTradeName.append(obj_)
            obj_.original_tagname_ = 'positionTradeName'
# end class positionsTradeName


class positionTradeName(GeneratedsSuper):
    """Позиция"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'tradeInfo': MemberSpec_('tradeInfo', 'tradeInfo', 0, 1, {'minOccurs': '0', 'name': 'tradeInfo', 'type': 'tradeInfo'}, None),
        'medicamentalFormInfo': MemberSpec_('medicamentalFormInfo', 'medicamentalFormInfo', 0, 1, {'minOccurs': '0', 'name': 'medicamentalFormInfo', 'type': 'medicamentalFormInfo'}, None),
        'dosageInfo': MemberSpec_('dosageInfo', 'dosageInfo', 0, 1, {'minOccurs': '0', 'name': 'dosageInfo', 'type': 'dosageInfo'}, None),
        'packagingsInfo': MemberSpec_('packagingsInfo', 'packagingsInfo', 0, 1, {'minOccurs': '0', 'name': 'packagingsInfo', 'type': 'packagingsInfo'}, None),
        'MNNNormName': MemberSpec_('MNNNormName', ['drugName2000Type', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'MNNNormName', 'type': 'xs:string'}, None),
        'dosageNormName': MemberSpec_('dosageNormName', ['drugName2000Type', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'dosageNormName', 'type': 'xs:string'}, None),
        'medicamentalFormNormName': MemberSpec_('medicamentalFormNormName', ['drugName2000Type', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'medicamentalFormNormName', 'type': 'xs:string'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, tradeInfo=None, medicamentalFormInfo=None, dosageInfo=None, packagingsInfo=None, MNNNormName=None, dosageNormName=None, medicamentalFormNormName=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.tradeInfo = tradeInfo
        self.tradeInfo_nsprefix_ = None
        self.medicamentalFormInfo = medicamentalFormInfo
        self.medicamentalFormInfo_nsprefix_ = None
        self.dosageInfo = dosageInfo
        self.dosageInfo_nsprefix_ = None
        self.packagingsInfo = packagingsInfo
        self.packagingsInfo_nsprefix_ = None
        self.MNNNormName = MNNNormName
        self.validate_drugName2000Type(self.MNNNormName)
        self.MNNNormName_nsprefix_ = None
        self.dosageNormName = dosageNormName
        self.validate_drugName2000Type(self.dosageNormName)
        self.dosageNormName_nsprefix_ = None
        self.medicamentalFormNormName = medicamentalFormNormName
        self.validate_drugName2000Type(self.medicamentalFormNormName)
        self.medicamentalFormNormName_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, positionTradeName)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if positionTradeName.subclass:
            return positionTradeName.subclass(*args_, **kwargs_)
        else:
            return positionTradeName(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_drugName2000Type(self, value):
        result = True
        # Validate type drugName2000Type, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 2000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on drugName2000Type' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on drugName2000Type' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.tradeInfo is not None or
            self.medicamentalFormInfo is not None or
            self.dosageInfo is not None or
            self.packagingsInfo is not None or
            self.MNNNormName is not None or
            self.dosageNormName is not None or
            self.medicamentalFormNormName is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'tradeInfo':
            obj_ = tradeInfo.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.tradeInfo = obj_
            obj_.original_tagname_ = 'tradeInfo'
        elif nodeName_ == 'medicamentalFormInfo':
            obj_ = medicamentalFormInfo.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.medicamentalFormInfo = obj_
            obj_.original_tagname_ = 'medicamentalFormInfo'
        elif nodeName_ == 'dosageInfo':
            obj_ = dosageInfo.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.dosageInfo = obj_
            obj_.original_tagname_ = 'dosageInfo'
        elif nodeName_ == 'packagingsInfo':
            obj_ = packagingsInfo.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.packagingsInfo = obj_
            obj_.original_tagname_ = 'packagingsInfo'
        elif nodeName_ == 'MNNNormName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'MNNNormName')
            value_ = self.gds_validate_string(value_, node, 'MNNNormName')
            self.MNNNormName = value_
            self.MNNNormName_nsprefix_ = child_.prefix
            # validate type drugName2000Type
            self.validate_drugName2000Type(self.MNNNormName)
        elif nodeName_ == 'dosageNormName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'dosageNormName')
            value_ = self.gds_validate_string(value_, node, 'dosageNormName')
            self.dosageNormName = value_
            self.dosageNormName_nsprefix_ = child_.prefix
            # validate type drugName2000Type
            self.validate_drugName2000Type(self.dosageNormName)
        elif nodeName_ == 'medicamentalFormNormName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'medicamentalFormNormName')
            value_ = self.gds_validate_string(value_, node, 'medicamentalFormNormName')
            self.medicamentalFormNormName = value_
            self.medicamentalFormNormName_nsprefix_ = child_.prefix
            # validate type drugName2000Type
            self.validate_drugName2000Type(self.medicamentalFormNormName)
# end class positionTradeName


class tradeInfo(GeneratedsSuper):
    """Торговое наименование (ТН) лекарственного препарата"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'tradeName': MemberSpec_('tradeName', ['drugNameType', 'xs:string'], 0, 0, {'name': 'tradeName', 'type': 'xs:string'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, tradeName=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.tradeName = tradeName
        self.validate_drugNameType(self.tradeName)
        self.tradeName_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tradeInfo)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tradeInfo.subclass:
            return tradeInfo.subclass(*args_, **kwargs_)
        else:
            return tradeInfo(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_drugNameType(self, value):
        result = True
        # Validate type drugNameType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 500:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on drugNameType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on drugNameType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.tradeName is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'tradeName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'tradeName')
            value_ = self.gds_validate_string(value_, node, 'tradeName')
            self.tradeName = value_
            self.tradeName_nsprefix_ = child_.prefix
            # validate type drugNameType
            self.validate_drugNameType(self.tradeName)
# end class tradeInfo


class medicamentalFormInfo(GeneratedsSuper):
    """Лекарственная форма"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'medicamentalFormName': MemberSpec_('medicamentalFormName', ['drugNameType', 'xs:string'], 0, 0, {'name': 'medicamentalFormName', 'type': 'xs:string'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, medicamentalFormName=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.medicamentalFormName = medicamentalFormName
        self.validate_drugNameType(self.medicamentalFormName)
        self.medicamentalFormName_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, medicamentalFormInfo)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if medicamentalFormInfo.subclass:
            return medicamentalFormInfo.subclass(*args_, **kwargs_)
        else:
            return medicamentalFormInfo(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_drugNameType(self, value):
        result = True
        # Validate type drugNameType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 500:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on drugNameType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on drugNameType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.medicamentalFormName is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'medicamentalFormName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'medicamentalFormName')
            value_ = self.gds_validate_string(value_, node, 'medicamentalFormName')
            self.medicamentalFormName = value_
            self.medicamentalFormName_nsprefix_ = child_.prefix
            # validate type drugNameType
            self.validate_drugNameType(self.medicamentalFormName)
# end class medicamentalFormInfo


class dosageInfo(GeneratedsSuper):
    """Дозировка"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'dosageName': MemberSpec_('dosageName', ['drugNameType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'dosageName', 'type': 'xs:string'}, None),
        'dosageValue': MemberSpec_('dosageValue', 'xs:string', 0, 0, {'name': 'dosageValue', 'type': 'xs:string'}, None),
        'dosageGRLSValue': MemberSpec_('dosageGRLSValue', ['drugNameType', 'xs:string'], 0, 0, {'name': 'dosageGRLSValue', 'type': 'xs:string'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, dosageName=None, dosageValue=None, dosageGRLSValue=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.dosageName = dosageName
        self.validate_drugNameType(self.dosageName)
        self.dosageName_nsprefix_ = None
        self.dosageValue = dosageValue
        self.dosageValue_nsprefix_ = None
        self.dosageGRLSValue = dosageGRLSValue
        self.validate_drugNameType(self.dosageGRLSValue)
        self.dosageGRLSValue_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, dosageInfo)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if dosageInfo.subclass:
            return dosageInfo.subclass(*args_, **kwargs_)
        else:
            return dosageInfo(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_drugNameType(self, value):
        result = True
        # Validate type drugNameType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 500:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on drugNameType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on drugNameType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.dosageName is not None or
            self.dosageValue is not None or
            self.dosageGRLSValue is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'dosageName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'dosageName')
            value_ = self.gds_validate_string(value_, node, 'dosageName')
            self.dosageName = value_
            self.dosageName_nsprefix_ = child_.prefix
            # validate type drugNameType
            self.validate_drugNameType(self.dosageName)
        elif nodeName_ == 'dosageValue':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'dosageValue')
            value_ = self.gds_validate_string(value_, node, 'dosageValue')
            self.dosageValue = value_
            self.dosageValue_nsprefix_ = child_.prefix
        elif nodeName_ == 'dosageGRLSValue':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'dosageGRLSValue')
            value_ = self.gds_validate_string(value_, node, 'dosageGRLSValue')
            self.dosageGRLSValue = value_
            self.dosageGRLSValue_nsprefix_ = child_.prefix
            # validate type drugNameType
            self.validate_drugNameType(self.dosageGRLSValue)
# end class dosageInfo


class packagingsInfo(GeneratedsSuper):
    """Сведения об упаковках"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'packagingInfo': MemberSpec_('packagingInfo', 'packagingInfo', 0, 0, {'name': 'packagingInfo', 'type': 'packagingInfo'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, packagingInfo=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.packagingInfo = packagingInfo
        self.packagingInfo_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, packagingsInfo)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if packagingsInfo.subclass:
            return packagingsInfo.subclass(*args_, **kwargs_)
        else:
            return packagingsInfo(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.packagingInfo is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'packagingInfo':
            obj_ = packagingInfo.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.packagingInfo = obj_
            obj_.original_tagname_ = 'packagingInfo'
# end class packagingsInfo


class packagingInfo(GeneratedsSuper):
    """Сведения об упаковке"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'primaryPackagingInfo': MemberSpec_('primaryPackagingInfo', 'primaryPackagingInfo', 0, 1, {'minOccurs': '0', 'name': 'primaryPackagingInfo', 'type': 'primaryPackagingInfo'}, None),
        'packaging1Quantity': MemberSpec_('packaging1Quantity', ['drugPackaging1QuantityType', 'xs:decimal'], 0, 1, {'minOccurs': '0', 'name': 'packaging1Quantity', 'type': 'xs:decimal'}, None),
        'packaging2Quantity': MemberSpec_('packaging2Quantity', ['drugPackaging2QuantityType', 'xs:int'], 0, 1, {'minOccurs': '0', 'name': 'packaging2Quantity', 'type': 'xs:int'}, None),
        'sumaryPackagingQuantity': MemberSpec_('sumaryPackagingQuantity', ['drugSumaryPackagingQuantityType', 'xs:decimal'], 0, 1, {'minOccurs': '0', 'name': 'sumaryPackagingQuantity', 'type': 'xs:decimal'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, primaryPackagingInfo=None, packaging1Quantity=None, packaging2Quantity=None, sumaryPackagingQuantity=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.primaryPackagingInfo = primaryPackagingInfo
        self.primaryPackagingInfo_nsprefix_ = None
        self.packaging1Quantity = packaging1Quantity
        self.validate_drugPackaging1QuantityType(self.packaging1Quantity)
        self.packaging1Quantity_nsprefix_ = None
        self.packaging2Quantity = packaging2Quantity
        self.validate_drugPackaging2QuantityType(self.packaging2Quantity)
        self.packaging2Quantity_nsprefix_ = None
        self.sumaryPackagingQuantity = sumaryPackagingQuantity
        self.validate_drugSumaryPackagingQuantityType(self.sumaryPackagingQuantity)
        self.sumaryPackagingQuantity_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, packagingInfo)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if packagingInfo.subclass:
            return packagingInfo.subclass(*args_, **kwargs_)
        else:
            return packagingInfo(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_drugPackaging1QuantityType(self, value):
        result = True
        # Validate type drugPackaging1QuantityType, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, decimal_.Decimal):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (decimal_.Decimal)' % {"value": value, "lineno": lineno, })
                return False
            if len(str(value)) >= 11:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd totalDigits restriction on drugPackaging1QuantityType' % {"value": value, "lineno": lineno} )
                result = False
        return result
    def validate_drugPackaging2QuantityType(self, value):
        result = True
        # Validate type drugPackaging2QuantityType, a restriction on xs:int.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            if len(str(value)) >= 11:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd totalDigits restriction on drugPackaging2QuantityType' % {"value": value, "lineno": lineno} )
                result = False
        return result
    def validate_drugSumaryPackagingQuantityType(self, value):
        result = True
        # Validate type drugSumaryPackagingQuantityType, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, decimal_.Decimal):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (decimal_.Decimal)' % {"value": value, "lineno": lineno, })
                return False
            if len(str(value)) >= 22:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd totalDigits restriction on drugSumaryPackagingQuantityType' % {"value": value, "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.primaryPackagingInfo is not None or
            self.packaging1Quantity is not None or
            self.packaging2Quantity is not None or
            self.sumaryPackagingQuantity is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'primaryPackagingInfo':
            obj_ = primaryPackagingInfo.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.primaryPackagingInfo = obj_
            obj_.original_tagname_ = 'primaryPackagingInfo'
        elif nodeName_ == 'packaging1Quantity' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'packaging1Quantity')
            fval_ = self.gds_validate_decimal(fval_, node, 'packaging1Quantity')
            self.packaging1Quantity = fval_
            self.packaging1Quantity_nsprefix_ = child_.prefix
            # validate type drugPackaging1QuantityType
            self.validate_drugPackaging1QuantityType(self.packaging1Quantity)
        elif nodeName_ == 'packaging2Quantity' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'packaging2Quantity')
            ival_ = self.gds_validate_integer(ival_, node, 'packaging2Quantity')
            self.packaging2Quantity = ival_
            self.packaging2Quantity_nsprefix_ = child_.prefix
            # validate type drugPackaging2QuantityType
            self.validate_drugPackaging2QuantityType(self.packaging2Quantity)
        elif nodeName_ == 'sumaryPackagingQuantity' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'sumaryPackagingQuantity')
            fval_ = self.gds_validate_decimal(fval_, node, 'sumaryPackagingQuantity')
            self.sumaryPackagingQuantity = fval_
            self.sumaryPackagingQuantity_nsprefix_ = child_.prefix
            # validate type drugSumaryPackagingQuantityType
            self.validate_drugSumaryPackagingQuantityType(self.sumaryPackagingQuantity)
# end class packagingInfo


class primaryPackagingInfo(GeneratedsSuper):
    """Сведения о первичной упаковке"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'primaryPackagingName': MemberSpec_('primaryPackagingName', ['drugNameType', 'xs:string'], 0, 0, {'name': 'primaryPackagingName', 'type': 'xs:string'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, primaryPackagingName=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.primaryPackagingName = primaryPackagingName
        self.validate_drugNameType(self.primaryPackagingName)
        self.primaryPackagingName_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, primaryPackagingInfo)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if primaryPackagingInfo.subclass:
            return primaryPackagingInfo.subclass(*args_, **kwargs_)
        else:
            return primaryPackagingInfo(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_drugNameType(self, value):
        result = True
        # Validate type drugNameType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 500:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on drugNameType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on drugNameType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.primaryPackagingName is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'primaryPackagingName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'primaryPackagingName')
            value_ = self.gds_validate_string(value_, node, 'primaryPackagingName')
            self.primaryPackagingName = value_
            self.primaryPackagingName_nsprefix_ = child_.prefix
            # validate type drugNameType
            self.validate_drugNameType(self.primaryPackagingName)
# end class primaryPackagingInfo


class dosageUser(GeneratedsSuper):
    """Потребительская единица дозировки"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'dosageUserOKEI': MemberSpec_('dosageUserOKEI', 'zfcs_contract.OKEIType', 0, 0, {'name': 'dosageUserOKEI', 'type': 'zfcs_contract.OKEIType'}, None),
        'dosageUserName': MemberSpec_('dosageUserName', ['drugNameType', 'xs:string'], 0, 0, {'name': 'dosageUserName', 'type': 'xs:string'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, dosageUserOKEI=None, dosageUserName=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.dosageUserOKEI = dosageUserOKEI
        self.dosageUserOKEI_nsprefix_ = None
        self.dosageUserName = dosageUserName
        self.validate_drugNameType(self.dosageUserName)
        self.dosageUserName_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, dosageUser)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if dosageUser.subclass:
            return dosageUser.subclass(*args_, **kwargs_)
        else:
            return dosageUser(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_drugNameType(self, value):
        result = True
        # Validate type drugNameType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 500:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on drugNameType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on drugNameType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.dosageUserOKEI is not None or
            self.dosageUserName is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'dosageUserOKEI':
            obj_ = zfcs_contract_OKEIType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.dosageUserOKEI = obj_
            obj_.original_tagname_ = 'dosageUserOKEI'
        elif nodeName_ == 'dosageUserName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'dosageUserName')
            value_ = self.gds_validate_string(value_, node, 'dosageUserName')
            self.dosageUserName = value_
            self.dosageUserName_nsprefix_ = child_.prefix
            # validate type drugNameType
            self.validate_drugNameType(self.dosageUserName)
# end class dosageUser


class consumerPackagesQuantity(GeneratedsSuper):
    """Количество поставленных потребительских упаковок"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, consumerPackagesQuantity)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if consumerPackagesQuantity.subclass:
            return consumerPackagesQuantity.subclass(*args_, **kwargs_)
        else:
            return consumerPackagesQuantity(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_consumerPackagesQuantity(self, value):
        result = True
        # Validate type consumerPackagesQuantity, a restriction on xs:int.
        pass
        return result
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class consumerPackagesQuantity


class drugSeries(GeneratedsSuper):
    """Серия лекарственного препарата"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, drugSeries)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if drugSeries.subclass:
            return drugSeries.subclass(*args_, **kwargs_)
        else:
            return drugSeries(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_drugSeries(self, value):
        result = True
        # Validate type drugSeries, a restriction on xs:string.
        pass
        return result
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class drugSeries


class pricesZNVLPInfo(GeneratedsSuper):
    """Информация о ценах в случае когда объектом закупки является
    лекарственный препарат, который включен в ЖНВЛП. Контролируется
    обязательность заполнения в случае если для лекарственного препарата
    isZNVLP = true"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'maxSalesPrice': MemberSpec_('maxSalesPrice', ['moneyPositiveType', 'xs:string'], 0, 0, {'name': 'maxSalesPrice', 'type': 'xs:string'}, None),
        'actualSalesPrice': MemberSpec_('actualSalesPrice', ['moneyPositiveType', 'xs:string'], 0, 0, {'name': 'actualSalesPrice', 'type': 'xs:string'}, None),
        'wholesaleAllowancesRUR': MemberSpec_('wholesaleAllowancesRUR', ['moneyPositiveType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'wholesaleAllowancesRUR', 'type': 'xs:string'}, None),
        'wholesaleAllowancesInProcent': MemberSpec_('wholesaleAllowancesInProcent', ['percentD2Type', 'xs:double'], 0, 1, {'minOccurs': '0', 'name': 'wholesaleAllowancesInProcent', 'type': 'xs:double'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, maxSalesPrice=None, actualSalesPrice=None, wholesaleAllowancesRUR=None, wholesaleAllowancesInProcent=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.maxSalesPrice = maxSalesPrice
        self.validate_moneyPositiveType(self.maxSalesPrice)
        self.maxSalesPrice_nsprefix_ = None
        self.actualSalesPrice = actualSalesPrice
        self.validate_moneyPositiveType(self.actualSalesPrice)
        self.actualSalesPrice_nsprefix_ = None
        self.wholesaleAllowancesRUR = wholesaleAllowancesRUR
        self.validate_moneyPositiveType(self.wholesaleAllowancesRUR)
        self.wholesaleAllowancesRUR_nsprefix_ = None
        self.wholesaleAllowancesInProcent = wholesaleAllowancesInProcent
        self.validate_percentD2Type(self.wholesaleAllowancesInProcent)
        self.wholesaleAllowancesInProcent_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, pricesZNVLPInfo)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if pricesZNVLPInfo.subclass:
            return pricesZNVLPInfo.subclass(*args_, **kwargs_)
        else:
            return pricesZNVLPInfo(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_moneyPositiveType(self, value):
        result = True
        # Validate type moneyPositiveType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 21:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on moneyPositiveType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on moneyPositiveType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_moneyPositiveType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_moneyPositiveType_patterns_, ))
                result = False
        return result
    validate_moneyPositiveType_patterns_ = [['^(\\d+(\\.\\d{1,2})?)$']]
    def validate_percentD2Type(self, value):
        result = True
        # Validate type percentD2Type, a restriction on xs:double.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, float):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (float)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_percentD2Type_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_percentD2Type_patterns_, ))
                result = False
        return result
    validate_percentD2Type_patterns_ = [['^(\\d+(\\.\\d{1,2})?)$']]
    def hasContent_(self):
        if (
            self.maxSalesPrice is not None or
            self.actualSalesPrice is not None or
            self.wholesaleAllowancesRUR is not None or
            self.wholesaleAllowancesInProcent is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'maxSalesPrice':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'maxSalesPrice')
            value_ = self.gds_validate_string(value_, node, 'maxSalesPrice')
            self.maxSalesPrice = value_
            self.maxSalesPrice_nsprefix_ = child_.prefix
            # validate type moneyPositiveType
            self.validate_moneyPositiveType(self.maxSalesPrice)
        elif nodeName_ == 'actualSalesPrice':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'actualSalesPrice')
            value_ = self.gds_validate_string(value_, node, 'actualSalesPrice')
            self.actualSalesPrice = value_
            self.actualSalesPrice_nsprefix_ = child_.prefix
            # validate type moneyPositiveType
            self.validate_moneyPositiveType(self.actualSalesPrice)
        elif nodeName_ == 'wholesaleAllowancesRUR':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'wholesaleAllowancesRUR')
            value_ = self.gds_validate_string(value_, node, 'wholesaleAllowancesRUR')
            self.wholesaleAllowancesRUR = value_
            self.wholesaleAllowancesRUR_nsprefix_ = child_.prefix
            # validate type moneyPositiveType
            self.validate_moneyPositiveType(self.wholesaleAllowancesRUR)
        elif nodeName_ == 'wholesaleAllowancesInProcent' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_double(sval_, node, 'wholesaleAllowancesInProcent')
            fval_ = self.gds_validate_double(fval_, node, 'wholesaleAllowancesInProcent')
            self.wholesaleAllowancesInProcent = fval_
            self.wholesaleAllowancesInProcent_nsprefix_ = child_.prefix
            # validate type percentD2Type
            self.validate_percentD2Type(self.wholesaleAllowancesInProcent)
# end class pricesZNVLPInfo


class productsCountries(GeneratedsSuper):
    """Страны происхождения товара, страны производителя.
    Устарел, не применяется"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'productsCountry': MemberSpec_('productsCountry', 'zfcs_contractProcedure2015ProductsCountryType', 1, 0, {'maxOccurs': 'unbounded', 'name': 'productsCountry', 'type': 'zfcs_contractProcedure2015ProductsCountryType'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, productsCountry=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if productsCountry is None:
            self.productsCountry = []
        else:
            self.productsCountry = productsCountry
        self.productsCountry_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, productsCountries)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if productsCountries.subclass:
            return productsCountries.subclass(*args_, **kwargs_)
        else:
            return productsCountries(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.productsCountry
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'productsCountry':
            obj_ = zfcs_contractProcedure2015ProductsCountryType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.productsCountry.append(obj_)
            obj_.original_tagname_ = 'productsCountry'
# end class productsCountries


class executionObligationGuarantee(GeneratedsSuper):
    """Информация о наступлении гарантийного случая и исполнении обязательств
    по предоставленной гарантии качества товаров, работ, услуг. Не может
    быть заполнен одновременно с блоками executions, termination,
    refundOverpaymentsInfo"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'documents': MemberSpec_('documents', 'documents', 0, 0, {'name': 'documents', 'type': 'documents'}, None),
        'bankGuaranteeTermination': MemberSpec_('bankGuaranteeTermination', 'zfcs_contractProcedure2015BankGuaranteeTerminationType', 0, 1, {'minOccurs': '0', 'name': 'bankGuaranteeTermination', 'type': 'zfcs_contractProcedure2015BankGuaranteeTerminationType'}, None),
        'productsCountries': MemberSpec_('productsCountries', 'productsCountries', 0, 1, {'minOccurs': '0', 'name': 'productsCountries', 'type': 'productsCountries'}, None),
        'bankGuaranteePayment': MemberSpec_('bankGuaranteePayment', 'zfcs_contractProcedure2015BankGuaranteePaymentType', 0, 1, {'minOccurs': '0', 'name': 'bankGuaranteePayment', 'type': 'zfcs_contractProcedure2015BankGuaranteePaymentType'}, None),
        'holdCashEnforcement': MemberSpec_('holdCashEnforcement', 'zfcs_contractProcedure2015HoldCashEnforcementType', 0, 1, {'minOccurs': '0', 'name': 'holdCashEnforcement', 'type': 'zfcs_contractProcedure2015HoldCashEnforcementType'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, documents=None, bankGuaranteeTermination=None, productsCountries=None, bankGuaranteePayment=None, holdCashEnforcement=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.documents = documents
        self.documents_nsprefix_ = None
        self.bankGuaranteeTermination = bankGuaranteeTermination
        self.bankGuaranteeTermination_nsprefix_ = None
        self.productsCountries = productsCountries
        self.productsCountries_nsprefix_ = None
        self.bankGuaranteePayment = bankGuaranteePayment
        self.bankGuaranteePayment_nsprefix_ = None
        self.holdCashEnforcement = holdCashEnforcement
        self.holdCashEnforcement_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, executionObligationGuarantee)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if executionObligationGuarantee.subclass:
            return executionObligationGuarantee.subclass(*args_, **kwargs_)
        else:
            return executionObligationGuarantee(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.documents is not None or
            self.bankGuaranteeTermination is not None or
            self.productsCountries is not None or
            self.bankGuaranteePayment is not None or
            self.holdCashEnforcement is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'documents':
            obj_ = documents.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.documents = obj_
            obj_.original_tagname_ = 'documents'
        elif nodeName_ == 'bankGuaranteeTermination':
            obj_ = zfcs_contractProcedure2015BankGuaranteeTerminationType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.bankGuaranteeTermination = obj_
            obj_.original_tagname_ = 'bankGuaranteeTermination'
        elif nodeName_ == 'productsCountries':
            obj_ = productsCountries.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.productsCountries = obj_
            obj_.original_tagname_ = 'productsCountries'
        elif nodeName_ == 'bankGuaranteePayment':
            obj_ = zfcs_contractProcedure2015BankGuaranteePaymentType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.bankGuaranteePayment = obj_
            obj_.original_tagname_ = 'bankGuaranteePayment'
        elif nodeName_ == 'holdCashEnforcement':
            obj_ = zfcs_contractProcedure2015HoldCashEnforcementType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.holdCashEnforcement = obj_
            obj_.original_tagname_ = 'holdCashEnforcement'
# end class executionObligationGuarantee


class termination(GeneratedsSuper):
    """Информация о расторжении контракта"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'paid': MemberSpec_('paid', ['moneyPositiveType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'paid', 'type': 'xs:string'}, None),
        'terminationDate': MemberSpec_('terminationDate', 'xs:date', 0, 0, {'name': 'terminationDate', 'type': 'xs:date'}, None),
        'reasonInfo': MemberSpec_('reasonInfo', ['zfcs_longTextMinType', 'xs:string'], 0, 0, {'name': 'reasonInfo', 'type': 'xs:string'}, None),
        'reason': MemberSpec_('reason', 'reason', 0, 0, {'name': 'reason', 'type': 'xs:string'}, None),
        'docTermination': MemberSpec_('docTermination', 'docTermination', 0, 0, {'name': 'docTermination', 'type': 'docTermination'}, None),
        'decisionDate': MemberSpec_('decisionDate', 'xs:date', 0, 1, {'minOccurs': '0', 'name': 'decisionDate', 'type': 'xs:date'}, None),
        'reparations': MemberSpec_('reparations', 'reparations', 0, 1, {'minOccurs': '0', 'name': 'reparations', 'type': 'reparations'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, paid=None, terminationDate=None, reasonInfo=None, reason=None, docTermination=None, decisionDate=None, reparations=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.paid = paid
        self.validate_moneyPositiveType(self.paid)
        self.paid_nsprefix_ = None
        if isinstance(terminationDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(terminationDate, '%Y-%m-%d').date()
        else:
            initvalue_ = terminationDate
        self.terminationDate = initvalue_
        self.terminationDate_nsprefix_ = None
        self.reasonInfo = reasonInfo
        self.validate_zfcs_longTextMinType(self.reasonInfo)
        self.reasonInfo_nsprefix_ = None
        self.reason = reason
        self.reason_nsprefix_ = None
        self.docTermination = docTermination
        self.docTermination_nsprefix_ = None
        if isinstance(decisionDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(decisionDate, '%Y-%m-%d').date()
        else:
            initvalue_ = decisionDate
        self.decisionDate = initvalue_
        self.decisionDate_nsprefix_ = None
        self.reparations = reparations
        self.reparations_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, termination)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if termination.subclass:
            return termination.subclass(*args_, **kwargs_)
        else:
            return termination(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_moneyPositiveType(self, value):
        result = True
        # Validate type moneyPositiveType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 21:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on moneyPositiveType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on moneyPositiveType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_moneyPositiveType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_moneyPositiveType_patterns_, ))
                result = False
        return result
    validate_moneyPositiveType_patterns_ = [['^(\\d+(\\.\\d{1,2})?)$']]
    def validate_zfcs_longTextMinType(self, value):
        result = True
        # Validate type zfcs_longTextMinType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 2000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on zfcs_longTextMinType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on zfcs_longTextMinType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.paid is not None or
            self.terminationDate is not None or
            self.reasonInfo is not None or
            self.reason is not None or
            self.docTermination is not None or
            self.decisionDate is not None or
            self.reparations is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'paid':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'paid')
            value_ = self.gds_validate_string(value_, node, 'paid')
            self.paid = value_
            self.paid_nsprefix_ = child_.prefix
            # validate type moneyPositiveType
            self.validate_moneyPositiveType(self.paid)
        elif nodeName_ == 'terminationDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.terminationDate = dval_
            self.terminationDate_nsprefix_ = child_.prefix
        elif nodeName_ == 'reasonInfo':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'reasonInfo')
            value_ = self.gds_validate_string(value_, node, 'reasonInfo')
            self.reasonInfo = value_
            self.reasonInfo_nsprefix_ = child_.prefix
            # validate type zfcs_longTextMinType
            self.validate_zfcs_longTextMinType(self.reasonInfo)
        elif nodeName_ == 'reason':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'reason')
            value_ = self.gds_validate_string(value_, node, 'reason')
            self.reason = value_
            self.reason_nsprefix_ = child_.prefix
        elif nodeName_ == 'docTermination':
            obj_ = docTermination.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.docTermination = obj_
            obj_.original_tagname_ = 'docTermination'
        elif nodeName_ == 'decisionDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.decisionDate = dval_
            self.decisionDate_nsprefix_ = child_.prefix
        elif nodeName_ == 'reparations':
            obj_ = reparations.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.reparations = obj_
            obj_.original_tagname_ = 'reparations'
# end class termination


class docTermination(GeneratedsSuper):
    """Документ, являющийся основанием расторжения контракта.
    Ссылка на блок "Документы, являющиеся основанием расторжения
    контракта"(documents) справочника "Основания расторжения контракта"
    (nsiContractTerminationReason)"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'code': MemberSpec_('code', 'xs:string', 0, 0, {'name': 'code', 'type': 'xs:string'}, None),
        'name': MemberSpec_('name', 'xs:string', 0, 1, {'minOccurs': '0', 'name': 'name', 'type': 'xs:string'}, None),
        'documentDate': MemberSpec_('documentDate', 'xs:date', 0, 0, {'name': 'documentDate', 'type': 'xs:date'}, None),
        'documentNum': MemberSpec_('documentNum', ['documentNum', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'documentNum', 'type': 'xs:string'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, code=None, name=None, documentDate=None, documentNum=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.code = code
        self.code_nsprefix_ = None
        self.name = name
        self.name_nsprefix_ = None
        if isinstance(documentDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(documentDate, '%Y-%m-%d').date()
        else:
            initvalue_ = documentDate
        self.documentDate = initvalue_
        self.documentDate_nsprefix_ = None
        self.documentNum = documentNum
        self.documentNum_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, docTermination)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if docTermination.subclass:
            return docTermination.subclass(*args_, **kwargs_)
        else:
            return docTermination(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.code is not None or
            self.name is not None or
            self.documentDate is not None or
            self.documentNum is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'code':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'code')
            value_ = self.gds_validate_string(value_, node, 'code')
            self.code = value_
            self.code_nsprefix_ = child_.prefix
        elif nodeName_ == 'name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'name')
            value_ = self.gds_validate_string(value_, node, 'name')
            self.name = value_
            self.name_nsprefix_ = child_.prefix
        elif nodeName_ == 'documentDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.documentDate = dval_
            self.documentDate_nsprefix_ = child_.prefix
        elif nodeName_ == 'documentNum':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'documentNum')
            value_ = self.gds_validate_string(value_, node, 'documentNum')
            self.documentNum = value_
            self.documentNum_nsprefix_ = child_.prefix
# end class docTermination


class reparations(GeneratedsSuper):
    """Суммы возмещения фактически понесенного ущерба"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'reparation': MemberSpec_('reparation', 'reparation', 1, 0, {'maxOccurs': 'unbounded', 'name': 'reparation', 'type': 'reparation'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, reparation=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if reparation is None:
            self.reparation = []
        else:
            self.reparation = reparation
        self.reparation_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, reparations)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if reparations.subclass:
            return reparations.subclass(*args_, **kwargs_)
        else:
            return reparations(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.reparation
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'reparation':
            obj_ = reparation.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.reparation.append(obj_)
            obj_.original_tagname_ = 'reparation'
# end class reparations


class reparation(GeneratedsSuper):
    """Сумма возмещения фактически понесенного ущерба"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'foundationDoc': MemberSpec_('foundationDoc', 'foundationDoc', 0, 0, {'name': 'foundationDoc', 'type': 'foundationDoc'}, 40),
        'payDoc': MemberSpec_('payDoc', 'payDoc', 0, 0, {'name': 'payDoc', 'type': 'payDoc'}, 40),
        'documentDate': MemberSpec_('documentDate', 'xs:date', 0, 0, {'name': 'documentDate', 'type': 'xs:date'}, None),
        'documentNum': MemberSpec_('documentNum', ['documentNum', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'documentNum', 'type': 'xs:string'}, None),
        'currency': MemberSpec_('currency', 'zfcs_currencyRef', 0, 0, {'name': 'currency', 'type': 'zfcs_currencyRef'}, None),
        'sum': MemberSpec_('sum', ['moneyPositiveType', 'xs:string'], 0, 0, {'name': 'sum', 'type': 'xs:string'}, None),
        'currencyRate': MemberSpec_('currencyRate', 'zfcs_currencyRateContract2015', 0, 1, {'minOccurs': '0', 'name': 'currencyRate', 'type': 'zfcs_currencyRateContract2015'}, None),
        'sumRUR': MemberSpec_('sumRUR', ['moneyPositiveType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'sumRUR', 'type': 'xs:string'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, foundationDoc=None, payDoc=None, documentDate=None, documentNum=None, currency=None, sum=None, currencyRate=None, sumRUR=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.foundationDoc = foundationDoc
        self.foundationDoc_nsprefix_ = None
        self.payDoc = payDoc
        self.payDoc_nsprefix_ = None
        if isinstance(documentDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(documentDate, '%Y-%m-%d').date()
        else:
            initvalue_ = documentDate
        self.documentDate = initvalue_
        self.documentDate_nsprefix_ = None
        self.documentNum = documentNum
        self.documentNum_nsprefix_ = None
        self.currency = currency
        self.currency_nsprefix_ = None
        self.sum = sum
        self.validate_moneyPositiveType(self.sum)
        self.sum_nsprefix_ = None
        self.currencyRate = currencyRate
        self.currencyRate_nsprefix_ = None
        self.sumRUR = sumRUR
        self.validate_moneyPositiveType(self.sumRUR)
        self.sumRUR_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, reparation)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if reparation.subclass:
            return reparation.subclass(*args_, **kwargs_)
        else:
            return reparation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_moneyPositiveType(self, value):
        result = True
        # Validate type moneyPositiveType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 21:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on moneyPositiveType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on moneyPositiveType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_moneyPositiveType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_moneyPositiveType_patterns_, ))
                result = False
        return result
    validate_moneyPositiveType_patterns_ = [['^(\\d+(\\.\\d{1,2})?)$']]
    def hasContent_(self):
        if (
            self.foundationDoc is not None or
            self.payDoc is not None or
            self.documentDate is not None or
            self.documentNum is not None or
            self.currency is not None or
            self.sum is not None or
            self.currencyRate is not None or
            self.sumRUR is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'foundationDoc':
            obj_ = foundationDoc.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.foundationDoc = obj_
            obj_.original_tagname_ = 'foundationDoc'
        elif nodeName_ == 'payDoc':
            obj_ = payDoc.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.payDoc = obj_
            obj_.original_tagname_ = 'payDoc'
        elif nodeName_ == 'documentDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.documentDate = dval_
            self.documentDate_nsprefix_ = child_.prefix
        elif nodeName_ == 'documentNum':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'documentNum')
            value_ = self.gds_validate_string(value_, node, 'documentNum')
            self.documentNum = value_
            self.documentNum_nsprefix_ = child_.prefix
        elif nodeName_ == 'currency':
            obj_ = zfcs_currencyRef.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.currency = obj_
            obj_.original_tagname_ = 'currency'
        elif nodeName_ == 'sum':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'sum')
            value_ = self.gds_validate_string(value_, node, 'sum')
            self.sum = value_
            self.sum_nsprefix_ = child_.prefix
            # validate type moneyPositiveType
            self.validate_moneyPositiveType(self.sum)
        elif nodeName_ == 'currencyRate':
            obj_ = zfcs_currencyRateContract2015.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.currencyRate = obj_
            obj_.original_tagname_ = 'currencyRate'
        elif nodeName_ == 'sumRUR':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'sumRUR')
            value_ = self.gds_validate_string(value_, node, 'sumRUR')
            self.sumRUR = value_
            self.sumRUR_nsprefix_ = child_.prefix
            # validate type moneyPositiveType
            self.validate_moneyPositiveType(self.sumRUR)
# end class reparation


class foundationDoc(GeneratedsSuper):
    """Документ, являющиийся основанием для начисления суммы возмещения
    фактически понесенного ущерба"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'code': MemberSpec_('code', 'xs:string', 0, 0, {'name': 'code', 'type': 'xs:string'}, 40),
        'name': MemberSpec_('name', 'xs:string', 0, 1, {'minOccurs': '0', 'name': 'name', 'type': 'xs:string'}, 40),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, code=None, name=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.code = code
        self.code_nsprefix_ = None
        self.name = name
        self.name_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, foundationDoc)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if foundationDoc.subclass:
            return foundationDoc.subclass(*args_, **kwargs_)
        else:
            return foundationDoc(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.code is not None or
            self.name is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'code':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'code')
            value_ = self.gds_validate_string(value_, node, 'code')
            self.code = value_
            self.code_nsprefix_ = child_.prefix
        elif nodeName_ == 'name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'name')
            value_ = self.gds_validate_string(value_, node, 'name')
            self.name = value_
            self.name_nsprefix_ = child_.prefix
# end class foundationDoc


class refundOverpaymentsInfo(GeneratedsSuper):
    """Информация о возврате поставщиком (подрядчиком, исполнителем) переплаты
    по контракту.
    Не может быть заполнен одновременно с блоками executions, termination,
    executionObligationGuarantee.
    При приеме контролируется, что:
    1. Контракт находится на этапе "Исполнение" или "Исполнение завершено" или
    "Исполнение прекращено"
    2. Есть размещенные сведения об исполнении/расторжении контракта,
    содержащие сведения о платежных документах (Хотя бы в одном из таких
    документов заполнен блок "Платежный документ"
    (executions/execution/payDoc))
    3. Разность суммы полей refundOverpaymentsInfo/refundOverpaymentInfo/amount
    OverpaidsInfo/amountOverpaidInfo/amountOverpaidSum и суммы полей refund
    OverpaymentsInfo/refundOverpaymentInfo/amountRefundsInfo/amountRefundIn
    fo/amountRefundSum больше 0
    4. Разность суммы полей refundOverpaymentsInfo/refundOverpaymentInfo/amount
    RefundsInfo/amountRefundInfo/amountRefundSum И суммы полей
    executions/execution/paid в документах об исполнении/расторжении, в
    которых заполнен блок executions/execution/payDoc больше 0"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'refundOverpaymentInfo': MemberSpec_('refundOverpaymentInfo', 'refundOverpaymentInfo', 1, 0, {'maxOccurs': 'unbounded', 'name': 'refundOverpaymentInfo', 'type': 'refundOverpaymentInfo'}, None),
        'currency': MemberSpec_('currency', 'zfcs_currencyRef', 0, 0, {'name': 'currency', 'type': 'zfcs_currencyRef'}, None),
        'refundOverpaidDocuments': MemberSpec_('refundOverpaidDocuments', 'xs:string', 0, 1, {'minOccurs': '0', 'name': 'refundOverpaidDocuments', 'type': 'xs:string'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, refundOverpaymentInfo=None, currency=None, refundOverpaidDocuments=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if refundOverpaymentInfo is None:
            self.refundOverpaymentInfo = []
        else:
            self.refundOverpaymentInfo = refundOverpaymentInfo
        self.refundOverpaymentInfo_nsprefix_ = None
        self.currency = currency
        self.currency_nsprefix_ = None
        self.refundOverpaidDocuments = refundOverpaidDocuments
        self.refundOverpaidDocuments_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, refundOverpaymentsInfo)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if refundOverpaymentsInfo.subclass:
            return refundOverpaymentsInfo.subclass(*args_, **kwargs_)
        else:
            return refundOverpaymentsInfo(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.refundOverpaymentInfo or
            self.currency is not None or
            self.refundOverpaidDocuments is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'refundOverpaymentInfo':
            obj_ = refundOverpaymentInfo.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.refundOverpaymentInfo.append(obj_)
            obj_.original_tagname_ = 'refundOverpaymentInfo'
        elif nodeName_ == 'currency':
            obj_ = zfcs_currencyRef.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.currency = obj_
            obj_.original_tagname_ = 'currency'
        elif nodeName_ == 'refundOverpaidDocuments':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'refundOverpaidDocuments')
            value_ = self.gds_validate_string(value_, node, 'refundOverpaidDocuments')
            self.refundOverpaidDocuments = value_
            self.refundOverpaidDocuments_nsprefix_ = child_.prefix
# end class refundOverpaymentsInfo


class refundOverpaymentInfo(GeneratedsSuper):
    """Информация о возврате поставщиком (подрядчиком, исполнителем) переплаты
    по контракту.
    В блоке контролируется, что (ИЛИ):
    1. Заполнены блоки foundationRefundDocsInfo, amountOverpaidsInfo и
    amountRefundsInfo
    2. Заполнены блоки foundationRefundDocsInfo и
    amountOverpaidsInfo
    3. Заполнен только блок amountRefundsInfo"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'foundationRefundDocsInfo': MemberSpec_('foundationRefundDocsInfo', 'foundationRefundDocsInfo', 0, 1, {'minOccurs': '0', 'name': 'foundationRefundDocsInfo', 'type': 'foundationRefundDocsInfo'}, None),
        'amountOverpaidsInfo': MemberSpec_('amountOverpaidsInfo', 'amountOverpaidsInfo', 0, 1, {'minOccurs': '0', 'name': 'amountOverpaidsInfo', 'type': 'amountOverpaidsInfo'}, None),
        'amountRefundsInfo': MemberSpec_('amountRefundsInfo', 'amountRefundsInfo', 0, 1, {'minOccurs': '0', 'name': 'amountRefundsInfo', 'type': 'amountRefundsInfo'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, foundationRefundDocsInfo=None, amountOverpaidsInfo=None, amountRefundsInfo=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.foundationRefundDocsInfo = foundationRefundDocsInfo
        self.foundationRefundDocsInfo_nsprefix_ = None
        self.amountOverpaidsInfo = amountOverpaidsInfo
        self.amountOverpaidsInfo_nsprefix_ = None
        self.amountRefundsInfo = amountRefundsInfo
        self.amountRefundsInfo_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, refundOverpaymentInfo)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if refundOverpaymentInfo.subclass:
            return refundOverpaymentInfo.subclass(*args_, **kwargs_)
        else:
            return refundOverpaymentInfo(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.foundationRefundDocsInfo is not None or
            self.amountOverpaidsInfo is not None or
            self.amountRefundsInfo is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'foundationRefundDocsInfo':
            obj_ = foundationRefundDocsInfo.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.foundationRefundDocsInfo = obj_
            obj_.original_tagname_ = 'foundationRefundDocsInfo'
        elif nodeName_ == 'amountOverpaidsInfo':
            obj_ = amountOverpaidsInfo.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.amountOverpaidsInfo = obj_
            obj_.original_tagname_ = 'amountOverpaidsInfo'
        elif nodeName_ == 'amountRefundsInfo':
            obj_ = amountRefundsInfo.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.amountRefundsInfo = obj_
            obj_.original_tagname_ = 'amountRefundsInfo'
# end class refundOverpaymentInfo


class foundationRefundDocsInfo(GeneratedsSuper):
    """Реквизиты документов, являющихся основанием для возврата заказчику
    излишне уплаченной суммы оплаты контракта"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'foundationRefundDocInfo': MemberSpec_('foundationRefundDocInfo', 'foundationRefundDocInfo', 1, 0, {'maxOccurs': 'unbounded', 'name': 'foundationRefundDocInfo', 'type': 'foundationRefundDocInfo'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, foundationRefundDocInfo=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if foundationRefundDocInfo is None:
            self.foundationRefundDocInfo = []
        else:
            self.foundationRefundDocInfo = foundationRefundDocInfo
        self.foundationRefundDocInfo_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, foundationRefundDocsInfo)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if foundationRefundDocsInfo.subclass:
            return foundationRefundDocsInfo.subclass(*args_, **kwargs_)
        else:
            return foundationRefundDocsInfo(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.foundationRefundDocInfo
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'foundationRefundDocInfo':
            obj_ = foundationRefundDocInfo.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.foundationRefundDocInfo.append(obj_)
            obj_.original_tagname_ = 'foundationRefundDocInfo'
# end class foundationRefundDocsInfo


class foundationRefundDocInfo(GeneratedsSuper):
    """Реквизиты документа, являющегося основанием для возврата заказчику
    излишне уплаченной суммы оплаты контракта"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'name': MemberSpec_('name', ['text200Type', 'xs:string'], 0, 0, {'name': 'name', 'type': 'xs:string'}, None),
        'number': MemberSpec_('number', ['text200Type', 'xs:string'], 0, 0, {'name': 'number', 'type': 'xs:string'}, None),
        'date': MemberSpec_('date', 'xs:date', 0, 0, {'name': 'date', 'type': 'xs:date'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, name=None, number=None, date=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.name = name
        self.validate_text200Type(self.name)
        self.name_nsprefix_ = None
        self.number = number
        self.validate_text200Type(self.number)
        self.number_nsprefix_ = None
        if isinstance(date, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(date, '%Y-%m-%d').date()
        else:
            initvalue_ = date
        self.date = initvalue_
        self.date_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, foundationRefundDocInfo)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if foundationRefundDocInfo.subclass:
            return foundationRefundDocInfo.subclass(*args_, **kwargs_)
        else:
            return foundationRefundDocInfo(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_text200Type(self, value):
        result = True
        # Validate type text200Type, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 200:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on text200Type' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on text200Type' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.name is not None or
            self.number is not None or
            self.date is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'name')
            value_ = self.gds_validate_string(value_, node, 'name')
            self.name = value_
            self.name_nsprefix_ = child_.prefix
            # validate type text200Type
            self.validate_text200Type(self.name)
        elif nodeName_ == 'number':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'number')
            value_ = self.gds_validate_string(value_, node, 'number')
            self.number = value_
            self.number_nsprefix_ = child_.prefix
            # validate type text200Type
            self.validate_text200Type(self.number)
        elif nodeName_ == 'date':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.date = dval_
            self.date_nsprefix_ = child_.prefix
# end class foundationRefundDocInfo


class amountOverpaidsInfo(GeneratedsSuper):
    """Размеры излишне уплаченной заказчиком суммы оплаты контракта"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'amountOverpaidInfo': MemberSpec_('amountOverpaidInfo', 'amountOverpaidInfo', 1, 0, {'maxOccurs': 'unbounded', 'name': 'amountOverpaidInfo', 'type': 'amountOverpaidInfo'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, amountOverpaidInfo=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if amountOverpaidInfo is None:
            self.amountOverpaidInfo = []
        else:
            self.amountOverpaidInfo = amountOverpaidInfo
        self.amountOverpaidInfo_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, amountOverpaidsInfo)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if amountOverpaidsInfo.subclass:
            return amountOverpaidsInfo.subclass(*args_, **kwargs_)
        else:
            return amountOverpaidsInfo(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.amountOverpaidInfo
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'amountOverpaidInfo':
            obj_ = amountOverpaidInfo.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.amountOverpaidInfo.append(obj_)
            obj_.original_tagname_ = 'amountOverpaidInfo'
# end class amountOverpaidsInfo


class amountOverpaidInfo(GeneratedsSuper):
    """Размер излишне уплаченной заказчиком суммы оплаты контракта"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'amountOverpaidSum': MemberSpec_('amountOverpaidSum', ['moneyMaxLengthToPoint18Type', 'xs:string'], 0, 0, {'name': 'amountOverpaidSum', 'type': 'xs:string'}, None),
        'amountOverpaidSumRUR': MemberSpec_('amountOverpaidSumRUR', ['moneyMaxLengthToPoint18Type', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'amountOverpaidSumRUR', 'type': 'xs:string'}, None),
        'overpaidDate': MemberSpec_('overpaidDate', 'xs:date', 0, 0, {'name': 'overpaidDate', 'type': 'xs:date'}, None),
        'currencyRate': MemberSpec_('currencyRate', 'zfcs_currencyRateContract2015', 0, 1, {'minOccurs': '0', 'name': 'currencyRate', 'type': 'zfcs_currencyRateContract2015'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, amountOverpaidSum=None, amountOverpaidSumRUR=None, overpaidDate=None, currencyRate=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.amountOverpaidSum = amountOverpaidSum
        self.validate_moneyMaxLengthToPoint18Type(self.amountOverpaidSum)
        self.amountOverpaidSum_nsprefix_ = None
        self.amountOverpaidSumRUR = amountOverpaidSumRUR
        self.validate_moneyMaxLengthToPoint18Type(self.amountOverpaidSumRUR)
        self.amountOverpaidSumRUR_nsprefix_ = None
        if isinstance(overpaidDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(overpaidDate, '%Y-%m-%d').date()
        else:
            initvalue_ = overpaidDate
        self.overpaidDate = initvalue_
        self.overpaidDate_nsprefix_ = None
        self.currencyRate = currencyRate
        self.currencyRate_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, amountOverpaidInfo)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if amountOverpaidInfo.subclass:
            return amountOverpaidInfo.subclass(*args_, **kwargs_)
        else:
            return amountOverpaidInfo(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_moneyMaxLengthToPoint18Type(self, value):
        result = True
        # Validate type moneyMaxLengthToPoint18Type, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 21:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on moneyMaxLengthToPoint18Type' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on moneyMaxLengthToPoint18Type' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_moneyMaxLengthToPoint18Type_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_moneyMaxLengthToPoint18Type_patterns_, ))
                result = False
        return result
    validate_moneyMaxLengthToPoint18Type_patterns_ = [['^(\\d{1,18}(\\.\\d{1,2})?)$']]
    def hasContent_(self):
        if (
            self.amountOverpaidSum is not None or
            self.amountOverpaidSumRUR is not None or
            self.overpaidDate is not None or
            self.currencyRate is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'amountOverpaidSum':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'amountOverpaidSum')
            value_ = self.gds_validate_string(value_, node, 'amountOverpaidSum')
            self.amountOverpaidSum = value_
            self.amountOverpaidSum_nsprefix_ = child_.prefix
            # validate type moneyMaxLengthToPoint18Type
            self.validate_moneyMaxLengthToPoint18Type(self.amountOverpaidSum)
        elif nodeName_ == 'amountOverpaidSumRUR':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'amountOverpaidSumRUR')
            value_ = self.gds_validate_string(value_, node, 'amountOverpaidSumRUR')
            self.amountOverpaidSumRUR = value_
            self.amountOverpaidSumRUR_nsprefix_ = child_.prefix
            # validate type moneyMaxLengthToPoint18Type
            self.validate_moneyMaxLengthToPoint18Type(self.amountOverpaidSumRUR)
        elif nodeName_ == 'overpaidDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.overpaidDate = dval_
            self.overpaidDate_nsprefix_ = child_.prefix
        elif nodeName_ == 'currencyRate':
            obj_ = zfcs_currencyRateContract2015.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.currencyRate = obj_
            obj_.original_tagname_ = 'currencyRate'
# end class amountOverpaidInfo


class amountRefundsInfo(GeneratedsSuper):
    """Размеры возвращенной заказчику излишне уплаченной заказчиком суммы
    оплаты контракта"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'amountRefundInfo': MemberSpec_('amountRefundInfo', 'amountRefundInfo', 1, 0, {'maxOccurs': 'unbounded', 'name': 'amountRefundInfo', 'type': 'amountRefundInfo'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, amountRefundInfo=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if amountRefundInfo is None:
            self.amountRefundInfo = []
        else:
            self.amountRefundInfo = amountRefundInfo
        self.amountRefundInfo_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, amountRefundsInfo)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if amountRefundsInfo.subclass:
            return amountRefundsInfo.subclass(*args_, **kwargs_)
        else:
            return amountRefundsInfo(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.amountRefundInfo
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'amountRefundInfo':
            obj_ = amountRefundInfo.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.amountRefundInfo.append(obj_)
            obj_.original_tagname_ = 'amountRefundInfo'
# end class amountRefundsInfo


class amountRefundInfo(GeneratedsSuper):
    """Размер возвращенной заказчику излишне уплаченной заказчиком суммы оплаты
    контракта"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'amountRefundSum': MemberSpec_('amountRefundSum', ['moneyMaxLengthToPoint18Type', 'xs:string'], 0, 0, {'name': 'amountRefundSum', 'type': 'xs:string'}, None),
        'amountRefundSumRUR': MemberSpec_('amountRefundSumRUR', ['moneyMaxLengthToPoint18Type', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'amountRefundSumRUR', 'type': 'xs:string'}, None),
        'refundDate': MemberSpec_('refundDate', 'xs:date', 0, 0, {'name': 'refundDate', 'type': 'xs:date'}, None),
        'currencyRate': MemberSpec_('currencyRate', 'zfcs_currencyRateContract2015', 0, 1, {'minOccurs': '0', 'name': 'currencyRate', 'type': 'zfcs_currencyRateContract2015'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, amountRefundSum=None, amountRefundSumRUR=None, refundDate=None, currencyRate=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.amountRefundSum = amountRefundSum
        self.validate_moneyMaxLengthToPoint18Type(self.amountRefundSum)
        self.amountRefundSum_nsprefix_ = None
        self.amountRefundSumRUR = amountRefundSumRUR
        self.validate_moneyMaxLengthToPoint18Type(self.amountRefundSumRUR)
        self.amountRefundSumRUR_nsprefix_ = None
        if isinstance(refundDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(refundDate, '%Y-%m-%d').date()
        else:
            initvalue_ = refundDate
        self.refundDate = initvalue_
        self.refundDate_nsprefix_ = None
        self.currencyRate = currencyRate
        self.currencyRate_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, amountRefundInfo)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if amountRefundInfo.subclass:
            return amountRefundInfo.subclass(*args_, **kwargs_)
        else:
            return amountRefundInfo(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_moneyMaxLengthToPoint18Type(self, value):
        result = True
        # Validate type moneyMaxLengthToPoint18Type, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 21:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on moneyMaxLengthToPoint18Type' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on moneyMaxLengthToPoint18Type' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_moneyMaxLengthToPoint18Type_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_moneyMaxLengthToPoint18Type_patterns_, ))
                result = False
        return result
    validate_moneyMaxLengthToPoint18Type_patterns_ = [['^(\\d{1,18}(\\.\\d{1,2})?)$']]
    def hasContent_(self):
        if (
            self.amountRefundSum is not None or
            self.amountRefundSumRUR is not None or
            self.refundDate is not None or
            self.currencyRate is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'amountRefundSum':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'amountRefundSum')
            value_ = self.gds_validate_string(value_, node, 'amountRefundSum')
            self.amountRefundSum = value_
            self.amountRefundSum_nsprefix_ = child_.prefix
            # validate type moneyMaxLengthToPoint18Type
            self.validate_moneyMaxLengthToPoint18Type(self.amountRefundSum)
        elif nodeName_ == 'amountRefundSumRUR':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'amountRefundSumRUR')
            value_ = self.gds_validate_string(value_, node, 'amountRefundSumRUR')
            self.amountRefundSumRUR = value_
            self.amountRefundSumRUR_nsprefix_ = child_.prefix
            # validate type moneyMaxLengthToPoint18Type
            self.validate_moneyMaxLengthToPoint18Type(self.amountRefundSumRUR)
        elif nodeName_ == 'refundDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.refundDate = dval_
            self.refundDate_nsprefix_ = child_.prefix
        elif nodeName_ == 'currencyRate':
            obj_ = zfcs_currencyRateContract2015.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.currencyRate = obj_
            obj_.original_tagname_ = 'currencyRate'
# end class amountRefundInfo


class contractInvalidation(GeneratedsSuper):
    """Информация о признании контракта недействительным"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'paid': MemberSpec_('paid', ['moneyPositiveType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'paid', 'type': 'xs:string'}, None),
        'invalidationReason': MemberSpec_('invalidationReason', 'xs:string', 0, 1, {'minOccurs': '0', 'name': 'invalidationReason', 'type': 'xs:string'}, None),
        'invalidationReasonDocument': MemberSpec_('invalidationReasonDocument', 'invalidationReasonDocument', 0, 0, {'name': 'invalidationReasonDocument', 'type': 'invalidationReasonDocument'}, None),
        'decisionDate': MemberSpec_('decisionDate', 'xs:date', 0, 0, {'name': 'decisionDate', 'type': 'xs:date'}, None),
        'invalidationDate': MemberSpec_('invalidationDate', 'xs:date', 0, 0, {'name': 'invalidationDate', 'type': 'xs:date'}, None),
        'invalidationDocuments': MemberSpec_('invalidationDocuments', 'xs:string', 0, 0, {'name': 'invalidationDocuments', 'type': 'xs:string'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, paid=None, invalidationReason=None, invalidationReasonDocument=None, decisionDate=None, invalidationDate=None, invalidationDocuments=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.paid = paid
        self.validate_moneyPositiveType(self.paid)
        self.paid_nsprefix_ = None
        self.invalidationReason = invalidationReason
        self.invalidationReason_nsprefix_ = None
        self.invalidationReasonDocument = invalidationReasonDocument
        self.invalidationReasonDocument_nsprefix_ = None
        if isinstance(decisionDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(decisionDate, '%Y-%m-%d').date()
        else:
            initvalue_ = decisionDate
        self.decisionDate = initvalue_
        self.decisionDate_nsprefix_ = None
        if isinstance(invalidationDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(invalidationDate, '%Y-%m-%d').date()
        else:
            initvalue_ = invalidationDate
        self.invalidationDate = initvalue_
        self.invalidationDate_nsprefix_ = None
        self.invalidationDocuments = invalidationDocuments
        self.invalidationDocuments_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, contractInvalidation)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if contractInvalidation.subclass:
            return contractInvalidation.subclass(*args_, **kwargs_)
        else:
            return contractInvalidation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_moneyPositiveType(self, value):
        result = True
        # Validate type moneyPositiveType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 21:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on moneyPositiveType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on moneyPositiveType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_moneyPositiveType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_moneyPositiveType_patterns_, ))
                result = False
        return result
    validate_moneyPositiveType_patterns_ = [['^(\\d+(\\.\\d{1,2})?)$']]
    def hasContent_(self):
        if (
            self.paid is not None or
            self.invalidationReason is not None or
            self.invalidationReasonDocument is not None or
            self.decisionDate is not None or
            self.invalidationDate is not None or
            self.invalidationDocuments is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'paid':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'paid')
            value_ = self.gds_validate_string(value_, node, 'paid')
            self.paid = value_
            self.paid_nsprefix_ = child_.prefix
            # validate type moneyPositiveType
            self.validate_moneyPositiveType(self.paid)
        elif nodeName_ == 'invalidationReason':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'invalidationReason')
            value_ = self.gds_validate_string(value_, node, 'invalidationReason')
            self.invalidationReason = value_
            self.invalidationReason_nsprefix_ = child_.prefix
        elif nodeName_ == 'invalidationReasonDocument':
            obj_ = invalidationReasonDocument.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.invalidationReasonDocument = obj_
            obj_.original_tagname_ = 'invalidationReasonDocument'
        elif nodeName_ == 'decisionDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.decisionDate = dval_
            self.decisionDate_nsprefix_ = child_.prefix
        elif nodeName_ == 'invalidationDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.invalidationDate = dval_
            self.invalidationDate_nsprefix_ = child_.prefix
        elif nodeName_ == 'invalidationDocuments':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'invalidationDocuments')
            value_ = self.gds_validate_string(value_, node, 'invalidationDocuments')
            self.invalidationDocuments = value_
            self.invalidationDocuments_nsprefix_ = child_.prefix
# end class contractInvalidation


class invalidationReasonDocument(GeneratedsSuper):
    """Наименование документа, являющегося основанием признания контракта
    недействительным.
    Ссылка на блок "Документы, являющиеся основанием расторжения
    контракта"(documents) справочника "Основания расторжения контракта"
    (nsiContractTerminationReason)"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'code': MemberSpec_('code', 'xs:string', 0, 1, {'minOccurs': '0', 'name': 'code', 'type': 'xs:string'}, None),
        'name': MemberSpec_('name', 'xs:string', 0, 1, {'minOccurs': '0', 'name': 'name', 'type': 'xs:string'}, None),
        'documentDate': MemberSpec_('documentDate', 'xs:date', 0, 0, {'name': 'documentDate', 'type': 'xs:date'}, None),
        'documentNum': MemberSpec_('documentNum', ['text100Type', 'xs:string'], 0, 0, {'name': 'documentNum', 'type': 'xs:string'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, code=None, name=None, documentDate=None, documentNum=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.code = code
        self.code_nsprefix_ = None
        self.name = name
        self.name_nsprefix_ = None
        if isinstance(documentDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(documentDate, '%Y-%m-%d').date()
        else:
            initvalue_ = documentDate
        self.documentDate = initvalue_
        self.documentDate_nsprefix_ = None
        self.documentNum = documentNum
        self.validate_text100Type(self.documentNum)
        self.documentNum_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, invalidationReasonDocument)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if invalidationReasonDocument.subclass:
            return invalidationReasonDocument.subclass(*args_, **kwargs_)
        else:
            return invalidationReasonDocument(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_text100Type(self, value):
        result = True
        # Validate type text100Type, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 100:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on text100Type' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on text100Type' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.code is not None or
            self.name is not None or
            self.documentDate is not None or
            self.documentNum is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'code':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'code')
            value_ = self.gds_validate_string(value_, node, 'code')
            self.code = value_
            self.code_nsprefix_ = child_.prefix
        elif nodeName_ == 'name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'name')
            value_ = self.gds_validate_string(value_, node, 'name')
            self.name = value_
            self.name_nsprefix_ = child_.prefix
        elif nodeName_ == 'documentDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.documentDate = dval_
            self.documentDate_nsprefix_ = child_.prefix
        elif nodeName_ == 'documentNum':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'documentNum')
            value_ = self.gds_validate_string(value_, node, 'documentNum')
            self.documentNum = value_
            self.documentNum_nsprefix_ = child_.prefix
            # validate type text100Type
            self.validate_text100Type(self.documentNum)
# end class invalidationReasonDocument


class penalties(GeneratedsSuper):
    """Информация о неустойках (штрафах, пени)"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'penaltyAccrual': MemberSpec_('penaltyAccrual', 'penaltyAccrual', 0, 0, {'name': 'penaltyAccrual', 'type': 'penaltyAccrual'}, None),
        'penaltyReturn': MemberSpec_('penaltyReturn', 'penaltyReturn', 0, 1, {'minOccurs': '0', 'name': 'penaltyReturn', 'type': 'penaltyReturn'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, penaltyAccrual=None, penaltyReturn=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.penaltyAccrual = penaltyAccrual
        self.penaltyAccrual_nsprefix_ = None
        self.penaltyReturn = penaltyReturn
        self.penaltyReturn_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, penalties)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if penalties.subclass:
            return penalties.subclass(*args_, **kwargs_)
        else:
            return penalties(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.penaltyAccrual is not None or
            self.penaltyReturn is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'penaltyAccrual':
            obj_ = penaltyAccrual.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.penaltyAccrual = obj_
            obj_.original_tagname_ = 'penaltyAccrual'
        elif nodeName_ == 'penaltyReturn':
            obj_ = penaltyReturn.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.penaltyReturn = obj_
            obj_.original_tagname_ = 'penaltyReturn'
# end class penalties


class penaltyAccrual(GeneratedsSuper):
    """Информация о начислении неустойки"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'contractParty': MemberSpec_('contractParty', ['contractPartyTypeEnum', 'xs:string'], 0, 0, {'name': 'contractParty', 'type': 'xs:string'}, None),
        'penaltyType': MemberSpec_('penaltyType', ['zfcs_contract2015PenaltyType', 'xs:string'], 0, 0, {'name': 'penaltyType', 'type': 'xs:string'}, None),
        'penaltyReason': MemberSpec_('penaltyReason', 'penaltyReason', 0, 0, {'name': 'penaltyReason', 'type': 'penaltyReason'}, None),
        'penaltyDocument': MemberSpec_('penaltyDocument', 'zfcs_contract2015.documentInfo', 0, 0, {'name': 'penaltyDocument', 'type': 'zfcs_contract2015.documentInfo'}, None),
        'accrualAmount': MemberSpec_('accrualAmount', ['moneyPositiveType', 'xs:string'], 0, 0, {'name': 'accrualAmount', 'type': 'xs:string'}, None),
        'currency': MemberSpec_('currency', 'zfcs_currencyRef', 0, 0, {'name': 'currency', 'type': 'zfcs_currencyRef'}, None),
        'currencyRate': MemberSpec_('currencyRate', 'zfcs_currencyRateContract2015', 0, 1, {'minOccurs': '0', 'name': 'currencyRate', 'type': 'zfcs_currencyRateContract2015'}, None),
        'accrualAmountRUR': MemberSpec_('accrualAmountRUR', ['moneyPositiveType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'accrualAmountRUR', 'type': 'xs:string'}, None),
        'payments': MemberSpec_('payments', 'payments', 0, 1, {'minOccurs': '0', 'name': 'payments', 'type': 'payments'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, contractParty=None, penaltyType=None, penaltyReason=None, penaltyDocument=None, accrualAmount=None, currency=None, currencyRate=None, accrualAmountRUR=None, payments=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.contractParty = contractParty
        self.validate_contractPartyTypeEnum(self.contractParty)
        self.contractParty_nsprefix_ = None
        self.penaltyType = penaltyType
        self.validate_zfcs_contract2015PenaltyType(self.penaltyType)
        self.penaltyType_nsprefix_ = None
        self.penaltyReason = penaltyReason
        self.penaltyReason_nsprefix_ = None
        self.penaltyDocument = penaltyDocument
        self.penaltyDocument_nsprefix_ = None
        self.accrualAmount = accrualAmount
        self.validate_moneyPositiveType(self.accrualAmount)
        self.accrualAmount_nsprefix_ = None
        self.currency = currency
        self.currency_nsprefix_ = None
        self.currencyRate = currencyRate
        self.currencyRate_nsprefix_ = None
        self.accrualAmountRUR = accrualAmountRUR
        self.validate_moneyPositiveType(self.accrualAmountRUR)
        self.accrualAmountRUR_nsprefix_ = None
        self.payments = payments
        self.payments_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, penaltyAccrual)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if penaltyAccrual.subclass:
            return penaltyAccrual.subclass(*args_, **kwargs_)
        else:
            return penaltyAccrual(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_contractPartyTypeEnum(self, value):
        result = True
        # Validate type contractPartyTypeEnum, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['C', 'S']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on contractPartyTypeEnum' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_zfcs_contract2015PenaltyType(self, value):
        result = True
        # Validate type zfcs_contract2015PenaltyType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['F', 'I']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on zfcs_contract2015PenaltyType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_moneyPositiveType(self, value):
        result = True
        # Validate type moneyPositiveType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 21:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on moneyPositiveType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on moneyPositiveType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_moneyPositiveType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_moneyPositiveType_patterns_, ))
                result = False
        return result
    validate_moneyPositiveType_patterns_ = [['^(\\d+(\\.\\d{1,2})?)$']]
    def hasContent_(self):
        if (
            self.contractParty is not None or
            self.penaltyType is not None or
            self.penaltyReason is not None or
            self.penaltyDocument is not None or
            self.accrualAmount is not None or
            self.currency is not None or
            self.currencyRate is not None or
            self.accrualAmountRUR is not None or
            self.payments is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'contractParty':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'contractParty')
            value_ = self.gds_validate_string(value_, node, 'contractParty')
            self.contractParty = value_
            self.contractParty_nsprefix_ = child_.prefix
            # validate type contractPartyTypeEnum
            self.validate_contractPartyTypeEnum(self.contractParty)
        elif nodeName_ == 'penaltyType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'penaltyType')
            value_ = self.gds_validate_string(value_, node, 'penaltyType')
            self.penaltyType = value_
            self.penaltyType_nsprefix_ = child_.prefix
            # validate type zfcs_contract2015PenaltyType
            self.validate_zfcs_contract2015PenaltyType(self.penaltyType)
        elif nodeName_ == 'penaltyReason':
            obj_ = penaltyReason.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.penaltyReason = obj_
            obj_.original_tagname_ = 'penaltyReason'
        elif nodeName_ == 'penaltyDocument':
            obj_ = zfcs_contract2015_documentInfo.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.penaltyDocument = obj_
            obj_.original_tagname_ = 'penaltyDocument'
        elif nodeName_ == 'accrualAmount':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'accrualAmount')
            value_ = self.gds_validate_string(value_, node, 'accrualAmount')
            self.accrualAmount = value_
            self.accrualAmount_nsprefix_ = child_.prefix
            # validate type moneyPositiveType
            self.validate_moneyPositiveType(self.accrualAmount)
        elif nodeName_ == 'currency':
            obj_ = zfcs_currencyRef.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.currency = obj_
            obj_.original_tagname_ = 'currency'
        elif nodeName_ == 'currencyRate':
            obj_ = zfcs_currencyRateContract2015.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.currencyRate = obj_
            obj_.original_tagname_ = 'currencyRate'
        elif nodeName_ == 'accrualAmountRUR':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'accrualAmountRUR')
            value_ = self.gds_validate_string(value_, node, 'accrualAmountRUR')
            self.accrualAmountRUR = value_
            self.accrualAmountRUR_nsprefix_ = child_.prefix
            # validate type moneyPositiveType
            self.validate_moneyPositiveType(self.accrualAmountRUR)
        elif nodeName_ == 'payments':
            obj_ = payments.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.payments = obj_
            obj_.original_tagname_ = 'payments'
# end class penaltyAccrual


class penaltyReason(GeneratedsSuper):
    """Причина начисления неустойки (штрафа, пени)"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'code': MemberSpec_('code', 'xs:string', 0, 0, {'name': 'code', 'type': 'xs:string'}, None),
        'name': MemberSpec_('name', 'xs:string', 0, 1, {'minOccurs': '0', 'name': 'name', 'type': 'xs:string'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, code=None, name=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.code = code
        self.code_nsprefix_ = None
        self.name = name
        self.name_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, penaltyReason)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if penaltyReason.subclass:
            return penaltyReason.subclass(*args_, **kwargs_)
        else:
            return penaltyReason(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.code is not None or
            self.name is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'code':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'code')
            value_ = self.gds_validate_string(value_, node, 'code')
            self.code = value_
            self.code_nsprefix_ = child_.prefix
        elif nodeName_ == 'name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'name')
            value_ = self.gds_validate_string(value_, node, 'name')
            self.name = value_
            self.name_nsprefix_ = child_.prefix
# end class penaltyReason


class penaltyReturn(GeneratedsSuper):
    """Информация о возврате излишне уплаченной неустойки"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'returnDocument': MemberSpec_('returnDocument', 'zfcs_contract2015.documentInfo', 0, 0, {'name': 'returnDocument', 'type': 'zfcs_contract2015.documentInfo'}, None),
        'accrualAmount': MemberSpec_('accrualAmount', ['moneyPositiveType', 'xs:string'], 0, 0, {'name': 'accrualAmount', 'type': 'xs:string'}, None),
        'currencyRate': MemberSpec_('currencyRate', 'zfcs_currencyRateContract2015', 0, 1, {'minOccurs': '0', 'name': 'currencyRate', 'type': 'zfcs_currencyRateContract2015'}, None),
        'accrualAmountRUR': MemberSpec_('accrualAmountRUR', ['moneyPositiveType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'accrualAmountRUR', 'type': 'xs:string'}, None),
        'payments': MemberSpec_('payments', 'payments', 0, 1, {'minOccurs': '0', 'name': 'payments', 'type': 'payments'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, returnDocument=None, accrualAmount=None, currencyRate=None, accrualAmountRUR=None, payments=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.returnDocument = returnDocument
        self.returnDocument_nsprefix_ = None
        self.accrualAmount = accrualAmount
        self.validate_moneyPositiveType(self.accrualAmount)
        self.accrualAmount_nsprefix_ = None
        self.currencyRate = currencyRate
        self.currencyRate_nsprefix_ = None
        self.accrualAmountRUR = accrualAmountRUR
        self.validate_moneyPositiveType(self.accrualAmountRUR)
        self.accrualAmountRUR_nsprefix_ = None
        self.payments = payments
        self.payments_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, penaltyReturn)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if penaltyReturn.subclass:
            return penaltyReturn.subclass(*args_, **kwargs_)
        else:
            return penaltyReturn(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_moneyPositiveType(self, value):
        result = True
        # Validate type moneyPositiveType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 21:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on moneyPositiveType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on moneyPositiveType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_moneyPositiveType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_moneyPositiveType_patterns_, ))
                result = False
        return result
    validate_moneyPositiveType_patterns_ = [['^(\\d+(\\.\\d{1,2})?)$']]
    def hasContent_(self):
        if (
            self.returnDocument is not None or
            self.accrualAmount is not None or
            self.currencyRate is not None or
            self.accrualAmountRUR is not None or
            self.payments is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'returnDocument':
            obj_ = zfcs_contract2015_documentInfo.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.returnDocument = obj_
            obj_.original_tagname_ = 'returnDocument'
        elif nodeName_ == 'accrualAmount':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'accrualAmount')
            value_ = self.gds_validate_string(value_, node, 'accrualAmount')
            self.accrualAmount = value_
            self.accrualAmount_nsprefix_ = child_.prefix
            # validate type moneyPositiveType
            self.validate_moneyPositiveType(self.accrualAmount)
        elif nodeName_ == 'currencyRate':
            obj_ = zfcs_currencyRateContract2015.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.currencyRate = obj_
            obj_.original_tagname_ = 'currencyRate'
        elif nodeName_ == 'accrualAmountRUR':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'accrualAmountRUR')
            value_ = self.gds_validate_string(value_, node, 'accrualAmountRUR')
            self.accrualAmountRUR = value_
            self.accrualAmountRUR_nsprefix_ = child_.prefix
            # validate type moneyPositiveType
            self.validate_moneyPositiveType(self.accrualAmountRUR)
        elif nodeName_ == 'payments':
            obj_ = payments.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.payments = obj_
            obj_.original_tagname_ = 'payments'
# end class penaltyReturn


class delayWriteOffPenalties(GeneratedsSuper):
    """Информация о предоставлении в 2015, 2016 и(или) 2020 году заказчиком
    отсрочек уплаты неустойки (штрафа, пени) и (или) осуществления списания
    начисленных сумм неустойки (штрафа, пени).
    Не может быть заполнен одновременно с executionObligationGuarantee"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'totalAmount': MemberSpec_('totalAmount', ['moneyPositiveType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'totalAmount', 'type': 'xs:string'}, None),
        'delayPenaltiesInProcent': MemberSpec_('delayPenaltiesInProcent', ['zfcs_valueType', 'xs:decimal'], 0, 1, {'minOccurs': '0', 'name': 'delayPenaltiesInProcent', 'type': 'xs:decimal'}, None),
        'delayPenalties': MemberSpec_('delayPenalties', 'delayPenalties', 0, 1, {'minOccurs': '0', 'name': 'delayPenalties', 'type': 'delayPenalties'}, None),
        'writeOffPenalties': MemberSpec_('writeOffPenalties', 'writeOffPenalties', 0, 1, {'minOccurs': '0', 'name': 'writeOffPenalties', 'type': 'writeOffPenalties'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, totalAmount=None, delayPenaltiesInProcent=None, delayPenalties=None, writeOffPenalties=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.totalAmount = totalAmount
        self.validate_moneyPositiveType(self.totalAmount)
        self.totalAmount_nsprefix_ = None
        self.delayPenaltiesInProcent = delayPenaltiesInProcent
        self.validate_zfcs_valueType(self.delayPenaltiesInProcent)
        self.delayPenaltiesInProcent_nsprefix_ = None
        self.delayPenalties = delayPenalties
        self.delayPenalties_nsprefix_ = None
        self.writeOffPenalties = writeOffPenalties
        self.writeOffPenalties_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, delayWriteOffPenalties)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if delayWriteOffPenalties.subclass:
            return delayWriteOffPenalties.subclass(*args_, **kwargs_)
        else:
            return delayWriteOffPenalties(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_moneyPositiveType(self, value):
        result = True
        # Validate type moneyPositiveType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 21:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on moneyPositiveType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on moneyPositiveType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_moneyPositiveType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_moneyPositiveType_patterns_, ))
                result = False
        return result
    validate_moneyPositiveType_patterns_ = [['^(\\d+(\\.\\d{1,2})?)$']]
    def validate_zfcs_valueType(self, value):
        result = True
        # Validate type zfcs_valueType, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, decimal_.Decimal):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (decimal_.Decimal)' % {"value": value, "lineno": lineno, })
                return False
            if len(str(value)) >= 5:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd totalDigits restriction on zfcs_valueType' % {"value": value, "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.totalAmount is not None or
            self.delayPenaltiesInProcent is not None or
            self.delayPenalties is not None or
            self.writeOffPenalties is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'totalAmount':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'totalAmount')
            value_ = self.gds_validate_string(value_, node, 'totalAmount')
            self.totalAmount = value_
            self.totalAmount_nsprefix_ = child_.prefix
            # validate type moneyPositiveType
            self.validate_moneyPositiveType(self.totalAmount)
        elif nodeName_ == 'delayPenaltiesInProcent' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'delayPenaltiesInProcent')
            fval_ = self.gds_validate_decimal(fval_, node, 'delayPenaltiesInProcent')
            self.delayPenaltiesInProcent = fval_
            self.delayPenaltiesInProcent_nsprefix_ = child_.prefix
            # validate type zfcs_valueType
            self.validate_zfcs_valueType(self.delayPenaltiesInProcent)
        elif nodeName_ == 'delayPenalties':
            obj_ = delayPenalties.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.delayPenalties = obj_
            obj_.original_tagname_ = 'delayPenalties'
        elif nodeName_ == 'writeOffPenalties':
            obj_ = writeOffPenalties.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.writeOffPenalties = obj_
            obj_.original_tagname_ = 'writeOffPenalties'
# end class delayWriteOffPenalties


class delayPenalties(GeneratedsSuper):
    """Информация о предоставлении отсрочки уплаты неустойки (штрафа, пени)"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'delayDate': MemberSpec_('delayDate', 'xs:date', 0, 0, {'name': 'delayDate', 'type': 'xs:date'}, None),
        'currency': MemberSpec_('currency', 'zfcs_currencyRef', 0, 0, {'name': 'currency', 'type': 'zfcs_currencyRef'}, None),
        'delayAmount': MemberSpec_('delayAmount', ['moneyPositiveType', 'xs:string'], 0, 0, {'name': 'delayAmount', 'type': 'xs:string'}, None),
        'currencyRate': MemberSpec_('currencyRate', 'zfcs_currencyRateContract2015', 0, 1, {'minOccurs': '0', 'name': 'currencyRate', 'type': 'zfcs_currencyRateContract2015'}, None),
        'delayAmountRUR': MemberSpec_('delayAmountRUR', ['moneyPositiveType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'delayAmountRUR', 'type': 'xs:string'}, None),
        'delayPeriod': MemberSpec_('delayPeriod', 'xs:date', 0, 1, {'minOccurs': '0', 'name': 'delayPeriod', 'type': 'xs:date'}, None),
        'noticeDetails': MemberSpec_('noticeDetails', 'noticeDetails', 0, 0, {'name': 'noticeDetails', 'type': 'noticeDetails'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, delayDate=None, currency=None, delayAmount=None, currencyRate=None, delayAmountRUR=None, delayPeriod=None, noticeDetails=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if isinstance(delayDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(delayDate, '%Y-%m-%d').date()
        else:
            initvalue_ = delayDate
        self.delayDate = initvalue_
        self.delayDate_nsprefix_ = None
        self.currency = currency
        self.currency_nsprefix_ = None
        self.delayAmount = delayAmount
        self.validate_moneyPositiveType(self.delayAmount)
        self.delayAmount_nsprefix_ = None
        self.currencyRate = currencyRate
        self.currencyRate_nsprefix_ = None
        self.delayAmountRUR = delayAmountRUR
        self.validate_moneyPositiveType(self.delayAmountRUR)
        self.delayAmountRUR_nsprefix_ = None
        if isinstance(delayPeriod, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(delayPeriod, '%Y-%m-%d').date()
        else:
            initvalue_ = delayPeriod
        self.delayPeriod = initvalue_
        self.delayPeriod_nsprefix_ = None
        self.noticeDetails = noticeDetails
        self.noticeDetails_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, delayPenalties)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if delayPenalties.subclass:
            return delayPenalties.subclass(*args_, **kwargs_)
        else:
            return delayPenalties(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_moneyPositiveType(self, value):
        result = True
        # Validate type moneyPositiveType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 21:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on moneyPositiveType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on moneyPositiveType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_moneyPositiveType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_moneyPositiveType_patterns_, ))
                result = False
        return result
    validate_moneyPositiveType_patterns_ = [['^(\\d+(\\.\\d{1,2})?)$']]
    def hasContent_(self):
        if (
            self.delayDate is not None or
            self.currency is not None or
            self.delayAmount is not None or
            self.currencyRate is not None or
            self.delayAmountRUR is not None or
            self.delayPeriod is not None or
            self.noticeDetails is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'delayDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.delayDate = dval_
            self.delayDate_nsprefix_ = child_.prefix
        elif nodeName_ == 'currency':
            obj_ = zfcs_currencyRef.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.currency = obj_
            obj_.original_tagname_ = 'currency'
        elif nodeName_ == 'delayAmount':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'delayAmount')
            value_ = self.gds_validate_string(value_, node, 'delayAmount')
            self.delayAmount = value_
            self.delayAmount_nsprefix_ = child_.prefix
            # validate type moneyPositiveType
            self.validate_moneyPositiveType(self.delayAmount)
        elif nodeName_ == 'currencyRate':
            obj_ = zfcs_currencyRateContract2015.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.currencyRate = obj_
            obj_.original_tagname_ = 'currencyRate'
        elif nodeName_ == 'delayAmountRUR':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'delayAmountRUR')
            value_ = self.gds_validate_string(value_, node, 'delayAmountRUR')
            self.delayAmountRUR = value_
            self.delayAmountRUR_nsprefix_ = child_.prefix
            # validate type moneyPositiveType
            self.validate_moneyPositiveType(self.delayAmountRUR)
        elif nodeName_ == 'delayPeriod':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.delayPeriod = dval_
            self.delayPeriod_nsprefix_ = child_.prefix
        elif nodeName_ == 'noticeDetails':
            obj_ = noticeDetails.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.noticeDetails = obj_
            obj_.original_tagname_ = 'noticeDetails'
# end class delayPenalties


class noticeDetails(GeneratedsSuper):
    """Реквизиты уведомления, направленного заказчиком поставщику (подрядчику,
    исполнителю) о предоставлении отсрочки уплаты неустойки (штрафа,
    пени)"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'documentNum': MemberSpec_('documentNum', ['documentNum', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'documentNum', 'type': 'xs:string'}, None),
        'documentDate': MemberSpec_('documentDate', 'xs:date', 0, 0, {'name': 'documentDate', 'type': 'xs:date'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, documentNum=None, documentDate=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.documentNum = documentNum
        self.documentNum_nsprefix_ = None
        if isinstance(documentDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(documentDate, '%Y-%m-%d').date()
        else:
            initvalue_ = documentDate
        self.documentDate = initvalue_
        self.documentDate_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, noticeDetails)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if noticeDetails.subclass:
            return noticeDetails.subclass(*args_, **kwargs_)
        else:
            return noticeDetails(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.documentNum is not None or
            self.documentDate is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'documentNum':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'documentNum')
            value_ = self.gds_validate_string(value_, node, 'documentNum')
            self.documentNum = value_
            self.documentNum_nsprefix_ = child_.prefix
        elif nodeName_ == 'documentDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.documentDate = dval_
            self.documentDate_nsprefix_ = child_.prefix
# end class noticeDetails


class writeOffPenalties(GeneratedsSuper):
    """Информация об осуществлении списания сумм неустойки (штрафа, пени)"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'writeOffDate': MemberSpec_('writeOffDate', 'xs:date', 0, 0, {'name': 'writeOffDate', 'type': 'xs:date'}, None),
        'currency': MemberSpec_('currency', 'zfcs_currencyRef', 0, 0, {'name': 'currency', 'type': 'zfcs_currencyRef'}, None),
        'writeOffAmount': MemberSpec_('writeOffAmount', ['moneyPositiveType', 'xs:string'], 0, 0, {'name': 'writeOffAmount', 'type': 'xs:string'}, None),
        'currencyRate': MemberSpec_('currencyRate', 'zfcs_currencyRateContract2015', 0, 1, {'minOccurs': '0', 'name': 'currencyRate', 'type': 'zfcs_currencyRateContract2015'}, None),
        'writeOffAmountRUR': MemberSpec_('writeOffAmountRUR', ['moneyPositiveType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'writeOffAmountRUR', 'type': 'xs:string'}, None),
        'noticeDetails': MemberSpec_('noticeDetails', 'noticeDetails', 0, 0, {'name': 'noticeDetails', 'type': 'noticeDetails'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, writeOffDate=None, currency=None, writeOffAmount=None, currencyRate=None, writeOffAmountRUR=None, noticeDetails=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if isinstance(writeOffDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(writeOffDate, '%Y-%m-%d').date()
        else:
            initvalue_ = writeOffDate
        self.writeOffDate = initvalue_
        self.writeOffDate_nsprefix_ = None
        self.currency = currency
        self.currency_nsprefix_ = None
        self.writeOffAmount = writeOffAmount
        self.validate_moneyPositiveType(self.writeOffAmount)
        self.writeOffAmount_nsprefix_ = None
        self.currencyRate = currencyRate
        self.currencyRate_nsprefix_ = None
        self.writeOffAmountRUR = writeOffAmountRUR
        self.validate_moneyPositiveType(self.writeOffAmountRUR)
        self.writeOffAmountRUR_nsprefix_ = None
        self.noticeDetails = noticeDetails
        self.noticeDetails_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, writeOffPenalties)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if writeOffPenalties.subclass:
            return writeOffPenalties.subclass(*args_, **kwargs_)
        else:
            return writeOffPenalties(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_moneyPositiveType(self, value):
        result = True
        # Validate type moneyPositiveType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 21:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on moneyPositiveType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on moneyPositiveType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_moneyPositiveType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_moneyPositiveType_patterns_, ))
                result = False
        return result
    validate_moneyPositiveType_patterns_ = [['^(\\d+(\\.\\d{1,2})?)$']]
    def hasContent_(self):
        if (
            self.writeOffDate is not None or
            self.currency is not None or
            self.writeOffAmount is not None or
            self.currencyRate is not None or
            self.writeOffAmountRUR is not None or
            self.noticeDetails is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'writeOffDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.writeOffDate = dval_
            self.writeOffDate_nsprefix_ = child_.prefix
        elif nodeName_ == 'currency':
            obj_ = zfcs_currencyRef.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.currency = obj_
            obj_.original_tagname_ = 'currency'
        elif nodeName_ == 'writeOffAmount':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'writeOffAmount')
            value_ = self.gds_validate_string(value_, node, 'writeOffAmount')
            self.writeOffAmount = value_
            self.writeOffAmount_nsprefix_ = child_.prefix
            # validate type moneyPositiveType
            self.validate_moneyPositiveType(self.writeOffAmount)
        elif nodeName_ == 'currencyRate':
            obj_ = zfcs_currencyRateContract2015.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.currencyRate = obj_
            obj_.original_tagname_ = 'currencyRate'
        elif nodeName_ == 'writeOffAmountRUR':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'writeOffAmountRUR')
            value_ = self.gds_validate_string(value_, node, 'writeOffAmountRUR')
            self.writeOffAmountRUR = value_
            self.writeOffAmountRUR_nsprefix_ = child_.prefix
            # validate type moneyPositiveType
            self.validate_moneyPositiveType(self.writeOffAmountRUR)
        elif nodeName_ == 'noticeDetails':
            obj_ = noticeDetails.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.noticeDetails = obj_
            obj_.original_tagname_ = 'noticeDetails'
# end class writeOffPenalties


class zfcs_contractProcedureCancel2015Type(GeneratedsSuper):
    """Сведения об отмене информации об исполнении контракта (расторжении
    контракта, признании контракта недействительным) с 01.01.2015Отмена
    информации об исполнении (расторжении) контрактаВерсия схемы"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'schemeVersion': MemberSpec_('schemeVersion', 'base:schemeVersionType', 0, 0, {'use': 'required'}),
        'cancelledProcedureId': MemberSpec_('cancelledProcedureId', ['cancelledProcedureId', 'xs:long'], 0, 0, {'name': 'cancelledProcedureId', 'type': 'xs:long'}, None),
        'regNum': MemberSpec_('regNum', 'xs:string', 0, 0, {'name': 'regNum', 'type': 'xs:string'}, None),
        'placer': MemberSpec_('placer', 'placer', 0, 1, {'minOccurs': '0', 'name': 'placer', 'type': 'placer'}, None),
        'cancelDate': MemberSpec_('cancelDate', 'xs:dateTime', 0, 0, {'name': 'cancelDate', 'type': 'xs:dateTime'}, 41),
        'reason': MemberSpec_('reason', ['zfcs_longTextMinType', 'xs:string'], 0, 0, {'name': 'reason', 'type': 'xs:string'}, 41),
        'contractInvalidationCancel': MemberSpec_('contractInvalidationCancel', 'contractInvalidationCancel', 0, 0, {'name': 'contractInvalidationCancel', 'type': 'contractInvalidationCancel'}, 41),
        'extPrintForm': MemberSpec_('extPrintForm', 'xs:string', 0, 1, {'minOccurs': '0', 'name': 'extPrintForm', 'type': 'xs:string'}, None),
        'currentContractStage': MemberSpec_('currentContractStage', 'xs:string', 0, 1, {'minOccurs': '0', 'name': 'currentContractStage', 'type': 'xs:string'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, schemeVersion=None, cancelledProcedureId=None, regNum=None, placer=None, cancelDate=None, reason=None, contractInvalidationCancel=None, extPrintForm=None, currentContractStage=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.schemeVersion = _cast(None, schemeVersion)
        self.schemeVersion_nsprefix_ = None
        self.cancelledProcedureId = cancelledProcedureId
        self.cancelledProcedureId_nsprefix_ = None
        self.regNum = regNum
        self.regNum_nsprefix_ = None
        self.placer = placer
        self.placer_nsprefix_ = None
        if isinstance(cancelDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(cancelDate, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = cancelDate
        self.cancelDate = initvalue_
        self.cancelDate_nsprefix_ = None
        self.reason = reason
        self.validate_zfcs_longTextMinType(self.reason)
        self.reason_nsprefix_ = None
        self.contractInvalidationCancel = contractInvalidationCancel
        self.contractInvalidationCancel_nsprefix_ = None
        self.extPrintForm = extPrintForm
        self.extPrintForm_nsprefix_ = None
        self.currentContractStage = currentContractStage
        self.currentContractStage_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, zfcs_contractProcedureCancel2015Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if zfcs_contractProcedureCancel2015Type.subclass:
            return zfcs_contractProcedureCancel2015Type.subclass(*args_, **kwargs_)
        else:
            return zfcs_contractProcedureCancel2015Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_zfcs_longTextMinType(self, value):
        result = True
        # Validate type zfcs_longTextMinType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 2000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on zfcs_longTextMinType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on zfcs_longTextMinType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_schemeVersionType(self, value):
        # Validate type base:schemeVersionType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['1.0', '4.1', '4.2', '4.3', '4.3.100', '4.4', '4.4.2', '4.5', '4.6', '5.0', '5.1', '5.2', '6.0', '6.1', '6.2', '6.2.100', '6.3', '6.4', '7.0', '7.1', '7.2', '7.3', '7.5', '8.0', '8.1', '8.2', '8.2.100', '8.3', '9.0', '9.1', '9.2', '9.3', '10.0', '10.1', '10.2', '10.2.310', '10.3', '11.0']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on schemeVersionType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            self.cancelledProcedureId is not None or
            self.regNum is not None or
            self.placer is not None or
            self.cancelDate is not None or
            self.reason is not None or
            self.contractInvalidationCancel is not None or
            self.extPrintForm is not None or
            self.currentContractStage is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('schemeVersion', node)
        if value is not None and 'schemeVersion' not in already_processed:
            already_processed.add('schemeVersion')
            self.schemeVersion = value
            self.validate_schemeVersionType(self.schemeVersion)    # validate type schemeVersionType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'cancelledProcedureId' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'cancelledProcedureId')
            ival_ = self.gds_validate_integer(ival_, node, 'cancelledProcedureId')
            self.cancelledProcedureId = ival_
            self.cancelledProcedureId_nsprefix_ = child_.prefix
        elif nodeName_ == 'regNum':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'regNum')
            value_ = self.gds_validate_string(value_, node, 'regNum')
            self.regNum = value_
            self.regNum_nsprefix_ = child_.prefix
        elif nodeName_ == 'placer':
            obj_ = placer.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.placer = obj_
            obj_.original_tagname_ = 'placer'
        elif nodeName_ == 'cancelDate':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.cancelDate = dval_
            self.cancelDate_nsprefix_ = child_.prefix
        elif nodeName_ == 'reason':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'reason')
            value_ = self.gds_validate_string(value_, node, 'reason')
            self.reason = value_
            self.reason_nsprefix_ = child_.prefix
            # validate type zfcs_longTextMinType
            self.validate_zfcs_longTextMinType(self.reason)
        elif nodeName_ == 'contractInvalidationCancel':
            obj_ = contractInvalidationCancel.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.contractInvalidationCancel = obj_
            obj_.original_tagname_ = 'contractInvalidationCancel'
        elif nodeName_ == 'extPrintForm':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'extPrintForm')
            value_ = self.gds_validate_string(value_, node, 'extPrintForm')
            self.extPrintForm = value_
            self.extPrintForm_nsprefix_ = child_.prefix
        elif nodeName_ == 'currentContractStage':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'currentContractStage')
            value_ = self.gds_validate_string(value_, node, 'currentContractStage')
            self.currentContractStage = value_
            self.currentContractStage_nsprefix_ = child_.prefix
# end class zfcs_contractProcedureCancel2015Type


class cancelledProcedureId(GeneratedsSuper):
    """Идентификатор отменяемой информации об исполнении (расторжении
    контракта, признании контракта недействительным) контракта"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, cancelledProcedureId)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if cancelledProcedureId.subclass:
            return cancelledProcedureId.subclass(*args_, **kwargs_)
        else:
            return cancelledProcedureId(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_cancelledProcedureId(self, value):
        result = True
        # Validate type cancelledProcedureId, a restriction on xs:long.
        pass
        return result
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class cancelledProcedureId


class contractInvalidationCancel(GeneratedsSuper):
    """Отмена информации о признании судом контракта недействительным"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'cancelReason': MemberSpec_('cancelReason', 'cancelReason', 0, 0, {'name': 'cancelReason', 'type': 'cancelReason'}, 41),
        'receiptDocuments': MemberSpec_('receiptDocuments', 'xs:string', 0, 0, {'name': 'receiptDocuments', 'type': 'xs:string'}, 41),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, cancelReason=None, receiptDocuments=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.cancelReason = cancelReason
        self.cancelReason_nsprefix_ = None
        self.receiptDocuments = receiptDocuments
        self.receiptDocuments_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, contractInvalidationCancel)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if contractInvalidationCancel.subclass:
            return contractInvalidationCancel.subclass(*args_, **kwargs_)
        else:
            return contractInvalidationCancel(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.cancelReason is not None or
            self.receiptDocuments is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'cancelReason':
            obj_ = cancelReason.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.cancelReason = obj_
            obj_.original_tagname_ = 'cancelReason'
        elif nodeName_ == 'receiptDocuments':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'receiptDocuments')
            value_ = self.gds_validate_string(value_, node, 'receiptDocuments')
            self.receiptDocuments = value_
            self.receiptDocuments_nsprefix_ = child_.prefix
# end class contractInvalidationCancel


class cancelReason(GeneratedsSuper):
    """Основание отмены признания контракта недействительным"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'courtName': MemberSpec_('courtName', ['zfcs_longTextMinType', 'xs:string'], 0, 0, {'name': 'courtName', 'type': 'xs:string'}, 41),
        'docName': MemberSpec_('docName', ['text1000Type', 'xs:string'], 0, 0, {'name': 'docName', 'type': 'xs:string'}, 41),
        'docDate': MemberSpec_('docDate', 'xs:date', 0, 0, {'name': 'docDate', 'type': 'xs:date'}, 41),
        'docNumber': MemberSpec_('docNumber', ['text100Type', 'xs:string'], 0, 0, {'name': 'docNumber', 'type': 'xs:string'}, 41),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, courtName=None, docName=None, docDate=None, docNumber=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.courtName = courtName
        self.validate_zfcs_longTextMinType(self.courtName)
        self.courtName_nsprefix_ = None
        self.docName = docName
        self.validate_text1000Type(self.docName)
        self.docName_nsprefix_ = None
        if isinstance(docDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(docDate, '%Y-%m-%d').date()
        else:
            initvalue_ = docDate
        self.docDate = initvalue_
        self.docDate_nsprefix_ = None
        self.docNumber = docNumber
        self.validate_text100Type(self.docNumber)
        self.docNumber_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, cancelReason)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if cancelReason.subclass:
            return cancelReason.subclass(*args_, **kwargs_)
        else:
            return cancelReason(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_zfcs_longTextMinType(self, value):
        result = True
        # Validate type zfcs_longTextMinType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 2000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on zfcs_longTextMinType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on zfcs_longTextMinType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_text1000Type(self, value):
        result = True
        # Validate type text1000Type, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on text1000Type' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on text1000Type' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_text100Type(self, value):
        result = True
        # Validate type text100Type, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 100:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on text100Type' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on text100Type' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.courtName is not None or
            self.docName is not None or
            self.docDate is not None or
            self.docNumber is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'courtName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'courtName')
            value_ = self.gds_validate_string(value_, node, 'courtName')
            self.courtName = value_
            self.courtName_nsprefix_ = child_.prefix
            # validate type zfcs_longTextMinType
            self.validate_zfcs_longTextMinType(self.courtName)
        elif nodeName_ == 'docName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'docName')
            value_ = self.gds_validate_string(value_, node, 'docName')
            self.docName = value_
            self.docName_nsprefix_ = child_.prefix
            # validate type text1000Type
            self.validate_text1000Type(self.docName)
        elif nodeName_ == 'docDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.docDate = dval_
            self.docDate_nsprefix_ = child_.prefix
        elif nodeName_ == 'docNumber':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'docNumber')
            value_ = self.gds_validate_string(value_, node, 'docNumber')
            self.docNumber = value_
            self.docNumber_nsprefix_ = child_.prefix
            # validate type text100Type
            self.validate_text100Type(self.docNumber)
# end class cancelReason


class zfcs_contractCancel2015Type(GeneratedsSuper):
    """Информация об аннулировании контракта с 01.01.2015Версия схемы"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'schemeVersion': MemberSpec_('schemeVersion', 'base:schemeVersionType', 0, 0, {'use': 'required'}),
        'regNum': MemberSpec_('regNum', 'xs:string', 0, 0, {'name': 'regNum', 'type': 'xs:string'}, None),
        'cancelDate': MemberSpec_('cancelDate', 'xs:dateTime', 0, 0, {'name': 'cancelDate', 'type': 'xs:dateTime'}, None),
        'publishDate': MemberSpec_('publishDate', 'xs:dateTime', 0, 1, {'minOccurs': '0', 'name': 'publishDate', 'type': 'xs:dateTime'}, None),
        'documentBase': MemberSpec_('documentBase', ['zfcs_longTextMinType', 'xs:string'], 0, 0, {'name': 'documentBase', 'type': 'xs:string'}, None),
        'currentContractStage': MemberSpec_('currentContractStage', 'xs:string', 0, 1, {'minOccurs': '0', 'name': 'currentContractStage', 'type': 'xs:string'}, None),
        'contractPrintFormInfo': MemberSpec_('contractPrintFormInfo', 'contractPrintFormInfo', 0, 1, {'minOccurs': '0', 'name': 'contractPrintFormInfo', 'type': 'contractPrintFormInfo'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, schemeVersion=None, regNum=None, cancelDate=None, publishDate=None, documentBase=None, currentContractStage=None, contractPrintFormInfo=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.schemeVersion = _cast(None, schemeVersion)
        self.schemeVersion_nsprefix_ = None
        self.regNum = regNum
        self.regNum_nsprefix_ = None
        if isinstance(cancelDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(cancelDate, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = cancelDate
        self.cancelDate = initvalue_
        self.cancelDate_nsprefix_ = None
        if isinstance(publishDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(publishDate, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = publishDate
        self.publishDate = initvalue_
        self.publishDate_nsprefix_ = None
        self.documentBase = documentBase
        self.validate_zfcs_longTextMinType(self.documentBase)
        self.documentBase_nsprefix_ = None
        self.currentContractStage = currentContractStage
        self.currentContractStage_nsprefix_ = None
        self.contractPrintFormInfo = contractPrintFormInfo
        self.contractPrintFormInfo_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, zfcs_contractCancel2015Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if zfcs_contractCancel2015Type.subclass:
            return zfcs_contractCancel2015Type.subclass(*args_, **kwargs_)
        else:
            return zfcs_contractCancel2015Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_zfcs_longTextMinType(self, value):
        result = True
        # Validate type zfcs_longTextMinType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 2000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on zfcs_longTextMinType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on zfcs_longTextMinType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_schemeVersionType(self, value):
        # Validate type base:schemeVersionType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['1.0', '4.1', '4.2', '4.3', '4.3.100', '4.4', '4.4.2', '4.5', '4.6', '5.0', '5.1', '5.2', '6.0', '6.1', '6.2', '6.2.100', '6.3', '6.4', '7.0', '7.1', '7.2', '7.3', '7.5', '8.0', '8.1', '8.2', '8.2.100', '8.3', '9.0', '9.1', '9.2', '9.3', '10.0', '10.1', '10.2', '10.2.310', '10.3', '11.0']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on schemeVersionType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            self.regNum is not None or
            self.cancelDate is not None or
            self.publishDate is not None or
            self.documentBase is not None or
            self.currentContractStage is not None or
            self.contractPrintFormInfo is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('schemeVersion', node)
        if value is not None and 'schemeVersion' not in already_processed:
            already_processed.add('schemeVersion')
            self.schemeVersion = value
            self.validate_schemeVersionType(self.schemeVersion)    # validate type schemeVersionType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'regNum':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'regNum')
            value_ = self.gds_validate_string(value_, node, 'regNum')
            self.regNum = value_
            self.regNum_nsprefix_ = child_.prefix
        elif nodeName_ == 'cancelDate':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.cancelDate = dval_
            self.cancelDate_nsprefix_ = child_.prefix
        elif nodeName_ == 'publishDate':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.publishDate = dval_
            self.publishDate_nsprefix_ = child_.prefix
        elif nodeName_ == 'documentBase':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'documentBase')
            value_ = self.gds_validate_string(value_, node, 'documentBase')
            self.documentBase = value_
            self.documentBase_nsprefix_ = child_.prefix
            # validate type zfcs_longTextMinType
            self.validate_zfcs_longTextMinType(self.documentBase)
        elif nodeName_ == 'currentContractStage':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'currentContractStage')
            value_ = self.gds_validate_string(value_, node, 'currentContractStage')
            self.currentContractStage = value_
            self.currentContractStage_nsprefix_ = child_.prefix
        elif nodeName_ == 'contractPrintFormInfo':
            obj_ = contractPrintFormInfo.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.contractPrintFormInfo = obj_
            obj_.original_tagname_ = 'contractPrintFormInfo'
# end class zfcs_contractCancel2015Type


class contractPrintFormInfo(GeneratedsSuper):
    """Информация о контракте (для печатной формы)"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'number': MemberSpec_('number', ['zfcs_contract.Number2015Type', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'number', 'type': 'xs:string'}, None),
        'signDate': MemberSpec_('signDate', 'xs:date', 0, 1, {'minOccurs': '0', 'name': 'signDate', 'type': 'xs:date'}, None),
        'customer': MemberSpec_('customer', 'zfcs_organizationRef', 0, 1, {'minOccurs': '0', 'name': 'customer', 'type': 'customer'}, None),
        'signName': MemberSpec_('signName', ['zfcs_longTextType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'signName', 'type': 'xs:string'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, number=None, signDate=None, customer=None, signName=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.number = number
        self.validate_zfcs_contract_Number2015Type(self.number)
        self.number_nsprefix_ = None
        if isinstance(signDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(signDate, '%Y-%m-%d').date()
        else:
            initvalue_ = signDate
        self.signDate = initvalue_
        self.signDate_nsprefix_ = None
        self.customer = customer
        self.customer_nsprefix_ = None
        self.signName = signName
        self.validate_zfcs_longTextType(self.signName)
        self.signName_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, contractPrintFormInfo)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if contractPrintFormInfo.subclass:
            return contractPrintFormInfo.subclass(*args_, **kwargs_)
        else:
            return contractPrintFormInfo(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_zfcs_contract_Number2015Type(self, value):
        result = True
        # Validate type zfcs_contract.Number2015Type, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 100:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on zfcs_contract.Number2015Type' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on zfcs_contract.Number2015Type' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_zfcs_longTextType(self, value):
        result = True
        # Validate type zfcs_longTextType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 2000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on zfcs_longTextType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.number is not None or
            self.signDate is not None or
            self.customer is not None or
            self.signName is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'number':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'number')
            value_ = self.gds_validate_string(value_, node, 'number')
            self.number = value_
            self.number_nsprefix_ = child_.prefix
            # validate type zfcs_contract.Number2015Type
            self.validate_zfcs_contract_Number2015Type(self.number)
        elif nodeName_ == 'signDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.signDate = dval_
            self.signDate_nsprefix_ = child_.prefix
        elif nodeName_ == 'customer':
            obj_ = customer.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.customer = obj_
            obj_.original_tagname_ = 'customer'
        elif nodeName_ == 'signName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'signName')
            value_ = self.gds_validate_string(value_, node, 'signName')
            self.signName = value_
            self.signName_nsprefix_ = child_.prefix
            # validate type zfcs_longTextType
            self.validate_zfcs_longTextType(self.signName)
# end class contractPrintFormInfo


class zfcs_contractAvailableForElAct(GeneratedsSuper):
    """Квитанция о доступности формирования документов электронного актирования
    по контрактуВерсия схемы"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'schemeVersion': MemberSpec_('schemeVersion', 'base:schemeVersionType', 0, 0, {'use': 'required'}),
        'id': MemberSpec_('id', 'xs:long', 0, 0, {'name': 'id', 'type': 'xs:long'}, None),
        'regNum': MemberSpec_('regNum', ['zfcs_contract.regNum2015Type', 'xs:string'], 0, 0, {'name': 'regNum', 'type': 'xs:string'}, None),
        'isAvailable': MemberSpec_('isAvailable', 'xs:boolean', 0, 0, {'fixed': 'true', 'name': 'isAvailable', 'type': 'xs:boolean'}, None),
        'availableDT': MemberSpec_('availableDT', 'xs:dateTime', 0, 0, {'name': 'availableDT', 'type': 'xs:dateTime'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, schemeVersion=None, id=None, regNum=None, isAvailable=None, availableDT=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.schemeVersion = _cast(None, schemeVersion)
        self.schemeVersion_nsprefix_ = None
        self.id = id
        self.id_nsprefix_ = None
        self.regNum = regNum
        self.validate_zfcs_contract_regNum2015Type(self.regNum)
        self.regNum_nsprefix_ = None
        self.isAvailable = isAvailable
        self.isAvailable_nsprefix_ = None
        if isinstance(availableDT, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(availableDT, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = availableDT
        self.availableDT = initvalue_
        self.availableDT_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, zfcs_contractAvailableForElAct)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if zfcs_contractAvailableForElAct.subclass:
            return zfcs_contractAvailableForElAct.subclass(*args_, **kwargs_)
        else:
            return zfcs_contractAvailableForElAct(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_zfcs_contract_regNum2015Type(self, value):
        result = True
        # Validate type zfcs_contract.regNum2015Type, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 19:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on zfcs_contract.regNum2015Type' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on zfcs_contract.regNum2015Type' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_schemeVersionType(self, value):
        # Validate type base:schemeVersionType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['1.0', '4.1', '4.2', '4.3', '4.3.100', '4.4', '4.4.2', '4.5', '4.6', '5.0', '5.1', '5.2', '6.0', '6.1', '6.2', '6.2.100', '6.3', '6.4', '7.0', '7.1', '7.2', '7.3', '7.5', '8.0', '8.1', '8.2', '8.2.100', '8.3', '9.0', '9.1', '9.2', '9.3', '10.0', '10.1', '10.2', '10.2.310', '10.3', '11.0']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on schemeVersionType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            self.id is not None or
            self.regNum is not None or
            self.isAvailable is not None or
            self.availableDT is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('schemeVersion', node)
        if value is not None and 'schemeVersion' not in already_processed:
            already_processed.add('schemeVersion')
            self.schemeVersion = value
            self.validate_schemeVersionType(self.schemeVersion)    # validate type schemeVersionType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'id' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'id')
            ival_ = self.gds_validate_integer(ival_, node, 'id')
            self.id = ival_
            self.id_nsprefix_ = child_.prefix
        elif nodeName_ == 'regNum':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'regNum')
            value_ = self.gds_validate_string(value_, node, 'regNum')
            self.regNum = value_
            self.regNum_nsprefix_ = child_.prefix
            # validate type zfcs_contract.regNum2015Type
            self.validate_zfcs_contract_regNum2015Type(self.regNum)
        elif nodeName_ == 'isAvailable':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'isAvailable')
            ival_ = self.gds_validate_boolean(ival_, node, 'isAvailable')
            self.isAvailable = ival_
            self.isAvailable_nsprefix_ = child_.prefix
        elif nodeName_ == 'availableDT':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.availableDT = dval_
            self.availableDT_nsprefix_ = child_.prefix
# end class zfcs_contractAvailableForElAct


class zfcs_contract2015SupplierType(GeneratedsSuper):
    """Поставщик в информации о контракте с 01.01.01.2015"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'legalEntityRF': MemberSpec_('legalEntityRF', 'legalEntityRF', 0, 0, {'name': 'legalEntityRF', 'type': 'corr_supplierLegalEntityRF'}, 42),
        'legalEntityForeignState': MemberSpec_('legalEntityForeignState', 'corr_supplierLegalEntityForeignState', 0, 0, {'name': 'legalEntityForeignState', 'type': 'corr_supplierLegalEntityForeignState'}, 42),
        'individualPersonRF': MemberSpec_('individualPersonRF', 'corr_supplierIndividualPersonRF', 0, 0, {'name': 'individualPersonRF', 'type': 'corr_supplierIndividualPersonRF'}, 42),
        'individualPersonForeignState': MemberSpec_('individualPersonForeignState', 'corr_supplierIndividualPersonForeignState', 0, 0, {'name': 'individualPersonForeignState', 'type': 'corr_supplierIndividualPersonForeignState'}, 42),
        'individualPersonRFisCulture': MemberSpec_('individualPersonRFisCulture', 'individualPersonRFisCulture', 0, 0, {'name': 'individualPersonRFisCulture', 'type': 'individualPersonRFisCulture'}, 42),
        'individualPersonForeignStateisCulture': MemberSpec_('individualPersonForeignStateisCulture', 'individualPersonForeignStateisCulture', 0, 0, {'name': 'individualPersonForeignStateisCulture', 'type': 'individualPersonForeignStateisCulture'}, 42),
        'notPublishedOnEIS': MemberSpec_('notPublishedOnEIS', 'xs:boolean', 0, 0, {'fixed': 'true', 'name': 'notPublishedOnEIS', 'type': 'xs:boolean'}, 42),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, legalEntityRF=None, legalEntityForeignState=None, individualPersonRF=None, individualPersonForeignState=None, individualPersonRFisCulture=None, individualPersonForeignStateisCulture=None, notPublishedOnEIS=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.legalEntityRF = legalEntityRF
        self.legalEntityRF_nsprefix_ = None
        self.legalEntityForeignState = legalEntityForeignState
        self.legalEntityForeignState_nsprefix_ = None
        self.individualPersonRF = individualPersonRF
        self.individualPersonRF_nsprefix_ = None
        self.individualPersonForeignState = individualPersonForeignState
        self.individualPersonForeignState_nsprefix_ = None
        self.individualPersonRFisCulture = individualPersonRFisCulture
        self.individualPersonRFisCulture_nsprefix_ = None
        self.individualPersonForeignStateisCulture = individualPersonForeignStateisCulture
        self.individualPersonForeignStateisCulture_nsprefix_ = None
        self.notPublishedOnEIS = notPublishedOnEIS
        self.notPublishedOnEIS_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, zfcs_contract2015SupplierType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if zfcs_contract2015SupplierType.subclass:
            return zfcs_contract2015SupplierType.subclass(*args_, **kwargs_)
        else:
            return zfcs_contract2015SupplierType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.legalEntityRF is not None or
            self.legalEntityForeignState is not None or
            self.individualPersonRF is not None or
            self.individualPersonForeignState is not None or
            self.individualPersonRFisCulture is not None or
            self.individualPersonForeignStateisCulture is not None or
            self.notPublishedOnEIS is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'legalEntityRF':
            obj_ = corr_supplierLegalEntityRF.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.legalEntityRF = obj_
            obj_.original_tagname_ = 'legalEntityRF'
        elif nodeName_ == 'legalEntityForeignState':
            obj_ = corr_supplierLegalEntityForeignState.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.legalEntityForeignState = obj_
            obj_.original_tagname_ = 'legalEntityForeignState'
        elif nodeName_ == 'individualPersonRF':
            obj_ = corr_supplierIndividualPersonRF.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.individualPersonRF = obj_
            obj_.original_tagname_ = 'individualPersonRF'
        elif nodeName_ == 'individualPersonForeignState':
            obj_ = corr_supplierIndividualPersonForeignState.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.individualPersonForeignState = obj_
            obj_.original_tagname_ = 'individualPersonForeignState'
        elif nodeName_ == 'individualPersonRFisCulture':
            obj_ = individualPersonRFisCulture.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.individualPersonRFisCulture = obj_
            obj_.original_tagname_ = 'individualPersonRFisCulture'
        elif nodeName_ == 'individualPersonForeignStateisCulture':
            obj_ = individualPersonForeignStateisCulture.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.individualPersonForeignStateisCulture = obj_
            obj_.original_tagname_ = 'individualPersonForeignStateisCulture'
        elif nodeName_ == 'notPublishedOnEIS':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'notPublishedOnEIS')
            ival_ = self.gds_validate_boolean(ival_, node, 'notPublishedOnEIS')
            self.notPublishedOnEIS = ival_
            self.notPublishedOnEIS_nsprefix_ = child_.prefix
# end class zfcs_contract2015SupplierType


class individualPersonRFisCulture(GeneratedsSuper):
    """Физическое лицо РФ. Поставщик культурных ценностей"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'lastName': MemberSpec_('lastName', ['lastName', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'lastName', 'type': 'xs:string'}, 42),
        'firstName': MemberSpec_('firstName', ['firstName', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'firstName', 'type': 'xs:string'}, 42),
        'middleName': MemberSpec_('middleName', ['middleName', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'middleName', 'type': 'xs:string'}, 42),
        'INN': MemberSpec_('INN', ['innType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'INN', 'type': 'xs:string'}, 42),
        'isIP': MemberSpec_('isIP', 'xs:boolean', 0, 1, {'minOccurs': '0', 'name': 'isIP', 'type': 'xs:boolean'}, 42),
        'registrationDate': MemberSpec_('registrationDate', 'xs:date', 0, 1, {'minOccurs': '0', 'name': 'registrationDate', 'type': 'xs:date'}, 42),
        'status': MemberSpec_('status', ['zfcs_participantStatusContract2015Type', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'status', 'type': 'xs:string'}, 42),
        'ERSMSPInclusionDate': MemberSpec_('ERSMSPInclusionDate', 'xs:date', 0, 1, {'minOccurs': '0', 'name': 'ERSMSPInclusionDate', 'type': 'xs:date'}, 42),
        'OKTMO': MemberSpec_('OKTMO', 'zfcs_OKTMORef', 0, 1, {'minOccurs': '0', 'name': 'OKTMO', 'type': 'zfcs_OKTMORef'}, 42),
        'personalAccount': MemberSpec_('personalAccount', ['zfcs_personalAccountType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'personalAccount', 'type': 'xs:string'}, 42),
        'address': MemberSpec_('address', ['zfcs_contract2015AddressType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'address', 'type': 'xs:string'}, 42),
        'postAddressInfo': MemberSpec_('postAddressInfo', 'postAddressInfo', 0, 1, {'minOccurs': '0', 'name': 'postAddressInfo', 'type': 'postAddressInfo'}, 42),
        'postAddress': MemberSpec_('postAddress', ['zfcs_contract2015AddressType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'postAddress', 'type': 'xs:string'}, 42),
        'contactEMail': MemberSpec_('contactEMail', ['eMailType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'contactEMail', 'type': 'xs:string'}, 42),
        'contactPhone': MemberSpec_('contactPhone', ['phoneType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'contactPhone', 'type': 'xs:string'}, 42),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, lastName=None, firstName=None, middleName=None, INN=None, isIP=None, registrationDate=None, status=None, ERSMSPInclusionDate=None, OKTMO=None, personalAccount=None, address=None, postAddressInfo=None, postAddress=None, contactEMail=None, contactPhone=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.lastName = lastName
        self.lastName_nsprefix_ = None
        self.firstName = firstName
        self.firstName_nsprefix_ = None
        self.middleName = middleName
        self.middleName_nsprefix_ = None
        self.INN = INN
        self.validate_innType(self.INN)
        self.INN_nsprefix_ = None
        self.isIP = isIP
        self.isIP_nsprefix_ = None
        if isinstance(registrationDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(registrationDate, '%Y-%m-%d').date()
        else:
            initvalue_ = registrationDate
        self.registrationDate = initvalue_
        self.registrationDate_nsprefix_ = None
        self.status = status
        self.validate_zfcs_participantStatusContract2015Type(self.status)
        self.status_nsprefix_ = None
        if isinstance(ERSMSPInclusionDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(ERSMSPInclusionDate, '%Y-%m-%d').date()
        else:
            initvalue_ = ERSMSPInclusionDate
        self.ERSMSPInclusionDate = initvalue_
        self.ERSMSPInclusionDate_nsprefix_ = None
        self.OKTMO = OKTMO
        self.OKTMO_nsprefix_ = None
        self.personalAccount = personalAccount
        self.validate_zfcs_personalAccountType(self.personalAccount)
        self.personalAccount_nsprefix_ = None
        self.address = address
        self.validate_zfcs_contract2015AddressType(self.address)
        self.address_nsprefix_ = None
        self.postAddressInfo = postAddressInfo
        self.postAddressInfo_nsprefix_ = None
        self.postAddress = postAddress
        self.validate_zfcs_contract2015AddressType(self.postAddress)
        self.postAddress_nsprefix_ = None
        self.contactEMail = contactEMail
        self.validate_eMailType(self.contactEMail)
        self.contactEMail_nsprefix_ = None
        self.contactPhone = contactPhone
        self.validate_phoneType(self.contactPhone)
        self.contactPhone_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, individualPersonRFisCulture)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if individualPersonRFisCulture.subclass:
            return individualPersonRFisCulture.subclass(*args_, **kwargs_)
        else:
            return individualPersonRFisCulture(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_innType(self, value):
        result = True
        # Validate type innType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 12:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on innType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_innType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_innType_patterns_, ))
                result = False
        return result
    validate_innType_patterns_ = [['^(\\d{1,12})$']]
    def validate_zfcs_participantStatusContract2015Type(self, value):
        result = True
        # Validate type zfcs_participantStatusContract2015Type, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['10', '20', '30', '31', '40', '41']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on zfcs_participantStatusContract2015Type' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_zfcs_personalAccountType(self, value):
        result = True
        # Validate type zfcs_personalAccountType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) != 11:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd length restriction on zfcs_personalAccountType' % {"value": encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_zfcs_contract2015AddressType(self, value):
        result = True
        # Validate type zfcs_contract2015AddressType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on zfcs_contract2015AddressType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on zfcs_contract2015AddressType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_eMailType(self, value):
        result = True
        # Validate type eMailType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 256:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on eMailType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on eMailType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_phoneType(self, value):
        result = True
        # Validate type phoneType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 30:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on phoneType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on phoneType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.lastName is not None or
            self.firstName is not None or
            self.middleName is not None or
            self.INN is not None or
            self.isIP is not None or
            self.registrationDate is not None or
            self.status is not None or
            self.ERSMSPInclusionDate is not None or
            self.OKTMO is not None or
            self.personalAccount is not None or
            self.address is not None or
            self.postAddressInfo is not None or
            self.postAddress is not None or
            self.contactEMail is not None or
            self.contactPhone is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'lastName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'lastName')
            value_ = self.gds_validate_string(value_, node, 'lastName')
            self.lastName = value_
            self.lastName_nsprefix_ = child_.prefix
        elif nodeName_ == 'firstName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'firstName')
            value_ = self.gds_validate_string(value_, node, 'firstName')
            self.firstName = value_
            self.firstName_nsprefix_ = child_.prefix
        elif nodeName_ == 'middleName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'middleName')
            value_ = self.gds_validate_string(value_, node, 'middleName')
            self.middleName = value_
            self.middleName_nsprefix_ = child_.prefix
        elif nodeName_ == 'INN':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'INN')
            value_ = self.gds_validate_string(value_, node, 'INN')
            self.INN = value_
            self.INN_nsprefix_ = child_.prefix
            # validate type innType
            self.validate_innType(self.INN)
        elif nodeName_ == 'isIP':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'isIP')
            ival_ = self.gds_validate_boolean(ival_, node, 'isIP')
            self.isIP = ival_
            self.isIP_nsprefix_ = child_.prefix
        elif nodeName_ == 'registrationDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.registrationDate = dval_
            self.registrationDate_nsprefix_ = child_.prefix
        elif nodeName_ == 'status':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'status')
            value_ = self.gds_validate_string(value_, node, 'status')
            self.status = value_
            self.status_nsprefix_ = child_.prefix
            # validate type zfcs_participantStatusContract2015Type
            self.validate_zfcs_participantStatusContract2015Type(self.status)
        elif nodeName_ == 'ERSMSPInclusionDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.ERSMSPInclusionDate = dval_
            self.ERSMSPInclusionDate_nsprefix_ = child_.prefix
        elif nodeName_ == 'OKTMO':
            obj_ = zfcs_OKTMORef.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.OKTMO = obj_
            obj_.original_tagname_ = 'OKTMO'
        elif nodeName_ == 'personalAccount':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'personalAccount')
            value_ = self.gds_validate_string(value_, node, 'personalAccount')
            self.personalAccount = value_
            self.personalAccount_nsprefix_ = child_.prefix
            # validate type zfcs_personalAccountType
            self.validate_zfcs_personalAccountType(self.personalAccount)
        elif nodeName_ == 'address':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'address')
            value_ = self.gds_validate_string(value_, node, 'address')
            self.address = value_
            self.address_nsprefix_ = child_.prefix
            # validate type zfcs_contract2015AddressType
            self.validate_zfcs_contract2015AddressType(self.address)
        elif nodeName_ == 'postAddressInfo':
            obj_ = postAddressInfo.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.postAddressInfo = obj_
            obj_.original_tagname_ = 'postAddressInfo'
        elif nodeName_ == 'postAddress':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'postAddress')
            value_ = self.gds_validate_string(value_, node, 'postAddress')
            self.postAddress = value_
            self.postAddress_nsprefix_ = child_.prefix
            # validate type zfcs_contract2015AddressType
            self.validate_zfcs_contract2015AddressType(self.postAddress)
        elif nodeName_ == 'contactEMail':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'contactEMail')
            value_ = self.gds_validate_string(value_, node, 'contactEMail')
            self.contactEMail = value_
            self.contactEMail_nsprefix_ = child_.prefix
            # validate type eMailType
            self.validate_eMailType(self.contactEMail)
        elif nodeName_ == 'contactPhone':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'contactPhone')
            value_ = self.gds_validate_string(value_, node, 'contactPhone')
            self.contactPhone = value_
            self.contactPhone_nsprefix_ = child_.prefix
            # validate type phoneType
            self.validate_phoneType(self.contactPhone)
# end class individualPersonRFisCulture


class individualPersonForeignStateisCulture(GeneratedsSuper):
    """Физическое лицо иностранного государства. Поставщик культурных
    ценностей"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'lastName': MemberSpec_('lastName', ['lastName', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'lastName', 'type': 'xs:string'}, 42),
        'firstName': MemberSpec_('firstName', ['firstName', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'firstName', 'type': 'xs:string'}, 42),
        'middleName': MemberSpec_('middleName', ['middleName', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'middleName', 'type': 'xs:string'}, 42),
        'lastNameLat': MemberSpec_('lastNameLat', ['lastNameLat', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'lastNameLat', 'type': 'xs:string'}, 42),
        'firstNameLat': MemberSpec_('firstNameLat', ['firstNameLat', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'firstNameLat', 'type': 'xs:string'}, 42),
        'middleNameLat': MemberSpec_('middleNameLat', ['middleNameLat', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'middleNameLat', 'type': 'xs:string'}, 42),
        'taxPayerCode': MemberSpec_('taxPayerCode', ['taxPayerCode', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'taxPayerCode', 'type': 'xs:string'}, 42),
        'personalAccount': MemberSpec_('personalAccount', ['zfcs_personalAccountType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'personalAccount', 'type': 'xs:string'}, 42),
        'registerInRFTaxBodies': MemberSpec_('registerInRFTaxBodies', 'registerInRFTaxBodies', 0, 1, {'minOccurs': '0', 'name': 'registerInRFTaxBodies', 'type': 'registerInRFTaxBodies'}, 42),
        'placeOfStayInRegCountry': MemberSpec_('placeOfStayInRegCountry', 'placeOfStayInRegCountry', 0, 1, {'minOccurs': '0', 'name': 'placeOfStayInRegCountry', 'type': 'placeOfStayInRegCountry'}, 42),
        'placeOfStayInRF': MemberSpec_('placeOfStayInRF', 'placeOfStayInRF', 0, 1, {'minOccurs': '0', 'name': 'placeOfStayInRF', 'type': 'placeOfStayInRF'}, 42),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, lastName=None, firstName=None, middleName=None, lastNameLat=None, firstNameLat=None, middleNameLat=None, taxPayerCode=None, personalAccount=None, registerInRFTaxBodies=None, placeOfStayInRegCountry=None, placeOfStayInRF=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.lastName = lastName
        self.lastName_nsprefix_ = None
        self.firstName = firstName
        self.firstName_nsprefix_ = None
        self.middleName = middleName
        self.middleName_nsprefix_ = None
        self.lastNameLat = lastNameLat
        self.lastNameLat_nsprefix_ = None
        self.firstNameLat = firstNameLat
        self.firstNameLat_nsprefix_ = None
        self.middleNameLat = middleNameLat
        self.middleNameLat_nsprefix_ = None
        self.taxPayerCode = taxPayerCode
        self.taxPayerCode_nsprefix_ = None
        self.personalAccount = personalAccount
        self.validate_zfcs_personalAccountType(self.personalAccount)
        self.personalAccount_nsprefix_ = None
        self.registerInRFTaxBodies = registerInRFTaxBodies
        self.registerInRFTaxBodies_nsprefix_ = None
        self.placeOfStayInRegCountry = placeOfStayInRegCountry
        self.placeOfStayInRegCountry_nsprefix_ = None
        self.placeOfStayInRF = placeOfStayInRF
        self.placeOfStayInRF_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, individualPersonForeignStateisCulture)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if individualPersonForeignStateisCulture.subclass:
            return individualPersonForeignStateisCulture.subclass(*args_, **kwargs_)
        else:
            return individualPersonForeignStateisCulture(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_zfcs_personalAccountType(self, value):
        result = True
        # Validate type zfcs_personalAccountType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) != 11:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd length restriction on zfcs_personalAccountType' % {"value": encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.lastName is not None or
            self.firstName is not None or
            self.middleName is not None or
            self.lastNameLat is not None or
            self.firstNameLat is not None or
            self.middleNameLat is not None or
            self.taxPayerCode is not None or
            self.personalAccount is not None or
            self.registerInRFTaxBodies is not None or
            self.placeOfStayInRegCountry is not None or
            self.placeOfStayInRF is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'lastName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'lastName')
            value_ = self.gds_validate_string(value_, node, 'lastName')
            self.lastName = value_
            self.lastName_nsprefix_ = child_.prefix
        elif nodeName_ == 'firstName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'firstName')
            value_ = self.gds_validate_string(value_, node, 'firstName')
            self.firstName = value_
            self.firstName_nsprefix_ = child_.prefix
        elif nodeName_ == 'middleName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'middleName')
            value_ = self.gds_validate_string(value_, node, 'middleName')
            self.middleName = value_
            self.middleName_nsprefix_ = child_.prefix
        elif nodeName_ == 'lastNameLat':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'lastNameLat')
            value_ = self.gds_validate_string(value_, node, 'lastNameLat')
            self.lastNameLat = value_
            self.lastNameLat_nsprefix_ = child_.prefix
        elif nodeName_ == 'firstNameLat':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'firstNameLat')
            value_ = self.gds_validate_string(value_, node, 'firstNameLat')
            self.firstNameLat = value_
            self.firstNameLat_nsprefix_ = child_.prefix
        elif nodeName_ == 'middleNameLat':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'middleNameLat')
            value_ = self.gds_validate_string(value_, node, 'middleNameLat')
            self.middleNameLat = value_
            self.middleNameLat_nsprefix_ = child_.prefix
        elif nodeName_ == 'taxPayerCode':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'taxPayerCode')
            value_ = self.gds_validate_string(value_, node, 'taxPayerCode')
            self.taxPayerCode = value_
            self.taxPayerCode_nsprefix_ = child_.prefix
        elif nodeName_ == 'personalAccount':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'personalAccount')
            value_ = self.gds_validate_string(value_, node, 'personalAccount')
            self.personalAccount = value_
            self.personalAccount_nsprefix_ = child_.prefix
            # validate type zfcs_personalAccountType
            self.validate_zfcs_personalAccountType(self.personalAccount)
        elif nodeName_ == 'registerInRFTaxBodies':
            obj_ = registerInRFTaxBodies.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.registerInRFTaxBodies = obj_
            obj_.original_tagname_ = 'registerInRFTaxBodies'
        elif nodeName_ == 'placeOfStayInRegCountry':
            obj_ = placeOfStayInRegCountry.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.placeOfStayInRegCountry = obj_
            obj_.original_tagname_ = 'placeOfStayInRegCountry'
        elif nodeName_ == 'placeOfStayInRF':
            obj_ = placeOfStayInRF.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.placeOfStayInRF = obj_
            obj_.original_tagname_ = 'placeOfStayInRF'
# end class individualPersonForeignStateisCulture


class zfcs_contract2015SingleCustomerType(GeneratedsSuper):
    """Единственный поставщик в информации о контракте с 01.01.01.2015"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'reason': MemberSpec_('reason', 'reason', 0, 0, {'name': 'reason', 'type': 'reason'}, None),
        'document': MemberSpec_('document', 'document', 0, 1, {'minOccurs': '0', 'name': 'document', 'type': 'document'}, None),
        'reportBase': MemberSpec_('reportBase', ['zfcs_longTextMinType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'reportBase', 'type': 'xs:string'}, None),
        'reportCode': MemberSpec_('reportCode', ['reportCode', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'reportCode', 'type': 'xs:string'}, None),
        'attachments': MemberSpec_('attachments', 'xs:string', 0, 1, {'minOccurs': '0', 'name': 'attachments', 'type': 'xs:string'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_) + ['extensiontype_']
    subclass = None
    superclass = None
    def __init__(self, reason=None, document=None, reportBase=None, reportCode=None, attachments=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.reason = reason
        self.reason_nsprefix_ = None
        self.document = document
        self.document_nsprefix_ = None
        self.reportBase = reportBase
        self.validate_zfcs_longTextMinType(self.reportBase)
        self.reportBase_nsprefix_ = None
        self.reportCode = reportCode
        self.reportCode_nsprefix_ = None
        self.attachments = attachments
        self.attachments_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, zfcs_contract2015SingleCustomerType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if zfcs_contract2015SingleCustomerType.subclass:
            return zfcs_contract2015SingleCustomerType.subclass(*args_, **kwargs_)
        else:
            return zfcs_contract2015SingleCustomerType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_zfcs_longTextMinType(self, value):
        result = True
        # Validate type zfcs_longTextMinType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 2000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on zfcs_longTextMinType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on zfcs_longTextMinType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.reason is not None or
            self.document is not None or
            self.reportBase is not None or
            self.reportCode is not None or
            self.attachments is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'reason':
            obj_ = reason.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.reason = obj_
            obj_.original_tagname_ = 'reason'
        elif nodeName_ == 'document':
            obj_ = document.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.document = obj_
            obj_.original_tagname_ = 'document'
        elif nodeName_ == 'reportBase':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'reportBase')
            value_ = self.gds_validate_string(value_, node, 'reportBase')
            self.reportBase = value_
            self.reportBase_nsprefix_ = child_.prefix
            # validate type zfcs_longTextMinType
            self.validate_zfcs_longTextMinType(self.reportBase)
        elif nodeName_ == 'reportCode':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'reportCode')
            value_ = self.gds_validate_string(value_, node, 'reportCode')
            self.reportCode = value_
            self.reportCode_nsprefix_ = child_.prefix
        elif nodeName_ == 'attachments':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'attachments')
            value_ = self.gds_validate_string(value_, node, 'attachments')
            self.attachments = value_
            self.attachments_nsprefix_ = child_.prefix
# end class zfcs_contract2015SingleCustomerType


class reportCode(GeneratedsSuper):
    """Код отчета (для печатной формы)"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, reportCode)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if reportCode.subclass:
            return reportCode.subclass(*args_, **kwargs_)
        else:
            return reportCode(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_reportCode(self, value):
        result = True
        # Validate type reportCode, a restriction on xs:string.
        pass
        return result
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class reportCode


class zfcs_contract2015_documentInfo(GeneratedsSuper):
    """Документ в сведениях о контракте с 01.01.2015"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'documentName': MemberSpec_('documentName', ['documentName', 'xs:string'], 0, 0, {'name': 'documentName', 'type': 'xs:string'}, None),
        'documentNum': MemberSpec_('documentNum', ['documentNum', 'xs:string'], 0, 0, {'name': 'documentNum', 'type': 'xs:string'}, None),
        'documentDate': MemberSpec_('documentDate', 'xs:date', 0, 0, {'name': 'documentDate', 'type': 'xs:date'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_) + ['extensiontype_']
    subclass = None
    superclass = None
    def __init__(self, documentName=None, documentNum=None, documentDate=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.documentName = documentName
        self.documentName_nsprefix_ = None
        self.documentNum = documentNum
        self.documentNum_nsprefix_ = None
        if isinstance(documentDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(documentDate, '%Y-%m-%d').date()
        else:
            initvalue_ = documentDate
        self.documentDate = initvalue_
        self.documentDate_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, zfcs_contract2015_documentInfo)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if zfcs_contract2015_documentInfo.subclass:
            return zfcs_contract2015_documentInfo.subclass(*args_, **kwargs_)
        else:
            return zfcs_contract2015_documentInfo(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.documentName is not None or
            self.documentNum is not None or
            self.documentDate is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'documentName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'documentName')
            value_ = self.gds_validate_string(value_, node, 'documentName')
            self.documentName = value_
            self.documentName_nsprefix_ = child_.prefix
        elif nodeName_ == 'documentNum':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'documentNum')
            value_ = self.gds_validate_string(value_, node, 'documentNum')
            self.documentNum = value_
            self.documentNum_nsprefix_ = child_.prefix
        elif nodeName_ == 'documentDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.documentDate = dval_
            self.documentDate_nsprefix_ = child_.prefix
# end class zfcs_contract2015_documentInfo


class zfcs_contract2015_payDocInfo(GeneratedsSuper):
    """Оплата в сведениях о контракте с 01.01.2015"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'documentName': MemberSpec_('documentName', ['documentName', 'xs:string'], 0, 0, {'name': 'documentName', 'type': 'xs:string'}, None),
        'documentNum': MemberSpec_('documentNum', ['documentNum', 'xs:string'], 0, 0, {'name': 'documentNum', 'type': 'xs:string'}, None),
        'documentDate': MemberSpec_('documentDate', 'xs:date', 0, 0, {'name': 'documentDate', 'type': 'xs:date'}, None),
        'amount': MemberSpec_('amount', ['moneyType', 'xs:string'], 0, 0, {'name': 'amount', 'type': 'xs:string'}, None),
        'amountRUR': MemberSpec_('amountRUR', ['moneyType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'amountRUR', 'type': 'xs:string'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, documentName=None, documentNum=None, documentDate=None, amount=None, amountRUR=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.documentName = documentName
        self.documentName_nsprefix_ = None
        self.documentNum = documentNum
        self.documentNum_nsprefix_ = None
        if isinstance(documentDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(documentDate, '%Y-%m-%d').date()
        else:
            initvalue_ = documentDate
        self.documentDate = initvalue_
        self.documentDate_nsprefix_ = None
        self.amount = amount
        self.validate_moneyType(self.amount)
        self.amount_nsprefix_ = None
        self.amountRUR = amountRUR
        self.validate_moneyType(self.amountRUR)
        self.amountRUR_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, zfcs_contract2015_payDocInfo)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if zfcs_contract2015_payDocInfo.subclass:
            return zfcs_contract2015_payDocInfo.subclass(*args_, **kwargs_)
        else:
            return zfcs_contract2015_payDocInfo(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_moneyType(self, value):
        result = True
        # Validate type moneyType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 21:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on moneyType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on moneyType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_moneyType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_moneyType_patterns_, ))
                result = False
        return result
    validate_moneyType_patterns_ = [['^((-)?\\d+(\\.\\d{1,2})?)$']]
    def hasContent_(self):
        if (
            self.documentName is not None or
            self.documentNum is not None or
            self.documentDate is not None or
            self.amount is not None or
            self.amountRUR is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'documentName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'documentName')
            value_ = self.gds_validate_string(value_, node, 'documentName')
            self.documentName = value_
            self.documentName_nsprefix_ = child_.prefix
        elif nodeName_ == 'documentNum':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'documentNum')
            value_ = self.gds_validate_string(value_, node, 'documentNum')
            self.documentNum = value_
            self.documentNum_nsprefix_ = child_.prefix
        elif nodeName_ == 'documentDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.documentDate = dval_
            self.documentDate_nsprefix_ = child_.prefix
        elif nodeName_ == 'amount':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'amount')
            value_ = self.gds_validate_string(value_, node, 'amount')
            self.amount = value_
            self.amount_nsprefix_ = child_.prefix
            # validate type moneyType
            self.validate_moneyType(self.amount)
        elif nodeName_ == 'amountRUR':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'amountRUR')
            value_ = self.gds_validate_string(value_, node, 'amountRUR')
            self.amountRUR = value_
            self.amountRUR_nsprefix_ = child_.prefix
            # validate type moneyType
            self.validate_moneyType(self.amountRUR)
# end class zfcs_contract2015_payDocInfo


class zfcs_contract2015_DocDictRef(GeneratedsSuper):
    """Ссылка на документ в справочнике в сведениях о контракте с 01.01.2015"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'code': MemberSpec_('code', ['code', 'xs:string'], 0, 0, {'name': 'code', 'type': 'xs:string'}, None),
        'name': MemberSpec_('name', ['name', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'name', 'type': 'xs:string'}, None),
        'documentDate': MemberSpec_('documentDate', 'xs:date', 0, 0, {'name': 'documentDate', 'type': 'xs:date'}, None),
        'documentNum': MemberSpec_('documentNum', ['documentNum', 'xs:string'], 0, 0, {'name': 'documentNum', 'type': 'xs:string'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, code=None, name=None, documentDate=None, documentNum=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.code = code
        self.code_nsprefix_ = None
        self.name = name
        self.name_nsprefix_ = None
        if isinstance(documentDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(documentDate, '%Y-%m-%d').date()
        else:
            initvalue_ = documentDate
        self.documentDate = initvalue_
        self.documentDate_nsprefix_ = None
        self.documentNum = documentNum
        self.documentNum_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, zfcs_contract2015_DocDictRef)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if zfcs_contract2015_DocDictRef.subclass:
            return zfcs_contract2015_DocDictRef.subclass(*args_, **kwargs_)
        else:
            return zfcs_contract2015_DocDictRef(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.code is not None or
            self.name is not None or
            self.documentDate is not None or
            self.documentNum is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'code':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'code')
            value_ = self.gds_validate_string(value_, node, 'code')
            self.code = value_
            self.code_nsprefix_ = child_.prefix
        elif nodeName_ == 'name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'name')
            value_ = self.gds_validate_string(value_, node, 'name')
            self.name = value_
            self.name_nsprefix_ = child_.prefix
        elif nodeName_ == 'documentDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.documentDate = dval_
            self.documentDate_nsprefix_ = child_.prefix
        elif nodeName_ == 'documentNum':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'documentNum')
            value_ = self.gds_validate_string(value_, node, 'documentNum')
            self.documentNum = value_
            self.documentNum_nsprefix_ = child_.prefix
# end class zfcs_contract2015_DocDictRef


class zfcs_contractProcedure2015BankGuaranteeTerminationType(GeneratedsSuper):
    """Информация о прекращении обязательств поставщика, обеспеченных
    банковской гарантией"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'regNumber': MemberSpec_('regNumber', ['bankGuaranteeRegNumberType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'regNumber', 'type': 'xs:string'}, 43),
        'docNumber': MemberSpec_('docNumber', ['bankGuaranteeDocNumberType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'docNumber', 'type': 'xs:string'}, 43),
        'terminationDate': MemberSpec_('terminationDate', 'xs:date', 0, 0, {'name': 'terminationDate', 'type': 'xs:date'}, 43),
        'terminationReason': MemberSpec_('terminationReason', ['zfcs_longTextMinType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'terminationReason', 'type': 'xs:string'}, 43),
        'notPublishedOnEIS': MemberSpec_('notPublishedOnEIS', 'xs:boolean', 0, 0, {'fixed': 'true', 'name': 'notPublishedOnEIS', 'type': 'xs:boolean'}, 43),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, regNumber=None, docNumber=None, terminationDate=None, terminationReason=None, notPublishedOnEIS=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.regNumber = regNumber
        self.validate_bankGuaranteeRegNumberType(self.regNumber)
        self.regNumber_nsprefix_ = None
        self.docNumber = docNumber
        self.validate_bankGuaranteeDocNumberType(self.docNumber)
        self.docNumber_nsprefix_ = None
        if isinstance(terminationDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(terminationDate, '%Y-%m-%d').date()
        else:
            initvalue_ = terminationDate
        self.terminationDate = initvalue_
        self.terminationDate_nsprefix_ = None
        self.terminationReason = terminationReason
        self.validate_zfcs_longTextMinType(self.terminationReason)
        self.terminationReason_nsprefix_ = None
        self.notPublishedOnEIS = notPublishedOnEIS
        self.notPublishedOnEIS_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, zfcs_contractProcedure2015BankGuaranteeTerminationType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if zfcs_contractProcedure2015BankGuaranteeTerminationType.subclass:
            return zfcs_contractProcedure2015BankGuaranteeTerminationType.subclass(*args_, **kwargs_)
        else:
            return zfcs_contractProcedure2015BankGuaranteeTerminationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_bankGuaranteeRegNumberType(self, value):
        result = True
        # Validate type bankGuaranteeRegNumberType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 20:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on bankGuaranteeRegNumberType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on bankGuaranteeRegNumberType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_bankGuaranteeDocNumberType(self, value):
        result = True
        # Validate type bankGuaranteeDocNumberType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 23:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on bankGuaranteeDocNumberType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on bankGuaranteeDocNumberType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_zfcs_longTextMinType(self, value):
        result = True
        # Validate type zfcs_longTextMinType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 2000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on zfcs_longTextMinType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on zfcs_longTextMinType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.regNumber is not None or
            self.docNumber is not None or
            self.terminationDate is not None or
            self.terminationReason is not None or
            self.notPublishedOnEIS is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'regNumber':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'regNumber')
            value_ = self.gds_validate_string(value_, node, 'regNumber')
            self.regNumber = value_
            self.regNumber_nsprefix_ = child_.prefix
            # validate type bankGuaranteeRegNumberType
            self.validate_bankGuaranteeRegNumberType(self.regNumber)
        elif nodeName_ == 'docNumber':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'docNumber')
            value_ = self.gds_validate_string(value_, node, 'docNumber')
            self.docNumber = value_
            self.docNumber_nsprefix_ = child_.prefix
            # validate type bankGuaranteeDocNumberType
            self.validate_bankGuaranteeDocNumberType(self.docNumber)
        elif nodeName_ == 'terminationDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.terminationDate = dval_
            self.terminationDate_nsprefix_ = child_.prefix
        elif nodeName_ == 'terminationReason':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'terminationReason')
            value_ = self.gds_validate_string(value_, node, 'terminationReason')
            self.terminationReason = value_
            self.terminationReason_nsprefix_ = child_.prefix
            # validate type zfcs_longTextMinType
            self.validate_zfcs_longTextMinType(self.terminationReason)
        elif nodeName_ == 'notPublishedOnEIS':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'notPublishedOnEIS')
            ival_ = self.gds_validate_boolean(ival_, node, 'notPublishedOnEIS')
            self.notPublishedOnEIS = ival_
            self.notPublishedOnEIS_nsprefix_ = child_.prefix
# end class zfcs_contractProcedure2015BankGuaranteeTerminationType


class zfcs_contract2015BankGuaranteeReturnType(GeneratedsSuper):
    """Информация о возвращении банковской гарантии или уведомление об
    освобождении от обязательств по банковской гарантии"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'guaranteeReturn': MemberSpec_('guaranteeReturn', 'guaranteeReturn', 1, 0, {'maxOccurs': 'unbounded', 'name': 'guaranteeReturn', 'type': 'guaranteeReturn'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, guaranteeReturn=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if guaranteeReturn is None:
            self.guaranteeReturn = []
        else:
            self.guaranteeReturn = guaranteeReturn
        self.guaranteeReturn_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, zfcs_contract2015BankGuaranteeReturnType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if zfcs_contract2015BankGuaranteeReturnType.subclass:
            return zfcs_contract2015BankGuaranteeReturnType.subclass(*args_, **kwargs_)
        else:
            return zfcs_contract2015BankGuaranteeReturnType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.guaranteeReturn
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'guaranteeReturn':
            obj_ = guaranteeReturn.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.guaranteeReturn.append(obj_)
            obj_.original_tagname_ = 'guaranteeReturn'
# end class zfcs_contract2015BankGuaranteeReturnType


class guaranteeReturn(GeneratedsSuper):
    """Информация"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'bankGuaranteeReturn': MemberSpec_('bankGuaranteeReturn', 'bankGuaranteeReturn', 0, 0, {'name': 'bankGuaranteeReturn', 'type': 'bankGuaranteeReturn'}, 44),
        'waiverNotice': MemberSpec_('waiverNotice', 'waiverNotice', 0, 0, {'name': 'waiverNotice', 'type': 'waiverNotice'}, 44),
        'notPublishedOnEIS': MemberSpec_('notPublishedOnEIS', 'xs:boolean', 0, 0, {'fixed': 'true', 'name': 'notPublishedOnEIS', 'type': 'xs:boolean'}, 44),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, bankGuaranteeReturn=None, waiverNotice=None, notPublishedOnEIS=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.bankGuaranteeReturn = bankGuaranteeReturn
        self.bankGuaranteeReturn_nsprefix_ = None
        self.waiverNotice = waiverNotice
        self.waiverNotice_nsprefix_ = None
        self.notPublishedOnEIS = notPublishedOnEIS
        self.notPublishedOnEIS_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, guaranteeReturn)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if guaranteeReturn.subclass:
            return guaranteeReturn.subclass(*args_, **kwargs_)
        else:
            return guaranteeReturn(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.bankGuaranteeReturn is not None or
            self.waiverNotice is not None or
            self.notPublishedOnEIS is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'bankGuaranteeReturn':
            obj_ = bankGuaranteeReturn.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.bankGuaranteeReturn = obj_
            obj_.original_tagname_ = 'bankGuaranteeReturn'
        elif nodeName_ == 'waiverNotice':
            obj_ = waiverNotice.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.waiverNotice = obj_
            obj_.original_tagname_ = 'waiverNotice'
        elif nodeName_ == 'notPublishedOnEIS':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'notPublishedOnEIS')
            ival_ = self.gds_validate_boolean(ival_, node, 'notPublishedOnEIS')
            self.notPublishedOnEIS = ival_
            self.notPublishedOnEIS_nsprefix_ = child_.prefix
# end class guaranteeReturn


class bankGuaranteeReturn(GeneratedsSuper):
    """Информация о возвращении заказчиком банковской гарантии гаранту"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'regNumber': MemberSpec_('regNumber', ['bankGuaranteeRegNumberType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'regNumber', 'type': 'xs:string'}, 44),
        'docNumber': MemberSpec_('docNumber', ['bankGuaranteeDocNumberType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'docNumber', 'type': 'xs:string'}, 44),
        'returnDate': MemberSpec_('returnDate', 'xs:date', 0, 0, {'name': 'returnDate', 'type': 'xs:date'}, 44),
        'returnReason': MemberSpec_('returnReason', ['zfcs_longTextMinType', 'xs:string'], 0, 0, {'name': 'returnReason', 'type': 'xs:string'}, 44),
        'returnPublishDate': MemberSpec_('returnPublishDate', 'xs:dateTime', 0, 1, {'minOccurs': '0', 'name': 'returnPublishDate', 'type': 'xs:dateTime'}, 44),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, regNumber=None, docNumber=None, returnDate=None, returnReason=None, returnPublishDate=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.regNumber = regNumber
        self.validate_bankGuaranteeRegNumberType(self.regNumber)
        self.regNumber_nsprefix_ = None
        self.docNumber = docNumber
        self.validate_bankGuaranteeDocNumberType(self.docNumber)
        self.docNumber_nsprefix_ = None
        if isinstance(returnDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(returnDate, '%Y-%m-%d').date()
        else:
            initvalue_ = returnDate
        self.returnDate = initvalue_
        self.returnDate_nsprefix_ = None
        self.returnReason = returnReason
        self.validate_zfcs_longTextMinType(self.returnReason)
        self.returnReason_nsprefix_ = None
        if isinstance(returnPublishDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(returnPublishDate, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = returnPublishDate
        self.returnPublishDate = initvalue_
        self.returnPublishDate_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, bankGuaranteeReturn)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if bankGuaranteeReturn.subclass:
            return bankGuaranteeReturn.subclass(*args_, **kwargs_)
        else:
            return bankGuaranteeReturn(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_bankGuaranteeRegNumberType(self, value):
        result = True
        # Validate type bankGuaranteeRegNumberType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 20:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on bankGuaranteeRegNumberType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on bankGuaranteeRegNumberType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_bankGuaranteeDocNumberType(self, value):
        result = True
        # Validate type bankGuaranteeDocNumberType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 23:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on bankGuaranteeDocNumberType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on bankGuaranteeDocNumberType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_zfcs_longTextMinType(self, value):
        result = True
        # Validate type zfcs_longTextMinType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 2000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on zfcs_longTextMinType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on zfcs_longTextMinType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.regNumber is not None or
            self.docNumber is not None or
            self.returnDate is not None or
            self.returnReason is not None or
            self.returnPublishDate is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'regNumber':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'regNumber')
            value_ = self.gds_validate_string(value_, node, 'regNumber')
            self.regNumber = value_
            self.regNumber_nsprefix_ = child_.prefix
            # validate type bankGuaranteeRegNumberType
            self.validate_bankGuaranteeRegNumberType(self.regNumber)
        elif nodeName_ == 'docNumber':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'docNumber')
            value_ = self.gds_validate_string(value_, node, 'docNumber')
            self.docNumber = value_
            self.docNumber_nsprefix_ = child_.prefix
            # validate type bankGuaranteeDocNumberType
            self.validate_bankGuaranteeDocNumberType(self.docNumber)
        elif nodeName_ == 'returnDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.returnDate = dval_
            self.returnDate_nsprefix_ = child_.prefix
        elif nodeName_ == 'returnReason':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'returnReason')
            value_ = self.gds_validate_string(value_, node, 'returnReason')
            self.returnReason = value_
            self.returnReason_nsprefix_ = child_.prefix
            # validate type zfcs_longTextMinType
            self.validate_zfcs_longTextMinType(self.returnReason)
        elif nodeName_ == 'returnPublishDate':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.returnPublishDate = dval_
            self.returnPublishDate_nsprefix_ = child_.prefix
# end class bankGuaranteeReturn


class waiverNotice(GeneratedsSuper):
    """Информация об уведомлении, направленном заказчиком гаранту, об
    освобождении от обязательств по банковской гарантии"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'regNumber': MemberSpec_('regNumber', ['bankGuaranteeRegNumberType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'regNumber', 'type': 'xs:string'}, 44),
        'docNumber': MemberSpec_('docNumber', ['bankGuaranteeDocNumberType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'docNumber', 'type': 'xs:string'}, 44),
        'noticeDate': MemberSpec_('noticeDate', 'xs:date', 0, 0, {'name': 'noticeDate', 'type': 'xs:date'}, 44),
        'noticeNumber': MemberSpec_('noticeNumber', ['noticeNumber', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'noticeNumber', 'type': 'xs:string'}, 44),
        'noticeReason': MemberSpec_('noticeReason', ['zfcs_longTextMinType', 'xs:string'], 0, 0, {'name': 'noticeReason', 'type': 'xs:string'}, 44),
        'noticePublishDate': MemberSpec_('noticePublishDate', 'xs:dateTime', 0, 1, {'minOccurs': '0', 'name': 'noticePublishDate', 'type': 'xs:dateTime'}, 44),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, regNumber=None, docNumber=None, noticeDate=None, noticeNumber=None, noticeReason=None, noticePublishDate=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.regNumber = regNumber
        self.validate_bankGuaranteeRegNumberType(self.regNumber)
        self.regNumber_nsprefix_ = None
        self.docNumber = docNumber
        self.validate_bankGuaranteeDocNumberType(self.docNumber)
        self.docNumber_nsprefix_ = None
        if isinstance(noticeDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(noticeDate, '%Y-%m-%d').date()
        else:
            initvalue_ = noticeDate
        self.noticeDate = initvalue_
        self.noticeDate_nsprefix_ = None
        self.noticeNumber = noticeNumber
        self.noticeNumber_nsprefix_ = None
        self.noticeReason = noticeReason
        self.validate_zfcs_longTextMinType(self.noticeReason)
        self.noticeReason_nsprefix_ = None
        if isinstance(noticePublishDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(noticePublishDate, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = noticePublishDate
        self.noticePublishDate = initvalue_
        self.noticePublishDate_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, waiverNotice)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if waiverNotice.subclass:
            return waiverNotice.subclass(*args_, **kwargs_)
        else:
            return waiverNotice(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_bankGuaranteeRegNumberType(self, value):
        result = True
        # Validate type bankGuaranteeRegNumberType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 20:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on bankGuaranteeRegNumberType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on bankGuaranteeRegNumberType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_bankGuaranteeDocNumberType(self, value):
        result = True
        # Validate type bankGuaranteeDocNumberType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 23:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on bankGuaranteeDocNumberType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on bankGuaranteeDocNumberType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_zfcs_longTextMinType(self, value):
        result = True
        # Validate type zfcs_longTextMinType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 2000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on zfcs_longTextMinType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on zfcs_longTextMinType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.regNumber is not None or
            self.docNumber is not None or
            self.noticeDate is not None or
            self.noticeNumber is not None or
            self.noticeReason is not None or
            self.noticePublishDate is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'regNumber':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'regNumber')
            value_ = self.gds_validate_string(value_, node, 'regNumber')
            self.regNumber = value_
            self.regNumber_nsprefix_ = child_.prefix
            # validate type bankGuaranteeRegNumberType
            self.validate_bankGuaranteeRegNumberType(self.regNumber)
        elif nodeName_ == 'docNumber':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'docNumber')
            value_ = self.gds_validate_string(value_, node, 'docNumber')
            self.docNumber = value_
            self.docNumber_nsprefix_ = child_.prefix
            # validate type bankGuaranteeDocNumberType
            self.validate_bankGuaranteeDocNumberType(self.docNumber)
        elif nodeName_ == 'noticeDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.noticeDate = dval_
            self.noticeDate_nsprefix_ = child_.prefix
        elif nodeName_ == 'noticeNumber':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'noticeNumber')
            value_ = self.gds_validate_string(value_, node, 'noticeNumber')
            self.noticeNumber = value_
            self.noticeNumber_nsprefix_ = child_.prefix
        elif nodeName_ == 'noticeReason':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'noticeReason')
            value_ = self.gds_validate_string(value_, node, 'noticeReason')
            self.noticeReason = value_
            self.noticeReason_nsprefix_ = child_.prefix
            # validate type zfcs_longTextMinType
            self.validate_zfcs_longTextMinType(self.noticeReason)
        elif nodeName_ == 'noticePublishDate':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.noticePublishDate = dval_
            self.noticePublishDate_nsprefix_ = child_.prefix
# end class waiverNotice


class noticeNumber(GeneratedsSuper):
    """Номер уведомления"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, noticeNumber)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if noticeNumber.subclass:
            return noticeNumber.subclass(*args_, **kwargs_)
        else:
            return noticeNumber(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_noticeNumber(self, value):
        result = True
        # Validate type noticeNumber, a restriction on xs:string.
        pass
        return result
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class noticeNumber


class zfcs_extraBudgetFundsContract2015(GeneratedsSuper):
    """Код и наименование вида внебюджетных средств в контракте"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'code': MemberSpec_('code', ['code', 'xs:string'], 0, 0, {'name': 'code', 'type': 'xs:string'}, None),
        'name': MemberSpec_('name', ['name', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'name', 'type': 'xs:string'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, code=None, name=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.code = code
        self.code_nsprefix_ = None
        self.name = name
        self.name_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, zfcs_extraBudgetFundsContract2015)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if zfcs_extraBudgetFundsContract2015.subclass:
            return zfcs_extraBudgetFundsContract2015.subclass(*args_, **kwargs_)
        else:
            return zfcs_extraBudgetFundsContract2015(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.code is not None or
            self.name is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'code':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'code')
            value_ = self.gds_validate_string(value_, node, 'code')
            self.code = value_
            self.code_nsprefix_ = child_.prefix
        elif nodeName_ == 'name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'name')
            value_ = self.gds_validate_string(value_, node, 'name')
            self.name = value_
            self.name_nsprefix_ = child_.prefix
# end class zfcs_extraBudgetFundsContract2015


class zfcs_currencyRateContract2015(GeneratedsSuper):
    """Курс валюты для сведений о контракте"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'rate': MemberSpec_('rate', ['rate', 'xs:decimal'], 0, 0, {'name': 'rate', 'type': 'xs:decimal'}, None),
        'raiting': MemberSpec_('raiting', 'xs:int', 0, 1, {'minOccurs': '0', 'name': 'raiting', 'type': 'xs:int'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, rate=None, raiting=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.rate = rate
        self.rate_nsprefix_ = None
        self.raiting = raiting
        self.raiting_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, zfcs_currencyRateContract2015)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if zfcs_currencyRateContract2015.subclass:
            return zfcs_currencyRateContract2015.subclass(*args_, **kwargs_)
        else:
            return zfcs_currencyRateContract2015(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.rate is not None or
            self.raiting is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'rate' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'rate')
            fval_ = self.gds_validate_decimal(fval_, node, 'rate')
            self.rate = fval_
            self.rate_nsprefix_ = child_.prefix
        elif nodeName_ == 'raiting' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'raiting')
            ival_ = self.gds_validate_integer(ival_, node, 'raiting')
            self.raiting = ival_
            self.raiting_nsprefix_ = child_.prefix
# end class zfcs_currencyRateContract2015


class rate(GeneratedsSuper):
    """Курс валюты по отношению к рублю"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, rate)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if rate.subclass:
            return rate.subclass(*args_, **kwargs_)
        else:
            return rate(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_rate(self, value):
        result = True
        # Validate type rate, a restriction on xs:decimal.
        pass
        return result
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class rate


class zfcs_contract2015DrugPurchaseInfoType(GeneratedsSuper):
    """Информация об объекте закупки - лекарственном препарате"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'drugInfoUsingReferenceInfo': MemberSpec_('drugInfoUsingReferenceInfo', 'drugInfoUsingReferenceInfo', 0, 0, {'name': 'drugInfoUsingReferenceInfo', 'type': 'drugInfoUsingReferenceInfo'}, 45),
        'drugInfoUsingTextForm': MemberSpec_('drugInfoUsingTextForm', 'drugInfoUsingTextForm', 0, 0, {'name': 'drugInfoUsingTextForm', 'type': 'drugInfoUsingTextForm'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, drugInfoUsingReferenceInfo=None, drugInfoUsingTextForm=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.drugInfoUsingReferenceInfo = drugInfoUsingReferenceInfo
        self.drugInfoUsingReferenceInfo_nsprefix_ = None
        self.drugInfoUsingTextForm = drugInfoUsingTextForm
        self.drugInfoUsingTextForm_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, zfcs_contract2015DrugPurchaseInfoType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if zfcs_contract2015DrugPurchaseInfoType.subclass:
            return zfcs_contract2015DrugPurchaseInfoType.subclass(*args_, **kwargs_)
        else:
            return zfcs_contract2015DrugPurchaseInfoType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.drugInfoUsingReferenceInfo is not None or
            self.drugInfoUsingTextForm is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'drugInfoUsingReferenceInfo':
            obj_ = drugInfoUsingReferenceInfo.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.drugInfoUsingReferenceInfo = obj_
            obj_.original_tagname_ = 'drugInfoUsingReferenceInfo'
        elif nodeName_ == 'drugInfoUsingTextForm':
            obj_ = drugInfoUsingTextForm.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.drugInfoUsingTextForm = obj_
            obj_.original_tagname_ = 'drugInfoUsingTextForm'
# end class zfcs_contract2015DrugPurchaseInfoType


class drugInfoUsingReferenceInfo(GeneratedsSuper):
    """Информация о лекарственных препаратах формируется с использованием
    справочной информации или в текстовой форме"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'MNNsInfo': MemberSpec_('MNNsInfo', 'MNNsInfo', 0, 1, {'minOccurs': '0', 'name': 'MNNsInfo', 'type': 'MNNsInfo'}, 45),
        'MNNInfo': MemberSpec_('MNNInfo', 'MNNInfo', 0, 1, {'minOccurs': '0', 'name': 'MNNInfo', 'type': 'MNNInfo'}, None),
        'expirationDateCustomFormatInfo': MemberSpec_('expirationDateCustomFormatInfo', 'expirationDateCustomFormatInfo', 0, 1, {'minOccurs': '0', 'name': 'expirationDateCustomFormatInfo', 'type': 'expirationDateCustomFormatInfo'}, None),
        'isZNVLP': MemberSpec_('isZNVLP', 'xs:boolean', 0, 1, {'minOccurs': '0', 'name': 'isZNVLP', 'type': 'xs:boolean'}, None),
        'positionsTradeName': MemberSpec_('positionsTradeName', 'positionsTradeName', 0, 1, {'minOccurs': '0', 'name': 'positionsTradeName', 'type': 'positionsTradeName'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, MNNsInfo=None, MNNInfo=None, expirationDateCustomFormatInfo=None, isZNVLP=None, positionsTradeName=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.MNNsInfo = MNNsInfo
        self.MNNsInfo_nsprefix_ = None
        self.MNNInfo = MNNInfo
        self.MNNInfo_nsprefix_ = None
        self.expirationDateCustomFormatInfo = expirationDateCustomFormatInfo
        self.expirationDateCustomFormatInfo_nsprefix_ = None
        self.isZNVLP = isZNVLP
        self.isZNVLP_nsprefix_ = None
        self.positionsTradeName = positionsTradeName
        self.positionsTradeName_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, drugInfoUsingReferenceInfo)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if drugInfoUsingReferenceInfo.subclass:
            return drugInfoUsingReferenceInfo.subclass(*args_, **kwargs_)
        else:
            return drugInfoUsingReferenceInfo(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.MNNsInfo is not None or
            self.MNNInfo is not None or
            self.expirationDateCustomFormatInfo is not None or
            self.isZNVLP is not None or
            self.positionsTradeName is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'MNNsInfo':
            obj_ = MNNsInfo.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.MNNsInfo = obj_
            obj_.original_tagname_ = 'MNNsInfo'
        elif nodeName_ == 'MNNInfo':
            obj_ = MNNInfo.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.MNNInfo = obj_
            obj_.original_tagname_ = 'MNNInfo'
        elif nodeName_ == 'expirationDateCustomFormatInfo':
            obj_ = expirationDateCustomFormatInfo.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.expirationDateCustomFormatInfo = obj_
            obj_.original_tagname_ = 'expirationDateCustomFormatInfo'
        elif nodeName_ == 'isZNVLP':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'isZNVLP')
            ival_ = self.gds_validate_boolean(ival_, node, 'isZNVLP')
            self.isZNVLP = ival_
            self.isZNVLP_nsprefix_ = child_.prefix
        elif nodeName_ == 'positionsTradeName':
            obj_ = positionsTradeName.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.positionsTradeName = obj_
            obj_.original_tagname_ = 'positionsTradeName'
# end class drugInfoUsingReferenceInfo


class MNNTextForm(GeneratedsSuper):
    """Международное непатентованное или
    группировочное или химическое наименование формируется в текстовой форме.
    Начиная с версии 10.1 не допускается указание лекарственных препаратов в
    текстовой форме. Запрет не учитывается, если при формировании первичной
    информации о контракте осуществляется наследование объектов закупки из
    извещения о закупке или позиции плана-графика 2019 года (2019 или
    ранее) и в источнике сведений об унаследованных объектах закупки хотя
    бы одно МНН объекта закупки-лекарственного препарата указано вручную. А
    так же при приеме информация об изменении контракта, если в предыдущей
    размещенной версии информации об этом контракте хотя бы одно МНН или ТН
    объекта закупки-лекарственного препарата указано вручную"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'MNNName': MemberSpec_('MNNName', ['drugName2000Type', 'xs:string'], 0, 0, {'name': 'MNNName', 'type': 'xs:string'}, 46),
        'drugChangeInfo': MemberSpec_('drugChangeInfo', 'drugChangeInfoType', 0, 1, {'minOccurs': '0', 'name': 'drugChangeInfo', 'type': 'drugChangeInfoType'}, 46),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, MNNName=None, drugChangeInfo=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.MNNName = MNNName
        self.validate_drugName2000Type(self.MNNName)
        self.MNNName_nsprefix_ = None
        self.drugChangeInfo = drugChangeInfo
        self.drugChangeInfo_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MNNTextForm)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MNNTextForm.subclass:
            return MNNTextForm.subclass(*args_, **kwargs_)
        else:
            return MNNTextForm(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_drugName2000Type(self, value):
        result = True
        # Validate type drugName2000Type, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 2000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on drugName2000Type' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on drugName2000Type' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.MNNName is not None or
            self.drugChangeInfo is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'MNNName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'MNNName')
            value_ = self.gds_validate_string(value_, node, 'MNNName')
            self.MNNName = value_
            self.MNNName_nsprefix_ = child_.prefix
            # validate type drugName2000Type
            self.validate_drugName2000Type(self.MNNName)
        elif nodeName_ == 'drugChangeInfo':
            obj_ = drugChangeInfoType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.drugChangeInfo = obj_
            obj_.original_tagname_ = 'drugChangeInfo'
# end class MNNTextForm


class editedTradeInfo(GeneratedsSuper):
    """Торговое наименование (ТН) лекарственного препарата. Изменено вручную"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'tradeName': MemberSpec_('tradeName', ['drugNameType', 'xs:string'], 0, 0, {'name': 'tradeName', 'type': 'xs:string'}, 48),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, tradeName=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.tradeName = tradeName
        self.validate_drugNameType(self.tradeName)
        self.tradeName_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, editedTradeInfo)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if editedTradeInfo.subclass:
            return editedTradeInfo.subclass(*args_, **kwargs_)
        else:
            return editedTradeInfo(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_drugNameType(self, value):
        result = True
        # Validate type drugNameType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 500:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on drugNameType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on drugNameType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.tradeName is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'tradeName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'tradeName')
            value_ = self.gds_validate_string(value_, node, 'tradeName')
            self.tradeName = value_
            self.tradeName_nsprefix_ = child_.prefix
            # validate type drugNameType
            self.validate_drugNameType(self.tradeName)
# end class editedTradeInfo


class certificateNumber(GeneratedsSuper):
    """Номер регистрационного удостоверения лекарственного препарата.
    Игнорируется при приеме, автоматически заполняется при передаче из
    справочника "Лекарственные препараты" (поле
    MNNInfo\positionsTradeName\positionTradeName\certificateNumber
    документа nsiFarmDrugDictionary)"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, certificateNumber)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if certificateNumber.subclass:
            return certificateNumber.subclass(*args_, **kwargs_)
        else:
            return certificateNumber(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_certificateNumber(self, value):
        result = True
        # Validate type certificateNumber, a restriction on xs:string.
        pass
        return result
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class certificateNumber


class editedCertificateNumber(GeneratedsSuper):
    """Номер регистрационного удостоверения лекарственного препарата. Изменено
    вручную"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, editedCertificateNumber)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if editedCertificateNumber.subclass:
            return editedCertificateNumber.subclass(*args_, **kwargs_)
        else:
            return editedCertificateNumber(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_editedCertificateNumber(self, value):
        result = True
        # Validate type editedCertificateNumber, a restriction on xs:string.
        pass
        return result
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class editedCertificateNumber


class editedMedicamentalFormInfo(GeneratedsSuper):
    """Лекарственная форма. Изменено вручную"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'medicamentalFormName': MemberSpec_('medicamentalFormName', ['drugNameType', 'xs:string'], 0, 0, {'name': 'medicamentalFormName', 'type': 'xs:string'}, 50),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, medicamentalFormName=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.medicamentalFormName = medicamentalFormName
        self.validate_drugNameType(self.medicamentalFormName)
        self.medicamentalFormName_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, editedMedicamentalFormInfo)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if editedMedicamentalFormInfo.subclass:
            return editedMedicamentalFormInfo.subclass(*args_, **kwargs_)
        else:
            return editedMedicamentalFormInfo(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_drugNameType(self, value):
        result = True
        # Validate type drugNameType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 500:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on drugNameType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on drugNameType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.medicamentalFormName is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'medicamentalFormName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'medicamentalFormName')
            value_ = self.gds_validate_string(value_, node, 'medicamentalFormName')
            self.medicamentalFormName = value_
            self.medicamentalFormName_nsprefix_ = child_.prefix
            # validate type drugNameType
            self.validate_drugNameType(self.medicamentalFormName)
# end class editedMedicamentalFormInfo


class editedDosageInfo(GeneratedsSuper):
    """Дозировка. Изменено вручную"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'dosageName': MemberSpec_('dosageName', ['drugNameType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'dosageName', 'type': 'xs:string'}, 51),
        'dosageOKEI': MemberSpec_('dosageOKEI', 'zfcs_OKEIRef', 0, 1, {'minOccurs': '0', 'name': 'dosageOKEI', 'type': 'zfcs_OKEIRef'}, 51),
        'dosageValue': MemberSpec_('dosageValue', ['dosageValue', 'xs:decimal'], 0, 0, {'name': 'dosageValue', 'type': 'xs:decimal'}, 51),
        'dosageGRLSValue': MemberSpec_('dosageGRLSValue', ['drugNameType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'dosageGRLSValue', 'type': 'xs:string'}, 51),
        'dosageUserName': MemberSpec_('dosageUserName', ['drugNameType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'dosageUserName', 'type': 'xs:string'}, 51),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, dosageName=None, dosageOKEI=None, dosageValue=None, dosageGRLSValue=None, dosageUserName=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.dosageName = dosageName
        self.validate_drugNameType(self.dosageName)
        self.dosageName_nsprefix_ = None
        self.dosageOKEI = dosageOKEI
        self.dosageOKEI_nsprefix_ = None
        self.dosageValue = dosageValue
        self.dosageValue_nsprefix_ = None
        self.dosageGRLSValue = dosageGRLSValue
        self.validate_drugNameType(self.dosageGRLSValue)
        self.dosageGRLSValue_nsprefix_ = None
        self.dosageUserName = dosageUserName
        self.validate_drugNameType(self.dosageUserName)
        self.dosageUserName_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, editedDosageInfo)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if editedDosageInfo.subclass:
            return editedDosageInfo.subclass(*args_, **kwargs_)
        else:
            return editedDosageInfo(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_drugNameType(self, value):
        result = True
        # Validate type drugNameType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 500:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on drugNameType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on drugNameType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.dosageName is not None or
            self.dosageOKEI is not None or
            self.dosageValue is not None or
            self.dosageGRLSValue is not None or
            self.dosageUserName is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'dosageName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'dosageName')
            value_ = self.gds_validate_string(value_, node, 'dosageName')
            self.dosageName = value_
            self.dosageName_nsprefix_ = child_.prefix
            # validate type drugNameType
            self.validate_drugNameType(self.dosageName)
        elif nodeName_ == 'dosageOKEI':
            obj_ = zfcs_OKEIRef.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.dosageOKEI = obj_
            obj_.original_tagname_ = 'dosageOKEI'
        elif nodeName_ == 'dosageValue' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'dosageValue')
            fval_ = self.gds_validate_decimal(fval_, node, 'dosageValue')
            self.dosageValue = fval_
            self.dosageValue_nsprefix_ = child_.prefix
        elif nodeName_ == 'dosageGRLSValue':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'dosageGRLSValue')
            value_ = self.gds_validate_string(value_, node, 'dosageGRLSValue')
            self.dosageGRLSValue = value_
            self.dosageGRLSValue_nsprefix_ = child_.prefix
            # validate type drugNameType
            self.validate_drugNameType(self.dosageGRLSValue)
        elif nodeName_ == 'dosageUserName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'dosageUserName')
            value_ = self.gds_validate_string(value_, node, 'dosageUserName')
            self.dosageUserName = value_
            self.dosageUserName_nsprefix_ = child_.prefix
            # validate type drugNameType
            self.validate_drugNameType(self.dosageUserName)
# end class editedDosageInfo


class dosageValue(GeneratedsSuper):
    """Значение дозировки"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, dosageValue)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if dosageValue.subclass:
            return dosageValue.subclass(*args_, **kwargs_)
        else:
            return dosageValue(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_dosageValue(self, value):
        result = True
        # Validate type dosageValue, a restriction on xs:decimal.
        pass
        return result
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class dosageValue


class manufacturerInfo(GeneratedsSuper):
    """Производитель лекарственного препарата. Игнорируется при приеме,
    автоматически заполняется при передаче из справочника "Лекарственные
    препараты" (блок MNNInfo\positionsTradeName\positionTradeNameдокумента
    nsiFarmDrugDictionary)"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'manufacturerOKSM': MemberSpec_('manufacturerOKSM', 'zfcs_OKSMRef', 0, 1, {'minOccurs': '0', 'name': 'manufacturerOKSM', 'type': 'zfcs_OKSMRef'}, 53),
        'manufacturerName': MemberSpec_('manufacturerName', ['drugNameType', 'xs:string'], 0, 0, {'name': 'manufacturerName', 'type': 'xs:string'}, 53),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, manufacturerOKSM=None, manufacturerName=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.manufacturerOKSM = manufacturerOKSM
        self.manufacturerOKSM_nsprefix_ = None
        self.manufacturerName = manufacturerName
        self.validate_drugNameType(self.manufacturerName)
        self.manufacturerName_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, manufacturerInfo)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if manufacturerInfo.subclass:
            return manufacturerInfo.subclass(*args_, **kwargs_)
        else:
            return manufacturerInfo(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_drugNameType(self, value):
        result = True
        # Validate type drugNameType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 500:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on drugNameType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on drugNameType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.manufacturerOKSM is not None or
            self.manufacturerName is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'manufacturerOKSM':
            obj_ = zfcs_OKSMRef.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.manufacturerOKSM = obj_
            obj_.original_tagname_ = 'manufacturerOKSM'
        elif nodeName_ == 'manufacturerName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'manufacturerName')
            value_ = self.gds_validate_string(value_, node, 'manufacturerName')
            self.manufacturerName = value_
            self.manufacturerName_nsprefix_ = child_.prefix
            # validate type drugNameType
            self.validate_drugNameType(self.manufacturerName)
# end class manufacturerInfo


class editedManufacturerInfo(GeneratedsSuper):
    """Производитель лекарственного препарата. Изменено вручную"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'manufacturerOKSM': MemberSpec_('manufacturerOKSM', 'zfcs_OKSMRef', 0, 1, {'minOccurs': '0', 'name': 'manufacturerOKSM', 'type': 'zfcs_OKSMRef'}, 53),
        'manufacturerName': MemberSpec_('manufacturerName', ['drugNameType', 'xs:string'], 0, 0, {'name': 'manufacturerName', 'type': 'xs:string'}, 53),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, manufacturerOKSM=None, manufacturerName=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.manufacturerOKSM = manufacturerOKSM
        self.manufacturerOKSM_nsprefix_ = None
        self.manufacturerName = manufacturerName
        self.validate_drugNameType(self.manufacturerName)
        self.manufacturerName_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, editedManufacturerInfo)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if editedManufacturerInfo.subclass:
            return editedManufacturerInfo.subclass(*args_, **kwargs_)
        else:
            return editedManufacturerInfo(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_drugNameType(self, value):
        result = True
        # Validate type drugNameType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 500:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on drugNameType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on drugNameType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.manufacturerOKSM is not None or
            self.manufacturerName is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'manufacturerOKSM':
            obj_ = zfcs_OKSMRef.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.manufacturerOKSM = obj_
            obj_.original_tagname_ = 'manufacturerOKSM'
        elif nodeName_ == 'manufacturerName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'manufacturerName')
            value_ = self.gds_validate_string(value_, node, 'manufacturerName')
            self.manufacturerName = value_
            self.manufacturerName_nsprefix_ = child_.prefix
            # validate type drugNameType
            self.validate_drugNameType(self.manufacturerName)
# end class editedManufacturerInfo


class completeness(GeneratedsSuper):
    """Комплектность упаковки"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, completeness)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if completeness.subclass:
            return completeness.subclass(*args_, **kwargs_)
        else:
            return completeness(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_completeness(self, value):
        result = True
        # Validate type completeness, a restriction on xs:string.
        pass
        return result
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class completeness


class editedPackagingsInfo(GeneratedsSuper):
    """Сведения об упаковках. Изменено вручную"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'packagingInfo': MemberSpec_('packagingInfo', 'packagingInfo', 0, 0, {'name': 'packagingInfo', 'type': 'packagingInfo'}, 54),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, packagingInfo=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.packagingInfo = packagingInfo
        self.packagingInfo_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, editedPackagingsInfo)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if editedPackagingsInfo.subclass:
            return editedPackagingsInfo.subclass(*args_, **kwargs_)
        else:
            return editedPackagingsInfo(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.packagingInfo is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'packagingInfo':
            obj_ = packagingInfo.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.packagingInfo = obj_
            obj_.original_tagname_ = 'packagingInfo'
# end class editedPackagingsInfo


class positionTradeNameUsingTextForm(GeneratedsSuper):
    """Позиция по торговому наименованию (ТН) лекарственного средства
    формируется в текстовой форме"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'guid': MemberSpec_('guid', ['guidType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'guid', 'type': 'xs:string'}, None),
        'sid': MemberSpec_('sid', 'xs:long', 0, 1, {'minOccurs': '0', 'name': 'sid', 'type': 'xs:long'}, None),
        'tradeInfo': MemberSpec_('tradeInfo', 'tradeInfo', 0, 0, {'name': 'tradeInfo', 'type': 'tradeInfo'}, None),
        'certificateNumber': MemberSpec_('certificateNumber', ['certificateNumber', 'xs:string'], 0, 0, {'name': 'certificateNumber', 'type': 'xs:string'}, None),
        'dosageFormInfo': MemberSpec_('dosageFormInfo', 'dosageFormInfo', 0, 0, {'name': 'dosageFormInfo', 'type': 'dosageFormInfo'}, None),
        'dosageInfo': MemberSpec_('dosageInfo', 'dosageInfo', 0, 0, {'name': 'dosageInfo', 'type': 'dosageInfo'}, None),
        'certificateKeeperName': MemberSpec_('certificateKeeperName', ['drugNameType', 'xs:string'], 0, 0, {'name': 'certificateKeeperName', 'type': 'xs:string'}, None),
        'manufacturerInfo': MemberSpec_('manufacturerInfo', 'manufacturerInfo', 0, 0, {'name': 'manufacturerInfo', 'type': 'manufacturerInfo'}, None),
        'packagingsInfo': MemberSpec_('packagingsInfo', 'packagingsInfo', 0, 0, {'name': 'packagingsInfo', 'type': 'packagingsInfo'}, None),
        'drugChangeInfo': MemberSpec_('drugChangeInfo', 'drugChangeInfoType', 0, 1, {'minOccurs': '0', 'name': 'drugChangeInfo', 'type': 'drugChangeInfoType'}, None),
        'MNNNormName': MemberSpec_('MNNNormName', ['drugName2000Type', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'MNNNormName', 'type': 'xs:string'}, None),
        'dosageNormName': MemberSpec_('dosageNormName', ['drugName2000Type', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'dosageNormName', 'type': 'xs:string'}, None),
        'medicamentalFormNormName': MemberSpec_('medicamentalFormNormName', ['drugName2000Type', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'medicamentalFormNormName', 'type': 'xs:string'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, guid=None, sid=None, tradeInfo=None, certificateNumber=None, dosageFormInfo=None, dosageInfo=None, certificateKeeperName=None, manufacturerInfo=None, packagingsInfo=None, drugChangeInfo=None, MNNNormName=None, dosageNormName=None, medicamentalFormNormName=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.guid = guid
        self.validate_guidType(self.guid)
        self.guid_nsprefix_ = None
        self.sid = sid
        self.sid_nsprefix_ = None
        self.tradeInfo = tradeInfo
        self.tradeInfo_nsprefix_ = None
        self.certificateNumber = certificateNumber
        self.certificateNumber_nsprefix_ = None
        self.dosageFormInfo = dosageFormInfo
        self.dosageFormInfo_nsprefix_ = None
        self.dosageInfo = dosageInfo
        self.dosageInfo_nsprefix_ = None
        self.certificateKeeperName = certificateKeeperName
        self.validate_drugNameType(self.certificateKeeperName)
        self.certificateKeeperName_nsprefix_ = None
        self.manufacturerInfo = manufacturerInfo
        self.manufacturerInfo_nsprefix_ = None
        self.packagingsInfo = packagingsInfo
        self.packagingsInfo_nsprefix_ = None
        self.drugChangeInfo = drugChangeInfo
        self.drugChangeInfo_nsprefix_ = None
        self.MNNNormName = MNNNormName
        self.validate_drugName2000Type(self.MNNNormName)
        self.MNNNormName_nsprefix_ = None
        self.dosageNormName = dosageNormName
        self.validate_drugName2000Type(self.dosageNormName)
        self.dosageNormName_nsprefix_ = None
        self.medicamentalFormNormName = medicamentalFormNormName
        self.validate_drugName2000Type(self.medicamentalFormNormName)
        self.medicamentalFormNormName_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, positionTradeNameUsingTextForm)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if positionTradeNameUsingTextForm.subclass:
            return positionTradeNameUsingTextForm.subclass(*args_, **kwargs_)
        else:
            return positionTradeNameUsingTextForm(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_guidType(self, value):
        result = True
        # Validate type guidType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 36:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on guidType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on guidType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_drugNameType(self, value):
        result = True
        # Validate type drugNameType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 500:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on drugNameType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on drugNameType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_drugName2000Type(self, value):
        result = True
        # Validate type drugName2000Type, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 2000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on drugName2000Type' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on drugName2000Type' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.guid is not None or
            self.sid is not None or
            self.tradeInfo is not None or
            self.certificateNumber is not None or
            self.dosageFormInfo is not None or
            self.dosageInfo is not None or
            self.certificateKeeperName is not None or
            self.manufacturerInfo is not None or
            self.packagingsInfo is not None or
            self.drugChangeInfo is not None or
            self.MNNNormName is not None or
            self.dosageNormName is not None or
            self.medicamentalFormNormName is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'guid':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'guid')
            value_ = self.gds_validate_string(value_, node, 'guid')
            self.guid = value_
            self.guid_nsprefix_ = child_.prefix
            # validate type guidType
            self.validate_guidType(self.guid)
        elif nodeName_ == 'sid' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'sid')
            ival_ = self.gds_validate_integer(ival_, node, 'sid')
            self.sid = ival_
            self.sid_nsprefix_ = child_.prefix
        elif nodeName_ == 'tradeInfo':
            obj_ = tradeInfo.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.tradeInfo = obj_
            obj_.original_tagname_ = 'tradeInfo'
        elif nodeName_ == 'certificateNumber':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'certificateNumber')
            value_ = self.gds_validate_string(value_, node, 'certificateNumber')
            self.certificateNumber = value_
            self.certificateNumber_nsprefix_ = child_.prefix
        elif nodeName_ == 'dosageFormInfo':
            obj_ = dosageFormInfo.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.dosageFormInfo = obj_
            obj_.original_tagname_ = 'dosageFormInfo'
        elif nodeName_ == 'dosageInfo':
            obj_ = dosageInfo.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.dosageInfo = obj_
            obj_.original_tagname_ = 'dosageInfo'
        elif nodeName_ == 'certificateKeeperName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'certificateKeeperName')
            value_ = self.gds_validate_string(value_, node, 'certificateKeeperName')
            self.certificateKeeperName = value_
            self.certificateKeeperName_nsprefix_ = child_.prefix
            # validate type drugNameType
            self.validate_drugNameType(self.certificateKeeperName)
        elif nodeName_ == 'manufacturerInfo':
            obj_ = manufacturerInfo.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.manufacturerInfo = obj_
            obj_.original_tagname_ = 'manufacturerInfo'
        elif nodeName_ == 'packagingsInfo':
            obj_ = packagingsInfo.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.packagingsInfo = obj_
            obj_.original_tagname_ = 'packagingsInfo'
        elif nodeName_ == 'drugChangeInfo':
            obj_ = drugChangeInfoType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.drugChangeInfo = obj_
            obj_.original_tagname_ = 'drugChangeInfo'
        elif nodeName_ == 'MNNNormName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'MNNNormName')
            value_ = self.gds_validate_string(value_, node, 'MNNNormName')
            self.MNNNormName = value_
            self.MNNNormName_nsprefix_ = child_.prefix
            # validate type drugName2000Type
            self.validate_drugName2000Type(self.MNNNormName)
        elif nodeName_ == 'dosageNormName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'dosageNormName')
            value_ = self.gds_validate_string(value_, node, 'dosageNormName')
            self.dosageNormName = value_
            self.dosageNormName_nsprefix_ = child_.prefix
            # validate type drugName2000Type
            self.validate_drugName2000Type(self.dosageNormName)
        elif nodeName_ == 'medicamentalFormNormName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'medicamentalFormNormName')
            value_ = self.gds_validate_string(value_, node, 'medicamentalFormNormName')
            self.medicamentalFormNormName = value_
            self.medicamentalFormNormName_nsprefix_ = child_.prefix
            # validate type drugName2000Type
            self.validate_drugName2000Type(self.medicamentalFormNormName)
# end class positionTradeNameUsingTextForm


class dosageFormInfo(GeneratedsSuper):
    """Лекарственная форма"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'dosageFormName': MemberSpec_('dosageFormName', ['drugNameType', 'xs:string'], 0, 0, {'name': 'dosageFormName', 'type': 'xs:string'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, dosageFormName=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.dosageFormName = dosageFormName
        self.validate_drugNameType(self.dosageFormName)
        self.dosageFormName_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, dosageFormInfo)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if dosageFormInfo.subclass:
            return dosageFormInfo.subclass(*args_, **kwargs_)
        else:
            return dosageFormInfo(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_drugNameType(self, value):
        result = True
        # Validate type drugNameType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 500:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on drugNameType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on drugNameType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.dosageFormName is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'dosageFormName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'dosageFormName')
            value_ = self.gds_validate_string(value_, node, 'dosageFormName')
            self.dosageFormName = value_
            self.dosageFormName_nsprefix_ = child_.prefix
            # validate type drugNameType
            self.validate_drugNameType(self.dosageFormName)
# end class dosageFormInfo


class expirationDateCustomFormatInfo(GeneratedsSuper):
    """Срок годности (годен до) в пользовательском формате"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'expirationDateMonthYear': MemberSpec_('expirationDateMonthYear', 'expirationDateMonthYear', 0, 0, {'name': 'expirationDateMonthYear', 'type': 'expirationDateMonthYear'}, 55),
        'expirationDate': MemberSpec_('expirationDate', 'xs:date', 0, 0, {'name': 'expirationDate', 'type': 'xs:date'}, 55),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, expirationDateMonthYear=None, expirationDate=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.expirationDateMonthYear = expirationDateMonthYear
        self.expirationDateMonthYear_nsprefix_ = None
        if isinstance(expirationDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(expirationDate, '%Y-%m-%d').date()
        else:
            initvalue_ = expirationDate
        self.expirationDate = initvalue_
        self.expirationDate_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, expirationDateCustomFormatInfo)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if expirationDateCustomFormatInfo.subclass:
            return expirationDateCustomFormatInfo.subclass(*args_, **kwargs_)
        else:
            return expirationDateCustomFormatInfo(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.expirationDateMonthYear is not None or
            self.expirationDate is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'expirationDateMonthYear':
            obj_ = expirationDateMonthYear.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.expirationDateMonthYear = obj_
            obj_.original_tagname_ = 'expirationDateMonthYear'
        elif nodeName_ == 'expirationDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.expirationDate = dval_
            self.expirationDate_nsprefix_ = child_.prefix
# end class expirationDateCustomFormatInfo


class expirationDateMonthYear(GeneratedsSuper):
    """Срок годности в формате "месяц-год".
    Окончание срока годности трактуется, как последний день месяца,
    предшествующего месяцу, указанному на упаковке лекарственного
    препарата"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'month': MemberSpec_('month', ['monthType', 'xs:byte'], 0, 0, {'name': 'month', 'type': 'xs:byte'}, 55),
        'year': MemberSpec_('year', ['year', 'zfcs_yearType', 'xs:int'], 0, 0, {'name': 'year', 'type': 'xs:int'}, 55),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, month=None, year=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.month = month
        self.validate_monthType(self.month)
        self.month_nsprefix_ = None
        self.year = year
        self.year_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, expirationDateMonthYear)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if expirationDateMonthYear.subclass:
            return expirationDateMonthYear.subclass(*args_, **kwargs_)
        else:
            return expirationDateMonthYear(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_monthType(self, value):
        result = True
        # Validate type monthType, a restriction on xs:byte.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            if value < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on monthType' % {"value": value, "lineno": lineno} )
                result = False
            if value > 12:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxInclusive restriction on monthType' % {"value": value, "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.month is not None or
            self.year is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'month' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'month')
            ival_ = self.gds_validate_integer(ival_, node, 'month')
            self.month = ival_
            self.month_nsprefix_ = child_.prefix
            # validate type monthType
            self.validate_monthType(self.month)
        elif nodeName_ == 'year' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'year')
            ival_ = self.gds_validate_integer(ival_, node, 'year')
            self.year = ival_
            self.year_nsprefix_ = child_.prefix
# end class expirationDateMonthYear


class year(GeneratedsSuper):
    """Год"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, year)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if year.subclass:
            return year.subclass(*args_, **kwargs_)
        else:
            return year(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_year(self, value):
        result = True
        # Validate type year, a restriction on zfcs_yearType.
        pass
        return result
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class year


class drugInfoUsingTextForm(GeneratedsSuper):
    """Информация о лекарственных препаратах формируется в текстовой форме.
    Устарело, не применяется"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'MNNsInfo': MemberSpec_('MNNsInfo', 'MNNsInfo', 0, 1, {'minOccurs': '0', 'name': 'MNNsInfo', 'type': 'MNNsInfo'}, None),
        'MNNInfo': MemberSpec_('MNNInfo', 'MNNInfo', 0, 1, {'minOccurs': '0', 'name': 'MNNInfo', 'type': 'MNNInfo'}, None),
        'expirationDateCustomFormatInfo': MemberSpec_('expirationDateCustomFormatInfo', 'expirationDateCustomFormatInfo', 0, 1, {'minOccurs': '0', 'name': 'expirationDateCustomFormatInfo', 'type': 'expirationDateCustomFormatInfo'}, None),
        'isZNVLP': MemberSpec_('isZNVLP', 'xs:boolean', 0, 0, {'name': 'isZNVLP', 'type': 'xs:boolean'}, None),
        'positionsTradeName': MemberSpec_('positionsTradeName', 'positionsTradeName', 0, 1, {'minOccurs': '0', 'name': 'positionsTradeName', 'type': 'positionsTradeName'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, MNNsInfo=None, MNNInfo=None, expirationDateCustomFormatInfo=None, isZNVLP=None, positionsTradeName=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.MNNsInfo = MNNsInfo
        self.MNNsInfo_nsprefix_ = None
        self.MNNInfo = MNNInfo
        self.MNNInfo_nsprefix_ = None
        self.expirationDateCustomFormatInfo = expirationDateCustomFormatInfo
        self.expirationDateCustomFormatInfo_nsprefix_ = None
        self.isZNVLP = isZNVLP
        self.isZNVLP_nsprefix_ = None
        self.positionsTradeName = positionsTradeName
        self.positionsTradeName_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, drugInfoUsingTextForm)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if drugInfoUsingTextForm.subclass:
            return drugInfoUsingTextForm.subclass(*args_, **kwargs_)
        else:
            return drugInfoUsingTextForm(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.MNNsInfo is not None or
            self.MNNInfo is not None or
            self.expirationDateCustomFormatInfo is not None or
            self.isZNVLP is not None or
            self.positionsTradeName is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'MNNsInfo':
            obj_ = MNNsInfo.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.MNNsInfo = obj_
            obj_.original_tagname_ = 'MNNsInfo'
        elif nodeName_ == 'MNNInfo':
            obj_ = MNNInfo.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.MNNInfo = obj_
            obj_.original_tagname_ = 'MNNInfo'
        elif nodeName_ == 'expirationDateCustomFormatInfo':
            obj_ = expirationDateCustomFormatInfo.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.expirationDateCustomFormatInfo = obj_
            obj_.original_tagname_ = 'expirationDateCustomFormatInfo'
        elif nodeName_ == 'isZNVLP':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'isZNVLP')
            ival_ = self.gds_validate_boolean(ival_, node, 'isZNVLP')
            self.isZNVLP = ival_
            self.isZNVLP_nsprefix_ = child_.prefix
        elif nodeName_ == 'positionsTradeName':
            obj_ = positionsTradeName.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.positionsTradeName = obj_
            obj_.original_tagname_ = 'positionsTradeName'
# end class drugInfoUsingTextForm


class zfcs_contract2015TenderPlanInfoType(GeneratedsSuper):
    """Информация о плане-графике для реестра контрактов"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'plan2017Number': MemberSpec_('plan2017Number', ['tenderPlan2017RegNumberType', 'xs:string'], 0, 0, {'name': 'plan2017Number', 'type': 'xs:string'}, None),
        'position2017Number': MemberSpec_('position2017Number', 'xs:string', 0, 0, {'name': 'position2017Number', 'type': 'xs:string'}, 57),
        'position2017ExtNumber': MemberSpec_('position2017ExtNumber', 'xs:string', 0, 0, {'name': 'position2017ExtNumber', 'type': 'xs:string'}, 57),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, plan2017Number=None, position2017Number=None, position2017ExtNumber=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.plan2017Number = plan2017Number
        self.validate_tenderPlan2017RegNumberType(self.plan2017Number)
        self.plan2017Number_nsprefix_ = None
        self.position2017Number = position2017Number
        self.position2017Number_nsprefix_ = None
        self.position2017ExtNumber = position2017ExtNumber
        self.position2017ExtNumber_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, zfcs_contract2015TenderPlanInfoType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if zfcs_contract2015TenderPlanInfoType.subclass:
            return zfcs_contract2015TenderPlanInfoType.subclass(*args_, **kwargs_)
        else:
            return zfcs_contract2015TenderPlanInfoType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_tenderPlan2017RegNumberType(self, value):
        result = True
        # Validate type tenderPlan2017RegNumberType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) != 22:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd length restriction on tenderPlan2017RegNumberType' % {"value": encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.plan2017Number is not None or
            self.position2017Number is not None or
            self.position2017ExtNumber is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'plan2017Number':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'plan2017Number')
            value_ = self.gds_validate_string(value_, node, 'plan2017Number')
            self.plan2017Number = value_
            self.plan2017Number_nsprefix_ = child_.prefix
            # validate type tenderPlan2017RegNumberType
            self.validate_tenderPlan2017RegNumberType(self.plan2017Number)
        elif nodeName_ == 'position2017Number':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'position2017Number')
            value_ = self.gds_validate_string(value_, node, 'position2017Number')
            self.position2017Number = value_
            self.position2017Number_nsprefix_ = child_.prefix
        elif nodeName_ == 'position2017ExtNumber':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'position2017ExtNumber')
            value_ = self.gds_validate_string(value_, node, 'position2017ExtNumber')
            self.position2017ExtNumber = value_
            self.position2017ExtNumber_nsprefix_ = child_.prefix
# end class zfcs_contract2015TenderPlanInfoType


class zfcs_contractProcedure2015ProductsCountryType(GeneratedsSuper):
    """Тип: Страна происхождения товара, страна производителя в информации об
    исполненни (исполнении обязательств по предоставленной гарантии
    качества, расторжении) контрактаПри приеме контролируется, что заполнен
    либо sid, либо externalSid, либо OKPD/OKPD2/KTRU"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'country': MemberSpec_('country', 'zfcs_countryRef', 0, 0, {'name': 'country', 'type': 'zfcs_countryRef'}, None),
        'sid': MemberSpec_('sid', ['sid', 'xs:long'], 0, 1, {'minOccurs': '0', 'name': 'sid', 'type': 'xs:long'}, None),
        'externalSid': MemberSpec_('externalSid', ['externalIdType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'externalSid', 'type': 'xs:string'}, None),
        'OKPD': MemberSpec_('OKPD', 'zfcs_OKPDRef', 0, 1, {'name': 'OKPD', 'type': 'zfcs_OKPDRef'}, 58),
        'OKPD2': MemberSpec_('OKPD2', 'OKPD2', 0, 1, {'name': 'OKPD2', 'type': 'zfcs_OKPDRef'}, 58),
        'KTRU': MemberSpec_('KTRU', 'KTRU', 0, 1, {'name': 'KTRU', 'type': 'zfcs_KTRURef'}, 58),
        'productName': MemberSpec_('productName', ['zfcs_longTextMinType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'productName', 'type': 'xs:string'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, country=None, sid=None, externalSid=None, OKPD=None, OKPD2=None, KTRU=None, productName=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.country = country
        self.country_nsprefix_ = None
        self.sid = sid
        self.sid_nsprefix_ = None
        self.externalSid = externalSid
        self.validate_externalIdType(self.externalSid)
        self.externalSid_nsprefix_ = None
        self.OKPD = OKPD
        self.OKPD_nsprefix_ = None
        self.OKPD2 = OKPD2
        self.OKPD2_nsprefix_ = None
        self.KTRU = KTRU
        self.KTRU_nsprefix_ = None
        self.productName = productName
        self.validate_zfcs_longTextMinType(self.productName)
        self.productName_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, zfcs_contractProcedure2015ProductsCountryType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if zfcs_contractProcedure2015ProductsCountryType.subclass:
            return zfcs_contractProcedure2015ProductsCountryType.subclass(*args_, **kwargs_)
        else:
            return zfcs_contractProcedure2015ProductsCountryType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_externalIdType(self, value):
        result = True
        # Validate type externalIdType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 40:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on externalIdType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on externalIdType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_zfcs_longTextMinType(self, value):
        result = True
        # Validate type zfcs_longTextMinType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 2000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on zfcs_longTextMinType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on zfcs_longTextMinType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.country is not None or
            self.sid is not None or
            self.externalSid is not None or
            self.OKPD is not None or
            self.OKPD2 is not None or
            self.KTRU is not None or
            self.productName is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'country':
            obj_ = zfcs_countryRef.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.country = obj_
            obj_.original_tagname_ = 'country'
        elif nodeName_ == 'sid' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'sid')
            ival_ = self.gds_validate_integer(ival_, node, 'sid')
            self.sid = ival_
            self.sid_nsprefix_ = child_.prefix
        elif nodeName_ == 'externalSid':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'externalSid')
            value_ = self.gds_validate_string(value_, node, 'externalSid')
            self.externalSid = value_
            self.externalSid_nsprefix_ = child_.prefix
            # validate type externalIdType
            self.validate_externalIdType(self.externalSid)
        elif nodeName_ == 'OKPD':
            obj_ = zfcs_OKPDRef.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.OKPD = obj_
            obj_.original_tagname_ = 'OKPD'
        elif nodeName_ == 'OKPD2':
            obj_ = zfcs_OKPDRef.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.OKPD2 = obj_
            obj_.original_tagname_ = 'OKPD2'
        elif nodeName_ == 'KTRU':
            class_obj_ = self.get_class_obj_(child_, zfcs_KTRURef)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.KTRU = obj_
            obj_.original_tagname_ = 'KTRU'
        elif nodeName_ == 'productName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'productName')
            value_ = self.gds_validate_string(value_, node, 'productName')
            self.productName = value_
            self.productName_nsprefix_ = child_.prefix
            # validate type zfcs_longTextMinType
            self.validate_zfcs_longTextMinType(self.productName)
# end class zfcs_contractProcedure2015ProductsCountryType


class zfcs_contractProcedure2015BankGuaranteePaymentType(GeneratedsSuper):
    """Тип: Информация об уплате по банковской гарантии в информации об
    исполнении (исполнении обязательств по предоставленной гарантии
    качества, расторжении) контракта"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'regNumber': MemberSpec_('regNumber', ['bankGuaranteeRegNumberType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'regNumber', 'type': 'xs:string'}, 59),
        'regNumberNotPublishedOnEIS': MemberSpec_('regNumberNotPublishedOnEIS', 'xs:boolean', 0, 0, {'fixed': 'true', 'name': 'regNumberNotPublishedOnEIS', 'type': 'xs:boolean'}, 59),
        'docNumber': MemberSpec_('docNumber', ['bankGuaranteeDocNumberType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'docNumber', 'type': 'xs:string'}, 60),
        'docNumberNotPublishedOnEIS': MemberSpec_('docNumberNotPublishedOnEIS', 'xs:boolean', 0, 0, {'fixed': 'true', 'name': 'docNumberNotPublishedOnEIS', 'type': 'xs:boolean'}, 60),
        'improperExecInfo': MemberSpec_('improperExecInfo', ['zfcs_longTextMinType', 'xs:string'], 0, 0, {'name': 'improperExecInfo', 'type': 'xs:string'}, None),
        'requirements': MemberSpec_('requirements', 'requirements', 0, 1, {'minOccurs': '0', 'name': 'requirements', 'type': 'requirements'}, None),
        'paid': MemberSpec_('paid', 'paid', 0, 1, {'minOccurs': '0', 'name': 'paid', 'type': 'paid'}, None),
        'bankCancelDetails': MemberSpec_('bankCancelDetails', ['bankCancelDetails', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'bankCancelDetails', 'type': 'xs:string'}, None),
        'improperGuaranteePaymentInfo': MemberSpec_('improperGuaranteePaymentInfo', ['zfcs_longTextMinType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'improperGuaranteePaymentInfo', 'type': 'xs:string'}, None),
        'restructure': MemberSpec_('restructure', 'restructure', 0, 1, {'minOccurs': '0', 'name': 'restructure', 'type': 'restructure'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, regNumber=None, regNumberNotPublishedOnEIS=None, docNumber=None, docNumberNotPublishedOnEIS=None, improperExecInfo=None, requirements=None, paid=None, bankCancelDetails=None, improperGuaranteePaymentInfo=None, restructure=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.regNumber = regNumber
        self.validate_bankGuaranteeRegNumberType(self.regNumber)
        self.regNumber_nsprefix_ = None
        self.regNumberNotPublishedOnEIS = regNumberNotPublishedOnEIS
        self.regNumberNotPublishedOnEIS_nsprefix_ = None
        self.docNumber = docNumber
        self.validate_bankGuaranteeDocNumberType(self.docNumber)
        self.docNumber_nsprefix_ = None
        self.docNumberNotPublishedOnEIS = docNumberNotPublishedOnEIS
        self.docNumberNotPublishedOnEIS_nsprefix_ = None
        self.improperExecInfo = improperExecInfo
        self.validate_zfcs_longTextMinType(self.improperExecInfo)
        self.improperExecInfo_nsprefix_ = None
        self.requirements = requirements
        self.requirements_nsprefix_ = None
        self.paid = paid
        self.paid_nsprefix_ = None
        self.bankCancelDetails = bankCancelDetails
        self.bankCancelDetails_nsprefix_ = None
        self.improperGuaranteePaymentInfo = improperGuaranteePaymentInfo
        self.validate_zfcs_longTextMinType(self.improperGuaranteePaymentInfo)
        self.improperGuaranteePaymentInfo_nsprefix_ = None
        self.restructure = restructure
        self.restructure_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, zfcs_contractProcedure2015BankGuaranteePaymentType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if zfcs_contractProcedure2015BankGuaranteePaymentType.subclass:
            return zfcs_contractProcedure2015BankGuaranteePaymentType.subclass(*args_, **kwargs_)
        else:
            return zfcs_contractProcedure2015BankGuaranteePaymentType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_bankGuaranteeRegNumberType(self, value):
        result = True
        # Validate type bankGuaranteeRegNumberType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 20:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on bankGuaranteeRegNumberType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on bankGuaranteeRegNumberType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_bankGuaranteeDocNumberType(self, value):
        result = True
        # Validate type bankGuaranteeDocNumberType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 23:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on bankGuaranteeDocNumberType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on bankGuaranteeDocNumberType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_zfcs_longTextMinType(self, value):
        result = True
        # Validate type zfcs_longTextMinType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 2000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on zfcs_longTextMinType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on zfcs_longTextMinType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.regNumber is not None or
            self.regNumberNotPublishedOnEIS is not None or
            self.docNumber is not None or
            self.docNumberNotPublishedOnEIS is not None or
            self.improperExecInfo is not None or
            self.requirements is not None or
            self.paid is not None or
            self.bankCancelDetails is not None or
            self.improperGuaranteePaymentInfo is not None or
            self.restructure is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'regNumber':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'regNumber')
            value_ = self.gds_validate_string(value_, node, 'regNumber')
            self.regNumber = value_
            self.regNumber_nsprefix_ = child_.prefix
            # validate type bankGuaranteeRegNumberType
            self.validate_bankGuaranteeRegNumberType(self.regNumber)
        elif nodeName_ == 'regNumberNotPublishedOnEIS':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'regNumberNotPublishedOnEIS')
            ival_ = self.gds_validate_boolean(ival_, node, 'regNumberNotPublishedOnEIS')
            self.regNumberNotPublishedOnEIS = ival_
            self.regNumberNotPublishedOnEIS_nsprefix_ = child_.prefix
        elif nodeName_ == 'docNumber':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'docNumber')
            value_ = self.gds_validate_string(value_, node, 'docNumber')
            self.docNumber = value_
            self.docNumber_nsprefix_ = child_.prefix
            # validate type bankGuaranteeDocNumberType
            self.validate_bankGuaranteeDocNumberType(self.docNumber)
        elif nodeName_ == 'docNumberNotPublishedOnEIS':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'docNumberNotPublishedOnEIS')
            ival_ = self.gds_validate_boolean(ival_, node, 'docNumberNotPublishedOnEIS')
            self.docNumberNotPublishedOnEIS = ival_
            self.docNumberNotPublishedOnEIS_nsprefix_ = child_.prefix
        elif nodeName_ == 'improperExecInfo':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'improperExecInfo')
            value_ = self.gds_validate_string(value_, node, 'improperExecInfo')
            self.improperExecInfo = value_
            self.improperExecInfo_nsprefix_ = child_.prefix
            # validate type zfcs_longTextMinType
            self.validate_zfcs_longTextMinType(self.improperExecInfo)
        elif nodeName_ == 'requirements':
            obj_ = requirements.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.requirements = obj_
            obj_.original_tagname_ = 'requirements'
        elif nodeName_ == 'paid':
            obj_ = paid.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.paid = obj_
            obj_.original_tagname_ = 'paid'
        elif nodeName_ == 'bankCancelDetails':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'bankCancelDetails')
            value_ = self.gds_validate_string(value_, node, 'bankCancelDetails')
            self.bankCancelDetails = value_
            self.bankCancelDetails_nsprefix_ = child_.prefix
        elif nodeName_ == 'improperGuaranteePaymentInfo':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'improperGuaranteePaymentInfo')
            value_ = self.gds_validate_string(value_, node, 'improperGuaranteePaymentInfo')
            self.improperGuaranteePaymentInfo = value_
            self.improperGuaranteePaymentInfo_nsprefix_ = child_.prefix
            # validate type zfcs_longTextMinType
            self.validate_zfcs_longTextMinType(self.improperGuaranteePaymentInfo)
        elif nodeName_ == 'restructure':
            obj_ = restructure.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.restructure = obj_
            obj_.original_tagname_ = 'restructure'
# end class zfcs_contractProcedure2015BankGuaranteePaymentType


class requirements(GeneratedsSuper):
    """Требования об уплате"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'requirementsDate': MemberSpec_('requirementsDate', 'xs:date', 0, 0, {'name': 'requirementsDate', 'type': 'xs:date'}, None),
        'paymentAmount': MemberSpec_('paymentAmount', ['moneyPositiveType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'paymentAmount', 'type': 'xs:string'}, None),
        'paymentAmountDetail': MemberSpec_('paymentAmountDetail', 'paymentAmountDetail', 0, 1, {'minOccurs': '0', 'name': 'paymentAmountDetail', 'type': 'paymentAmountDetail'}, None),
        'currency': MemberSpec_('currency', 'zfcs_currencyRef', 0, 1, {'minOccurs': '0', 'name': 'currency', 'type': 'zfcs_currencyRef'}, None),
        'currencyRate': MemberSpec_('currencyRate', 'zfcs_currencyRateContract2015', 0, 1, {'minOccurs': '0', 'name': 'currencyRate', 'type': 'zfcs_currencyRateContract2015'}, None),
        'paymentAmountRUR': MemberSpec_('paymentAmountRUR', ['moneyPositiveType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'paymentAmountRUR', 'type': 'xs:string'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, requirementsDate=None, paymentAmount=None, paymentAmountDetail=None, currency=None, currencyRate=None, paymentAmountRUR=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if isinstance(requirementsDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(requirementsDate, '%Y-%m-%d').date()
        else:
            initvalue_ = requirementsDate
        self.requirementsDate = initvalue_
        self.requirementsDate_nsprefix_ = None
        self.paymentAmount = paymentAmount
        self.validate_moneyPositiveType(self.paymentAmount)
        self.paymentAmount_nsprefix_ = None
        self.paymentAmountDetail = paymentAmountDetail
        self.paymentAmountDetail_nsprefix_ = None
        self.currency = currency
        self.currency_nsprefix_ = None
        self.currencyRate = currencyRate
        self.currencyRate_nsprefix_ = None
        self.paymentAmountRUR = paymentAmountRUR
        self.validate_moneyPositiveType(self.paymentAmountRUR)
        self.paymentAmountRUR_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, requirements)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if requirements.subclass:
            return requirements.subclass(*args_, **kwargs_)
        else:
            return requirements(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_moneyPositiveType(self, value):
        result = True
        # Validate type moneyPositiveType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 21:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on moneyPositiveType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on moneyPositiveType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_moneyPositiveType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_moneyPositiveType_patterns_, ))
                result = False
        return result
    validate_moneyPositiveType_patterns_ = [['^(\\d+(\\.\\d{1,2})?)$']]
    def hasContent_(self):
        if (
            self.requirementsDate is not None or
            self.paymentAmount is not None or
            self.paymentAmountDetail is not None or
            self.currency is not None or
            self.currencyRate is not None or
            self.paymentAmountRUR is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'requirementsDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.requirementsDate = dval_
            self.requirementsDate_nsprefix_ = child_.prefix
        elif nodeName_ == 'paymentAmount':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'paymentAmount')
            value_ = self.gds_validate_string(value_, node, 'paymentAmount')
            self.paymentAmount = value_
            self.paymentAmount_nsprefix_ = child_.prefix
            # validate type moneyPositiveType
            self.validate_moneyPositiveType(self.paymentAmount)
        elif nodeName_ == 'paymentAmountDetail':
            obj_ = paymentAmountDetail.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.paymentAmountDetail = obj_
            obj_.original_tagname_ = 'paymentAmountDetail'
        elif nodeName_ == 'currency':
            obj_ = zfcs_currencyRef.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.currency = obj_
            obj_.original_tagname_ = 'currency'
        elif nodeName_ == 'currencyRate':
            obj_ = zfcs_currencyRateContract2015.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.currencyRate = obj_
            obj_.original_tagname_ = 'currencyRate'
        elif nodeName_ == 'paymentAmountRUR':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'paymentAmountRUR')
            value_ = self.gds_validate_string(value_, node, 'paymentAmountRUR')
            self.paymentAmountRUR = value_
            self.paymentAmountRUR_nsprefix_ = child_.prefix
            # validate type moneyPositiveType
            self.validate_moneyPositiveType(self.paymentAmountRUR)
# end class requirements


class paymentAmountDetail(GeneratedsSuper):
    """Детализация суммы, требуемой к уплате"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'refundAmount': MemberSpec_('refundAmount', ['moneyPositiveType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'refundAmount', 'type': 'xs:string'}, None),
        'penaltiesAmount': MemberSpec_('penaltiesAmount', ['moneyPositiveType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'penaltiesAmount', 'type': 'xs:string'}, None),
        'lossNotCoveredAmount': MemberSpec_('lossNotCoveredAmount', ['moneyPositiveType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'lossNotCoveredAmount', 'type': 'xs:string'}, None),
        'warrantyAmount': MemberSpec_('warrantyAmount', ['moneyPositiveType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'warrantyAmount', 'type': 'xs:string'}, None),
        'otherAmount': MemberSpec_('otherAmount', ['moneyPositiveType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'otherAmount', 'type': 'xs:string'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, refundAmount=None, penaltiesAmount=None, lossNotCoveredAmount=None, warrantyAmount=None, otherAmount=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.refundAmount = refundAmount
        self.validate_moneyPositiveType(self.refundAmount)
        self.refundAmount_nsprefix_ = None
        self.penaltiesAmount = penaltiesAmount
        self.validate_moneyPositiveType(self.penaltiesAmount)
        self.penaltiesAmount_nsprefix_ = None
        self.lossNotCoveredAmount = lossNotCoveredAmount
        self.validate_moneyPositiveType(self.lossNotCoveredAmount)
        self.lossNotCoveredAmount_nsprefix_ = None
        self.warrantyAmount = warrantyAmount
        self.validate_moneyPositiveType(self.warrantyAmount)
        self.warrantyAmount_nsprefix_ = None
        self.otherAmount = otherAmount
        self.validate_moneyPositiveType(self.otherAmount)
        self.otherAmount_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, paymentAmountDetail)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if paymentAmountDetail.subclass:
            return paymentAmountDetail.subclass(*args_, **kwargs_)
        else:
            return paymentAmountDetail(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_moneyPositiveType(self, value):
        result = True
        # Validate type moneyPositiveType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 21:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on moneyPositiveType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on moneyPositiveType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_moneyPositiveType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_moneyPositiveType_patterns_, ))
                result = False
        return result
    validate_moneyPositiveType_patterns_ = [['^(\\d+(\\.\\d{1,2})?)$']]
    def hasContent_(self):
        if (
            self.refundAmount is not None or
            self.penaltiesAmount is not None or
            self.lossNotCoveredAmount is not None or
            self.warrantyAmount is not None or
            self.otherAmount is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'refundAmount':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'refundAmount')
            value_ = self.gds_validate_string(value_, node, 'refundAmount')
            self.refundAmount = value_
            self.refundAmount_nsprefix_ = child_.prefix
            # validate type moneyPositiveType
            self.validate_moneyPositiveType(self.refundAmount)
        elif nodeName_ == 'penaltiesAmount':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'penaltiesAmount')
            value_ = self.gds_validate_string(value_, node, 'penaltiesAmount')
            self.penaltiesAmount = value_
            self.penaltiesAmount_nsprefix_ = child_.prefix
            # validate type moneyPositiveType
            self.validate_moneyPositiveType(self.penaltiesAmount)
        elif nodeName_ == 'lossNotCoveredAmount':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'lossNotCoveredAmount')
            value_ = self.gds_validate_string(value_, node, 'lossNotCoveredAmount')
            self.lossNotCoveredAmount = value_
            self.lossNotCoveredAmount_nsprefix_ = child_.prefix
            # validate type moneyPositiveType
            self.validate_moneyPositiveType(self.lossNotCoveredAmount)
        elif nodeName_ == 'warrantyAmount':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'warrantyAmount')
            value_ = self.gds_validate_string(value_, node, 'warrantyAmount')
            self.warrantyAmount = value_
            self.warrantyAmount_nsprefix_ = child_.prefix
            # validate type moneyPositiveType
            self.validate_moneyPositiveType(self.warrantyAmount)
        elif nodeName_ == 'otherAmount':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'otherAmount')
            value_ = self.gds_validate_string(value_, node, 'otherAmount')
            self.otherAmount = value_
            self.otherAmount_nsprefix_ = child_.prefix
            # validate type moneyPositiveType
            self.validate_moneyPositiveType(self.otherAmount)
# end class paymentAmountDetail


class paid(GeneratedsSuper):
    """Факт оплаты"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'name': MemberSpec_('name', ['name', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'name', 'type': 'xs:string'}, None),
        'documentDate': MemberSpec_('documentDate', 'xs:date', 0, 0, {'name': 'documentDate', 'type': 'xs:date'}, None),
        'documentNum': MemberSpec_('documentNum', ['documentNum', 'xs:string'], 0, 0, {'name': 'documentNum', 'type': 'xs:string'}, None),
        'currency': MemberSpec_('currency', 'zfcs_currencyRef', 0, 1, {'minOccurs': '0', 'name': 'currency', 'type': 'zfcs_currencyRef'}, None),
        'bankPaid': MemberSpec_('bankPaid', ['moneyPositiveType', 'xs:string'], 0, 0, {'name': 'bankPaid', 'type': 'xs:string'}, None),
        'currencyRate': MemberSpec_('currencyRate', 'zfcs_currencyRateContract2015', 0, 1, {'minOccurs': '0', 'name': 'currencyRate', 'type': 'zfcs_currencyRateContract2015'}, None),
        'bankPaidRUR': MemberSpec_('bankPaidRUR', ['moneyPositiveType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'bankPaidRUR', 'type': 'xs:string'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, name=None, documentDate=None, documentNum=None, currency=None, bankPaid=None, currencyRate=None, bankPaidRUR=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.name = name
        self.name_nsprefix_ = None
        if isinstance(documentDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(documentDate, '%Y-%m-%d').date()
        else:
            initvalue_ = documentDate
        self.documentDate = initvalue_
        self.documentDate_nsprefix_ = None
        self.documentNum = documentNum
        self.documentNum_nsprefix_ = None
        self.currency = currency
        self.currency_nsprefix_ = None
        self.bankPaid = bankPaid
        self.validate_moneyPositiveType(self.bankPaid)
        self.bankPaid_nsprefix_ = None
        self.currencyRate = currencyRate
        self.currencyRate_nsprefix_ = None
        self.bankPaidRUR = bankPaidRUR
        self.validate_moneyPositiveType(self.bankPaidRUR)
        self.bankPaidRUR_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, paid)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if paid.subclass:
            return paid.subclass(*args_, **kwargs_)
        else:
            return paid(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_moneyPositiveType(self, value):
        result = True
        # Validate type moneyPositiveType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 21:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on moneyPositiveType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on moneyPositiveType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_moneyPositiveType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_moneyPositiveType_patterns_, ))
                result = False
        return result
    validate_moneyPositiveType_patterns_ = [['^(\\d+(\\.\\d{1,2})?)$']]
    def hasContent_(self):
        if (
            self.name is not None or
            self.documentDate is not None or
            self.documentNum is not None or
            self.currency is not None or
            self.bankPaid is not None or
            self.currencyRate is not None or
            self.bankPaidRUR is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'name')
            value_ = self.gds_validate_string(value_, node, 'name')
            self.name = value_
            self.name_nsprefix_ = child_.prefix
        elif nodeName_ == 'documentDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.documentDate = dval_
            self.documentDate_nsprefix_ = child_.prefix
        elif nodeName_ == 'documentNum':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'documentNum')
            value_ = self.gds_validate_string(value_, node, 'documentNum')
            self.documentNum = value_
            self.documentNum_nsprefix_ = child_.prefix
        elif nodeName_ == 'currency':
            obj_ = zfcs_currencyRef.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.currency = obj_
            obj_.original_tagname_ = 'currency'
        elif nodeName_ == 'bankPaid':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'bankPaid')
            value_ = self.gds_validate_string(value_, node, 'bankPaid')
            self.bankPaid = value_
            self.bankPaid_nsprefix_ = child_.prefix
            # validate type moneyPositiveType
            self.validate_moneyPositiveType(self.bankPaid)
        elif nodeName_ == 'currencyRate':
            obj_ = zfcs_currencyRateContract2015.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.currencyRate = obj_
            obj_.original_tagname_ = 'currencyRate'
        elif nodeName_ == 'bankPaidRUR':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'bankPaidRUR')
            value_ = self.gds_validate_string(value_, node, 'bankPaidRUR')
            self.bankPaidRUR = value_
            self.bankPaidRUR_nsprefix_ = child_.prefix
            # validate type moneyPositiveType
            self.validate_moneyPositiveType(self.bankPaidRUR)
# end class paid


class bankCancelDetails(GeneratedsSuper):
    """Дата и номер уведомления банка об отказе в удовлетворении требования"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, bankCancelDetails)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if bankCancelDetails.subclass:
            return bankCancelDetails.subclass(*args_, **kwargs_)
        else:
            return bankCancelDetails(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_bankCancelDetails(self, value):
        result = True
        # Validate type bankCancelDetails, a restriction on xs:string.
        pass
        return result
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class bankCancelDetails


class restructure(GeneratedsSuper):
    """Информация о реструктуризации в 2015 году задолженности банка, возникшей
    в связи с предъявлением требований к исполнению банковской гарантии"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'restructureDate': MemberSpec_('restructureDate', 'xs:date', 0, 0, {'name': 'restructureDate', 'type': 'xs:date'}, None),
        'restructureAmount': MemberSpec_('restructureAmount', ['moneyPositiveType', 'xs:string'], 0, 0, {'name': 'restructureAmount', 'type': 'xs:string'}, None),
        'repaymentSchedule': MemberSpec_('repaymentSchedule', ['zfcs_longTextMinType', 'xs:string'], 0, 0, {'name': 'repaymentSchedule', 'type': 'xs:string'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, restructureDate=None, restructureAmount=None, repaymentSchedule=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if isinstance(restructureDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(restructureDate, '%Y-%m-%d').date()
        else:
            initvalue_ = restructureDate
        self.restructureDate = initvalue_
        self.restructureDate_nsprefix_ = None
        self.restructureAmount = restructureAmount
        self.validate_moneyPositiveType(self.restructureAmount)
        self.restructureAmount_nsprefix_ = None
        self.repaymentSchedule = repaymentSchedule
        self.validate_zfcs_longTextMinType(self.repaymentSchedule)
        self.repaymentSchedule_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, restructure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if restructure.subclass:
            return restructure.subclass(*args_, **kwargs_)
        else:
            return restructure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_moneyPositiveType(self, value):
        result = True
        # Validate type moneyPositiveType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 21:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on moneyPositiveType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on moneyPositiveType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_moneyPositiveType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_moneyPositiveType_patterns_, ))
                result = False
        return result
    validate_moneyPositiveType_patterns_ = [['^(\\d+(\\.\\d{1,2})?)$']]
    def validate_zfcs_longTextMinType(self, value):
        result = True
        # Validate type zfcs_longTextMinType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 2000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on zfcs_longTextMinType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on zfcs_longTextMinType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.restructureDate is not None or
            self.restructureAmount is not None or
            self.repaymentSchedule is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'restructureDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.restructureDate = dval_
            self.restructureDate_nsprefix_ = child_.prefix
        elif nodeName_ == 'restructureAmount':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'restructureAmount')
            value_ = self.gds_validate_string(value_, node, 'restructureAmount')
            self.restructureAmount = value_
            self.restructureAmount_nsprefix_ = child_.prefix
            # validate type moneyPositiveType
            self.validate_moneyPositiveType(self.restructureAmount)
        elif nodeName_ == 'repaymentSchedule':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'repaymentSchedule')
            value_ = self.gds_validate_string(value_, node, 'repaymentSchedule')
            self.repaymentSchedule = value_
            self.repaymentSchedule_nsprefix_ = child_.prefix
            # validate type zfcs_longTextMinType
            self.validate_zfcs_longTextMinType(self.repaymentSchedule)
# end class restructure


class zfcs_contractProcedure2015HoldCashEnforcementType(GeneratedsSuper):
    """Тип: Сведения об удержании денежных средств, перечисленных в качестве
    обеспечения исполнения контракта (исполнения обязательств по гарантии
    качества товаров, работ, услуг)"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'improperSupplierInfo': MemberSpec_('improperSupplierInfo', ['zfcs_longTextMinType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'improperSupplierInfo', 'type': 'xs:string'}, None),
        'currency': MemberSpec_('currency', 'zfcs_currencyRef', 0, 1, {'minOccurs': '0', 'name': 'currency', 'type': 'zfcs_currencyRef'}, None),
        'holdAmount': MemberSpec_('holdAmount', ['moneyPositiveType', 'xs:string'], 0, 0, {'name': 'holdAmount', 'type': 'xs:string'}, None),
        'holdDate': MemberSpec_('holdDate', 'xs:date', 0, 1, {'minOccurs': '0', 'name': 'holdDate', 'type': 'xs:date'}, None),
        'currencyRate': MemberSpec_('currencyRate', 'zfcs_currencyRateContract2015', 0, 1, {'minOccurs': '0', 'name': 'currencyRate', 'type': 'zfcs_currencyRateContract2015'}, None),
        'holdAmountRUR': MemberSpec_('holdAmountRUR', ['moneyPositiveType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'holdAmountRUR', 'type': 'xs:string'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, improperSupplierInfo=None, currency=None, holdAmount=None, holdDate=None, currencyRate=None, holdAmountRUR=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.improperSupplierInfo = improperSupplierInfo
        self.validate_zfcs_longTextMinType(self.improperSupplierInfo)
        self.improperSupplierInfo_nsprefix_ = None
        self.currency = currency
        self.currency_nsprefix_ = None
        self.holdAmount = holdAmount
        self.validate_moneyPositiveType(self.holdAmount)
        self.holdAmount_nsprefix_ = None
        if isinstance(holdDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(holdDate, '%Y-%m-%d').date()
        else:
            initvalue_ = holdDate
        self.holdDate = initvalue_
        self.holdDate_nsprefix_ = None
        self.currencyRate = currencyRate
        self.currencyRate_nsprefix_ = None
        self.holdAmountRUR = holdAmountRUR
        self.validate_moneyPositiveType(self.holdAmountRUR)
        self.holdAmountRUR_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, zfcs_contractProcedure2015HoldCashEnforcementType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if zfcs_contractProcedure2015HoldCashEnforcementType.subclass:
            return zfcs_contractProcedure2015HoldCashEnforcementType.subclass(*args_, **kwargs_)
        else:
            return zfcs_contractProcedure2015HoldCashEnforcementType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_zfcs_longTextMinType(self, value):
        result = True
        # Validate type zfcs_longTextMinType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 2000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on zfcs_longTextMinType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on zfcs_longTextMinType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_moneyPositiveType(self, value):
        result = True
        # Validate type moneyPositiveType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 21:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on moneyPositiveType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on moneyPositiveType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_moneyPositiveType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_moneyPositiveType_patterns_, ))
                result = False
        return result
    validate_moneyPositiveType_patterns_ = [['^(\\d+(\\.\\d{1,2})?)$']]
    def hasContent_(self):
        if (
            self.improperSupplierInfo is not None or
            self.currency is not None or
            self.holdAmount is not None or
            self.holdDate is not None or
            self.currencyRate is not None or
            self.holdAmountRUR is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'improperSupplierInfo':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'improperSupplierInfo')
            value_ = self.gds_validate_string(value_, node, 'improperSupplierInfo')
            self.improperSupplierInfo = value_
            self.improperSupplierInfo_nsprefix_ = child_.prefix
            # validate type zfcs_longTextMinType
            self.validate_zfcs_longTextMinType(self.improperSupplierInfo)
        elif nodeName_ == 'currency':
            obj_ = zfcs_currencyRef.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.currency = obj_
            obj_.original_tagname_ = 'currency'
        elif nodeName_ == 'holdAmount':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'holdAmount')
            value_ = self.gds_validate_string(value_, node, 'holdAmount')
            self.holdAmount = value_
            self.holdAmount_nsprefix_ = child_.prefix
            # validate type moneyPositiveType
            self.validate_moneyPositiveType(self.holdAmount)
        elif nodeName_ == 'holdDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.holdDate = dval_
            self.holdDate_nsprefix_ = child_.prefix
        elif nodeName_ == 'currencyRate':
            obj_ = zfcs_currencyRateContract2015.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.currencyRate = obj_
            obj_.original_tagname_ = 'currencyRate'
        elif nodeName_ == 'holdAmountRUR':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'holdAmountRUR')
            value_ = self.gds_validate_string(value_, node, 'holdAmountRUR')
            self.holdAmountRUR = value_
            self.holdAmountRUR_nsprefix_ = child_.prefix
            # validate type moneyPositiveType
            self.validate_moneyPositiveType(self.holdAmountRUR)
# end class zfcs_contractProcedure2015HoldCashEnforcementType


class zfcs_contractProcedure2015SearchProductsAttrsType(GeneratedsSuper):
    """Тип: Реквизиты предмета контракта для поиска в исполнении контракта"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'OKPD': MemberSpec_('OKPD', 'zfcs_OKPDRef', 0, 0, {'name': 'OKPD', 'type': 'zfcs_OKPDRef'}, 61),
        'OKPD2': MemberSpec_('OKPD2', 'OKPD2', 0, 0, {'name': 'OKPD2', 'type': 'zfcs_OKPDRef'}, 61),
        'KTRU': MemberSpec_('KTRU', 'KTRU', 0, 0, {'name': 'KTRU', 'type': 'zfcs_KTRURef'}, 61),
        'name': MemberSpec_('name', ['zfcs_longTextMinType', 'xs:string'], 0, 0, {'name': 'name', 'type': 'xs:string'}, None),
        'OKEI': MemberSpec_('OKEI', 'zfcs_contract.OKEIType', 0, 0, {'name': 'OKEI', 'type': 'zfcs_contract.OKEIType'}, None),
        'price': MemberSpec_('price', ['moneyLongType', 'xs:string'], 0, 0, {'name': 'price', 'type': 'xs:string'}, None),
        'quantity': MemberSpec_('quantity', ['quantity18p11Type', 'xs:decimal'], 0, 1, {'minOccurs': '0', 'name': 'quantity', 'type': 'xs:decimal'}, 62),
        'volumeTextForm': MemberSpec_('volumeTextForm', ['text500Type', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'volumeTextForm', 'type': 'xs:string'}, 62),
        'sum': MemberSpec_('sum', ['moneyPositiveType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'sum', 'type': 'xs:string'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, OKPD=None, OKPD2=None, KTRU=None, name=None, OKEI=None, price=None, quantity=None, volumeTextForm=None, sum=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.OKPD = OKPD
        self.OKPD_nsprefix_ = None
        self.OKPD2 = OKPD2
        self.OKPD2_nsprefix_ = None
        self.KTRU = KTRU
        self.KTRU_nsprefix_ = None
        self.name = name
        self.validate_zfcs_longTextMinType(self.name)
        self.name_nsprefix_ = None
        self.OKEI = OKEI
        self.OKEI_nsprefix_ = None
        self.price = price
        self.validate_moneyLongType(self.price)
        self.price_nsprefix_ = None
        self.quantity = quantity
        self.validate_quantity18p11Type(self.quantity)
        self.quantity_nsprefix_ = None
        self.volumeTextForm = volumeTextForm
        self.validate_text500Type(self.volumeTextForm)
        self.volumeTextForm_nsprefix_ = None
        self.sum = sum
        self.validate_moneyPositiveType(self.sum)
        self.sum_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, zfcs_contractProcedure2015SearchProductsAttrsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if zfcs_contractProcedure2015SearchProductsAttrsType.subclass:
            return zfcs_contractProcedure2015SearchProductsAttrsType.subclass(*args_, **kwargs_)
        else:
            return zfcs_contractProcedure2015SearchProductsAttrsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_zfcs_longTextMinType(self, value):
        result = True
        # Validate type zfcs_longTextMinType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 2000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on zfcs_longTextMinType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on zfcs_longTextMinType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_moneyLongType(self, value):
        result = True
        # Validate type moneyLongType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 30:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on moneyLongType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on moneyLongType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_moneyLongType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_moneyLongType_patterns_, ))
                result = False
        return result
    validate_moneyLongType_patterns_ = [['^((-)?\\d+(\\.\\d{1,11})?)$']]
    def validate_quantity18p11Type(self, value):
        result = True
        # Validate type quantity18p11Type, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, decimal_.Decimal):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (decimal_.Decimal)' % {"value": value, "lineno": lineno, })
                return False
            if len(str(value)) >= 29:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd totalDigits restriction on quantity18p11Type' % {"value": value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_quantity18p11Type_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_quantity18p11Type_patterns_, ))
                result = False
        return result
    validate_quantity18p11Type_patterns_ = [['^(\\d{1,18}(\\.\\d{1,11})?)$']]
    def validate_text500Type(self, value):
        result = True
        # Validate type text500Type, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 500:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on text500Type' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on text500Type' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_moneyPositiveType(self, value):
        result = True
        # Validate type moneyPositiveType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 21:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on moneyPositiveType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on moneyPositiveType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_moneyPositiveType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_moneyPositiveType_patterns_, ))
                result = False
        return result
    validate_moneyPositiveType_patterns_ = [['^(\\d+(\\.\\d{1,2})?)$']]
    def hasContent_(self):
        if (
            self.OKPD is not None or
            self.OKPD2 is not None or
            self.KTRU is not None or
            self.name is not None or
            self.OKEI is not None or
            self.price is not None or
            self.quantity is not None or
            self.volumeTextForm is not None or
            self.sum is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'OKPD':
            obj_ = zfcs_OKPDRef.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.OKPD = obj_
            obj_.original_tagname_ = 'OKPD'
        elif nodeName_ == 'OKPD2':
            obj_ = zfcs_OKPDRef.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.OKPD2 = obj_
            obj_.original_tagname_ = 'OKPD2'
        elif nodeName_ == 'KTRU':
            class_obj_ = self.get_class_obj_(child_, zfcs_KTRURef)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.KTRU = obj_
            obj_.original_tagname_ = 'KTRU'
        elif nodeName_ == 'name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'name')
            value_ = self.gds_validate_string(value_, node, 'name')
            self.name = value_
            self.name_nsprefix_ = child_.prefix
            # validate type zfcs_longTextMinType
            self.validate_zfcs_longTextMinType(self.name)
        elif nodeName_ == 'OKEI':
            obj_ = zfcs_contract_OKEIType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.OKEI = obj_
            obj_.original_tagname_ = 'OKEI'
        elif nodeName_ == 'price':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'price')
            value_ = self.gds_validate_string(value_, node, 'price')
            self.price = value_
            self.price_nsprefix_ = child_.prefix
            # validate type moneyLongType
            self.validate_moneyLongType(self.price)
        elif nodeName_ == 'quantity' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'quantity')
            fval_ = self.gds_validate_decimal(fval_, node, 'quantity')
            self.quantity = fval_
            self.quantity_nsprefix_ = child_.prefix
            # validate type quantity18p11Type
            self.validate_quantity18p11Type(self.quantity)
        elif nodeName_ == 'volumeTextForm':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'volumeTextForm')
            value_ = self.gds_validate_string(value_, node, 'volumeTextForm')
            self.volumeTextForm = value_
            self.volumeTextForm_nsprefix_ = child_.prefix
            # validate type text500Type
            self.validate_text500Type(self.volumeTextForm)
        elif nodeName_ == 'sum':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'sum')
            value_ = self.gds_validate_string(value_, node, 'sum')
            self.sum = value_
            self.sum_nsprefix_ = child_.prefix
            # validate type moneyPositiveType
            self.validate_moneyPositiveType(self.sum)
# end class zfcs_contractProcedure2015SearchProductsAttrsType


class zfcs_contractProcedure2015SearchDrugProductsAttrsType(GeneratedsSuper):
    """Тип: Реквизиты предмета контракта-лекарственного препарата для поиска в
    исполнении контракта"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'drugInfoUsingReferenceInfo': MemberSpec_('drugInfoUsingReferenceInfo', 'drugInfoUsingReferenceInfo', 0, 0, {'name': 'drugInfoUsingReferenceInfo', 'type': 'drugInfoUsingReferenceInfo'}, 63),
        'drugInfoUsingTextForm': MemberSpec_('drugInfoUsingTextForm', 'drugInfoUsingTextForm', 0, 0, {'name': 'drugInfoUsingTextForm', 'type': 'drugInfoUsingTextForm'}, 63),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, drugInfoUsingReferenceInfo=None, drugInfoUsingTextForm=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.drugInfoUsingReferenceInfo = drugInfoUsingReferenceInfo
        self.drugInfoUsingReferenceInfo_nsprefix_ = None
        self.drugInfoUsingTextForm = drugInfoUsingTextForm
        self.drugInfoUsingTextForm_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, zfcs_contractProcedure2015SearchDrugProductsAttrsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if zfcs_contractProcedure2015SearchDrugProductsAttrsType.subclass:
            return zfcs_contractProcedure2015SearchDrugProductsAttrsType.subclass(*args_, **kwargs_)
        else:
            return zfcs_contractProcedure2015SearchDrugProductsAttrsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.drugInfoUsingReferenceInfo is not None or
            self.drugInfoUsingTextForm is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'drugInfoUsingReferenceInfo':
            obj_ = drugInfoUsingReferenceInfo.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.drugInfoUsingReferenceInfo = obj_
            obj_.original_tagname_ = 'drugInfoUsingReferenceInfo'
        elif nodeName_ == 'drugInfoUsingTextForm':
            obj_ = drugInfoUsingTextForm.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.drugInfoUsingTextForm = obj_
            obj_.original_tagname_ = 'drugInfoUsingTextForm'
# end class zfcs_contractProcedure2015SearchDrugProductsAttrsType


class manufacturerOKSMCode(GeneratedsSuper):
    """Цифровой код страны производителя"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, manufacturerOKSMCode)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if manufacturerOKSMCode.subclass:
            return manufacturerOKSMCode.subclass(*args_, **kwargs_)
        else:
            return manufacturerOKSMCode(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_manufacturerOKSMCode(self, value):
        result = True
        # Validate type manufacturerOKSMCode, a restriction on xs:string.
        pass
        return result
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class manufacturerOKSMCode


class zfcs_contract2015SubContractInfoType(GeneratedsSuper):
    """Тип: Информация о субподрядном договоре в сведениях о контракте"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'subContractDate': MemberSpec_('subContractDate', 'xs:date', 0, 0, {'name': 'subContractDate', 'type': 'xs:date'}, None),
        'subContractNumber': MemberSpec_('subContractNumber', ['subContractNumber', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'subContractNumber', 'type': 'xs:string'}, None),
        'subContractSubject': MemberSpec_('subContractSubject', ['zfcs_longTextMinType', 'xs:string'], 0, 0, {'name': 'subContractSubject', 'type': 'xs:string'}, None),
        'contractPriceSpecify': MemberSpec_('contractPriceSpecify', ['zfcs_contract2015ContractPriceSpecifyType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'contractPriceSpecify', 'type': 'xs:string'}, None),
        'quantityUndefined': MemberSpec_('quantityUndefined', 'quantityUndefined', 0, 1, {'minOccurs': '0', 'name': 'quantityUndefined', 'type': 'xs:boolean'}, None),
        'subContractPriceInfo': MemberSpec_('subContractPriceInfo', 'subContractPriceInfo', 0, 0, {'name': 'subContractPriceInfo', 'type': 'subContractPriceInfo'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, subContractDate=None, subContractNumber=None, subContractSubject=None, contractPriceSpecify=None, quantityUndefined=None, subContractPriceInfo=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if isinstance(subContractDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(subContractDate, '%Y-%m-%d').date()
        else:
            initvalue_ = subContractDate
        self.subContractDate = initvalue_
        self.subContractDate_nsprefix_ = None
        self.subContractNumber = subContractNumber
        self.subContractNumber_nsprefix_ = None
        self.subContractSubject = subContractSubject
        self.validate_zfcs_longTextMinType(self.subContractSubject)
        self.subContractSubject_nsprefix_ = None
        self.contractPriceSpecify = contractPriceSpecify
        self.validate_zfcs_contract2015ContractPriceSpecifyType(self.contractPriceSpecify)
        self.contractPriceSpecify_nsprefix_ = None
        self.quantityUndefined = quantityUndefined
        self.quantityUndefined_nsprefix_ = None
        self.subContractPriceInfo = subContractPriceInfo
        self.subContractPriceInfo_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, zfcs_contract2015SubContractInfoType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if zfcs_contract2015SubContractInfoType.subclass:
            return zfcs_contract2015SubContractInfoType.subclass(*args_, **kwargs_)
        else:
            return zfcs_contract2015SubContractInfoType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_zfcs_longTextMinType(self, value):
        result = True
        # Validate type zfcs_longTextMinType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 2000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on zfcs_longTextMinType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on zfcs_longTextMinType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_zfcs_contract2015ContractPriceSpecifyType(self, value):
        result = True
        # Validate type zfcs_contract2015ContractPriceSpecifyType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['CP', 'ACP', 'MCP']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on zfcs_contract2015ContractPriceSpecifyType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.subContractDate is not None or
            self.subContractNumber is not None or
            self.subContractSubject is not None or
            self.contractPriceSpecify is not None or
            self.quantityUndefined is not None or
            self.subContractPriceInfo is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'subContractDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.subContractDate = dval_
            self.subContractDate_nsprefix_ = child_.prefix
        elif nodeName_ == 'subContractNumber':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'subContractNumber')
            value_ = self.gds_validate_string(value_, node, 'subContractNumber')
            self.subContractNumber = value_
            self.subContractNumber_nsprefix_ = child_.prefix
        elif nodeName_ == 'subContractSubject':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'subContractSubject')
            value_ = self.gds_validate_string(value_, node, 'subContractSubject')
            self.subContractSubject = value_
            self.subContractSubject_nsprefix_ = child_.prefix
            # validate type zfcs_longTextMinType
            self.validate_zfcs_longTextMinType(self.subContractSubject)
        elif nodeName_ == 'contractPriceSpecify':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'contractPriceSpecify')
            value_ = self.gds_validate_string(value_, node, 'contractPriceSpecify')
            self.contractPriceSpecify = value_
            self.contractPriceSpecify_nsprefix_ = child_.prefix
            # validate type zfcs_contract2015ContractPriceSpecifyType
            self.validate_zfcs_contract2015ContractPriceSpecifyType(self.contractPriceSpecify)
        elif nodeName_ == 'quantityUndefined':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'quantityUndefined')
            ival_ = self.gds_validate_boolean(ival_, node, 'quantityUndefined')
            self.quantityUndefined = ival_
            self.quantityUndefined_nsprefix_ = child_.prefix
        elif nodeName_ == 'subContractPriceInfo':
            obj_ = subContractPriceInfo.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.subContractPriceInfo = obj_
            obj_.original_tagname_ = 'subContractPriceInfo'
# end class zfcs_contract2015SubContractInfoType


class subContractNumber(GeneratedsSuper):
    """Номер договора"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, subContractNumber)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if subContractNumber.subclass:
            return subContractNumber.subclass(*args_, **kwargs_)
        else:
            return subContractNumber(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_subContractNumber(self, value):
        result = True
        # Validate type subContractNumber, a restriction on xs:string.
        pass
        return result
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class subContractNumber


class subContractPriceInfo(GeneratedsSuper):
    """Информация о цене договора"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'price': MemberSpec_('price', ['moneyPositiveType', 'xs:string'], 0, 0, {'name': 'price', 'type': 'xs:string'}, None),
        'currency': MemberSpec_('currency', 'zfcs_currencyRef', 0, 0, {'name': 'currency', 'type': 'zfcs_currencyRef'}, None),
        'currencyRate': MemberSpec_('currencyRate', 'zfcs_currencyRateContract2015', 0, 1, {'minOccurs': '0', 'name': 'currencyRate', 'type': 'zfcs_currencyRateContract2015'}, None),
        'priceRUR': MemberSpec_('priceRUR', ['moneyPositiveType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'priceRUR', 'type': 'xs:string'}, None),
        'VATSum': MemberSpec_('VATSum', ['moneyMaxLengthToPoint18Type', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'VATSum', 'type': 'xs:string'}, None),
        'VATSumRUR': MemberSpec_('VATSumRUR', ['moneyMaxLengthToPoint18Type', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'VATSumRUR', 'type': 'xs:string'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, price=None, currency=None, currencyRate=None, priceRUR=None, VATSum=None, VATSumRUR=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.price = price
        self.validate_moneyPositiveType(self.price)
        self.price_nsprefix_ = None
        self.currency = currency
        self.currency_nsprefix_ = None
        self.currencyRate = currencyRate
        self.currencyRate_nsprefix_ = None
        self.priceRUR = priceRUR
        self.validate_moneyPositiveType(self.priceRUR)
        self.priceRUR_nsprefix_ = None
        self.VATSum = VATSum
        self.validate_moneyMaxLengthToPoint18Type(self.VATSum)
        self.VATSum_nsprefix_ = None
        self.VATSumRUR = VATSumRUR
        self.validate_moneyMaxLengthToPoint18Type(self.VATSumRUR)
        self.VATSumRUR_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, subContractPriceInfo)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if subContractPriceInfo.subclass:
            return subContractPriceInfo.subclass(*args_, **kwargs_)
        else:
            return subContractPriceInfo(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_moneyPositiveType(self, value):
        result = True
        # Validate type moneyPositiveType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 21:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on moneyPositiveType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on moneyPositiveType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_moneyPositiveType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_moneyPositiveType_patterns_, ))
                result = False
        return result
    validate_moneyPositiveType_patterns_ = [['^(\\d+(\\.\\d{1,2})?)$']]
    def validate_moneyMaxLengthToPoint18Type(self, value):
        result = True
        # Validate type moneyMaxLengthToPoint18Type, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 21:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on moneyMaxLengthToPoint18Type' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on moneyMaxLengthToPoint18Type' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_moneyMaxLengthToPoint18Type_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_moneyMaxLengthToPoint18Type_patterns_, ))
                result = False
        return result
    validate_moneyMaxLengthToPoint18Type_patterns_ = [['^(\\d{1,18}(\\.\\d{1,2})?)$']]
    def hasContent_(self):
        if (
            self.price is not None or
            self.currency is not None or
            self.currencyRate is not None or
            self.priceRUR is not None or
            self.VATSum is not None or
            self.VATSumRUR is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'price':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'price')
            value_ = self.gds_validate_string(value_, node, 'price')
            self.price = value_
            self.price_nsprefix_ = child_.prefix
            # validate type moneyPositiveType
            self.validate_moneyPositiveType(self.price)
        elif nodeName_ == 'currency':
            obj_ = zfcs_currencyRef.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.currency = obj_
            obj_.original_tagname_ = 'currency'
        elif nodeName_ == 'currencyRate':
            obj_ = zfcs_currencyRateContract2015.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.currencyRate = obj_
            obj_.original_tagname_ = 'currencyRate'
        elif nodeName_ == 'priceRUR':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'priceRUR')
            value_ = self.gds_validate_string(value_, node, 'priceRUR')
            self.priceRUR = value_
            self.priceRUR_nsprefix_ = child_.prefix
            # validate type moneyPositiveType
            self.validate_moneyPositiveType(self.priceRUR)
        elif nodeName_ == 'VATSum':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'VATSum')
            value_ = self.gds_validate_string(value_, node, 'VATSum')
            self.VATSum = value_
            self.VATSum_nsprefix_ = child_.prefix
            # validate type moneyMaxLengthToPoint18Type
            self.validate_moneyMaxLengthToPoint18Type(self.VATSum)
        elif nodeName_ == 'VATSumRUR':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'VATSumRUR')
            value_ = self.gds_validate_string(value_, node, 'VATSumRUR')
            self.VATSumRUR = value_
            self.VATSumRUR_nsprefix_ = child_.prefix
            # validate type moneyMaxLengthToPoint18Type
            self.validate_moneyMaxLengthToPoint18Type(self.VATSumRUR)
# end class subContractPriceInfo


class zfcs_contract2015PriceInfoType(GeneratedsSuper):
    """Тип: Информация о цене за право заключения контракта для контракта и
    выжимки контракта"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'price': MemberSpec_('price', ['moneyPositiveType', 'xs:string'], 0, 0, {'name': 'price', 'type': 'xs:string'}, None),
        'currency': MemberSpec_('currency', 'zfcs_currencyRef', 0, 0, {'name': 'currency', 'type': 'zfcs_currencyRef'}, None),
        'currencyRate': MemberSpec_('currencyRate', 'zfcs_currencyRateContract2015', 0, 1, {'minOccurs': '0', 'name': 'currencyRate', 'type': 'zfcs_currencyRateContract2015'}, None),
        'priceRUR': MemberSpec_('priceRUR', ['moneyPositiveType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'priceRUR', 'type': 'xs:string'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_) + ['extensiontype_']
    subclass = None
    superclass = None
    def __init__(self, price=None, currency=None, currencyRate=None, priceRUR=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.price = price
        self.validate_moneyPositiveType(self.price)
        self.price_nsprefix_ = None
        self.currency = currency
        self.currency_nsprefix_ = None
        self.currencyRate = currencyRate
        self.currencyRate_nsprefix_ = None
        self.priceRUR = priceRUR
        self.validate_moneyPositiveType(self.priceRUR)
        self.priceRUR_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, zfcs_contract2015PriceInfoType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if zfcs_contract2015PriceInfoType.subclass:
            return zfcs_contract2015PriceInfoType.subclass(*args_, **kwargs_)
        else:
            return zfcs_contract2015PriceInfoType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_moneyPositiveType(self, value):
        result = True
        # Validate type moneyPositiveType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 21:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on moneyPositiveType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on moneyPositiveType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_moneyPositiveType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_moneyPositiveType_patterns_, ))
                result = False
        return result
    validate_moneyPositiveType_patterns_ = [['^(\\d+(\\.\\d{1,2})?)$']]
    def hasContent_(self):
        if (
            self.price is not None or
            self.currency is not None or
            self.currencyRate is not None or
            self.priceRUR is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'price':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'price')
            value_ = self.gds_validate_string(value_, node, 'price')
            self.price = value_
            self.price_nsprefix_ = child_.prefix
            # validate type moneyPositiveType
            self.validate_moneyPositiveType(self.price)
        elif nodeName_ == 'currency':
            obj_ = zfcs_currencyRef.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.currency = obj_
            obj_.original_tagname_ = 'currency'
        elif nodeName_ == 'currencyRate':
            obj_ = zfcs_currencyRateContract2015.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.currencyRate = obj_
            obj_.original_tagname_ = 'currencyRate'
        elif nodeName_ == 'priceRUR':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'priceRUR')
            value_ = self.gds_validate_string(value_, node, 'priceRUR')
            self.priceRUR = value_
            self.priceRUR_nsprefix_ = child_.prefix
            # validate type moneyPositiveType
            self.validate_moneyPositiveType(self.priceRUR)
# end class zfcs_contract2015PriceInfoType


class zfcs_contract2015PurchaseObjectInfoType(GeneratedsSuper):
    """Тип: Информация об объекте закупки в сведениях о контрактеЗначение
    блоков OKPD/OKPD2/KTRU игнорируется и заполняется значением
    соответствующей позиции КТРУ, в случае если контракт создан на
    основании извещения об осуществлении закупки (заполнен блок
    foundation\fcsOrder\order\notificationNumber) и в извещении заполнен
    код по КТРУ, либо в случае если контракт создан на основании позиции
    плана-графика (заполнен блок foundation\singleCustomer\tenderPlanInfo
    или foundation\ notOosOrder\ tenderPlanInfo) и в такой позиции заполнен
    код по КТРУ.
    В других случаях сохраняется значение одного из блоков OKPD/OKPD2/KTRU.
    Принимается и сохраняется в случае, если получен признак «Предмет
    контракта относится к работам по строительству»
    (constructionWorksInfo/isConstructionWorks) И «Причина изменений
    условий контракта из справочника "Справочник: Причины изменения условий
    контракта" (nsiContractModificationReason)»
    (modification/contractChange/reason/code) имеет значение с кодом по
    справочнику 014 или 015Контролируется обязательность заполнения одного
    из полей quantity и volumeTextForm за исключением вариантов при которых
    данные поля игнорируются при приеме"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'purchaseObjectSid': MemberSpec_('purchaseObjectSid', ['purchaseObjectSid', 'xs:long'], 0, 1, {'minOccurs': '0', 'name': 'purchaseObjectSid', 'type': 'xs:long'}, None),
        'purchaseObjectExternalSid': MemberSpec_('purchaseObjectExternalSid', ['externalIdType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'purchaseObjectExternalSid', 'type': 'xs:string'}, None),
        'sid': MemberSpec_('sid', ['sid', 'xs:long'], 0, 1, {'minOccurs': '0', 'name': 'sid', 'type': 'xs:long'}, None),
        'externalSid': MemberSpec_('externalSid', ['externalIdType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'externalSid', 'type': 'xs:string'}, None),
        'guid': MemberSpec_('guid', ['guidType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'guid', 'type': 'xs:string'}, None),
        'OKPD': MemberSpec_('OKPD', 'zfcs_OKPDRef', 0, 0, {'name': 'OKPD', 'type': 'zfcs_OKPDRef'}, 64),
        'OKPD2': MemberSpec_('OKPD2', 'OKPD2', 0, 0, {'name': 'OKPD2', 'type': 'zfcs_OKPDRef'}, 64),
        'KTRU': MemberSpec_('KTRU', 'zfcs_KTRURef', 0, 0, {'name': 'KTRU', 'type': 'KTRU'}, 64),
        'name': MemberSpec_('name', ['zfcs_longTextMinType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'name', 'type': 'xs:string'}, None),
        'type_': MemberSpec_('type_', ['productTypeEnumType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'type', 'type': 'xs:string'}, None),
        'OKEI': MemberSpec_('OKEI', 'zfcs_contract.OKEIType', 0, 1, {'minOccurs': '0', 'name': 'OKEI', 'type': 'zfcs_contract.OKEIType'}, None),
        'KTRUNotUsingReason': MemberSpec_('KTRUNotUsingReason', 'KTRUNotUsingReason', 0, 1, {'minOccurs': '0', 'name': 'KTRUNotUsingReason', 'type': 'KTRUNotUsingReason'}, None),
        'price': MemberSpec_('price', ['moneyLongType', 'xs:string'], 0, 0, {'name': 'price', 'type': 'xs:string'}, None),
        'priceRUR': MemberSpec_('priceRUR', ['moneyLongType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'priceRUR', 'type': 'xs:string'}, None),
        'whitoutVATPrice': MemberSpec_('whitoutVATPrice', ['moneyLongType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'whitoutVATPrice', 'type': 'xs:string'}, None),
        'whitoutVATPriceRUR': MemberSpec_('whitoutVATPriceRUR', ['moneyLongType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'whitoutVATPriceRUR', 'type': 'xs:string'}, None),
        'quantity': MemberSpec_('quantity', ['quantity18p11Type', 'xs:decimal'], 0, 1, {'minOccurs': '0', 'name': 'quantity', 'type': 'xs:decimal'}, 65),
        'volumeTextForm': MemberSpec_('volumeTextForm', ['text500Type', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'volumeTextForm', 'type': 'xs:string'}, 65),
        'sum': MemberSpec_('sum', ['moneyPositiveType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'sum', 'type': 'xs:string'}, None),
        'sumRUR': MemberSpec_('sumRUR', ['moneyPositiveType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'sumRUR', 'type': 'xs:string'}, None),
        'withoutVATSum': MemberSpec_('withoutVATSum', ['moneyMaxLengthToPoint18Type', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'withoutVATSum', 'type': 'xs:string'}, None),
        'withoutVATSumRUR': MemberSpec_('withoutVATSumRUR', ['moneyMaxLengthToPoint18Type', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'withoutVATSumRUR', 'type': 'xs:string'}, None),
        'VATRate': MemberSpec_('VATRate', ['VATRateEnum', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'VATRate', 'type': 'xs:string'}, None),
        'VATSum': MemberSpec_('VATSum', ['moneyMaxLengthToPoint18Type', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'VATSum', 'type': 'xs:string'}, None),
        'VATSumRUR': MemberSpec_('VATSumRUR', ['moneyMaxLengthToPoint18Type', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'VATSumRUR', 'type': 'xs:string'}, None),
        'originCountry': MemberSpec_('originCountry', 'zfcs_countryRef', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'originCountry', 'type': 'zfcs_countryRef'}, None),
        'improvedProductReplacement': MemberSpec_('improvedProductReplacement', 'xs:boolean', 0, 1, {'minOccurs': '0', 'name': 'improvedProductReplacement', 'type': 'xs:boolean'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_) + ['extensiontype_']
    subclass = None
    superclass = None
    def __init__(self, purchaseObjectSid=None, purchaseObjectExternalSid=None, sid=None, externalSid=None, guid=None, OKPD=None, OKPD2=None, KTRU=None, name=None, type_=None, OKEI=None, KTRUNotUsingReason=None, price=None, priceRUR=None, whitoutVATPrice=None, whitoutVATPriceRUR=None, quantity=None, volumeTextForm=None, sum=None, sumRUR=None, withoutVATSum=None, withoutVATSumRUR=None, VATRate=None, VATSum=None, VATSumRUR=None, originCountry=None, improvedProductReplacement=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.purchaseObjectSid = purchaseObjectSid
        self.purchaseObjectSid_nsprefix_ = None
        self.purchaseObjectExternalSid = purchaseObjectExternalSid
        self.validate_externalIdType(self.purchaseObjectExternalSid)
        self.purchaseObjectExternalSid_nsprefix_ = None
        self.sid = sid
        self.sid_nsprefix_ = None
        self.externalSid = externalSid
        self.validate_externalIdType(self.externalSid)
        self.externalSid_nsprefix_ = None
        self.guid = guid
        self.validate_guidType(self.guid)
        self.guid_nsprefix_ = None
        self.OKPD = OKPD
        self.OKPD_nsprefix_ = None
        self.OKPD2 = OKPD2
        self.OKPD2_nsprefix_ = None
        self.KTRU = KTRU
        self.KTRU_nsprefix_ = None
        self.name = name
        self.validate_zfcs_longTextMinType(self.name)
        self.name_nsprefix_ = None
        self.type_ = type_
        self.validate_productTypeEnumType(self.type_)
        self.type__nsprefix_ = None
        self.OKEI = OKEI
        self.OKEI_nsprefix_ = None
        self.KTRUNotUsingReason = KTRUNotUsingReason
        self.KTRUNotUsingReason_nsprefix_ = None
        self.price = price
        self.validate_moneyLongType(self.price)
        self.price_nsprefix_ = None
        self.priceRUR = priceRUR
        self.validate_moneyLongType(self.priceRUR)
        self.priceRUR_nsprefix_ = None
        self.whitoutVATPrice = whitoutVATPrice
        self.validate_moneyLongType(self.whitoutVATPrice)
        self.whitoutVATPrice_nsprefix_ = None
        self.whitoutVATPriceRUR = whitoutVATPriceRUR
        self.validate_moneyLongType(self.whitoutVATPriceRUR)
        self.whitoutVATPriceRUR_nsprefix_ = None
        self.quantity = quantity
        self.validate_quantity18p11Type(self.quantity)
        self.quantity_nsprefix_ = None
        self.volumeTextForm = volumeTextForm
        self.validate_text500Type(self.volumeTextForm)
        self.volumeTextForm_nsprefix_ = None
        self.sum = sum
        self.validate_moneyPositiveType(self.sum)
        self.sum_nsprefix_ = None
        self.sumRUR = sumRUR
        self.validate_moneyPositiveType(self.sumRUR)
        self.sumRUR_nsprefix_ = None
        self.withoutVATSum = withoutVATSum
        self.validate_moneyMaxLengthToPoint18Type(self.withoutVATSum)
        self.withoutVATSum_nsprefix_ = None
        self.withoutVATSumRUR = withoutVATSumRUR
        self.validate_moneyMaxLengthToPoint18Type(self.withoutVATSumRUR)
        self.withoutVATSumRUR_nsprefix_ = None
        self.VATRate = VATRate
        self.validate_VATRateEnum(self.VATRate)
        self.VATRate_nsprefix_ = None
        self.VATSum = VATSum
        self.validate_moneyMaxLengthToPoint18Type(self.VATSum)
        self.VATSum_nsprefix_ = None
        self.VATSumRUR = VATSumRUR
        self.validate_moneyMaxLengthToPoint18Type(self.VATSumRUR)
        self.VATSumRUR_nsprefix_ = None
        if originCountry is None:
            self.originCountry = []
        else:
            self.originCountry = originCountry
        self.originCountry_nsprefix_ = None
        self.improvedProductReplacement = improvedProductReplacement
        self.improvedProductReplacement_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, zfcs_contract2015PurchaseObjectInfoType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if zfcs_contract2015PurchaseObjectInfoType.subclass:
            return zfcs_contract2015PurchaseObjectInfoType.subclass(*args_, **kwargs_)
        else:
            return zfcs_contract2015PurchaseObjectInfoType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_externalIdType(self, value):
        result = True
        # Validate type externalIdType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 40:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on externalIdType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on externalIdType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_guidType(self, value):
        result = True
        # Validate type guidType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 36:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on guidType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on guidType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_zfcs_longTextMinType(self, value):
        result = True
        # Validate type zfcs_longTextMinType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 2000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on zfcs_longTextMinType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on zfcs_longTextMinType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_productTypeEnumType(self, value):
        result = True
        # Validate type productTypeEnumType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['PRODUCT', 'WORK', 'SERVICE']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on productTypeEnumType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_moneyLongType(self, value):
        result = True
        # Validate type moneyLongType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 30:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on moneyLongType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on moneyLongType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_moneyLongType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_moneyLongType_patterns_, ))
                result = False
        return result
    validate_moneyLongType_patterns_ = [['^((-)?\\d+(\\.\\d{1,11})?)$']]
    def validate_quantity18p11Type(self, value):
        result = True
        # Validate type quantity18p11Type, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, decimal_.Decimal):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (decimal_.Decimal)' % {"value": value, "lineno": lineno, })
                return False
            if len(str(value)) >= 29:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd totalDigits restriction on quantity18p11Type' % {"value": value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_quantity18p11Type_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_quantity18p11Type_patterns_, ))
                result = False
        return result
    validate_quantity18p11Type_patterns_ = [['^(\\d{1,18}(\\.\\d{1,11})?)$']]
    def validate_text500Type(self, value):
        result = True
        # Validate type text500Type, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 500:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on text500Type' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on text500Type' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_moneyPositiveType(self, value):
        result = True
        # Validate type moneyPositiveType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 21:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on moneyPositiveType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on moneyPositiveType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_moneyPositiveType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_moneyPositiveType_patterns_, ))
                result = False
        return result
    validate_moneyPositiveType_patterns_ = [['^(\\d+(\\.\\d{1,2})?)$']]
    def validate_moneyMaxLengthToPoint18Type(self, value):
        result = True
        # Validate type moneyMaxLengthToPoint18Type, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 21:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on moneyMaxLengthToPoint18Type' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on moneyMaxLengthToPoint18Type' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_moneyMaxLengthToPoint18Type_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_moneyMaxLengthToPoint18Type_patterns_, ))
                result = False
        return result
    validate_moneyMaxLengthToPoint18Type_patterns_ = [['^(\\d{1,18}(\\.\\d{1,2})?)$']]
    def validate_VATRateEnum(self, value):
        result = True
        # Validate type VATRateEnum, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['0', '10', '18', '20', 'n']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on VATRateEnum' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.purchaseObjectSid is not None or
            self.purchaseObjectExternalSid is not None or
            self.sid is not None or
            self.externalSid is not None or
            self.guid is not None or
            self.OKPD is not None or
            self.OKPD2 is not None or
            self.KTRU is not None or
            self.name is not None or
            self.type_ is not None or
            self.OKEI is not None or
            self.KTRUNotUsingReason is not None or
            self.price is not None or
            self.priceRUR is not None or
            self.whitoutVATPrice is not None or
            self.whitoutVATPriceRUR is not None or
            self.quantity is not None or
            self.volumeTextForm is not None or
            self.sum is not None or
            self.sumRUR is not None or
            self.withoutVATSum is not None or
            self.withoutVATSumRUR is not None or
            self.VATRate is not None or
            self.VATSum is not None or
            self.VATSumRUR is not None or
            self.originCountry or
            self.improvedProductReplacement is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'purchaseObjectSid' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'purchaseObjectSid')
            ival_ = self.gds_validate_integer(ival_, node, 'purchaseObjectSid')
            self.purchaseObjectSid = ival_
            self.purchaseObjectSid_nsprefix_ = child_.prefix
        elif nodeName_ == 'purchaseObjectExternalSid':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'purchaseObjectExternalSid')
            value_ = self.gds_validate_string(value_, node, 'purchaseObjectExternalSid')
            self.purchaseObjectExternalSid = value_
            self.purchaseObjectExternalSid_nsprefix_ = child_.prefix
            # validate type externalIdType
            self.validate_externalIdType(self.purchaseObjectExternalSid)
        elif nodeName_ == 'sid' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'sid')
            ival_ = self.gds_validate_integer(ival_, node, 'sid')
            self.sid = ival_
            self.sid_nsprefix_ = child_.prefix
        elif nodeName_ == 'externalSid':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'externalSid')
            value_ = self.gds_validate_string(value_, node, 'externalSid')
            self.externalSid = value_
            self.externalSid_nsprefix_ = child_.prefix
            # validate type externalIdType
            self.validate_externalIdType(self.externalSid)
        elif nodeName_ == 'guid':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'guid')
            value_ = self.gds_validate_string(value_, node, 'guid')
            self.guid = value_
            self.guid_nsprefix_ = child_.prefix
            # validate type guidType
            self.validate_guidType(self.guid)
        elif nodeName_ == 'OKPD':
            obj_ = zfcs_OKPDRef.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.OKPD = obj_
            obj_.original_tagname_ = 'OKPD'
        elif nodeName_ == 'OKPD2':
            obj_ = zfcs_OKPDRef.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.OKPD2 = obj_
            obj_.original_tagname_ = 'OKPD2'
        elif nodeName_ == 'KTRU':
            obj_ = KTRU.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.KTRU = obj_
            obj_.original_tagname_ = 'KTRU'
        elif nodeName_ == 'name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'name')
            value_ = self.gds_validate_string(value_, node, 'name')
            self.name = value_
            self.name_nsprefix_ = child_.prefix
            # validate type zfcs_longTextMinType
            self.validate_zfcs_longTextMinType(self.name)
        elif nodeName_ == 'type':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'type')
            value_ = self.gds_validate_string(value_, node, 'type')
            self.type_ = value_
            self.type_nsprefix_ = child_.prefix
            # validate type productTypeEnumType
            self.validate_productTypeEnumType(self.type_)
        elif nodeName_ == 'OKEI':
            obj_ = zfcs_contract_OKEIType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.OKEI = obj_
            obj_.original_tagname_ = 'OKEI'
        elif nodeName_ == 'KTRUNotUsingReason':
            obj_ = KTRUNotUsingReason.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.KTRUNotUsingReason = obj_
            obj_.original_tagname_ = 'KTRUNotUsingReason'
        elif nodeName_ == 'price':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'price')
            value_ = self.gds_validate_string(value_, node, 'price')
            self.price = value_
            self.price_nsprefix_ = child_.prefix
            # validate type moneyLongType
            self.validate_moneyLongType(self.price)
        elif nodeName_ == 'priceRUR':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'priceRUR')
            value_ = self.gds_validate_string(value_, node, 'priceRUR')
            self.priceRUR = value_
            self.priceRUR_nsprefix_ = child_.prefix
            # validate type moneyLongType
            self.validate_moneyLongType(self.priceRUR)
        elif nodeName_ == 'whitoutVATPrice':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'whitoutVATPrice')
            value_ = self.gds_validate_string(value_, node, 'whitoutVATPrice')
            self.whitoutVATPrice = value_
            self.whitoutVATPrice_nsprefix_ = child_.prefix
            # validate type moneyLongType
            self.validate_moneyLongType(self.whitoutVATPrice)
        elif nodeName_ == 'whitoutVATPriceRUR':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'whitoutVATPriceRUR')
            value_ = self.gds_validate_string(value_, node, 'whitoutVATPriceRUR')
            self.whitoutVATPriceRUR = value_
            self.whitoutVATPriceRUR_nsprefix_ = child_.prefix
            # validate type moneyLongType
            self.validate_moneyLongType(self.whitoutVATPriceRUR)
        elif nodeName_ == 'quantity' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'quantity')
            fval_ = self.gds_validate_decimal(fval_, node, 'quantity')
            self.quantity = fval_
            self.quantity_nsprefix_ = child_.prefix
            # validate type quantity18p11Type
            self.validate_quantity18p11Type(self.quantity)
        elif nodeName_ == 'volumeTextForm':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'volumeTextForm')
            value_ = self.gds_validate_string(value_, node, 'volumeTextForm')
            self.volumeTextForm = value_
            self.volumeTextForm_nsprefix_ = child_.prefix
            # validate type text500Type
            self.validate_text500Type(self.volumeTextForm)
        elif nodeName_ == 'sum':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'sum')
            value_ = self.gds_validate_string(value_, node, 'sum')
            self.sum = value_
            self.sum_nsprefix_ = child_.prefix
            # validate type moneyPositiveType
            self.validate_moneyPositiveType(self.sum)
        elif nodeName_ == 'sumRUR':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'sumRUR')
            value_ = self.gds_validate_string(value_, node, 'sumRUR')
            self.sumRUR = value_
            self.sumRUR_nsprefix_ = child_.prefix
            # validate type moneyPositiveType
            self.validate_moneyPositiveType(self.sumRUR)
        elif nodeName_ == 'withoutVATSum':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'withoutVATSum')
            value_ = self.gds_validate_string(value_, node, 'withoutVATSum')
            self.withoutVATSum = value_
            self.withoutVATSum_nsprefix_ = child_.prefix
            # validate type moneyMaxLengthToPoint18Type
            self.validate_moneyMaxLengthToPoint18Type(self.withoutVATSum)
        elif nodeName_ == 'withoutVATSumRUR':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'withoutVATSumRUR')
            value_ = self.gds_validate_string(value_, node, 'withoutVATSumRUR')
            self.withoutVATSumRUR = value_
            self.withoutVATSumRUR_nsprefix_ = child_.prefix
            # validate type moneyMaxLengthToPoint18Type
            self.validate_moneyMaxLengthToPoint18Type(self.withoutVATSumRUR)
        elif nodeName_ == 'VATRate':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'VATRate')
            value_ = self.gds_validate_string(value_, node, 'VATRate')
            self.VATRate = value_
            self.VATRate_nsprefix_ = child_.prefix
            # validate type VATRateEnum
            self.validate_VATRateEnum(self.VATRate)
        elif nodeName_ == 'VATSum':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'VATSum')
            value_ = self.gds_validate_string(value_, node, 'VATSum')
            self.VATSum = value_
            self.VATSum_nsprefix_ = child_.prefix
            # validate type moneyMaxLengthToPoint18Type
            self.validate_moneyMaxLengthToPoint18Type(self.VATSum)
        elif nodeName_ == 'VATSumRUR':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'VATSumRUR')
            value_ = self.gds_validate_string(value_, node, 'VATSumRUR')
            self.VATSumRUR = value_
            self.VATSumRUR_nsprefix_ = child_.prefix
            # validate type moneyMaxLengthToPoint18Type
            self.validate_moneyMaxLengthToPoint18Type(self.VATSumRUR)
        elif nodeName_ == 'originCountry':
            obj_ = zfcs_countryRef.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.originCountry.append(obj_)
            obj_.original_tagname_ = 'originCountry'
        elif nodeName_ == 'improvedProductReplacement':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'improvedProductReplacement')
            ival_ = self.gds_validate_boolean(ival_, node, 'improvedProductReplacement')
            self.improvedProductReplacement = ival_
            self.improvedProductReplacement_nsprefix_ = child_.prefix
# end class zfcs_contract2015PurchaseObjectInfoType


class purchaseObjectSid(GeneratedsSuper):
    """Уникальный идентификатор объекта закупки в ЕИС в извещении-основании.
    При приеме контролируется, что извещение с реестровым номером
    foundation/fcsOrder/order/notificationNumber имеет один из следующих
    способов определения поставщика: ЭА20, ЭОК20, ЭЗК20, ЭЗТ . Также
    контролируется, что указанный идентификатор присутствует в извещении с
    реетровым номером foundation/fcsOrder/order/notificationNumber"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, purchaseObjectSid)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if purchaseObjectSid.subclass:
            return purchaseObjectSid.subclass(*args_, **kwargs_)
        else:
            return purchaseObjectSid(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_purchaseObjectSid(self, value):
        result = True
        # Validate type purchaseObjectSid, a restriction on xs:long.
        pass
        return result
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class purchaseObjectSid


class rightSideKTRUInfo(righSideKTRURef):
    """Сведения о связи с позицией правой части (ПЧ) КТРУ.
    При приеме контролируется, что указанная позиция ПЧ КТРУ связана с позицией
    КТРУ с кодом, заданным в поле "Код товара, работы или услуги в
    справочнике Каталог товаров, работ, услуг (КТРУ) (nsiKTRU)"
    (products/product/KTRU/code).
    Связь определяется по наличию позиции КТРУ в справочнике позиций ПЧ КТРУ
    (nsiRightSideKTRU) для записи с кодом, указанным в поле "Код позции ПЧ
    КТРУ" (products/product/KTRU/rightSideKTRUInfo/code)"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'characteristics': MemberSpec_('characteristics', 'characteristics', 0, 1, {'minOccurs': '0', 'name': 'characteristics', 'type': 'characteristics'}, 64),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = righSideKTRURef
    def __init__(self, code=None, name=None, versionNumber=None, characteristics=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(rightSideKTRUInfo, self).__init__(code, name, versionNumber,  **kwargs_)
        self.characteristics = characteristics
        self.characteristics_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, rightSideKTRUInfo)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if rightSideKTRUInfo.subclass:
            return rightSideKTRUInfo.subclass(*args_, **kwargs_)
        else:
            return rightSideKTRUInfo(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.characteristics is not None or
            super(rightSideKTRUInfo, self).hasContent_()
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(rightSideKTRUInfo, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'characteristics':
            obj_ = characteristics.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.characteristics = obj_
            obj_.original_tagname_ = 'characteristics'
        super(rightSideKTRUInfo, self).buildChildren(child_, node, nodeName_, True)
# end class rightSideKTRUInfo


class characteristics(GeneratedsSuper):
    """Характеристики позиции ПЧ КТРУ"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'characteristicsUsingReferenceInfo': MemberSpec_('characteristicsUsingReferenceInfo', 'rightSideKTRUCharacteristicType', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'characteristicsUsingReferenceInfo', 'type': 'rightSideKTRUCharacteristicType'}, 64),
        'characteristicsUsingTextForm': MemberSpec_('characteristicsUsingTextForm', 'manualKTRUCharacteristicType', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'characteristicsUsingTextForm', 'type': 'manualKTRUCharacteristicType'}, 64),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, characteristicsUsingReferenceInfo=None, characteristicsUsingTextForm=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if characteristicsUsingReferenceInfo is None:
            self.characteristicsUsingReferenceInfo = []
        else:
            self.characteristicsUsingReferenceInfo = characteristicsUsingReferenceInfo
        self.characteristicsUsingReferenceInfo_nsprefix_ = None
        if characteristicsUsingTextForm is None:
            self.characteristicsUsingTextForm = []
        else:
            self.characteristicsUsingTextForm = characteristicsUsingTextForm
        self.characteristicsUsingTextForm_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, characteristics)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if characteristics.subclass:
            return characteristics.subclass(*args_, **kwargs_)
        else:
            return characteristics(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.characteristicsUsingReferenceInfo or
            self.characteristicsUsingTextForm
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'characteristicsUsingReferenceInfo':
            obj_ = rightSideKTRUCharacteristicType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.characteristicsUsingReferenceInfo.append(obj_)
            obj_.original_tagname_ = 'characteristicsUsingReferenceInfo'
        elif nodeName_ == 'characteristicsUsingTextForm':
            obj_ = manualKTRUCharacteristicType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.characteristicsUsingTextForm.append(obj_)
            obj_.original_tagname_ = 'characteristicsUsingTextForm'
# end class characteristics


class KTRUNotUsingReason(GeneratedsSuper):
    """Причины выбора единицы измерения, отличающейся от указанной в КТРУ.
    Контролируется обязательность заполнения, если значение поля
    products/product/OKEI не соответствует единице измерения указанной
    позиции КТРУ products/product/KTRU/code в справочнике "Каталог товаров,
    работ, услуг (КТРУ) " (nsiKTRU)"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'code': MemberSpec_('code', ['KTRUNotUsingReasonCodeType', 'xs:string'], 0, 0, {'name': 'code', 'type': 'xs:string'}, None),
        'name': MemberSpec_('name', ['text2000Type', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'name', 'type': 'xs:string'}, None),
        'anotherKTRUNotUsingReason': MemberSpec_('anotherKTRUNotUsingReason', ['anotherKTRUNotUsingReasonType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'anotherKTRUNotUsingReason', 'type': 'xs:string'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, code=None, name=None, anotherKTRUNotUsingReason=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.code = code
        self.validate_KTRUNotUsingReasonCodeType(self.code)
        self.code_nsprefix_ = None
        self.name = name
        self.validate_text2000Type(self.name)
        self.name_nsprefix_ = None
        self.anotherKTRUNotUsingReason = anotherKTRUNotUsingReason
        self.validate_anotherKTRUNotUsingReasonType(self.anotherKTRUNotUsingReason)
        self.anotherKTRUNotUsingReason_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, KTRUNotUsingReason)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if KTRUNotUsingReason.subclass:
            return KTRUNotUsingReason.subclass(*args_, **kwargs_)
        else:
            return KTRUNotUsingReason(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_KTRUNotUsingReasonCodeType(self, value):
        result = True
        # Validate type KTRUNotUsingReasonCodeType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 10:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on KTRUNotUsingReasonCodeType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on KTRUNotUsingReasonCodeType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_text2000Type(self, value):
        result = True
        # Validate type text2000Type, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 2000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on text2000Type' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on text2000Type' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_anotherKTRUNotUsingReasonType(self, value):
        result = True
        # Validate type anotherKTRUNotUsingReasonType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 256:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on anotherKTRUNotUsingReasonType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on anotherKTRUNotUsingReasonType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.code is not None or
            self.name is not None or
            self.anotherKTRUNotUsingReason is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'code':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'code')
            value_ = self.gds_validate_string(value_, node, 'code')
            self.code = value_
            self.code_nsprefix_ = child_.prefix
            # validate type KTRUNotUsingReasonCodeType
            self.validate_KTRUNotUsingReasonCodeType(self.code)
        elif nodeName_ == 'name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'name')
            value_ = self.gds_validate_string(value_, node, 'name')
            self.name = value_
            self.name_nsprefix_ = child_.prefix
            # validate type text2000Type
            self.validate_text2000Type(self.name)
        elif nodeName_ == 'anotherKTRUNotUsingReason':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'anotherKTRUNotUsingReason')
            value_ = self.gds_validate_string(value_, node, 'anotherKTRUNotUsingReason')
            self.anotherKTRUNotUsingReason = value_
            self.anotherKTRUNotUsingReason_nsprefix_ = child_.prefix
            # validate type anotherKTRUNotUsingReasonType
            self.validate_anotherKTRUNotUsingReasonType(self.anotherKTRUNotUsingReason)
# end class KTRUNotUsingReason


class zfcs_contract2015EnforcementType(GeneratedsSuper):
    """Тип: Обеспечение исполнения контракта"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'bankGuarantee': MemberSpec_('bankGuarantee', 'bankGuarantee', 0, 0, {'name': 'bankGuarantee', 'type': 'bankGuarantee'}, 66),
        'cashAccount': MemberSpec_('cashAccount', 'cashAccount', 0, 0, {'name': 'cashAccount', 'type': 'cashAccount'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, bankGuarantee=None, cashAccount=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.bankGuarantee = bankGuarantee
        self.bankGuarantee_nsprefix_ = None
        self.cashAccount = cashAccount
        self.cashAccount_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, zfcs_contract2015EnforcementType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if zfcs_contract2015EnforcementType.subclass:
            return zfcs_contract2015EnforcementType.subclass(*args_, **kwargs_)
        else:
            return zfcs_contract2015EnforcementType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.bankGuarantee is not None or
            self.cashAccount is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'bankGuarantee':
            obj_ = bankGuarantee.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.bankGuarantee = obj_
            obj_.original_tagname_ = 'bankGuarantee'
        elif nodeName_ == 'cashAccount':
            obj_ = cashAccount.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.cashAccount = obj_
            obj_.original_tagname_ = 'cashAccount'
# end class zfcs_contract2015EnforcementType


class zfcs_auditActionSubjectsRef(GeneratedsSuper):
    """Ссылка на предмет мероприятия аудита"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'id': MemberSpec_('id', 'xs:long', 0, 0, {'name': 'id', 'type': 'xs:long'}, None),
        'name': MemberSpec_('name', ['zfcs_longTextMinType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'name', 'type': 'xs:string'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, id=None, name=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.id = id
        self.id_nsprefix_ = None
        self.name = name
        self.validate_zfcs_longTextMinType(self.name)
        self.name_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, zfcs_auditActionSubjectsRef)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if zfcs_auditActionSubjectsRef.subclass:
            return zfcs_auditActionSubjectsRef.subclass(*args_, **kwargs_)
        else:
            return zfcs_auditActionSubjectsRef(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_zfcs_longTextMinType(self, value):
        result = True
        # Validate type zfcs_longTextMinType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 2000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on zfcs_longTextMinType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on zfcs_longTextMinType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.id is not None or
            self.name is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'id' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'id')
            ival_ = self.gds_validate_integer(ival_, node, 'id')
            self.id = ival_
            self.id_nsprefix_ = child_.prefix
        elif nodeName_ == 'name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'name')
            value_ = self.gds_validate_string(value_, node, 'name')
            self.name = value_
            self.name_nsprefix_ = child_.prefix
            # validate type zfcs_longTextMinType
            self.validate_zfcs_longTextMinType(self.name)
# end class zfcs_auditActionSubjectsRef


class zfcs_countryRef(GeneratedsSuper):
    """Ссылка на страну"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'countryCode': MemberSpec_('countryCode', ['countryCodeType', 'xs:string'], 0, 0, {'name': 'countryCode', 'type': 'xs:string'}, None),
        'countryFullName': MemberSpec_('countryFullName', ['countryFullName', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'countryFullName', 'type': 'xs:string'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, countryCode=None, countryFullName=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.countryCode = countryCode
        self.validate_countryCodeType(self.countryCode)
        self.countryCode_nsprefix_ = None
        self.countryFullName = countryFullName
        self.countryFullName_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, zfcs_countryRef)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if zfcs_countryRef.subclass:
            return zfcs_countryRef.subclass(*args_, **kwargs_)
        else:
            return zfcs_countryRef(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_countryCodeType(self, value):
        result = True
        # Validate type countryCodeType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 3:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on countryCodeType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on countryCodeType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.countryCode is not None or
            self.countryFullName is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'countryCode':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'countryCode')
            value_ = self.gds_validate_string(value_, node, 'countryCode')
            self.countryCode = value_
            self.countryCode_nsprefix_ = child_.prefix
            # validate type countryCodeType
            self.validate_countryCodeType(self.countryCode)
        elif nodeName_ == 'countryFullName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'countryFullName')
            value_ = self.gds_validate_string(value_, node, 'countryFullName')
            self.countryFullName = value_
            self.countryFullName_nsprefix_ = child_.prefix
# end class zfcs_countryRef


class countryFullName(GeneratedsSuper):
    """Полное наименование страны"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, countryFullName)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if countryFullName.subclass:
            return countryFullName.subclass(*args_, **kwargs_)
        else:
            return countryFullName(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_countryFullName(self, value):
        result = True
        # Validate type countryFullName, a restriction on xs:string.
        pass
        return result
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class countryFullName


class zfcs_currencyFullRef(GeneratedsSuper):
    """Ссылка на валюту с цифровым кодом"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'code': MemberSpec_('code', ['code', 'xs:string'], 0, 0, {'name': 'code', 'type': 'xs:string'}, None),
        'digitalCode': MemberSpec_('digitalCode', ['digitalCode', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'digitalCode', 'type': 'xs:string'}, None),
        'name': MemberSpec_('name', ['name', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'name', 'type': 'xs:string'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, code=None, digitalCode=None, name=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.code = code
        self.code_nsprefix_ = None
        self.digitalCode = digitalCode
        self.digitalCode_nsprefix_ = None
        self.name = name
        self.name_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, zfcs_currencyFullRef)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if zfcs_currencyFullRef.subclass:
            return zfcs_currencyFullRef.subclass(*args_, **kwargs_)
        else:
            return zfcs_currencyFullRef(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.code is not None or
            self.digitalCode is not None or
            self.name is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'code':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'code')
            value_ = self.gds_validate_string(value_, node, 'code')
            self.code = value_
            self.code_nsprefix_ = child_.prefix
        elif nodeName_ == 'digitalCode':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'digitalCode')
            value_ = self.gds_validate_string(value_, node, 'digitalCode')
            self.digitalCode = value_
            self.digitalCode_nsprefix_ = child_.prefix
        elif nodeName_ == 'name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'name')
            value_ = self.gds_validate_string(value_, node, 'name')
            self.name = value_
            self.name_nsprefix_ = child_.prefix
# end class zfcs_currencyFullRef


class digitalCode(GeneratedsSuper):
    """Цифровой код валюты"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, digitalCode)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if digitalCode.subclass:
            return digitalCode.subclass(*args_, **kwargs_)
        else:
            return digitalCode(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_digitalCode(self, value):
        result = True
        # Validate type digitalCode, a restriction on xs:string.
        pass
        return result
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class digitalCode


class zfcs_OKPDRef(GeneratedsSuper):
    """Ссылка на ОКПД"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'code': MemberSpec_('code', ['code', 'xs:string'], 0, 0, {'name': 'code', 'type': 'xs:string'}, None),
        'name': MemberSpec_('name', ['name', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'name', 'type': 'xs:string'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, code=None, name=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.code = code
        self.code_nsprefix_ = None
        self.name = name
        self.name_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, zfcs_OKPDRef)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if zfcs_OKPDRef.subclass:
            return zfcs_OKPDRef.subclass(*args_, **kwargs_)
        else:
            return zfcs_OKPDRef(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.code is not None or
            self.name is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'code':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'code')
            value_ = self.gds_validate_string(value_, node, 'code')
            self.code = value_
            self.code_nsprefix_ = child_.prefix
        elif nodeName_ == 'name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'name')
            value_ = self.gds_validate_string(value_, node, 'name')
            self.name = value_
            self.name_nsprefix_ = child_.prefix
# end class zfcs_OKPDRef


class zfcs_OKVEDRef(GeneratedsSuper):
    """Ссылка на ОКВЕД"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'code': MemberSpec_('code', ['code', 'xs:string'], 0, 0, {'name': 'code', 'type': 'xs:string'}, None),
        'name': MemberSpec_('name', ['name', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'name', 'type': 'xs:string'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, code=None, name=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.code = code
        self.code_nsprefix_ = None
        self.name = name
        self.name_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, zfcs_OKVEDRef)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if zfcs_OKVEDRef.subclass:
            return zfcs_OKVEDRef.subclass(*args_, **kwargs_)
        else:
            return zfcs_OKVEDRef(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.code is not None or
            self.name is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'code':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'code')
            value_ = self.gds_validate_string(value_, node, 'code')
            self.code = value_
            self.code_nsprefix_ = child_.prefix
        elif nodeName_ == 'name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'name')
            value_ = self.gds_validate_string(value_, node, 'name')
            self.name = value_
            self.name_nsprefix_ = child_.prefix
# end class zfcs_OKVEDRef


class zfcs_OKATORef(GeneratedsSuper):
    """Ссылка на ОКАТО"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'code': MemberSpec_('code', ['code', 'xs:string'], 0, 0, {'name': 'code', 'type': 'xs:string'}, None),
        'name': MemberSpec_('name', ['zfcs_longTextType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'name', 'type': 'xs:string'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, code=None, name=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.code = code
        self.code_nsprefix_ = None
        self.name = name
        self.validate_zfcs_longTextType(self.name)
        self.name_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, zfcs_OKATORef)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if zfcs_OKATORef.subclass:
            return zfcs_OKATORef.subclass(*args_, **kwargs_)
        else:
            return zfcs_OKATORef(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_zfcs_longTextType(self, value):
        result = True
        # Validate type zfcs_longTextType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 2000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on zfcs_longTextType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.code is not None or
            self.name is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'code':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'code')
            value_ = self.gds_validate_string(value_, node, 'code')
            self.code = value_
            self.code_nsprefix_ = child_.prefix
        elif nodeName_ == 'name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'name')
            value_ = self.gds_validate_string(value_, node, 'name')
            self.name = value_
            self.name_nsprefix_ = child_.prefix
            # validate type zfcs_longTextType
            self.validate_zfcs_longTextType(self.name)
# end class zfcs_OKATORef


class zfcs_OKPORef(GeneratedsSuper):
    """Ссылка на ОКПО"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'code': MemberSpec_('code', ['zfcs_okpoType', 'xs:string'], 0, 0, {'name': 'code', 'type': 'xs:string'}, None),
        'name': MemberSpec_('name', ['zfcs_longTextMinType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'name', 'type': 'xs:string'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, code=None, name=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.code = code
        self.validate_zfcs_okpoType(self.code)
        self.code_nsprefix_ = None
        self.name = name
        self.validate_zfcs_longTextMinType(self.name)
        self.name_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, zfcs_OKPORef)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if zfcs_OKPORef.subclass:
            return zfcs_OKPORef.subclass(*args_, **kwargs_)
        else:
            return zfcs_OKPORef(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_zfcs_okpoType(self, value):
        result = True
        # Validate type zfcs_okpoType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 10:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on zfcs_okpoType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on zfcs_okpoType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_zfcs_longTextMinType(self, value):
        result = True
        # Validate type zfcs_longTextMinType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 2000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on zfcs_longTextMinType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on zfcs_longTextMinType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.code is not None or
            self.name is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'code':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'code')
            value_ = self.gds_validate_string(value_, node, 'code')
            self.code = value_
            self.code_nsprefix_ = child_.prefix
            # validate type zfcs_okpoType
            self.validate_zfcs_okpoType(self.code)
        elif nodeName_ == 'name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'name')
            value_ = self.gds_validate_string(value_, node, 'name')
            self.name = value_
            self.name_nsprefix_ = child_.prefix
            # validate type zfcs_longTextMinType
            self.validate_zfcs_longTextMinType(self.name)
# end class zfcs_OKPORef


class zfcs_subjectRFRef(GeneratedsSuper):
    """Ссылка на справочник субъектов РФ"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'code': MemberSpec_('code', ['code', 'xs:string'], 0, 0, {'name': 'code', 'type': 'xs:string'}, None),
        'name': MemberSpec_('name', ['name', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'name', 'type': 'xs:string'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, code=None, name=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.code = code
        self.code_nsprefix_ = None
        self.name = name
        self.name_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, zfcs_subjectRFRef)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if zfcs_subjectRFRef.subclass:
            return zfcs_subjectRFRef.subclass(*args_, **kwargs_)
        else:
            return zfcs_subjectRFRef(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.code is not None or
            self.name is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'code':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'code')
            value_ = self.gds_validate_string(value_, node, 'code')
            self.code = value_
            self.code_nsprefix_ = child_.prefix
        elif nodeName_ == 'name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'name')
            value_ = self.gds_validate_string(value_, node, 'name')
            self.name = value_
            self.name_nsprefix_ = child_.prefix
# end class zfcs_subjectRFRef


class zfcs_organizationLink(GeneratedsSuper):
    """Подчиненные организации в праве осушествления закупок"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'id': MemberSpec_('id', 'xs:long', 0, 0, {'name': 'id', 'type': 'xs:long'}, None),
        'activeUntil': MemberSpec_('activeUntil', 'xs:dateTime', 0, 1, {'minOccurs': '0', 'name': 'activeUntil', 'type': 'xs:dateTime'}, None),
        'blockStatus': MemberSpec_('blockStatus', ['zfcs_organizationLinkBlockStatusType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'blockStatus', 'type': 'xs:string'}, None),
        'dependentOrganization': MemberSpec_('dependentOrganization', 'zfcs_organizationRef', 0, 0, {'name': 'dependentOrganization', 'type': 'zfcs_organizationRef'}, None),
        'linkUsers': MemberSpec_('linkUsers', 'xs:string', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'linkUsers', 'nillable': 'true', 'type': 'xs:string'}, None),
        'ordersVisibilityType': MemberSpec_('ordersVisibilityType', ['zfcs_orgLinkOrdersVisibilityTypeEnum', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'ordersVisibilityType', 'type': 'xs:string'}, None),
        'lastModifyDate': MemberSpec_('lastModifyDate', 'xs:dateTime', 0, 1, {'minOccurs': '0', 'name': 'lastModifyDate', 'type': 'xs:dateTime'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, id=None, activeUntil=None, blockStatus=None, dependentOrganization=None, linkUsers=None, ordersVisibilityType=None, lastModifyDate=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.id = id
        self.id_nsprefix_ = None
        if isinstance(activeUntil, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(activeUntil, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = activeUntil
        self.activeUntil = initvalue_
        self.activeUntil_nsprefix_ = None
        self.blockStatus = blockStatus
        self.validate_zfcs_organizationLinkBlockStatusType(self.blockStatus)
        self.blockStatus_nsprefix_ = None
        self.dependentOrganization = dependentOrganization
        self.dependentOrganization_nsprefix_ = None
        if linkUsers is None:
            self.linkUsers = []
        else:
            self.linkUsers = linkUsers
        self.linkUsers_nsprefix_ = None
        self.ordersVisibilityType = ordersVisibilityType
        self.validate_zfcs_orgLinkOrdersVisibilityTypeEnum(self.ordersVisibilityType)
        self.ordersVisibilityType_nsprefix_ = None
        if isinstance(lastModifyDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(lastModifyDate, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = lastModifyDate
        self.lastModifyDate = initvalue_
        self.lastModifyDate_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, zfcs_organizationLink)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if zfcs_organizationLink.subclass:
            return zfcs_organizationLink.subclass(*args_, **kwargs_)
        else:
            return zfcs_organizationLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_zfcs_organizationLinkBlockStatusType(self, value):
        result = True
        # Validate type zfcs_organizationLinkBlockStatusType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['A', 'B', 'BO']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on zfcs_organizationLinkBlockStatusType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_zfcs_orgLinkOrdersVisibilityTypeEnum(self, value):
        result = True
        # Validate type zfcs_orgLinkOrdersVisibilityTypeEnum, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['A', 'B']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on zfcs_orgLinkOrdersVisibilityTypeEnum' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.id is not None or
            self.activeUntil is not None or
            self.blockStatus is not None or
            self.dependentOrganization is not None or
            self.linkUsers or
            self.ordersVisibilityType is not None or
            self.lastModifyDate is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'id' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'id')
            ival_ = self.gds_validate_integer(ival_, node, 'id')
            self.id = ival_
            self.id_nsprefix_ = child_.prefix
        elif nodeName_ == 'activeUntil':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.activeUntil = dval_
            self.activeUntil_nsprefix_ = child_.prefix
        elif nodeName_ == 'blockStatus':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'blockStatus')
            value_ = self.gds_validate_string(value_, node, 'blockStatus')
            self.blockStatus = value_
            self.blockStatus_nsprefix_ = child_.prefix
            # validate type zfcs_organizationLinkBlockStatusType
            self.validate_zfcs_organizationLinkBlockStatusType(self.blockStatus)
        elif nodeName_ == 'dependentOrganization':
            class_obj_ = self.get_class_obj_(child_, zfcs_organizationRef)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.dependentOrganization = obj_
            obj_.original_tagname_ = 'dependentOrganization'
        elif nodeName_ == 'linkUsers':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'linkUsers')
            value_ = self.gds_validate_string(value_, node, 'linkUsers')
            self.linkUsers.append(value_)
            self.linkUsers_nsprefix_ = child_.prefix
        elif nodeName_ == 'ordersVisibilityType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'ordersVisibilityType')
            value_ = self.gds_validate_string(value_, node, 'ordersVisibilityType')
            self.ordersVisibilityType = value_
            self.ordersVisibilityType_nsprefix_ = child_.prefix
            # validate type zfcs_orgLinkOrdersVisibilityTypeEnum
            self.validate_zfcs_orgLinkOrdersVisibilityTypeEnum(self.ordersVisibilityType)
        elif nodeName_ == 'lastModifyDate':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.lastModifyDate = dval_
            self.lastModifyDate_nsprefix_ = child_.prefix
# end class zfcs_organizationLink


class zfcs_organizationControlRegistersRef(GeneratedsSuper):
    """Ссылка на организацию для контрольных реестров"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'fullName': MemberSpec_('fullName', ['zfcs_longTextMinType', 'xs:string'], 0, 0, {'name': 'fullName', 'type': 'xs:string'}, None),
        'shortName': MemberSpec_('shortName', ['zfcs_longTextMinType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'shortName', 'type': 'xs:string'}, None),
        'legalForm': MemberSpec_('legalForm', 'zfcs_okopfRef', 0, 0, {'name': 'legalForm', 'type': 'zfcs_okopfRef'}, None),
        'INN': MemberSpec_('INN', ['innType', 'xs:string'], 0, 0, {'name': 'INN', 'type': 'xs:string'}, None),
        'KPP': MemberSpec_('KPP', ['kppType', 'xs:string'], 0, 0, {'name': 'KPP', 'type': 'xs:string'}, None),
        'registrationDate': MemberSpec_('registrationDate', 'xs:date', 0, 1, {'minOccurs': '0', 'name': 'registrationDate', 'type': 'xs:date'}, None),
        'OKPO': MemberSpec_('OKPO', ['zfcs_okpoType', 'xs:string'], 0, 0, {'name': 'OKPO', 'type': 'xs:string'}, None),
        'address': MemberSpec_('address', ['zfcs_longTextMinType', 'xs:string'], 0, 0, {'name': 'address', 'type': 'xs:string'}, None),
        'contactPhone': MemberSpec_('contactPhone', ['contactPhone', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'contactPhone', 'type': 'xs:string'}, None),
        'contactEMail': MemberSpec_('contactEMail', ['contactEMail', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'contactEMail', 'type': 'xs:string'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, fullName=None, shortName=None, legalForm=None, INN=None, KPP=None, registrationDate=None, OKPO=None, address=None, contactPhone=None, contactEMail=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.fullName = fullName
        self.validate_zfcs_longTextMinType(self.fullName)
        self.fullName_nsprefix_ = None
        self.shortName = shortName
        self.validate_zfcs_longTextMinType(self.shortName)
        self.shortName_nsprefix_ = None
        self.legalForm = legalForm
        self.legalForm_nsprefix_ = None
        self.INN = INN
        self.validate_innType(self.INN)
        self.INN_nsprefix_ = None
        self.KPP = KPP
        self.validate_kppType(self.KPP)
        self.KPP_nsprefix_ = None
        if isinstance(registrationDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(registrationDate, '%Y-%m-%d').date()
        else:
            initvalue_ = registrationDate
        self.registrationDate = initvalue_
        self.registrationDate_nsprefix_ = None
        self.OKPO = OKPO
        self.validate_zfcs_okpoType(self.OKPO)
        self.OKPO_nsprefix_ = None
        self.address = address
        self.validate_zfcs_longTextMinType(self.address)
        self.address_nsprefix_ = None
        self.contactPhone = contactPhone
        self.contactPhone_nsprefix_ = None
        self.contactEMail = contactEMail
        self.contactEMail_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, zfcs_organizationControlRegistersRef)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if zfcs_organizationControlRegistersRef.subclass:
            return zfcs_organizationControlRegistersRef.subclass(*args_, **kwargs_)
        else:
            return zfcs_organizationControlRegistersRef(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_zfcs_longTextMinType(self, value):
        result = True
        # Validate type zfcs_longTextMinType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 2000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on zfcs_longTextMinType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on zfcs_longTextMinType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_innType(self, value):
        result = True
        # Validate type innType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 12:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on innType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_innType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_innType_patterns_, ))
                result = False
        return result
    validate_innType_patterns_ = [['^(\\d{1,12})$']]
    def validate_kppType(self, value):
        result = True
        # Validate type kppType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) != 9:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd length restriction on kppType' % {"value": encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_zfcs_okpoType(self, value):
        result = True
        # Validate type zfcs_okpoType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 10:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on zfcs_okpoType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on zfcs_okpoType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.fullName is not None or
            self.shortName is not None or
            self.legalForm is not None or
            self.INN is not None or
            self.KPP is not None or
            self.registrationDate is not None or
            self.OKPO is not None or
            self.address is not None or
            self.contactPhone is not None or
            self.contactEMail is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'fullName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'fullName')
            value_ = self.gds_validate_string(value_, node, 'fullName')
            self.fullName = value_
            self.fullName_nsprefix_ = child_.prefix
            # validate type zfcs_longTextMinType
            self.validate_zfcs_longTextMinType(self.fullName)
        elif nodeName_ == 'shortName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'shortName')
            value_ = self.gds_validate_string(value_, node, 'shortName')
            self.shortName = value_
            self.shortName_nsprefix_ = child_.prefix
            # validate type zfcs_longTextMinType
            self.validate_zfcs_longTextMinType(self.shortName)
        elif nodeName_ == 'legalForm':
            obj_ = zfcs_okopfRef.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.legalForm = obj_
            obj_.original_tagname_ = 'legalForm'
        elif nodeName_ == 'INN':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'INN')
            value_ = self.gds_validate_string(value_, node, 'INN')
            self.INN = value_
            self.INN_nsprefix_ = child_.prefix
            # validate type innType
            self.validate_innType(self.INN)
        elif nodeName_ == 'KPP':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'KPP')
            value_ = self.gds_validate_string(value_, node, 'KPP')
            self.KPP = value_
            self.KPP_nsprefix_ = child_.prefix
            # validate type kppType
            self.validate_kppType(self.KPP)
        elif nodeName_ == 'registrationDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.registrationDate = dval_
            self.registrationDate_nsprefix_ = child_.prefix
        elif nodeName_ == 'OKPO':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'OKPO')
            value_ = self.gds_validate_string(value_, node, 'OKPO')
            self.OKPO = value_
            self.OKPO_nsprefix_ = child_.prefix
            # validate type zfcs_okpoType
            self.validate_zfcs_okpoType(self.OKPO)
        elif nodeName_ == 'address':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'address')
            value_ = self.gds_validate_string(value_, node, 'address')
            self.address = value_
            self.address_nsprefix_ = child_.prefix
            # validate type zfcs_longTextMinType
            self.validate_zfcs_longTextMinType(self.address)
        elif nodeName_ == 'contactPhone':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'contactPhone')
            value_ = self.gds_validate_string(value_, node, 'contactPhone')
            self.contactPhone = value_
            self.contactPhone_nsprefix_ = child_.prefix
        elif nodeName_ == 'contactEMail':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'contactEMail')
            value_ = self.gds_validate_string(value_, node, 'contactEMail')
            self.contactEMail = value_
            self.contactEMail_nsprefix_ = child_.prefix
# end class zfcs_organizationControlRegistersRef


class contactPhone(GeneratedsSuper):
    """Номер контактного телефона"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, contactPhone)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if contactPhone.subclass:
            return contactPhone.subclass(*args_, **kwargs_)
        else:
            return contactPhone(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_contactPhone(self, value):
        result = True
        # Validate type contactPhone, a restriction on xs:string.
        pass
        return result
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class contactPhone


class contactEMail(GeneratedsSuper):
    """Адрес электронной почты"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, contactEMail)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if contactEMail.subclass:
            return contactEMail.subclass(*args_, **kwargs_)
        else:
            return contactEMail(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_contactEMail(self, value):
        result = True
        # Validate type contactEMail, a restriction on xs:string.
        pass
        return result
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class contactEMail


class zfcs_publicDiscussionFoundationRef(GeneratedsSuper):
    """Ссылка на основание результата общественного обсуждения"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'code': MemberSpec_('code', ['code', 'xs:string'], 0, 0, {'name': 'code', 'type': 'xs:string'}, None),
        'name': MemberSpec_('name', ['zfcs_longTextMinType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'name', 'type': 'xs:string'}, None),
        'foundationDescription': MemberSpec_('foundationDescription', ['zfcs_longTextMinType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'foundationDescription', 'type': 'xs:string'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, code=None, name=None, foundationDescription=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.code = code
        self.code_nsprefix_ = None
        self.name = name
        self.validate_zfcs_longTextMinType(self.name)
        self.name_nsprefix_ = None
        self.foundationDescription = foundationDescription
        self.validate_zfcs_longTextMinType(self.foundationDescription)
        self.foundationDescription_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, zfcs_publicDiscussionFoundationRef)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if zfcs_publicDiscussionFoundationRef.subclass:
            return zfcs_publicDiscussionFoundationRef.subclass(*args_, **kwargs_)
        else:
            return zfcs_publicDiscussionFoundationRef(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_zfcs_longTextMinType(self, value):
        result = True
        # Validate type zfcs_longTextMinType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 2000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on zfcs_longTextMinType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on zfcs_longTextMinType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.code is not None or
            self.name is not None or
            self.foundationDescription is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'code':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'code')
            value_ = self.gds_validate_string(value_, node, 'code')
            self.code = value_
            self.code_nsprefix_ = child_.prefix
        elif nodeName_ == 'name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'name')
            value_ = self.gds_validate_string(value_, node, 'name')
            self.name = value_
            self.name_nsprefix_ = child_.prefix
            # validate type zfcs_longTextMinType
            self.validate_zfcs_longTextMinType(self.name)
        elif nodeName_ == 'foundationDescription':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'foundationDescription')
            value_ = self.gds_validate_string(value_, node, 'foundationDescription')
            self.foundationDescription = value_
            self.foundationDescription_nsprefix_ = child_.prefix
            # validate type zfcs_longTextMinType
            self.validate_zfcs_longTextMinType(self.foundationDescription)
# end class zfcs_publicDiscussionFoundationRef


class zfcs_publicDiscussionDecisionRef(GeneratedsSuper):
    """Ссылка на решение общественного обсуждения"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'code': MemberSpec_('code', ['code', 'xs:string'], 0, 0, {'name': 'code', 'type': 'xs:string'}, None),
        'name': MemberSpec_('name', ['zfcs_longTextMinType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'name', 'type': 'xs:string'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, code=None, name=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.code = code
        self.code_nsprefix_ = None
        self.name = name
        self.validate_zfcs_longTextMinType(self.name)
        self.name_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, zfcs_publicDiscussionDecisionRef)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if zfcs_publicDiscussionDecisionRef.subclass:
            return zfcs_publicDiscussionDecisionRef.subclass(*args_, **kwargs_)
        else:
            return zfcs_publicDiscussionDecisionRef(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_zfcs_longTextMinType(self, value):
        result = True
        # Validate type zfcs_longTextMinType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 2000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on zfcs_longTextMinType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on zfcs_longTextMinType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.code is not None or
            self.name is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'code':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'code')
            value_ = self.gds_validate_string(value_, node, 'code')
            self.code = value_
            self.code_nsprefix_ = child_.prefix
        elif nodeName_ == 'name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'name')
            value_ = self.gds_validate_string(value_, node, 'name')
            self.name = value_
            self.name_nsprefix_ = child_.prefix
            # validate type zfcs_longTextMinType
            self.validate_zfcs_longTextMinType(self.name)
# end class zfcs_publicDiscussionDecisionRef


class zfcs_publicDiscussionFacetRef(GeneratedsSuper):
    """Ссылка на аспект общественного обсуждений"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'code': MemberSpec_('code', ['code', 'xs:string'], 0, 0, {'name': 'code', 'type': 'xs:string'}, None),
        'facetName': MemberSpec_('facetName', ['zfcs_longTextMinType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'facetName', 'type': 'xs:string'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, code=None, facetName=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.code = code
        self.code_nsprefix_ = None
        self.facetName = facetName
        self.validate_zfcs_longTextMinType(self.facetName)
        self.facetName_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, zfcs_publicDiscussionFacetRef)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if zfcs_publicDiscussionFacetRef.subclass:
            return zfcs_publicDiscussionFacetRef.subclass(*args_, **kwargs_)
        else:
            return zfcs_publicDiscussionFacetRef(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_zfcs_longTextMinType(self, value):
        result = True
        # Validate type zfcs_longTextMinType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 2000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on zfcs_longTextMinType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on zfcs_longTextMinType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.code is not None or
            self.facetName is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'code':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'code')
            value_ = self.gds_validate_string(value_, node, 'code')
            self.code = value_
            self.code_nsprefix_ = child_.prefix
        elif nodeName_ == 'facetName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'facetName')
            value_ = self.gds_validate_string(value_, node, 'facetName')
            self.facetName = value_
            self.facetName_nsprefix_ = child_.prefix
            # validate type zfcs_longTextMinType
            self.validate_zfcs_longTextMinType(self.facetName)
# end class zfcs_publicDiscussionFacetRef


class zfcs_publicDiscussionQuestionRef(GeneratedsSuper):
    """Ссылка на вопрос аспекта общественного обсуждений"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'code': MemberSpec_('code', ['code', 'xs:string'], 0, 0, {'name': 'code', 'type': 'xs:string'}, None),
        'name': MemberSpec_('name', ['zfcs_longTextMinType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'name', 'type': 'xs:string'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, code=None, name=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.code = code
        self.code_nsprefix_ = None
        self.name = name
        self.validate_zfcs_longTextMinType(self.name)
        self.name_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, zfcs_publicDiscussionQuestionRef)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if zfcs_publicDiscussionQuestionRef.subclass:
            return zfcs_publicDiscussionQuestionRef.subclass(*args_, **kwargs_)
        else:
            return zfcs_publicDiscussionQuestionRef(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_zfcs_longTextMinType(self, value):
        result = True
        # Validate type zfcs_longTextMinType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 2000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on zfcs_longTextMinType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on zfcs_longTextMinType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.code is not None or
            self.name is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'code':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'code')
            value_ = self.gds_validate_string(value_, node, 'code')
            self.code = value_
            self.code_nsprefix_ = child_.prefix
        elif nodeName_ == 'name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'name')
            value_ = self.gds_validate_string(value_, node, 'name')
            self.name = value_
            self.name_nsprefix_ = child_.prefix
            # validate type zfcs_longTextMinType
            self.validate_zfcs_longTextMinType(self.name)
# end class zfcs_publicDiscussionQuestionRef


class zfcs_unfairSupplierType(GeneratedsSuper):
    """Сведения о недобросовестном поставщикеВерсия схемы"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'schemeVersion': MemberSpec_('schemeVersion', 'base:schemeVersionType', 0, 0, {'use': 'required'}),
        'registryNum': MemberSpec_('registryNum', ['zfcs_documentNumberType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'registryNum', 'type': 'xs:string'}, None),
        'publishDate': MemberSpec_('publishDate', 'xs:dateTime', 0, 1, {'minOccurs': '0', 'name': 'publishDate', 'type': 'xs:dateTime'}, None),
        'approveDate': MemberSpec_('approveDate', 'xs:dateTime', 0, 1, {'minOccurs': '0', 'name': 'approveDate', 'type': 'xs:dateTime'}, None),
        'occurrenceReasonDate': MemberSpec_('occurrenceReasonDate', 'xs:date', 0, 1, {'minOccurs': '0', 'name': 'occurrenceReasonDate', 'type': 'xs:date'}, None),
        'ergRequestApproveDate': MemberSpec_('ergRequestApproveDate', 'xs:date', 0, 1, {'minOccurs': '0', 'name': 'ergRequestApproveDate', 'type': 'xs:date'}, None),
        'state': MemberSpec_('state', ['state', 'xs:string'], 0, 0, {'name': 'state', 'type': 'xs:string'}, None),
        'publishOrg': MemberSpec_('publishOrg', 'zfcs_organizationRef', 0, 1, {'minOccurs': '0', 'name': 'publishOrg', 'type': 'zfcs_organizationRef'}, None),
        'createReason': MemberSpec_('createReason', ['zfcs_longTextType', 'xs:string'], 0, 0, {'name': 'createReason', 'type': 'xs:string'}, None),
        'approveReason': MemberSpec_('approveReason', ['zfcs_longTextType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'approveReason', 'type': 'xs:string'}, None),
        'approveOrderReasonInfo': MemberSpec_('approveOrderReasonInfo', 'approveOrderReasonInfo', 0, 1, {'minOccurs': '0', 'name': 'approveOrderReasonInfo', 'type': 'approveOrderReasonInfo'}, None),
        'customer': MemberSpec_('customer', 'customer', 0, 1, {'minOccurs': '0', 'name': 'customer', 'type': 'xs:string'}, None),
        'unfairSupplier': MemberSpec_('unfairSupplier', 'unfairSupplier', 0, 0, {'name': 'unfairSupplier', 'type': 'unfairSupplier'}, None),
        'purchase': MemberSpec_('purchase', 'purchase', 0, 1, {'minOccurs': '0', 'name': 'purchase', 'type': 'purchase'}, None),
        'notOosPurchase': MemberSpec_('notOosPurchase', 'xs:boolean', 0, 1, {'fixed': 'true', 'minOccurs': '0', 'name': 'notOosPurchase', 'type': 'xs:boolean'}, None),
        'contract': MemberSpec_('contract', 'contract', 0, 0, {'name': 'contract', 'type': 'contract'}, None),
        'exclude': MemberSpec_('exclude', 'exclude', 0, 1, {'minOccurs': '0', 'name': 'exclude', 'type': 'exclude'}, None),
        'finalDateInclude': MemberSpec_('finalDateInclude', 'xs:date', 0, 1, {'minOccurs': '0', 'name': 'finalDateInclude', 'type': 'xs:date'}, None),
        'autoExDateInfo': MemberSpec_('autoExDateInfo', 'autoExDateInfo', 0, 1, {'minOccurs': '0', 'name': 'autoExDateInfo', 'type': 'autoExDateInfo'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, schemeVersion=None, registryNum=None, publishDate=None, approveDate=None, occurrenceReasonDate=None, ergRequestApproveDate=None, state=None, publishOrg=None, createReason=None, approveReason=None, approveOrderReasonInfo=None, customer=None, unfairSupplier=None, purchase=None, notOosPurchase=None, contract=None, exclude=None, finalDateInclude=None, autoExDateInfo=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.schemeVersion = _cast(None, schemeVersion)
        self.schemeVersion_nsprefix_ = None
        self.registryNum = registryNum
        self.validate_zfcs_documentNumberType(self.registryNum)
        self.registryNum_nsprefix_ = None
        if isinstance(publishDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(publishDate, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = publishDate
        self.publishDate = initvalue_
        self.publishDate_nsprefix_ = None
        if isinstance(approveDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(approveDate, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = approveDate
        self.approveDate = initvalue_
        self.approveDate_nsprefix_ = None
        if isinstance(occurrenceReasonDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(occurrenceReasonDate, '%Y-%m-%d').date()
        else:
            initvalue_ = occurrenceReasonDate
        self.occurrenceReasonDate = initvalue_
        self.occurrenceReasonDate_nsprefix_ = None
        if isinstance(ergRequestApproveDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(ergRequestApproveDate, '%Y-%m-%d').date()
        else:
            initvalue_ = ergRequestApproveDate
        self.ergRequestApproveDate = initvalue_
        self.ergRequestApproveDate_nsprefix_ = None
        self.state = state
        self.state_nsprefix_ = None
        self.publishOrg = publishOrg
        self.publishOrg_nsprefix_ = None
        self.createReason = createReason
        self.validate_zfcs_longTextType(self.createReason)
        self.createReason_nsprefix_ = None
        self.approveReason = approveReason
        self.validate_zfcs_longTextType(self.approveReason)
        self.approveReason_nsprefix_ = None
        self.approveOrderReasonInfo = approveOrderReasonInfo
        self.approveOrderReasonInfo_nsprefix_ = None
        self.customer = customer
        self.customer_nsprefix_ = None
        self.unfairSupplier = unfairSupplier
        self.unfairSupplier_nsprefix_ = None
        self.purchase = purchase
        self.purchase_nsprefix_ = None
        self.notOosPurchase = notOosPurchase
        self.notOosPurchase_nsprefix_ = None
        self.contract = contract
        self.contract_nsprefix_ = None
        self.exclude = exclude
        self.exclude_nsprefix_ = None
        if isinstance(finalDateInclude, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(finalDateInclude, '%Y-%m-%d').date()
        else:
            initvalue_ = finalDateInclude
        self.finalDateInclude = initvalue_
        self.finalDateInclude_nsprefix_ = None
        self.autoExDateInfo = autoExDateInfo
        self.autoExDateInfo_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, zfcs_unfairSupplierType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if zfcs_unfairSupplierType.subclass:
            return zfcs_unfairSupplierType.subclass(*args_, **kwargs_)
        else:
            return zfcs_unfairSupplierType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_zfcs_documentNumberType(self, value):
        result = True
        # Validate type zfcs_documentNumberType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 100:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on zfcs_documentNumberType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_zfcs_longTextType(self, value):
        result = True
        # Validate type zfcs_longTextType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 2000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on zfcs_longTextType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_schemeVersionType(self, value):
        # Validate type base:schemeVersionType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['1.0', '4.1', '4.2', '4.3', '4.3.100', '4.4', '4.4.2', '4.5', '4.6', '5.0', '5.1', '5.2', '6.0', '6.1', '6.2', '6.2.100', '6.3', '6.4', '7.0', '7.1', '7.2', '7.3', '7.5', '8.0', '8.1', '8.2', '8.2.100', '8.3', '9.0', '9.1', '9.2', '9.3', '10.0', '10.1', '10.2', '10.2.310', '10.3', '11.0']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on schemeVersionType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            self.registryNum is not None or
            self.publishDate is not None or
            self.approveDate is not None or
            self.occurrenceReasonDate is not None or
            self.ergRequestApproveDate is not None or
            self.state is not None or
            self.publishOrg is not None or
            self.createReason is not None or
            self.approveReason is not None or
            self.approveOrderReasonInfo is not None or
            self.customer is not None or
            self.unfairSupplier is not None or
            self.purchase is not None or
            self.notOosPurchase is not None or
            self.contract is not None or
            self.exclude is not None or
            self.finalDateInclude is not None or
            self.autoExDateInfo is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('schemeVersion', node)
        if value is not None and 'schemeVersion' not in already_processed:
            already_processed.add('schemeVersion')
            self.schemeVersion = value
            self.validate_schemeVersionType(self.schemeVersion)    # validate type schemeVersionType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'registryNum':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'registryNum')
            value_ = self.gds_validate_string(value_, node, 'registryNum')
            self.registryNum = value_
            self.registryNum_nsprefix_ = child_.prefix
            # validate type zfcs_documentNumberType
            self.validate_zfcs_documentNumberType(self.registryNum)
        elif nodeName_ == 'publishDate':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.publishDate = dval_
            self.publishDate_nsprefix_ = child_.prefix
        elif nodeName_ == 'approveDate':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.approveDate = dval_
            self.approveDate_nsprefix_ = child_.prefix
        elif nodeName_ == 'occurrenceReasonDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.occurrenceReasonDate = dval_
            self.occurrenceReasonDate_nsprefix_ = child_.prefix
        elif nodeName_ == 'ergRequestApproveDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.ergRequestApproveDate = dval_
            self.ergRequestApproveDate_nsprefix_ = child_.prefix
        elif nodeName_ == 'state':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'state')
            value_ = self.gds_validate_string(value_, node, 'state')
            self.state = value_
            self.state_nsprefix_ = child_.prefix
        elif nodeName_ == 'publishOrg':
            class_obj_ = self.get_class_obj_(child_, zfcs_organizationRef)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.publishOrg = obj_
            obj_.original_tagname_ = 'publishOrg'
        elif nodeName_ == 'createReason':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'createReason')
            value_ = self.gds_validate_string(value_, node, 'createReason')
            self.createReason = value_
            self.createReason_nsprefix_ = child_.prefix
            # validate type zfcs_longTextType
            self.validate_zfcs_longTextType(self.createReason)
        elif nodeName_ == 'approveReason':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'approveReason')
            value_ = self.gds_validate_string(value_, node, 'approveReason')
            self.approveReason = value_
            self.approveReason_nsprefix_ = child_.prefix
            # validate type zfcs_longTextType
            self.validate_zfcs_longTextType(self.approveReason)
        elif nodeName_ == 'approveOrderReasonInfo':
            obj_ = approveOrderReasonInfo.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.approveOrderReasonInfo = obj_
            obj_.original_tagname_ = 'approveOrderReasonInfo'
        elif nodeName_ == 'customer':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'customer')
            value_ = self.gds_validate_string(value_, node, 'customer')
            self.customer = value_
            self.customer_nsprefix_ = child_.prefix
        elif nodeName_ == 'unfairSupplier':
            obj_ = unfairSupplier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.unfairSupplier = obj_
            obj_.original_tagname_ = 'unfairSupplier'
        elif nodeName_ == 'purchase':
            obj_ = purchase.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.purchase = obj_
            obj_.original_tagname_ = 'purchase'
        elif nodeName_ == 'notOosPurchase':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'notOosPurchase')
            ival_ = self.gds_validate_boolean(ival_, node, 'notOosPurchase')
            self.notOosPurchase = ival_
            self.notOosPurchase_nsprefix_ = child_.prefix
        elif nodeName_ == 'contract':
            obj_ = contract.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.contract = obj_
            obj_.original_tagname_ = 'contract'
        elif nodeName_ == 'exclude':
            obj_ = exclude.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.exclude = obj_
            obj_.original_tagname_ = 'exclude'
        elif nodeName_ == 'finalDateInclude':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.finalDateInclude = dval_
            self.finalDateInclude_nsprefix_ = child_.prefix
        elif nodeName_ == 'autoExDateInfo':
            obj_ = autoExDateInfo.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.autoExDateInfo = obj_
            obj_.original_tagname_ = 'autoExDateInfo'
# end class zfcs_unfairSupplierType


class state(GeneratedsSuper):
    """Статус информации
    REVIEW_CANCELED - Отклонена (Отказ во включении в РНП);
    PUBLISHED - Опубликована;
    ON_EXCLUSION - Заявка на исключение сведений;
    TEMP_EXCLUDED - Информация исключена из РНП на время судебного
    разбирательства;
    ARCHIVED - Информация исключена из РНП. Архив;"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, state)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if state.subclass:
            return state.subclass(*args_, **kwargs_)
        else:
            return state(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_state(self, value):
        result = True
        # Validate type state, a restriction on xs:string.
        pass
        return result
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class state


class approveOrderReasonInfo(GeneratedsSuper):
    """Основание для включения в РНП (решение/приказ)"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'number': MemberSpec_('number', ['unfairSupplierOrderNumberType', 'xs:string'], 0, 0, {'minOccurs': '1', 'name': 'number', 'type': 'xs:string'}, None),
        'date': MemberSpec_('date', 'xs:date', 0, 0, {'minOccurs': '1', 'name': 'date', 'type': 'xs:date'}, None),
        'approveReason': MemberSpec_('approveReason', ['text2000Type', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'approveReason', 'type': 'xs:string'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, number=None, date=None, approveReason=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.number = number
        self.validate_unfairSupplierOrderNumberType(self.number)
        self.number_nsprefix_ = None
        if isinstance(date, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(date, '%Y-%m-%d').date()
        else:
            initvalue_ = date
        self.date = initvalue_
        self.date_nsprefix_ = None
        self.approveReason = approveReason
        self.validate_text2000Type(self.approveReason)
        self.approveReason_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, approveOrderReasonInfo)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if approveOrderReasonInfo.subclass:
            return approveOrderReasonInfo.subclass(*args_, **kwargs_)
        else:
            return approveOrderReasonInfo(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_unfairSupplierOrderNumberType(self, value):
        result = True
        # Validate type unfairSupplierOrderNumberType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 60:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on unfairSupplierOrderNumberType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on unfairSupplierOrderNumberType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_text2000Type(self, value):
        result = True
        # Validate type text2000Type, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 2000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on text2000Type' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on text2000Type' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.number is not None or
            self.date is not None or
            self.approveReason is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'number':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'number')
            value_ = self.gds_validate_string(value_, node, 'number')
            self.number = value_
            self.number_nsprefix_ = child_.prefix
            # validate type unfairSupplierOrderNumberType
            self.validate_unfairSupplierOrderNumberType(self.number)
        elif nodeName_ == 'date':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.date = dval_
            self.date_nsprefix_ = child_.prefix
        elif nodeName_ == 'approveReason':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'approveReason')
            value_ = self.gds_validate_string(value_, node, 'approveReason')
            self.approveReason = value_
            self.approveReason_nsprefix_ = child_.prefix
            # validate type text2000Type
            self.validate_text2000Type(self.approveReason)
# end class approveOrderReasonInfo


class unfairSupplier(GeneratedsSuper):
    """Информация о недобросовестном поставщике (подрядчике, исполнителе)"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'fullName': MemberSpec_('fullName', ['zfcs_longTextType', 'xs:string'], 0, 0, {'name': 'fullName', 'type': 'xs:string'}, None),
        'type_': MemberSpec_('type_', ['zfcs_participantTypeEnum', 'xs:string'], 0, 0, {'name': 'type', 'type': 'xs:string'}, None),
        'firmName': MemberSpec_('firmName', ['zfcs_longTextType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'firmName', 'type': 'xs:string'}, None),
        'inn': MemberSpec_('inn', ['inn', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'inn', 'type': 'xs:string'}, None),
        'kpp': MemberSpec_('kpp', ['kppType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'kpp', 'type': 'xs:string'}, None),
        'place': MemberSpec_('place', 'place', 0, 1, {'minOccurs': '0', 'name': 'place', 'type': 'place'}, None),
        'email': MemberSpec_('email', ['email', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'email', 'type': 'xs:string'}, None),
        'founders': MemberSpec_('founders', 'founders', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'founders', 'type': 'founders'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, fullName=None, type_=None, firmName=None, inn=None, kpp=None, place=None, email=None, founders=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.fullName = fullName
        self.validate_zfcs_longTextType(self.fullName)
        self.fullName_nsprefix_ = None
        self.type_ = type_
        self.validate_zfcs_participantTypeEnum(self.type_)
        self.type__nsprefix_ = None
        self.firmName = firmName
        self.validate_zfcs_longTextType(self.firmName)
        self.firmName_nsprefix_ = None
        self.inn = inn
        self.inn_nsprefix_ = None
        self.kpp = kpp
        self.validate_kppType(self.kpp)
        self.kpp_nsprefix_ = None
        self.place = place
        self.place_nsprefix_ = None
        self.email = email
        self.email_nsprefix_ = None
        if founders is None:
            self.founders = []
        else:
            self.founders = founders
        self.founders_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, unfairSupplier)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if unfairSupplier.subclass:
            return unfairSupplier.subclass(*args_, **kwargs_)
        else:
            return unfairSupplier(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_zfcs_longTextType(self, value):
        result = True
        # Validate type zfcs_longTextType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 2000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on zfcs_longTextType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_zfcs_participantTypeEnum(self, value):
        result = True
        # Validate type zfcs_participantTypeEnum, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['P', 'PF', 'U', 'UF', 'B', 'BF']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on zfcs_participantTypeEnum' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_kppType(self, value):
        result = True
        # Validate type kppType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) != 9:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd length restriction on kppType' % {"value": encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.fullName is not None or
            self.type_ is not None or
            self.firmName is not None or
            self.inn is not None or
            self.kpp is not None or
            self.place is not None or
            self.email is not None or
            self.founders
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'fullName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'fullName')
            value_ = self.gds_validate_string(value_, node, 'fullName')
            self.fullName = value_
            self.fullName_nsprefix_ = child_.prefix
            # validate type zfcs_longTextType
            self.validate_zfcs_longTextType(self.fullName)
        elif nodeName_ == 'type':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'type')
            value_ = self.gds_validate_string(value_, node, 'type')
            self.type_ = value_
            self.type_nsprefix_ = child_.prefix
            # validate type zfcs_participantTypeEnum
            self.validate_zfcs_participantTypeEnum(self.type_)
        elif nodeName_ == 'firmName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'firmName')
            value_ = self.gds_validate_string(value_, node, 'firmName')
            self.firmName = value_
            self.firmName_nsprefix_ = child_.prefix
            # validate type zfcs_longTextType
            self.validate_zfcs_longTextType(self.firmName)
        elif nodeName_ == 'inn':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'inn')
            value_ = self.gds_validate_string(value_, node, 'inn')
            self.inn = value_
            self.inn_nsprefix_ = child_.prefix
        elif nodeName_ == 'kpp':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'kpp')
            value_ = self.gds_validate_string(value_, node, 'kpp')
            self.kpp = value_
            self.kpp_nsprefix_ = child_.prefix
            # validate type kppType
            self.validate_kppType(self.kpp)
        elif nodeName_ == 'place':
            obj_ = place.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.place = obj_
            obj_.original_tagname_ = 'place'
        elif nodeName_ == 'email':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'email')
            value_ = self.gds_validate_string(value_, node, 'email')
            self.email = value_
            self.email_nsprefix_ = child_.prefix
        elif nodeName_ == 'founders':
            obj_ = founders.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.founders.append(obj_)
            obj_.original_tagname_ = 'founders'
# end class unfairSupplier


class inn(GeneratedsSuper):
    """ИНН (или аналог ИНН для иностранного поставщика)"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, inn)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if inn.subclass:
            return inn.subclass(*args_, **kwargs_)
        else:
            return inn(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_inn(self, value):
        result = True
        # Validate type inn, a restriction on xs:string.
        pass
        return result
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class inn


class place(GeneratedsSuper):
    """Место нахождения юридического лица"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'kladr': MemberSpec_('kladr', 'zfcs_kladrType', 0, 1, {'name': 'kladr', 'type': 'kladr'}, 69),
        'country': MemberSpec_('country', 'zfcs_countryRef', 0, 1, {'name': 'country', 'type': 'zfcs_countryRef'}, 69),
        'zip': MemberSpec_('zip', ['zip', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'zip', 'type': 'xs:string'}, None),
        'place': MemberSpec_('place', ['zfcs_longTextType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'place', 'type': 'xs:string'}, None),
        'email': MemberSpec_('email', ['email', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'email', 'type': 'xs:string'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, kladr=None, country=None, zip=None, place_member=None, email=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.kladr = kladr
        self.kladr_nsprefix_ = None
        self.country = country
        self.country_nsprefix_ = None
        self.zip = zip
        self.zip_nsprefix_ = None
        self.place = place_member
        self.validate_zfcs_longTextType(self.place)
        self.place_nsprefix_ = None
        self.email = email
        self.email_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, place)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if place.subclass:
            return place.subclass(*args_, **kwargs_)
        else:
            return place(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_zfcs_longTextType(self, value):
        result = True
        # Validate type zfcs_longTextType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 2000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on zfcs_longTextType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.kladr is not None or
            self.country is not None or
            self.zip is not None or
            self.place is not None or
            self.email is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'kladr':
            obj_ = kladr.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.kladr = obj_
            obj_.original_tagname_ = 'kladr'
        elif nodeName_ == 'country':
            obj_ = zfcs_countryRef.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.country = obj_
            obj_.original_tagname_ = 'country'
        elif nodeName_ == 'zip':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'zip')
            value_ = self.gds_validate_string(value_, node, 'zip')
            self.zip = value_
            self.zip_nsprefix_ = child_.prefix
        elif nodeName_ == 'place':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'place')
            value_ = self.gds_validate_string(value_, node, 'place')
            self.place = value_
            self.place_nsprefix_ = child_.prefix
            # validate type zfcs_longTextType
            self.validate_zfcs_longTextType(self.place)
        elif nodeName_ == 'email':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'email')
            value_ = self.gds_validate_string(value_, node, 'email')
            self.email = value_
            self.email_nsprefix_ = child_.prefix
# end class place


class kladr(GeneratedsSuper):
    """Код КЛАДР - если в РФ"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'subjectRF': MemberSpec_('subjectRF', ['zfcs_kladrTextType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'subjectRF', 'type': 'xs:string'}, 69),
        'area': MemberSpec_('area', ['zfcs_kladrTextType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'area', 'type': 'xs:string'}, 69),
        'city': MemberSpec_('city', ['zfcs_kladrTextType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'city', 'type': 'xs:string'}, 69),
        'street': MemberSpec_('street', ['zfcs_kladrTextType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'street', 'type': 'xs:string'}, 69),
        'building': MemberSpec_('building', ['zfcs_kladrTextType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'building', 'type': 'xs:string'}, 69),
        'office': MemberSpec_('office', ['zfcs_kladrTextType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'office', 'type': 'xs:string'}, 69),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, subjectRF=None, area=None, city=None, street=None, building=None, office=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.subjectRF = subjectRF
        self.validate_zfcs_kladrTextType(self.subjectRF)
        self.subjectRF_nsprefix_ = None
        self.area = area
        self.validate_zfcs_kladrTextType(self.area)
        self.area_nsprefix_ = None
        self.city = city
        self.validate_zfcs_kladrTextType(self.city)
        self.city_nsprefix_ = None
        self.street = street
        self.validate_zfcs_kladrTextType(self.street)
        self.street_nsprefix_ = None
        self.building = building
        self.validate_zfcs_kladrTextType(self.building)
        self.building_nsprefix_ = None
        self.office = office
        self.validate_zfcs_kladrTextType(self.office)
        self.office_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, kladr)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if kladr.subclass:
            return kladr.subclass(*args_, **kwargs_)
        else:
            return kladr(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_zfcs_kladrTextType(self, value):
        result = True
        # Validate type zfcs_kladrTextType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 200:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on zfcs_kladrTextType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on zfcs_kladrTextType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.subjectRF is not None or
            self.area is not None or
            self.city is not None or
            self.street is not None or
            self.building is not None or
            self.office is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'subjectRF':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'subjectRF')
            value_ = self.gds_validate_string(value_, node, 'subjectRF')
            self.subjectRF = value_
            self.subjectRF_nsprefix_ = child_.prefix
            # validate type zfcs_kladrTextType
            self.validate_zfcs_kladrTextType(self.subjectRF)
        elif nodeName_ == 'area':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'area')
            value_ = self.gds_validate_string(value_, node, 'area')
            self.area = value_
            self.area_nsprefix_ = child_.prefix
            # validate type zfcs_kladrTextType
            self.validate_zfcs_kladrTextType(self.area)
        elif nodeName_ == 'city':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'city')
            value_ = self.gds_validate_string(value_, node, 'city')
            self.city = value_
            self.city_nsprefix_ = child_.prefix
            # validate type zfcs_kladrTextType
            self.validate_zfcs_kladrTextType(self.city)
        elif nodeName_ == 'street':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'street')
            value_ = self.gds_validate_string(value_, node, 'street')
            self.street = value_
            self.street_nsprefix_ = child_.prefix
            # validate type zfcs_kladrTextType
            self.validate_zfcs_kladrTextType(self.street)
        elif nodeName_ == 'building':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'building')
            value_ = self.gds_validate_string(value_, node, 'building')
            self.building = value_
            self.building_nsprefix_ = child_.prefix
            # validate type zfcs_kladrTextType
            self.validate_zfcs_kladrTextType(self.building)
        elif nodeName_ == 'office':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'office')
            value_ = self.gds_validate_string(value_, node, 'office')
            self.office = value_
            self.office_nsprefix_ = child_.prefix
            # validate type zfcs_kladrTextType
            self.validate_zfcs_kladrTextType(self.office)
        super(kladr, self).buildChildren(child_, node, nodeName_, True)
# end class kladr


class zip(GeneratedsSuper):
    """Почтовый индекс"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, zip)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if zip.subclass:
            return zip.subclass(*args_, **kwargs_)
        else:
            return zip(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_zip(self, value):
        result = True
        # Validate type zip, a restriction on xs:string.
        pass
        return result
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class zip


class email(GeneratedsSuper):
    """Адрес электронной почты.
    (Устарело, не применяется)"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, email)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if email.subclass:
            return email.subclass(*args_, **kwargs_)
        else:
            return email(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_email(self, value):
        result = True
        # Validate type email, a restriction on xs:string.
        pass
        return result
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class email


class founders(GeneratedsSuper):
    """Учредители, члены коллегиальных исполнительных органов, лица,
    исполняющие функции единоличного исполнительного органа юридического
    лица"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'names': MemberSpec_('names', ['zfcs_longTextType', 'xs:string'], 0, 0, {'name': 'names', 'type': 'xs:string'}, None),
        'inn': MemberSpec_('inn', ['inn', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'inn', 'type': 'xs:string'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, names=None, inn=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.names = names
        self.validate_zfcs_longTextType(self.names)
        self.names_nsprefix_ = None
        self.inn = inn
        self.inn_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, founders)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if founders.subclass:
            return founders.subclass(*args_, **kwargs_)
        else:
            return founders(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_zfcs_longTextType(self, value):
        result = True
        # Validate type zfcs_longTextType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 2000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on zfcs_longTextType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.names is not None or
            self.inn is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'names':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'names')
            value_ = self.gds_validate_string(value_, node, 'names')
            self.names = value_
            self.names_nsprefix_ = child_.prefix
            # validate type zfcs_longTextType
            self.validate_zfcs_longTextType(self.names)
        elif nodeName_ == 'inn':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'inn')
            value_ = self.gds_validate_string(value_, node, 'inn')
            self.inn = value_
            self.inn_nsprefix_ = child_.prefix
# end class founders


class placingWayName(GeneratedsSuper):
    """Наименование подспособа определения поставщика"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, placingWayName)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if placingWayName.subclass:
            return placingWayName.subclass(*args_, **kwargs_)
        else:
            return placingWayName(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_placingWayName(self, value):
        result = True
        # Validate type placingWayName, a restriction on xs:string.
        pass
        return result
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class placingWayName


class cancel(GeneratedsSuper):
    """Расторжение контракта"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'signDate': MemberSpec_('signDate', 'xs:date', 0, 1, {'minOccurs': '0', 'name': 'signDate', 'type': 'xs:date'}, None),
        'performanceDate': MemberSpec_('performanceDate', 'xs:date', 0, 0, {'name': 'performanceDate', 'type': 'xs:date'}, None),
        'base': MemberSpec_('base', 'base', 0, 0, {'name': 'base', 'type': 'base'}, None),
        'cancelDate': MemberSpec_('cancelDate', 'xs:date', 0, 0, {'name': 'cancelDate', 'type': 'xs:date'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, signDate=None, performanceDate=None, base=None, cancelDate=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if isinstance(signDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(signDate, '%Y-%m-%d').date()
        else:
            initvalue_ = signDate
        self.signDate = initvalue_
        self.signDate_nsprefix_ = None
        if isinstance(performanceDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(performanceDate, '%Y-%m-%d').date()
        else:
            initvalue_ = performanceDate
        self.performanceDate = initvalue_
        self.performanceDate_nsprefix_ = None
        self.base = base
        self.base_nsprefix_ = None
        if isinstance(cancelDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(cancelDate, '%Y-%m-%d').date()
        else:
            initvalue_ = cancelDate
        self.cancelDate = initvalue_
        self.cancelDate_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, cancel)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if cancel.subclass:
            return cancel.subclass(*args_, **kwargs_)
        else:
            return cancel(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.signDate is not None or
            self.performanceDate is not None or
            self.base is not None or
            self.cancelDate is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'signDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.signDate = dval_
            self.signDate_nsprefix_ = child_.prefix
        elif nodeName_ == 'performanceDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.performanceDate = dval_
            self.performanceDate_nsprefix_ = child_.prefix
        elif nodeName_ == 'base':
            obj_ = base.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.base = obj_
            obj_.original_tagname_ = 'base'
        elif nodeName_ == 'cancelDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.cancelDate = dval_
            self.cancelDate_nsprefix_ = child_.prefix
# end class cancel


class base(GeneratedsSuper):
    """Основание для расторжения контракта"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'name': MemberSpec_('name', ['zfcs_longTextType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'name', 'type': 'xs:string'}, None),
        'number': MemberSpec_('number', ['zfcs_documentNumberType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'number', 'type': 'xs:string'}, None),
        'date': MemberSpec_('date', 'xs:date', 0, 1, {'minOccurs': '0', 'name': 'date', 'type': 'xs:date'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, name=None, number=None, date=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.name = name
        self.validate_zfcs_longTextType(self.name)
        self.name_nsprefix_ = None
        self.number = number
        self.validate_zfcs_documentNumberType(self.number)
        self.number_nsprefix_ = None
        if isinstance(date, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(date, '%Y-%m-%d').date()
        else:
            initvalue_ = date
        self.date = initvalue_
        self.date_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, base)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if base.subclass:
            return base.subclass(*args_, **kwargs_)
        else:
            return base(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_zfcs_longTextType(self, value):
        result = True
        # Validate type zfcs_longTextType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 2000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on zfcs_longTextType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_zfcs_documentNumberType(self, value):
        result = True
        # Validate type zfcs_documentNumberType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 100:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on zfcs_documentNumberType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.name is not None or
            self.number is not None or
            self.date is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'name')
            value_ = self.gds_validate_string(value_, node, 'name')
            self.name = value_
            self.name_nsprefix_ = child_.prefix
            # validate type zfcs_longTextType
            self.validate_zfcs_longTextType(self.name)
        elif nodeName_ == 'number':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'number')
            value_ = self.gds_validate_string(value_, node, 'number')
            self.number = value_
            self.number_nsprefix_ = child_.prefix
            # validate type zfcs_documentNumberType
            self.validate_zfcs_documentNumberType(self.number)
        elif nodeName_ == 'date':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.date = dval_
            self.date_nsprefix_ = child_.prefix
# end class base


class exclude(GeneratedsSuper):
    """Исключение из реестра"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'excludeDate': MemberSpec_('excludeDate', 'xs:dateTime', 0, 0, {'name': 'excludeDate', 'type': 'xs:dateTime'}, None),
        'name': MemberSpec_('name', ['zfcs_longTextType', 'xs:string'], 0, 0, {'name': 'name', 'type': 'xs:string'}, None),
        'date': MemberSpec_('date', 'xs:date', 0, 0, {'name': 'date', 'type': 'xs:date'}, None),
        'number': MemberSpec_('number', ['zfcs_documentNumberType', 'xs:string'], 0, 0, {'name': 'number', 'type': 'xs:string'}, None),
        'type_': MemberSpec_('type_', ['type', 'xs:string'], 0, 0, {'name': 'type', 'type': 'xs:string'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, excludeDate=None, name=None, date=None, number=None, type_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if isinstance(excludeDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(excludeDate, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = excludeDate
        self.excludeDate = initvalue_
        self.excludeDate_nsprefix_ = None
        self.name = name
        self.validate_zfcs_longTextType(self.name)
        self.name_nsprefix_ = None
        if isinstance(date, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(date, '%Y-%m-%d').date()
        else:
            initvalue_ = date
        self.date = initvalue_
        self.date_nsprefix_ = None
        self.number = number
        self.validate_zfcs_documentNumberType(self.number)
        self.number_nsprefix_ = None
        self.type_ = type_
        self.type__nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, exclude)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if exclude.subclass:
            return exclude.subclass(*args_, **kwargs_)
        else:
            return exclude(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_zfcs_longTextType(self, value):
        result = True
        # Validate type zfcs_longTextType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 2000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on zfcs_longTextType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_zfcs_documentNumberType(self, value):
        result = True
        # Validate type zfcs_documentNumberType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 100:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on zfcs_documentNumberType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.excludeDate is not None or
            self.name is not None or
            self.date is not None or
            self.number is not None or
            self.type_ is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'excludeDate':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.excludeDate = dval_
            self.excludeDate_nsprefix_ = child_.prefix
        elif nodeName_ == 'name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'name')
            value_ = self.gds_validate_string(value_, node, 'name')
            self.name = value_
            self.name_nsprefix_ = child_.prefix
            # validate type zfcs_longTextType
            self.validate_zfcs_longTextType(self.name)
        elif nodeName_ == 'date':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.date = dval_
            self.date_nsprefix_ = child_.prefix
        elif nodeName_ == 'number':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'number')
            value_ = self.gds_validate_string(value_, node, 'number')
            self.number = value_
            self.number_nsprefix_ = child_.prefix
            # validate type zfcs_documentNumberType
            self.validate_zfcs_documentNumberType(self.number)
        elif nodeName_ == 'type':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'type')
            value_ = self.gds_validate_string(value_, node, 'type')
            self.type_ = value_
            self.type_nsprefix_ = child_.prefix
# end class exclude


class type_(GeneratedsSuper):
    """Тип исключения из реестра:
    ORDER - Приказ об исключении из реестра;
    EXCLUSION - Решение суда об исключении сведений из РНП;
    ROLLBACK - Решение суда об отмене решения ФАС."""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, type_)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if type_.subclass:
            return type_.subclass(*args_, **kwargs_)
        else:
            return type_(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_type(self, value):
        result = True
        # Validate type type, a restriction on xs:string.
        pass
        return result
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class type_


class autoExDateInfo(GeneratedsSuper):
    """Информация о дате автоматического исключения"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'autoExDateCalcSign': MemberSpec_('autoExDateCalcSign', ['autoExDateCalcSign', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'autoExDateCalcSign', 'type': 'xs:string'}, None),
        'autoExDate': MemberSpec_('autoExDate', 'xs:date', 0, 1, {'minOccurs': '0', 'name': 'autoExDate', 'type': 'xs:date'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, autoExDateCalcSign=None, autoExDate=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.autoExDateCalcSign = autoExDateCalcSign
        self.autoExDateCalcSign_nsprefix_ = None
        if isinstance(autoExDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(autoExDate, '%Y-%m-%d').date()
        else:
            initvalue_ = autoExDate
        self.autoExDate = initvalue_
        self.autoExDate_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, autoExDateInfo)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if autoExDateInfo.subclass:
            return autoExDateInfo.subclass(*args_, **kwargs_)
        else:
            return autoExDateInfo(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.autoExDateCalcSign is not None or
            self.autoExDate is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'autoExDateCalcSign':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'autoExDateCalcSign')
            value_ = self.gds_validate_string(value_, node, 'autoExDateCalcSign')
            self.autoExDateCalcSign = value_
            self.autoExDateCalcSign_nsprefix_ = child_.prefix
        elif nodeName_ == 'autoExDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.autoExDate = dval_
            self.autoExDate_nsprefix_ = child_.prefix
# end class autoExDateInfo


class autoExDateCalcSign(GeneratedsSuper):
    """Признак расчета даты автоматического исключения из реестра:
    ACTUAL – расчет на основании даты фактического включения в реестр
    (approveDate);
    FINAL – расчет на основании предельной даты включения в реестр
    (finalDateInclude)."""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, autoExDateCalcSign)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if autoExDateCalcSign.subclass:
            return autoExDateCalcSign.subclass(*args_, **kwargs_)
        else:
            return autoExDateCalcSign(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_autoExDateCalcSign(self, value):
        result = True
        # Validate type autoExDateCalcSign, a restriction on xs:string.
        pass
        return result
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class autoExDateCalcSign


class zfcs_violationType(GeneratedsSuper):
    """Нарушение приема"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'errCode': MemberSpec_('errCode', ['errCode', 'xs:string'], 0, 0, {'name': 'errCode', 'type': 'xs:string'}, None),
        'level': MemberSpec_('level', ['zfcs_violationLevelType', 'xs:string'], 0, 0, {'name': 'level', 'type': 'xs:string'}, None),
        'name': MemberSpec_('name', ['name', 'xs:string'], 0, 0, {'name': 'name', 'type': 'xs:string'}, None),
        'description': MemberSpec_('description', ['zfcs_longTextMinType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'description', 'type': 'xs:string'}, None),
        'fullErrorLog': MemberSpec_('fullErrorLog', 'xs:base64Binary', 0, 1, {'minOccurs': '0', 'name': 'fullErrorLog', 'type': 'xs:base64Binary'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, errCode=None, level=None, name=None, description=None, fullErrorLog=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.errCode = errCode
        self.errCode_nsprefix_ = None
        self.level = level
        self.validate_zfcs_violationLevelType(self.level)
        self.level_nsprefix_ = None
        self.name = name
        self.name_nsprefix_ = None
        self.description = description
        self.validate_zfcs_longTextMinType(self.description)
        self.description_nsprefix_ = None
        self.fullErrorLog = fullErrorLog
        self.fullErrorLog_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, zfcs_violationType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if zfcs_violationType.subclass:
            return zfcs_violationType.subclass(*args_, **kwargs_)
        else:
            return zfcs_violationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_zfcs_violationLevelType(self, value):
        result = True
        # Validate type zfcs_violationLevelType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['error', 'warning']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on zfcs_violationLevelType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_zfcs_longTextMinType(self, value):
        result = True
        # Validate type zfcs_longTextMinType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 2000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on zfcs_longTextMinType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on zfcs_longTextMinType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.errCode is not None or
            self.level is not None or
            self.name is not None or
            self.description is not None or
            self.fullErrorLog is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'errCode':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'errCode')
            value_ = self.gds_validate_string(value_, node, 'errCode')
            self.errCode = value_
            self.errCode_nsprefix_ = child_.prefix
        elif nodeName_ == 'level':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'level')
            value_ = self.gds_validate_string(value_, node, 'level')
            self.level = value_
            self.level_nsprefix_ = child_.prefix
            # validate type zfcs_violationLevelType
            self.validate_zfcs_violationLevelType(self.level)
        elif nodeName_ == 'name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'name')
            value_ = self.gds_validate_string(value_, node, 'name')
            self.name = value_
            self.name_nsprefix_ = child_.prefix
        elif nodeName_ == 'description':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'description')
            value_ = self.gds_validate_string(value_, node, 'description')
            self.description = value_
            self.description_nsprefix_ = child_.prefix
            # validate type zfcs_longTextMinType
            self.validate_zfcs_longTextMinType(self.description)
        elif nodeName_ == 'fullErrorLog':
            sval_ = child_.text
            if sval_ is not None:
                try:
                    bval_ = base64.b64decode(sval_)
                except (TypeError, ValueError) as exp:
                    raise_parse_error(child_, 'requires base64 encoded string: %s' % exp)
                bval_ = self.gds_validate_base64(bval_, node, 'fullErrorLog')
            else:
                bval_ = None
            self.fullErrorLog = bval_
            self.fullErrorLog_nsprefix_ = child_.prefix
# end class zfcs_violationType


class errCode(GeneratedsSuper):
    """Код ошибки"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, errCode)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if errCode.subclass:
            return errCode.subclass(*args_, **kwargs_)
        else:
            return errCode(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_errCode(self, value):
        result = True
        # Validate type errCode, a restriction on xs:string.
        pass
        return result
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class errCode


class zfcs_currencyRef(GeneratedsSuper):
    """Тип: Ссылка на ОКВ"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'code': MemberSpec_('code', ['currencyCodeType', 'xs:string'], 0, 0, {'name': 'code', 'type': 'xs:string'}, None),
        'name': MemberSpec_('name', ['text50Type', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'name', 'type': 'xs:string'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, code=None, name=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.code = code
        self.validate_currencyCodeType(self.code)
        self.code_nsprefix_ = None
        self.name = name
        self.validate_text50Type(self.name)
        self.name_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, zfcs_currencyRef)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if zfcs_currencyRef.subclass:
            return zfcs_currencyRef.subclass(*args_, **kwargs_)
        else:
            return zfcs_currencyRef(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_currencyCodeType(self, value):
        result = True
        # Validate type currencyCodeType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 3:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on currencyCodeType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on currencyCodeType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_text50Type(self, value):
        result = True
        # Validate type text50Type, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 50:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on text50Type' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on text50Type' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.code is not None or
            self.name is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'code':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'code')
            value_ = self.gds_validate_string(value_, node, 'code')
            self.code = value_
            self.code_nsprefix_ = child_.prefix
            # validate type currencyCodeType
            self.validate_currencyCodeType(self.code)
        elif nodeName_ == 'name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'name')
            value_ = self.gds_validate_string(value_, node, 'name')
            self.name = value_
            self.name_nsprefix_ = child_.prefix
            # validate type text50Type
            self.validate_text50Type(self.name)
# end class zfcs_currencyRef


class zfcs_KTRURef(GeneratedsSuper):
    """Тип: Ссылка на КТРУ"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'code': MemberSpec_('code', ['ktruCodeType', 'xs:string'], 0, 0, {'name': 'code', 'type': 'xs:string'}, None),
        'name': MemberSpec_('name', ['text2000Type', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'name', 'type': 'xs:string'}, None),
        'versionId': MemberSpec_('versionId', 'xs:long', 0, 1, {'minOccurs': '0', 'name': 'versionId', 'type': 'xs:long'}, None),
        'versionNumber': MemberSpec_('versionNumber', 'xs:int', 0, 1, {'minOccurs': '0', 'name': 'versionNumber', 'type': 'xs:int'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_) + ['extensiontype_']
    subclass = None
    superclass = None
    def __init__(self, code=None, name=None, versionId=None, versionNumber=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.code = code
        self.validate_ktruCodeType(self.code)
        self.code_nsprefix_ = None
        self.name = name
        self.validate_text2000Type(self.name)
        self.name_nsprefix_ = None
        self.versionId = versionId
        self.versionId_nsprefix_ = None
        self.versionNumber = versionNumber
        self.versionNumber_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, zfcs_KTRURef)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if zfcs_KTRURef.subclass:
            return zfcs_KTRURef.subclass(*args_, **kwargs_)
        else:
            return zfcs_KTRURef(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_ktruCodeType(self, value):
        result = True
        # Validate type ktruCodeType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 25:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ktruCodeType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ktruCodeType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_text2000Type(self, value):
        result = True
        # Validate type text2000Type, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 2000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on text2000Type' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on text2000Type' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.code is not None or
            self.name is not None or
            self.versionId is not None or
            self.versionNumber is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'code':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'code')
            value_ = self.gds_validate_string(value_, node, 'code')
            self.code = value_
            self.code_nsprefix_ = child_.prefix
            # validate type ktruCodeType
            self.validate_ktruCodeType(self.code)
        elif nodeName_ == 'name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'name')
            value_ = self.gds_validate_string(value_, node, 'name')
            self.name = value_
            self.name_nsprefix_ = child_.prefix
            # validate type text2000Type
            self.validate_text2000Type(self.name)
        elif nodeName_ == 'versionId' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'versionId')
            ival_ = self.gds_validate_integer(ival_, node, 'versionId')
            self.versionId = ival_
            self.versionId_nsprefix_ = child_.prefix
        elif nodeName_ == 'versionNumber' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'versionNumber')
            ival_ = self.gds_validate_integer(ival_, node, 'versionNumber')
            self.versionNumber = ival_
            self.versionNumber_nsprefix_ = child_.prefix
# end class zfcs_KTRURef


class zfcs_budgetFundsContract2015(GeneratedsSuper):
    """Тип: Ссылка на Код и наименование бюджета в контракте"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'code': MemberSpec_('code', ['budgetCodeType', 'xs:string'], 0, 0, {'name': 'code', 'type': 'xs:string'}, None),
        'name': MemberSpec_('name', ['text2000Type', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'name', 'type': 'xs:string'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, code=None, name=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.code = code
        self.validate_budgetCodeType(self.code)
        self.code_nsprefix_ = None
        self.name = name
        self.validate_text2000Type(self.name)
        self.name_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, zfcs_budgetFundsContract2015)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if zfcs_budgetFundsContract2015.subclass:
            return zfcs_budgetFundsContract2015.subclass(*args_, **kwargs_)
        else:
            return zfcs_budgetFundsContract2015(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_budgetCodeType(self, value):
        result = True
        # Validate type budgetCodeType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 8:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on budgetCodeType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on budgetCodeType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_text2000Type(self, value):
        result = True
        # Validate type text2000Type, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 2000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on text2000Type' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on text2000Type' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.code is not None or
            self.name is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'code':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'code')
            value_ = self.gds_validate_string(value_, node, 'code')
            self.code = value_
            self.code_nsprefix_ = child_.prefix
            # validate type budgetCodeType
            self.validate_budgetCodeType(self.code)
        elif nodeName_ == 'name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'name')
            value_ = self.gds_validate_string(value_, node, 'name')
            self.name = value_
            self.name_nsprefix_ = child_.prefix
            # validate type text2000Type
            self.validate_text2000Type(self.name)
# end class zfcs_budgetFundsContract2015


class zfcs_tenderPlan2017ContractLifeCycleCaseRef(GeneratedsSuper):
    """Тип: Ссылка на справочник: Случаи заключения контракта жизненного
    цикла"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'code': MemberSpec_('code', ['contractLifeCycleCaseCodeType', 'text10Type', 'xs:string'], 0, 0, {'name': 'code', 'type': 'xs:string'}, None),
        'name': MemberSpec_('name', ['text2000Type', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'name', 'type': 'xs:string'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, code=None, name=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.code = code
        self.validate_contractLifeCycleCaseCodeType(self.code)
        self.code_nsprefix_ = None
        self.name = name
        self.validate_text2000Type(self.name)
        self.name_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, zfcs_tenderPlan2017ContractLifeCycleCaseRef)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if zfcs_tenderPlan2017ContractLifeCycleCaseRef.subclass:
            return zfcs_tenderPlan2017ContractLifeCycleCaseRef.subclass(*args_, **kwargs_)
        else:
            return zfcs_tenderPlan2017ContractLifeCycleCaseRef(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_contractLifeCycleCaseCodeType(self, value):
        result = True
        # Validate type contractLifeCycleCaseCodeType, a restriction on text10Type.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 10:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on contractLifeCycleCaseCodeType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on contractLifeCycleCaseCodeType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_text2000Type(self, value):
        result = True
        # Validate type text2000Type, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 2000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on text2000Type' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on text2000Type' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.code is not None or
            self.name is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'code':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'code')
            value_ = self.gds_validate_string(value_, node, 'code')
            self.code = value_
            self.code_nsprefix_ = child_.prefix
            # validate type contractLifeCycleCaseCodeType
            self.validate_contractLifeCycleCaseCodeType(self.code)
        elif nodeName_ == 'name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'name')
            value_ = self.gds_validate_string(value_, node, 'name')
            self.name = value_
            self.name_nsprefix_ = child_.prefix
            # validate type text2000Type
            self.validate_text2000Type(self.name)
# end class zfcs_tenderPlan2017ContractLifeCycleCaseRef


class zfcs_deviationFactFoundation(GeneratedsSuper):
    """Тип: Ссылка на справочник Причины признания участника уклонившимся от
    заключения контракта"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'code': MemberSpec_('code', ['deviationFactFoundationCodeType', 'text10Type', 'xs:string'], 0, 0, {'name': 'code', 'type': 'xs:string'}, None),
        'name': MemberSpec_('name', ['text1000Type', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'name', 'type': 'xs:string'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, code=None, name=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.code = code
        self.validate_deviationFactFoundationCodeType(self.code)
        self.code_nsprefix_ = None
        self.name = name
        self.validate_text1000Type(self.name)
        self.name_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, zfcs_deviationFactFoundation)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if zfcs_deviationFactFoundation.subclass:
            return zfcs_deviationFactFoundation.subclass(*args_, **kwargs_)
        else:
            return zfcs_deviationFactFoundation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_deviationFactFoundationCodeType(self, value):
        result = True
        # Validate type deviationFactFoundationCodeType, a restriction on text10Type.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 10:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on deviationFactFoundationCodeType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on deviationFactFoundationCodeType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_text1000Type(self, value):
        result = True
        # Validate type text1000Type, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on text1000Type' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on text1000Type' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.code is not None or
            self.name is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'code':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'code')
            value_ = self.gds_validate_string(value_, node, 'code')
            self.code = value_
            self.code_nsprefix_ = child_.prefix
            # validate type deviationFactFoundationCodeType
            self.validate_deviationFactFoundationCodeType(self.code)
        elif nodeName_ == 'name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'name')
            value_ = self.gds_validate_string(value_, node, 'name')
            self.name = value_
            self.name_nsprefix_ = child_.prefix
            # validate type text1000Type
            self.validate_text1000Type(self.name)
# end class zfcs_deviationFactFoundation


class zfcs_ETPType(GeneratedsSuper):
    """Тип: Ссылка на справочник Электронные площадки"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'code': MemberSpec_('code', ['etpCodeType', 'xs:string'], 0, 0, {'name': 'code', 'type': 'xs:string'}, None),
        'name': MemberSpec_('name', ['text200Type', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'name', 'type': 'xs:string'}, None),
        'url': MemberSpec_('url', ['hrefType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'url', 'type': 'xs:string'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, code=None, name=None, url=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.code = code
        self.validate_etpCodeType(self.code)
        self.code_nsprefix_ = None
        self.name = name
        self.validate_text200Type(self.name)
        self.name_nsprefix_ = None
        self.url = url
        self.validate_hrefType(self.url)
        self.url_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, zfcs_ETPType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if zfcs_ETPType.subclass:
            return zfcs_ETPType.subclass(*args_, **kwargs_)
        else:
            return zfcs_ETPType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_etpCodeType(self, value):
        result = True
        # Validate type etpCodeType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 20:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on etpCodeType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on etpCodeType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_text200Type(self, value):
        result = True
        # Validate type text200Type, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 200:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on text200Type' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on text200Type' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_hrefType(self, value):
        result = True
        # Validate type hrefType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on hrefType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on hrefType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.code is not None or
            self.name is not None or
            self.url is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'code':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'code')
            value_ = self.gds_validate_string(value_, node, 'code')
            self.code = value_
            self.code_nsprefix_ = child_.prefix
            # validate type etpCodeType
            self.validate_etpCodeType(self.code)
        elif nodeName_ == 'name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'name')
            value_ = self.gds_validate_string(value_, node, 'name')
            self.name = value_
            self.name_nsprefix_ = child_.prefix
            # validate type text200Type
            self.validate_text200Type(self.name)
        elif nodeName_ == 'url':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'url')
            value_ = self.gds_validate_string(value_, node, 'url')
            self.url = value_
            self.url_nsprefix_ = child_.prefix
            # validate type hrefType
            self.validate_hrefType(self.url)
# end class zfcs_ETPType


class zfcs_okopfRef(GeneratedsSuper):
    """Тип: Ссылка на ОКОПФ"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'code': MemberSpec_('code', ['okopfCodeType', 'xs:string'], 0, 0, {'name': 'code', 'type': 'xs:string'}, None),
        'singularName': MemberSpec_('singularName', ['text2000Type', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'singularName', 'type': 'xs:string'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, code=None, singularName=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.code = code
        self.validate_okopfCodeType(self.code)
        self.code_nsprefix_ = None
        self.singularName = singularName
        self.validate_text2000Type(self.singularName)
        self.singularName_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, zfcs_okopfRef)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if zfcs_okopfRef.subclass:
            return zfcs_okopfRef.subclass(*args_, **kwargs_)
        else:
            return zfcs_okopfRef(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_okopfCodeType(self, value):
        result = True
        # Validate type okopfCodeType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 5:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on okopfCodeType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on okopfCodeType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_text2000Type(self, value):
        result = True
        # Validate type text2000Type, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 2000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on text2000Type' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on text2000Type' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.code is not None or
            self.singularName is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'code':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'code')
            value_ = self.gds_validate_string(value_, node, 'code')
            self.code = value_
            self.code_nsprefix_ = child_.prefix
            # validate type okopfCodeType
            self.validate_okopfCodeType(self.code)
        elif nodeName_ == 'singularName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'singularName')
            value_ = self.gds_validate_string(value_, node, 'singularName')
            self.singularName = value_
            self.singularName_nsprefix_ = child_.prefix
            # validate type text2000Type
            self.validate_text2000Type(self.singularName)
# end class zfcs_okopfRef


class zfcs_OKPD2Ref(GeneratedsSuper):
    """Тип: Ссылка на ОКПД2"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'code': MemberSpec_('code', ['okpdCodeType', 'xs:string'], 0, 0, {'name': 'code', 'type': 'xs:string'}, None),
        'name': MemberSpec_('name', ['okpdNameType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'name', 'type': 'xs:string'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, code=None, name=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.code = code
        self.validate_okpdCodeType(self.code)
        self.code_nsprefix_ = None
        self.name = name
        self.validate_okpdNameType(self.name)
        self.name_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, zfcs_OKPD2Ref)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if zfcs_OKPD2Ref.subclass:
            return zfcs_OKPD2Ref.subclass(*args_, **kwargs_)
        else:
            return zfcs_OKPD2Ref(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_okpdCodeType(self, value):
        result = True
        # Validate type okpdCodeType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 12:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on okpdCodeType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on okpdCodeType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_okpdNameType(self, value):
        result = True
        # Validate type okpdNameType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 2000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on okpdNameType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on okpdNameType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.code is not None or
            self.name is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'code':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'code')
            value_ = self.gds_validate_string(value_, node, 'code')
            self.code = value_
            self.code_nsprefix_ = child_.prefix
            # validate type okpdCodeType
            self.validate_okpdCodeType(self.code)
        elif nodeName_ == 'name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'name')
            value_ = self.gds_validate_string(value_, node, 'name')
            self.name = value_
            self.name_nsprefix_ = child_.prefix
            # validate type okpdNameType
            self.validate_okpdNameType(self.name)
# end class zfcs_OKPD2Ref


class zfcs_OKEIRef(GeneratedsSuper):
    """Тип: Ссылка на ОКЕИ"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'code': MemberSpec_('code', ['okeiCodeType', 'xs:string'], 0, 0, {'name': 'code', 'type': 'xs:string'}, None),
        'nationalCode': MemberSpec_('nationalCode', ['text50Type', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'nationalCode', 'type': 'xs:string'}, None),
        'name': MemberSpec_('name', ['text1000Type', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'name', 'type': 'xs:string'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, code=None, nationalCode=None, name=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.code = code
        self.validate_okeiCodeType(self.code)
        self.code_nsprefix_ = None
        self.nationalCode = nationalCode
        self.validate_text50Type(self.nationalCode)
        self.nationalCode_nsprefix_ = None
        self.name = name
        self.validate_text1000Type(self.name)
        self.name_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, zfcs_OKEIRef)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if zfcs_OKEIRef.subclass:
            return zfcs_OKEIRef.subclass(*args_, **kwargs_)
        else:
            return zfcs_OKEIRef(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_okeiCodeType(self, value):
        result = True
        # Validate type okeiCodeType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 4:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on okeiCodeType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on okeiCodeType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_text50Type(self, value):
        result = True
        # Validate type text50Type, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 50:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on text50Type' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on text50Type' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_text1000Type(self, value):
        result = True
        # Validate type text1000Type, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on text1000Type' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on text1000Type' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.code is not None or
            self.nationalCode is not None or
            self.name is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'code':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'code')
            value_ = self.gds_validate_string(value_, node, 'code')
            self.code = value_
            self.code_nsprefix_ = child_.prefix
            # validate type okeiCodeType
            self.validate_okeiCodeType(self.code)
        elif nodeName_ == 'nationalCode':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'nationalCode')
            value_ = self.gds_validate_string(value_, node, 'nationalCode')
            self.nationalCode = value_
            self.nationalCode_nsprefix_ = child_.prefix
            # validate type text50Type
            self.validate_text50Type(self.nationalCode)
        elif nodeName_ == 'name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'name')
            value_ = self.gds_validate_string(value_, node, 'name')
            self.name = value_
            self.name_nsprefix_ = child_.prefix
            # validate type text1000Type
            self.validate_text1000Type(self.name)
# end class zfcs_OKEIRef


class zfcs_contract_OKEIType(GeneratedsSuper):
    """Тип: Ссылка на ОКЕИ в Реестре контрактов"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'code': MemberSpec_('code', ['okeiCodeType', 'xs:string'], 0, 0, {'name': 'code', 'type': 'xs:string'}, None),
        'nationalCode': MemberSpec_('nationalCode', ['text50Type', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'nationalCode', 'type': 'xs:string'}, None),
        'trueNationalCode': MemberSpec_('trueNationalCode', ['text50Type', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'trueNationalCode', 'type': 'xs:string'}, None),
        'fullName': MemberSpec_('fullName', ['text1000Type', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'fullName', 'type': 'xs:string'}, None),
        'nationalName': MemberSpec_('nationalName', ['text50Type', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'nationalName', 'type': 'xs:string'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, code=None, nationalCode=None, trueNationalCode=None, fullName=None, nationalName=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.code = code
        self.validate_okeiCodeType(self.code)
        self.code_nsprefix_ = None
        self.nationalCode = nationalCode
        self.validate_text50Type(self.nationalCode)
        self.nationalCode_nsprefix_ = None
        self.trueNationalCode = trueNationalCode
        self.validate_text50Type(self.trueNationalCode)
        self.trueNationalCode_nsprefix_ = None
        self.fullName = fullName
        self.validate_text1000Type(self.fullName)
        self.fullName_nsprefix_ = None
        self.nationalName = nationalName
        self.validate_text50Type(self.nationalName)
        self.nationalName_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, zfcs_contract_OKEIType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if zfcs_contract_OKEIType.subclass:
            return zfcs_contract_OKEIType.subclass(*args_, **kwargs_)
        else:
            return zfcs_contract_OKEIType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_okeiCodeType(self, value):
        result = True
        # Validate type okeiCodeType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 4:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on okeiCodeType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on okeiCodeType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_text50Type(self, value):
        result = True
        # Validate type text50Type, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 50:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on text50Type' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on text50Type' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_text1000Type(self, value):
        result = True
        # Validate type text1000Type, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on text1000Type' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on text1000Type' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.code is not None or
            self.nationalCode is not None or
            self.trueNationalCode is not None or
            self.fullName is not None or
            self.nationalName is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'code':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'code')
            value_ = self.gds_validate_string(value_, node, 'code')
            self.code = value_
            self.code_nsprefix_ = child_.prefix
            # validate type okeiCodeType
            self.validate_okeiCodeType(self.code)
        elif nodeName_ == 'nationalCode':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'nationalCode')
            value_ = self.gds_validate_string(value_, node, 'nationalCode')
            self.nationalCode = value_
            self.nationalCode_nsprefix_ = child_.prefix
            # validate type text50Type
            self.validate_text50Type(self.nationalCode)
        elif nodeName_ == 'trueNationalCode':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'trueNationalCode')
            value_ = self.gds_validate_string(value_, node, 'trueNationalCode')
            self.trueNationalCode = value_
            self.trueNationalCode_nsprefix_ = child_.prefix
            # validate type text50Type
            self.validate_text50Type(self.trueNationalCode)
        elif nodeName_ == 'fullName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'fullName')
            value_ = self.gds_validate_string(value_, node, 'fullName')
            self.fullName = value_
            self.fullName_nsprefix_ = child_.prefix
            # validate type text1000Type
            self.validate_text1000Type(self.fullName)
        elif nodeName_ == 'nationalName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'nationalName')
            value_ = self.gds_validate_string(value_, node, 'nationalName')
            self.nationalName = value_
            self.nationalName_nsprefix_ = child_.prefix
            # validate type text50Type
            self.validate_text50Type(self.nationalName)
# end class zfcs_contract_OKEIType


class zfcs_OKSMRef(GeneratedsSuper):
    """Тип: Ссылка на ОКСМ"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'countryCode': MemberSpec_('countryCode', ['countryCodeType', 'xs:string'], 0, 0, {'name': 'countryCode', 'type': 'xs:string'}, None),
        'countryFullName': MemberSpec_('countryFullName', ['text200Type', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'countryFullName', 'type': 'xs:string'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, countryCode=None, countryFullName=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.countryCode = countryCode
        self.validate_countryCodeType(self.countryCode)
        self.countryCode_nsprefix_ = None
        self.countryFullName = countryFullName
        self.validate_text200Type(self.countryFullName)
        self.countryFullName_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, zfcs_OKSMRef)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if zfcs_OKSMRef.subclass:
            return zfcs_OKSMRef.subclass(*args_, **kwargs_)
        else:
            return zfcs_OKSMRef(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_countryCodeType(self, value):
        result = True
        # Validate type countryCodeType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 3:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on countryCodeType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on countryCodeType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_text200Type(self, value):
        result = True
        # Validate type text200Type, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 200:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on text200Type' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on text200Type' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.countryCode is not None or
            self.countryFullName is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'countryCode':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'countryCode')
            value_ = self.gds_validate_string(value_, node, 'countryCode')
            self.countryCode = value_
            self.countryCode_nsprefix_ = child_.prefix
            # validate type countryCodeType
            self.validate_countryCodeType(self.countryCode)
        elif nodeName_ == 'countryFullName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'countryFullName')
            value_ = self.gds_validate_string(value_, node, 'countryFullName')
            self.countryFullName = value_
            self.countryFullName_nsprefix_ = child_.prefix
            # validate type text200Type
            self.validate_text200Type(self.countryFullName)
# end class zfcs_OKSMRef


class zfcs_OKFSRef(GeneratedsSuper):
    """Тип: Ссылка на ОКФС"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'code': MemberSpec_('code', ['okfsCodeType', 'xs:string'], 0, 0, {'name': 'code', 'type': 'xs:string'}, None),
        'name': MemberSpec_('name', ['text2000Type', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'name', 'type': 'xs:string'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, code=None, name=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.code = code
        self.validate_okfsCodeType(self.code)
        self.code_nsprefix_ = None
        self.name = name
        self.validate_text2000Type(self.name)
        self.name_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, zfcs_OKFSRef)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if zfcs_OKFSRef.subclass:
            return zfcs_OKFSRef.subclass(*args_, **kwargs_)
        else:
            return zfcs_OKFSRef(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_okfsCodeType(self, value):
        result = True
        # Validate type okfsCodeType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 2:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on okfsCodeType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on okfsCodeType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_text2000Type(self, value):
        result = True
        # Validate type text2000Type, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 2000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on text2000Type' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on text2000Type' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.code is not None or
            self.name is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'code':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'code')
            value_ = self.gds_validate_string(value_, node, 'code')
            self.code = value_
            self.code_nsprefix_ = child_.prefix
            # validate type okfsCodeType
            self.validate_okfsCodeType(self.code)
        elif nodeName_ == 'name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'name')
            value_ = self.gds_validate_string(value_, node, 'name')
            self.name = value_
            self.name_nsprefix_ = child_.prefix
            # validate type text2000Type
            self.validate_text2000Type(self.name)
# end class zfcs_OKFSRef


class zfcs_OKTMORef(GeneratedsSuper):
    """Тип: Ссылка на ОКТМО"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'code': MemberSpec_('code', ['oktmoCodeType', 'xs:string'], 0, 0, {'name': 'code', 'type': 'xs:string'}, None),
        'name': MemberSpec_('name', ['text1000Type', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'name', 'type': 'xs:string'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, code=None, name=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.code = code
        self.validate_oktmoCodeType(self.code)
        self.code_nsprefix_ = None
        self.name = name
        self.validate_text1000Type(self.name)
        self.name_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, zfcs_OKTMORef)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if zfcs_OKTMORef.subclass:
            return zfcs_OKTMORef.subclass(*args_, **kwargs_)
        else:
            return zfcs_OKTMORef(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_oktmoCodeType(self, value):
        result = True
        # Validate type oktmoCodeType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 11:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on oktmoCodeType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on oktmoCodeType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_text1000Type(self, value):
        result = True
        # Validate type text1000Type, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on text1000Type' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on text1000Type' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.code is not None or
            self.name is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'code':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'code')
            value_ = self.gds_validate_string(value_, node, 'code')
            self.code = value_
            self.code_nsprefix_ = child_.prefix
            # validate type oktmoCodeType
            self.validate_oktmoCodeType(self.code)
        elif nodeName_ == 'name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'name')
            value_ = self.gds_validate_string(value_, node, 'name')
            self.name = value_
            self.name_nsprefix_ = child_.prefix
            # validate type text1000Type
            self.validate_text1000Type(self.name)
# end class zfcs_OKTMORef


class zfcs_OKTMOPPORef(GeneratedsSuper):
    """Тип: Ссылка на ОКТМО ППО (Справочник ZAKUPKI_DEV.NSI_PPO)"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'code': MemberSpec_('code', ['oktmoCodeType', 'xs:string'], 0, 0, {'name': 'code', 'type': 'xs:string'}, None),
        'name': MemberSpec_('name', ['text2000Type', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'name', 'type': 'xs:string'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, code=None, name=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.code = code
        self.validate_oktmoCodeType(self.code)
        self.code_nsprefix_ = None
        self.name = name
        self.validate_text2000Type(self.name)
        self.name_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, zfcs_OKTMOPPORef)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if zfcs_OKTMOPPORef.subclass:
            return zfcs_OKTMOPPORef.subclass(*args_, **kwargs_)
        else:
            return zfcs_OKTMOPPORef(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_oktmoCodeType(self, value):
        result = True
        # Validate type oktmoCodeType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 11:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on oktmoCodeType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on oktmoCodeType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_text2000Type(self, value):
        result = True
        # Validate type text2000Type, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 2000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on text2000Type' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on text2000Type' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.code is not None or
            self.name is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'code':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'code')
            value_ = self.gds_validate_string(value_, node, 'code')
            self.code = value_
            self.code_nsprefix_ = child_.prefix
            # validate type oktmoCodeType
            self.validate_oktmoCodeType(self.code)
        elif nodeName_ == 'name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'name')
            value_ = self.gds_validate_string(value_, node, 'name')
            self.name = value_
            self.name_nsprefix_ = child_.prefix
            # validate type text2000Type
            self.validate_text2000Type(self.name)
# end class zfcs_OKTMOPPORef


class zfcs_organizationRef(GeneratedsSuper):
    """Тип: Ссылка на организацию с учетом кодов по СПЗ и по СвР"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'regNum': MemberSpec_('regNum', ['spzNumType', 'xs:string'], 0, 0, {'name': 'regNum', 'type': 'xs:string'}, None),
        'consRegistryNum': MemberSpec_('consRegistryNum', ['consRegistryNumType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'consRegistryNum', 'type': 'xs:string'}, None),
        'fullName': MemberSpec_('fullName', ['text2000Type', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'fullName', 'type': 'xs:string'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_) + ['extensiontype_']
    subclass = None
    superclass = None
    def __init__(self, regNum=None, consRegistryNum=None, fullName=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.regNum = regNum
        self.validate_spzNumType(self.regNum)
        self.regNum_nsprefix_ = None
        self.consRegistryNum = consRegistryNum
        self.validate_consRegistryNumType(self.consRegistryNum)
        self.consRegistryNum_nsprefix_ = None
        self.fullName = fullName
        self.validate_text2000Type(self.fullName)
        self.fullName_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, zfcs_organizationRef)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if zfcs_organizationRef.subclass:
            return zfcs_organizationRef.subclass(*args_, **kwargs_)
        else:
            return zfcs_organizationRef(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_spzNumType(self, value):
        result = True
        # Validate type spzNumType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_spzNumType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_spzNumType_patterns_, ))
                result = False
        return result
    validate_spzNumType_patterns_ = [['^(\\d{11})$']]
    def validate_consRegistryNumType(self, value):
        result = True
        # Validate type consRegistryNumType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) != 8:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd length restriction on consRegistryNumType' % {"value": encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_text2000Type(self, value):
        result = True
        # Validate type text2000Type, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 2000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on text2000Type' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on text2000Type' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.regNum is not None or
            self.consRegistryNum is not None or
            self.fullName is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'regNum':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'regNum')
            value_ = self.gds_validate_string(value_, node, 'regNum')
            self.regNum = value_
            self.regNum_nsprefix_ = child_.prefix
            # validate type spzNumType
            self.validate_spzNumType(self.regNum)
        elif nodeName_ == 'consRegistryNum':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'consRegistryNum')
            value_ = self.gds_validate_string(value_, node, 'consRegistryNum')
            self.consRegistryNum = value_
            self.consRegistryNum_nsprefix_ = child_.prefix
            # validate type consRegistryNumType
            self.validate_consRegistryNumType(self.consRegistryNum)
        elif nodeName_ == 'fullName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'fullName')
            value_ = self.gds_validate_string(value_, node, 'fullName')
            self.fullName = value_
            self.fullName_nsprefix_ = child_.prefix
            # validate type text2000Type
            self.validate_text2000Type(self.fullName)
# end class zfcs_organizationRef


class zfcs_placingWayType(GeneratedsSuper):
    """Тип: Подспособ определения поставщика"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'code': MemberSpec_('code', ['placingWayCodeType', 'xs:string'], 0, 0, {'name': 'code', 'type': 'xs:string'}, None),
        'name': MemberSpec_('name', ['text500Type', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'name', 'type': 'xs:string'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = None
    def __init__(self, code=None, name=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.code = code
        self.validate_placingWayCodeType(self.code)
        self.code_nsprefix_ = None
        self.name = name
        self.validate_text500Type(self.name)
        self.name_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, zfcs_placingWayType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if zfcs_placingWayType.subclass:
            return zfcs_placingWayType.subclass(*args_, **kwargs_)
        else:
            return zfcs_placingWayType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_placingWayCodeType(self, value):
        result = True
        # Validate type placingWayCodeType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 7:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on placingWayCodeType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on placingWayCodeType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_text500Type(self, value):
        result = True
        # Validate type text500Type, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 500:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on text500Type' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on text500Type' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.code is not None or
            self.name is not None
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'code':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'code')
            value_ = self.gds_validate_string(value_, node, 'code')
            self.code = value_
            self.code_nsprefix_ = child_.prefix
            # validate type placingWayCodeType
            self.validate_placingWayCodeType(self.code)
        elif nodeName_ == 'name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'name')
            value_ = self.gds_validate_string(value_, node, 'name')
            self.name = value_
            self.name_nsprefix_ = child_.prefix
            # validate type text500Type
            self.validate_text500Type(self.name)
# end class zfcs_placingWayType


class KTRU(zfcs_KTRURef):
    """Классификация по КТРУ.
    При приеме контролируется, что позиция с данным кодом НЕ является
    укрупненной (для нее НЕ заполнено поле position/data/isTemplate в
    справочнике nsiKTRU).
    Не допускается указание блока в информации об субподрядчике"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'rightSideKTRUInfo': MemberSpec_('rightSideKTRUInfo', 'righSideKTRURef', 0, 1, {'minOccurs': '0', 'name': 'rightSideKTRUInfo', 'type': 'rightSideKTRUInfo'}, 64),
        'characteristics': MemberSpec_('characteristics', 'characteristics', 0, 1, {'minOccurs': '0', 'name': 'characteristics', 'type': 'characteristics'}, 64),
        'OKPD2': MemberSpec_('OKPD2', 'OKPD2', 0, 1, {'minOccurs': '0', 'name': 'OKPD2', 'type': 'zfcs_OKPDRef'}, 64),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = zfcs_KTRURef
    def __init__(self, code=None, name=None, versionId=None, versionNumber=None, rightSideKTRUInfo=None, characteristics=None, OKPD2=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(KTRU, self).__init__(code, name, versionId, versionNumber,  **kwargs_)
        self.rightSideKTRUInfo = rightSideKTRUInfo
        self.rightSideKTRUInfo_nsprefix_ = None
        self.characteristics = characteristics
        self.characteristics_nsprefix_ = None
        self.OKPD2 = OKPD2
        self.OKPD2_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, KTRU)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if KTRU.subclass:
            return KTRU.subclass(*args_, **kwargs_)
        else:
            return KTRU(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.rightSideKTRUInfo is not None or
            self.characteristics is not None or
            self.OKPD2 is not None or
            super(KTRU, self).hasContent_()
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(KTRU, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'rightSideKTRUInfo':
            obj_ = rightSideKTRUInfo.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.rightSideKTRUInfo = obj_
            obj_.original_tagname_ = 'rightSideKTRUInfo'
        elif nodeName_ == 'characteristics':
            obj_ = characteristics.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.characteristics = obj_
            obj_.original_tagname_ = 'characteristics'
        elif nodeName_ == 'OKPD2':
            obj_ = zfcs_OKPDRef.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.OKPD2 = obj_
            obj_.original_tagname_ = 'OKPD2'
        super(KTRU, self).buildChildren(child_, node, nodeName_, True)
# end class KTRU


class customer(zfcs_organizationRef):
    """Заказчик в информации о контракте (для печатной формы)"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'shortName': MemberSpec_('shortName', ['zfcs_longTextType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'shortName', 'type': 'xs:string'}, None),
        'registrationDate': MemberSpec_('registrationDate', 'xs:date', 0, 1, {'minOccurs': '0', 'name': 'registrationDate', 'type': 'xs:date'}, None),
        'inn': MemberSpec_('inn', ['innType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'inn', 'type': 'xs:string'}, None),
        'kpp': MemberSpec_('kpp', ['kppType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'kpp', 'type': 'xs:string'}, None),
        'legalForm': MemberSpec_('legalForm', 'xs:string', 0, 1, {'minOccurs': '0', 'name': 'legalForm', 'type': 'xs:string'}, None),
        'OKPO': MemberSpec_('OKPO', ['zfcs_okpoType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'OKPO', 'type': 'xs:string'}, None),
        'customerCode': MemberSpec_('customerCode', ['ikuType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'customerCode', 'type': 'xs:string'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = zfcs_organizationRef
    def __init__(self, regNum=None, consRegistryNum=None, fullName=None, shortName=None, registrationDate=None, inn=None, kpp=None, legalForm=None, OKPO=None, customerCode=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(customer, self).__init__(regNum, consRegistryNum, fullName,  **kwargs_)
        self.shortName = shortName
        self.validate_zfcs_longTextType(self.shortName)
        self.shortName_nsprefix_ = None
        if isinstance(registrationDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(registrationDate, '%Y-%m-%d').date()
        else:
            initvalue_ = registrationDate
        self.registrationDate = initvalue_
        self.registrationDate_nsprefix_ = None
        self.inn = inn
        self.validate_innType(self.inn)
        self.inn_nsprefix_ = None
        self.kpp = kpp
        self.validate_kppType(self.kpp)
        self.kpp_nsprefix_ = None
        self.legalForm = legalForm
        self.legalForm_nsprefix_ = None
        self.OKPO = OKPO
        self.validate_zfcs_okpoType(self.OKPO)
        self.OKPO_nsprefix_ = None
        self.customerCode = customerCode
        self.validate_ikuType(self.customerCode)
        self.customerCode_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, customer)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if customer.subclass:
            return customer.subclass(*args_, **kwargs_)
        else:
            return customer(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_zfcs_longTextType(self, value):
        result = True
        # Validate type zfcs_longTextType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 2000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on zfcs_longTextType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_innType(self, value):
        result = True
        # Validate type innType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 12:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on innType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_innType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_innType_patterns_, ))
                result = False
        return result
    validate_innType_patterns_ = [['^(\\d{1,12})$']]
    def validate_kppType(self, value):
        result = True
        # Validate type kppType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) != 9:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd length restriction on kppType' % {"value": encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_zfcs_okpoType(self, value):
        result = True
        # Validate type zfcs_okpoType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 10:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on zfcs_okpoType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on zfcs_okpoType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_ikuType(self, value):
        result = True
        # Validate type ikuType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_ikuType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_ikuType_patterns_, ))
                result = False
        return result
    validate_ikuType_patterns_ = [['^(\\d{20})$']]
    def hasContent_(self):
        if (
            self.shortName is not None or
            self.registrationDate is not None or
            self.inn is not None or
            self.kpp is not None or
            self.legalForm is not None or
            self.OKPO is not None or
            self.customerCode is not None or
            super(customer, self).hasContent_()
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(customer, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'shortName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'shortName')
            value_ = self.gds_validate_string(value_, node, 'shortName')
            self.shortName = value_
            self.shortName_nsprefix_ = child_.prefix
            # validate type zfcs_longTextType
            self.validate_zfcs_longTextType(self.shortName)
        elif nodeName_ == 'registrationDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.registrationDate = dval_
            self.registrationDate_nsprefix_ = child_.prefix
        elif nodeName_ == 'inn':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'inn')
            value_ = self.gds_validate_string(value_, node, 'inn')
            self.inn = value_
            self.inn_nsprefix_ = child_.prefix
            # validate type innType
            self.validate_innType(self.inn)
        elif nodeName_ == 'kpp':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'kpp')
            value_ = self.gds_validate_string(value_, node, 'kpp')
            self.kpp = value_
            self.kpp_nsprefix_ = child_.prefix
            # validate type kppType
            self.validate_kppType(self.kpp)
        elif nodeName_ == 'legalForm':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'legalForm')
            value_ = self.gds_validate_string(value_, node, 'legalForm')
            self.legalForm = value_
            self.legalForm_nsprefix_ = child_.prefix
        elif nodeName_ == 'OKPO':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'OKPO')
            value_ = self.gds_validate_string(value_, node, 'OKPO')
            self.OKPO = value_
            self.OKPO_nsprefix_ = child_.prefix
            # validate type zfcs_okpoType
            self.validate_zfcs_okpoType(self.OKPO)
        elif nodeName_ == 'customerCode':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'customerCode')
            value_ = self.gds_validate_string(value_, node, 'customerCode')
            self.customerCode = value_
            self.customerCode_nsprefix_ = child_.prefix
            # validate type ikuType
            self.validate_ikuType(self.customerCode)
        super(customer, self).buildChildren(child_, node, nodeName_, True)
# end class customer


class payment(zfcs_contract2015_documentInfo):
    """Детализация информации о возврате плательщику неустойки"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'amount': MemberSpec_('amount', ['moneyPositiveType', 'xs:string'], 0, 0, {'name': 'amount', 'type': 'xs:string'}, None),
        'currencyRate': MemberSpec_('currencyRate', 'zfcs_currencyRateContract2015', 0, 1, {'minOccurs': '0', 'name': 'currencyRate', 'type': 'zfcs_currencyRateContract2015'}, None),
        'amountRUR': MemberSpec_('amountRUR', ['moneyPositiveType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'amountRUR', 'type': 'xs:string'}, None),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = zfcs_contract2015_documentInfo
    def __init__(self, documentName=None, documentNum=None, documentDate=None, amount=None, currencyRate=None, amountRUR=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(payment, self).__init__(documentName, documentNum, documentDate,  **kwargs_)
        self.amount = amount
        self.validate_moneyPositiveType(self.amount)
        self.amount_nsprefix_ = None
        self.currencyRate = currencyRate
        self.currencyRate_nsprefix_ = None
        self.amountRUR = amountRUR
        self.validate_moneyPositiveType(self.amountRUR)
        self.amountRUR_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, payment)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if payment.subclass:
            return payment.subclass(*args_, **kwargs_)
        else:
            return payment(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_moneyPositiveType(self, value):
        result = True
        # Validate type moneyPositiveType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 21:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on moneyPositiveType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on moneyPositiveType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_moneyPositiveType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_moneyPositiveType_patterns_, ))
                result = False
        return result
    validate_moneyPositiveType_patterns_ = [['^(\\d+(\\.\\d{1,2})?)$']]
    def hasContent_(self):
        if (
            self.amount is not None or
            self.currencyRate is not None or
            self.amountRUR is not None or
            super(payment, self).hasContent_()
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(payment, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'amount':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'amount')
            value_ = self.gds_validate_string(value_, node, 'amount')
            self.amount = value_
            self.amount_nsprefix_ = child_.prefix
            # validate type moneyPositiveType
            self.validate_moneyPositiveType(self.amount)
        elif nodeName_ == 'currencyRate':
            obj_ = zfcs_currencyRateContract2015.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.currencyRate = obj_
            obj_.original_tagname_ = 'currencyRate'
        elif nodeName_ == 'amountRUR':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'amountRUR')
            value_ = self.gds_validate_string(value_, node, 'amountRUR')
            self.amountRUR = value_
            self.amountRUR_nsprefix_ = child_.prefix
            # validate type moneyPositiveType
            self.validate_moneyPositiveType(self.amountRUR)
        super(payment, self).buildChildren(child_, node, nodeName_, True)
# end class payment


class rightToConcludeContractPriceInfo(zfcs_contract2015PriceInfoType):
    """Цена за право заключения контракта. Заполняется в случае если
    выполняются условия:
    1) Закупка размещалась в ЕИС(заполнен блок foundation\fcsOrder\order) с
    номером, указанным в поле "Номер извещения о проведении"
    (foundation\fcsOrder\order\notificationNumber)
    и имеет один из способов определения поставщика:
    12011 - электронный аукцион (ЭА);
    11011 - открытый конкурс (ОК);
    11013 - открытый конкурс в электронной форме (ЭОК);
    11033 - двухэтапный конкурс в электронной форме (ЭОКД);
    11023 - конкурс с ограниченным участием в электронной форме (ЭОК-ОУ);
    14013 - запрос предложений в электронной форме (ЭЗП)
    20000 - закупка у единственного поставщика (подрядчика, исполнителя)
    2) Закупка не размещалась в ЕИС (заполнен блок
    foundation\fcsOrder\notOosOrder)
    и имеет один из способов определения поставщика:
    11042 - закрытый конкурс (ЗК);
    11052 - закрытый конкурс с ограниченным участием (ЗК-ОУ);
    11062 - закрытый двухэтапный конкурс (ЗКД)
    3) Для закупок со способом ЭА в поле "Признак аукциона на повышение
    начальной (максимальной) цены контракта" (IncreaseWinnerInitialPrice)
    документа "Протокол подведения итогов электронного аукциона" (protocolEF3)
    закупки, на основании которой заключается контракт, установлено
    значение true
    4) Для закупок со способами ОК, ЭОК, ЭОКД, ЭОК-ОУ,ЭЗП, ЗК, ЗК-ОУ, ЗКД в
    поле "Цена за право заключения контракта" (rightConcludeContractPrice)
    соответствующего протокола
    закупки, на основании которой заключается контракт, установлено значение
    true
    5) Для закупок со способом "Закупка у единственного поставщика (подрядчика,
    исполнителя)" в поле
    «Основание заключения контракта с единственным поставщиком»
    (order\singleCustomer\reason\code) установлено одно из значений:
    20230 или 20550 или 20570 или 20560 или 20710"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = zfcs_contract2015PriceInfoType
    def __init__(self, price=None, currency=None, currencyRate=None, priceRUR=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(rightToConcludeContractPriceInfo, self).__init__(price, currency, currencyRate, priceRUR,  **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, rightToConcludeContractPriceInfo)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if rightToConcludeContractPriceInfo.subclass:
            return rightToConcludeContractPriceInfo.subclass(*args_, **kwargs_)
        else:
            return rightToConcludeContractPriceInfo(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(rightToConcludeContractPriceInfo, self).hasContent_()
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(rightToConcludeContractPriceInfo, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(rightToConcludeContractPriceInfo, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class rightToConcludeContractPriceInfo


class singleCustomer(zfcs_contract2015SingleCustomerType):
    """Закупка у единственного поставщика (извещение не размещалось на ЕИС)"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'purchaseCode': MemberSpec_('purchaseCode', ['ikzCodeType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'purchaseCode', 'type': 'xs:string'}, None),
        'contractProjectNumber': MemberSpec_('contractProjectNumber', ['contractProjNumType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'contractProjectNumber', 'type': 'xs:string'}, None),
        'tenderPlanInfo': MemberSpec_('tenderPlanInfo', 'zfcs_contract2015TenderPlanInfoType', 0, 1, {'name': 'tenderPlanInfo', 'type': 'zfcs_contract2015TenderPlanInfoType'}, 12),
        'tenderPlan2020Info': MemberSpec_('tenderPlan2020Info', 'tenderPlan2020InfoType', 0, 1, {'name': 'tenderPlan2020Info', 'type': 'tenderPlan2020InfoType'}, 12),
    }
    __slots__ = GeneratedsSuper.gds_subclass_slots(member_data_items_)
    subclass = None
    superclass = zfcs_contract2015SingleCustomerType
    def __init__(self, reason=None, document=None, reportBase=None, reportCode=None, attachments=None, purchaseCode=None, contractProjectNumber=None, tenderPlanInfo=None, tenderPlan2020Info=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(singleCustomer, self).__init__(reason, document, reportBase, reportCode, attachments,  **kwargs_)
        self.purchaseCode = purchaseCode
        self.validate_ikzCodeType(self.purchaseCode)
        self.purchaseCode_nsprefix_ = None
        self.contractProjectNumber = contractProjectNumber
        self.validate_contractProjNumType(self.contractProjectNumber)
        self.contractProjectNumber_nsprefix_ = None
        self.tenderPlanInfo = tenderPlanInfo
        self.tenderPlanInfo_nsprefix_ = None
        self.tenderPlan2020Info = tenderPlan2020Info
        self.tenderPlan2020Info_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, singleCustomer)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if singleCustomer.subclass:
            return singleCustomer.subclass(*args_, **kwargs_)
        else:
            return singleCustomer(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_ikzCodeType(self, value):
        result = True
        # Validate type ikzCodeType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_ikzCodeType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_ikzCodeType_patterns_, ))
                result = False
        return result
    validate_ikzCodeType_patterns_ = [['^(\\d{36})$']]
    def validate_contractProjNumType(self, value):
        result = True
        # Validate type contractProjNumType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_contractProjNumType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_contractProjNumType_patterns_, ))
                result = False
        return result
    validate_contractProjNumType_patterns_ = [['^(\\d{23})$']]
    def hasContent_(self):
        if (
            self.purchaseCode is not None or
            self.contractProjectNumber is not None or
            self.tenderPlanInfo is not None or
            self.tenderPlan2020Info is not None or
            super(singleCustomer, self).hasContent_()
        ):
            return True
        else:
            return False
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(singleCustomer, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'purchaseCode':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'purchaseCode')
            value_ = self.gds_validate_string(value_, node, 'purchaseCode')
            self.purchaseCode = value_
            self.purchaseCode_nsprefix_ = child_.prefix
            # validate type ikzCodeType
            self.validate_ikzCodeType(self.purchaseCode)
        elif nodeName_ == 'contractProjectNumber':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'contractProjectNumber')
            value_ = self.gds_validate_string(value_, node, 'contractProjectNumber')
            self.contractProjectNumber = value_
            self.contractProjectNumber_nsprefix_ = child_.prefix
            # validate type contractProjNumType
            self.validate_contractProjNumType(self.contractProjectNumber)
        elif nodeName_ == 'tenderPlanInfo':
            obj_ = zfcs_contract2015TenderPlanInfoType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.tenderPlanInfo = obj_
            obj_.original_tagname_ = 'tenderPlanInfo'
        elif nodeName_ == 'tenderPlan2020Info':
            obj_ = tenderPlan2020InfoType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.tenderPlan2020Info = obj_
            obj_.original_tagname_ = 'tenderPlan2020Info'
        super(singleCustomer, self).buildChildren(child_, node, nodeName_, True)
# end class singleCustomer


GDSClassesMapping = {
}


USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""


def usage():
    print(USAGE_TEXT)
    sys.exit(1)


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    rootClass = GDSClassesMapping.get(tag)
    if rootClass is None:
        rootClass = globals().get(tag)
    return tag, rootClass


def get_required_ns_prefix_defs(rootNode):
    '''Get all name space prefix definitions required in this XML doc.
    Return a dictionary of definitions and a char string of definitions.
    '''
    nsmap = {
        prefix: uri
        for node in rootNode.iter()
        for (prefix, uri) in node.nsmap.items()
        if prefix is not None
    }
    namespacedefs = ' '.join([
        'xmlns:{}="{}"'.format(prefix, uri)
        for prefix, uri in nsmap.items()
    ])
    return nsmap, namespacedefs


def parse(inFileName, silence=False, print_warnings=True):
    global CapturedNsmap_
    gds_collector = GdsCollector_()
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'corr_supplierLegalEntityRF'
        rootClass = corr_supplierLegalEntityRF
    rootObj = rootClass.factory()
    rootObj.build(rootNode, gds_collector_=gds_collector)
    CapturedNsmap_, namespacedefs = get_required_ns_prefix_defs(rootNode)
    if not SaveElementTreeNode:
        doc = None
        rootNode = None
##     if not silence:
##         sys.stdout.write('<?xml version="1.0" ?>\n')
##         rootObj.export(
##             sys.stdout, 0, name_=rootTag,
##             namespacedef_=namespacedefs,
##             pretty_print=True)
    if print_warnings and len(gds_collector.get_messages()) > 0:
        separator = ('-' * 50) + '\n'
        sys.stderr.write(separator)
        sys.stderr.write('----- Warnings -- count: {} -----\n'.format(
            len(gds_collector.get_messages()), ))
        gds_collector.write_messages(sys.stderr)
        sys.stderr.write(separator)
    return rootObj


def parseEtree(inFileName, silence=False, print_warnings=True,
               mapping=None, nsmap=None):
    parser = None
    doc = parsexml_(inFileName, parser)
    gds_collector = GdsCollector_()
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'corr_supplierLegalEntityRF'
        rootClass = corr_supplierLegalEntityRF
    rootObj = rootClass.factory()
    rootObj.build(rootNode, gds_collector_=gds_collector)
    # Enable Python to collect the space used by the DOM.
    if mapping is None:
        mapping = {}
    rootElement = rootObj.to_etree(
        None, name_=rootTag, mapping_=mapping, nsmap_=nsmap)
    reverse_mapping = rootObj.gds_reverse_node_mapping(mapping)
    if not SaveElementTreeNode:
        doc = None
        rootNode = None
##     if not silence:
##         content = etree_.tostring(
##             rootElement, pretty_print=True,
##             xml_declaration=True, encoding="utf-8")
##         sys.stdout.write(str(content))
##         sys.stdout.write('\n')
    if print_warnings and len(gds_collector.get_messages()) > 0:
        separator = ('-' * 50) + '\n'
        sys.stderr.write(separator)
        sys.stderr.write('----- Warnings -- count: {} -----\n'.format(
            len(gds_collector.get_messages()), ))
        gds_collector.write_messages(sys.stderr)
        sys.stderr.write(separator)
    return rootObj, rootElement, mapping, reverse_mapping


def parseString(inString, silence=False, print_warnings=True):
    '''Parse a string, create the object tree, and export it.

    Arguments:
    - inString -- A string.  This XML fragment should not start
      with an XML declaration containing an encoding.
    - silence -- A boolean.  If False, export the object.
    Returns -- The root object in the tree.
    '''
    parser = None
    rootNode= parsexmlstring_(inString, parser)
    gds_collector = GdsCollector_()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'corr_supplierLegalEntityRF'
        rootClass = corr_supplierLegalEntityRF
    rootObj = rootClass.factory()
    rootObj.build(rootNode, gds_collector_=gds_collector)
    if not SaveElementTreeNode:
        rootNode = None
##     if not silence:
##         sys.stdout.write('<?xml version="1.0" ?>\n')
##         rootObj.export(
##             sys.stdout, 0, name_=rootTag,
##             namespacedef_='')
    if print_warnings and len(gds_collector.get_messages()) > 0:
        separator = ('-' * 50) + '\n'
        sys.stderr.write(separator)
        sys.stderr.write('----- Warnings -- count: {} -----\n'.format(
            len(gds_collector.get_messages()), ))
        gds_collector.write_messages(sys.stderr)
        sys.stderr.write(separator)
    return rootObj


def parseLiteral(inFileName, silence=False, print_warnings=True):
    parser = None
    doc = parsexml_(inFileName, parser)
    gds_collector = GdsCollector_()
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'corr_supplierLegalEntityRF'
        rootClass = corr_supplierLegalEntityRF
    rootObj = rootClass.factory()
    rootObj.build(rootNode, gds_collector_=gds_collector)
    # Enable Python to collect the space used by the DOM.
    if not SaveElementTreeNode:
        doc = None
        rootNode = None
##     if not silence:
##         sys.stdout.write('#from IntegrationTypes import *\n\n')
##         sys.stdout.write('import IntegrationTypes as model_\n\n')
##         sys.stdout.write('rootObj = model_.rootClass(\n')
##         rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
##         sys.stdout.write(')\n')
    if print_warnings and len(gds_collector.get_messages()) > 0:
        separator = ('-' * 50) + '\n'
        sys.stderr.write(separator)
        sys.stderr.write('----- Warnings -- count: {} -----\n'.format(
            len(gds_collector.get_messages()), ))
        gds_collector.write_messages(sys.stderr)
        sys.stderr.write(separator)
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()

RenameMappings_ = {
    "{http://zakupki.gov.ru/oos/base/1}bikType": "bikType1",
    "{http://zakupki.gov.ru/oos/base/1}checkResultNumberType": "checkResultNumberType2",
    "{http://zakupki.gov.ru/oos/base/1}innType": "innType3",
    "{http://zakupki.gov.ru/oos/base/1}monthType": "monthType4",
    "{http://zakupki.gov.ru/oos/base/1}prescriptionNumberType": "prescriptionNumberType5",
    "{http://zakupki.gov.ru/oos/base/1}yearType": "yearType6",
    "{http://zakupki.gov.ru/oos/common/1}organizationType": "organizationType7",
    "{http://zakupki.gov.ru/oos/common/1}signatureType": "signatureType8",

}
__all__ = [
    "ETPRef",
    "KTRU",
    "KTRUCharacteristicValueType",
    "KTRUNotUsingReason",
    "KTRURef",
    "KVRFinancingType",
    "KVRFinancingsType",
    "KVRRef",
    "MNNInfo",
    "MNNInfoType",
    "MNNTextForm",
    "MNNsInfo",
    "NPASt14Ref",
    "NPAsInfo",
    "OKEIRef",
    "OKFSRef",
    "OKOPFRef",
    "OKPD2",
    "OKPD2Ref",
    "OKPORef",
    "OKSMRef",
    "OKTMOPPORef",
    "OKTMORef",
    "abandonedReasonRef",
    "addInfoKTRURef",
    "addRequirement",
    "addRequirementType",
    "addRequirements",
    "address",
    "advancePaymentPayDoc",
    "advancePaymentSum",
    "amountOverpaidInfo",
    "amountOverpaidsInfo",
    "amountRefundInfo",
    "amountRefundsInfo",
    "appRejectedReasonType",
    "approveOrderReasonInfo",
    "attachmentInfo",
    "attachmentListSignCheckUrlType",
    "attachmentListType",
    "attachmentListWithKindType",
    "attachmentType",
    "attachmentWithKindType",
    "autoExDateCalcSign",
    "autoExDateInfo",
    "bankCancelDetails",
    "bankGuarantee",
    "bankGuaranteeReturn",
    "bankSupportContractRequiredInfo2020Type",
    "bankSupportContractRequiredInfoType",
    "base",
    "budgetFunds",
    "budgetFundsContractRef",
    "cancel",
    "cancelReason",
    "cancelledProcedureId",
    "cashAccount",
    "certificateNumber",
    "changePriceFoundationRef",
    "characteristics",
    "closedEPCasesRef",
    "code",
    "commissionMemberType",
    "commissionMembers",
    "commissionRoleType",
    "commissionType",
    "commonUnitsMeasurementsRef",
    "completeness",
    "concreteValue",
    "constructionWorkGroup",
    "constructionWorksInfo",
    "consumerPackagesQuantity",
    "contactEMail",
    "contactInfo",
    "contactPhone",
    "content",
    "contract",
    "contractChange",
    "contractInvalidation",
    "contractInvalidationCancel",
    "contractLifeCycleCaseRef",
    "contractNotPublished",
    "contractOKEIExtendedRef",
    "contractOKEIRef",
    "contractPrintFormInfo",
    "contractRefusalReasonRef",
    "contractor",
    "control99ControlAuthorityInfoType",
    "control99ControlObjectWithMandatoryDocsInfoType",
    "control99CustomerInfoType",
    "control99DocumentObjectType",
    "control99NoticeComplianceWithDocType",
    "control99ResponsibleType",
    "controlDocumentsInfo",
    "controlObjectsInfo",
    "corr_supplierIndividualPersonForeignState",
    "corr_supplierIndividualPersonRF",
    "corr_supplierLegalEntityForeignState",
    "corr_supplierLegalEntityRF",
    "countryFullName",
    "cryptoSigns",
    "currencyCBRFRef",
    "currencyRateType",
    "currencyRef",
    "customer",
    "customerInfo",
    "customerQuantities",
    "customerQuantity",
    "damagePayments",
    "delayPenalties",
    "delayWriteOffPenalties",
    "deviationFactFoundationRef",
    "digitalCode",
    "docAcceptance",
    "docAcceptancePayDoc",
    "docDescription",
    "docExecution",
    "docPropertyType",
    "docRejectReasonRef",
    "docTermination",
    "docType",
    "document",
    "documentCode",
    "documentKindRef",
    "documentName",
    "documentNum",
    "documents",
    "dosageFormInfo",
    "dosageInfo",
    "dosageUser",
    "dosageValue",
    "drugChangeInfoType",
    "drugChangeReasonRef",
    "drugInfo",
    "drugInfoType",
    "drugInfoUsingReferenceInfo",
    "drugInfoUsingTextForm",
    "drugInfoUsingTextFormType",
    "drugInterchangeInfo",
    "drugInterchangeManualInfoType",
    "drugInterchangeReferenceInfoType",
    "drugInterchangeTextFormInfoType",
    "drugPurchaseObjectCustomerInfo",
    "drugPurchaseObjectCustomersInfo",
    "drugPurchaseObjectInfo",
    "drugQuantityCustomerInfo",
    "drugQuantityCustomersInfo",
    "drugSeries",
    "drugsInfo",
    "editedCertificateNumber",
    "editedDosageInfo",
    "editedManufacturerInfo",
    "editedMedicamentalFormInfo",
    "editedPackagingsInfo",
    "editedTradeInfo",
    "email",
    "ensuringWay",
    "errCode",
    "errorCorrection",
    "errorInfoType",
    "evasDevFactFoundationRef",
    "exception",
    "exclude",
    "exclusionReason615Ref",
    "execObligationsGuaranteeInfo",
    "execution",
    "executionObligationGuarantee",
    "executionPeriod",
    "executions",
    "expirationDateCustomFormatInfo",
    "expirationDateMonthYear",
    "extPrintFormType",
    "extrabudgetFunds",
    "fcsOrder",
    "fileName",
    "fileSize",
    "financeResourcesType",
    "finances",
    "firstName",
    "firstNameLat",
    "foundation",
    "foundationDoc",
    "foundationRefundDocInfo",
    "foundationRefundDocsInfo",
    "founders",
    "fundingSources615Ref",
    "groupOKEI",
    "guaranteeReturn",
    "id",
    "individualBusinessmanRF",
    "individualPersonForeignStateInfo",
    "individualPersonForeignStateisCulture",
    "individualPersonRFInfo",
    "individualPersonRFisCulture",
    "inn",
    "interchangeGroupInfo",
    "invalidationReasonDocument",
    "invalidityInfo",
    "kladr",
    "lastName",
    "lastNameLat",
    "legalEntityForeignStateInfo",
    "legalEntityRF",
    "legalEntityRFInfo",
    "manualKTRUCharacteristicType",
    "manufacturerInfo",
    "manufacturerOKSMCode",
    "max",
    "medicalProductInfo",
    "medicamentalFormInfo",
    "middleName",
    "middleNameLat",
    "min",
    "modification",
    "mustSpecifyDrugPackage",
    "name",
    "nationalCode",
    "notOosOrder",
    "noticeDetails",
    "noticeNumber",
    "notificationNumber",
    "objectInfoUsingReferenceInfo",
    "objectInfoUsingTextForm",
    "oosOrder",
    "order",
    "organizationForeignState",
    "organizationRF",
    "organizationRef",
    "organizationType",
    "other",
    "packagingInfo",
    "packagingsInfo",
    "paid",
    "parentContractSubject",
    "participantType",
    "payDoc",
    "payDocToDocAcceptanceCompliances",
    "payDocTypeInfo",
    "payment",
    "paymentAmountDetail",
    "paymentGuaranteeInfoType",
    "paymentPropertysType",
    "payments",
    "penalties",
    "penaltyAccrual",
    "penaltyReason",
    "penaltyReturn",
    "personForeignState",
    "personRF",
    "personType",
    "place",
    "placeOfStayInRF",
    "placeOfStayInRFInfo",
    "placeOfStayInRegCountry",
    "placeOfStayInRegCountryInfo",
    "placer",
    "placing",
    "placingWay",
    "placingWayName",
    "placingWayRef",
    "positionTradeName",
    "positionTradeNameUsingTextForm",
    "positionsTradeName",
    "postAddressInfo",
    "postAdressInfo",
    "prefRateRef",
    "preferenseType",
    "prefsReqsRef",
    "priceInfo",
    "priceType",
    "pricesZNVLPInfo",
    "primaryPackagingInfo",
    "printFormType",
    "product",
    "products",
    "productsChange",
    "productsCountries",
    "providedPeriod",
    "publicDiscussionInEISInfo",
    "publicDiscussionInfoType",
    "purchase",
    "purchaseDrugObjectsInfoType",
    "purchaseIsMaxPriceCurrencyType",
    "purchaseObject",
    "purchaseObjectSid",
    "purchaseObjectsType",
    "purchaseSubjectRef",
    "qualifiedContractorRef",
    "qualityGuaranteeInfo",
    "quantity",
    "quantityContractSubject",
    "quantityContractSubjects",
    "quantityDrugContractSubject",
    "quantityDrugContractSubjects",
    "quantityUndefined",
    "rangeSet",
    "rate",
    "reason",
    "refId",
    "refKTRUCharacteristicType",
    "refundOverpaymentInfo",
    "refundOverpaymentsInfo",
    "registerInRFTaxBodies",
    "registerInRFTaxBodiesInfo",
    "rejectReasonRef",
    "reparation",
    "reparations",
    "reportCode",
    "reqValue",
    "requirement2020Type",
    "requirement2020WithAddReqsType",
    "requirementRestrictionType",
    "requirementType",
    "requirementWithAddReqsType",
    "requirements",
    "requirementsType",
    "restrictionSt14",
    "restrictionSt14Type",
    "restrictionType",
    "restructure",
    "righSideKTRURef",
    "rightSideKTRUCharacteristicType",
    "rightSideKTRUInfo",
    "rightToConcludeContractPriceInfo",
    "schemeVersion",
    "serviceWorkSt166Ref",
    "sid",
    "signature",
    "signatureType",
    "singleCustomer",
    "st14Info",
    "stage",
    "stageAdvancePaymentSum",
    "stages",
    "state",
    "subContractNumber",
    "subContractPriceInfo",
    "subContractor",
    "subContractors",
    "subContractorsSum",
    "subPurchaseObjectsInfo",
    "sumInPercents",
    "suppliers",
    "targetArticleFinancingType",
    "targetArticleFinancingsType",
    "taxPayerCode",
    "tenderPlan2020InfoType",
    "tenderPlan2020KVRRefType",
    "tenderPlan2020OKPD2RefType",
    "termination",
    "terminationGround615Ref",
    "terminationReason615Ref",
    "tradeInfo",
    "tradeInfoType",
    "treasurySupportContractInfo",
    "type_",
    "unfairSupplier",
    "url",
    "valueRange",
    "valueSet",
    "values",
    "violationType",
    "waiverNotice",
    "writeOffPenalties",
    "year",
    "zfcs_ETPType",
    "zfcs_KTRURef",
    "zfcs_OKATORef",
    "zfcs_OKEIRef",
    "zfcs_OKFSRef",
    "zfcs_OKPD2Ref",
    "zfcs_OKPDRef",
    "zfcs_OKPORef",
    "zfcs_OKSMRef",
    "zfcs_OKTMOPPORef",
    "zfcs_OKTMORef",
    "zfcs_OKVEDRef",
    "zfcs_abandonedReasonType",
    "zfcs_addInfoInvalidType",
    "zfcs_addInfoType",
    "zfcs_attachmentListType",
    "zfcs_attachmentType",
    "zfcs_auditActionSubjectsRef",
    "zfcs_baseRef",
    "zfcs_budgetFundsContract2015",
    "zfcs_contactInfoType",
    "zfcs_contactPersonType",
    "zfcs_contract2015BankGuaranteeReturnType",
    "zfcs_contract2015DrugPurchaseInfoType",
    "zfcs_contract2015EnforcementType",
    "zfcs_contract2015PriceInfoType",
    "zfcs_contract2015PurchaseObjectInfoType",
    "zfcs_contract2015SingleCustomerType",
    "zfcs_contract2015SubContractInfoType",
    "zfcs_contract2015SupplierType",
    "zfcs_contract2015TenderPlanInfoType",
    "zfcs_contract2015Type",
    "zfcs_contract2015_DocDictRef",
    "zfcs_contract2015_documentInfo",
    "zfcs_contract2015_payDocInfo",
    "zfcs_contractAvailableForElAct",
    "zfcs_contractCancel2015Type",
    "zfcs_contractProcedure2015BankGuaranteePaymentType",
    "zfcs_contractProcedure2015BankGuaranteeTerminationType",
    "zfcs_contractProcedure2015HoldCashEnforcementType",
    "zfcs_contractProcedure2015ProductsCountryType",
    "zfcs_contractProcedure2015SearchDrugProductsAttrsType",
    "zfcs_contractProcedure2015SearchProductsAttrsType",
    "zfcs_contractProcedure2015Type",
    "zfcs_contractProcedureCancel2015Type",
    "zfcs_contract_OKEIType",
    "zfcs_countryRef",
    "zfcs_currencyFullRef",
    "zfcs_currencyRateContract2015",
    "zfcs_currencyRef",
    "zfcs_decisionRef",
    "zfcs_deviationFactFoundation",
    "zfcs_extraBudgetFundsContract2015",
    "zfcs_okopfRef",
    "zfcs_organizationControlRegistersRef",
    "zfcs_organizationLink",
    "zfcs_organizationRef",
    "zfcs_placingWayType",
    "zfcs_publicDiscussionDecisionRef",
    "zfcs_publicDiscussionFacetRef",
    "zfcs_publicDiscussionFoundationRef",
    "zfcs_publicDiscussionQuestionRef",
    "zfcs_subjectRFRef",
    "zfcs_tenderPlan2017ContractLifeCycleCaseRef",
    "zfcs_timelineViolationType",
    "zfcs_unfairSupplierType",
    "zfcs_violationType",
    "zip"
]
